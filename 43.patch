diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/configs/monarudo_defconfig monarudo-jb-3.4.10-e22f38b/arch/arm/configs/monarudo_defconfig
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/configs/monarudo_defconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/configs/monarudo_defconfig	2013-08-01 23:38:06.000000000 -0600
@@ -75,7 +75,7 @@
 # CONFIG_TREE_RCU_TRACE is not set
 # CONFIG_RCU_BOOST is not set
 CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=17
 CONFIG_CGROUPS=y
 # CONFIG_CGROUP_DEBUG is not set
@@ -168,11 +168,11 @@
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
 CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
+# CONFIG_MODULES is not set
 # CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODVERSIONS is not set
+CONFIG_MODVERSIONS=y
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_STOP_MACHINE=y
 CONFIG_BLOCK=y
@@ -649,7 +649,7 @@
 #
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_TABLE=y
-# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_STAT=y
 # CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
@@ -1315,7 +1315,7 @@
 # CONFIG_BLK_DEV_MD is not set
 CONFIG_BLK_DEV_DM=y
 # CONFIG_DM_DEBUG is not set
-CONFIG_DM_CRYPT=m
+CONFIG_DM_CRYPT=y
 # CONFIG_DM_SNAPSHOT is not set
 # CONFIG_DM_THIN_PROVISIONING is not set
 # CONFIG_DM_MIRROR is not set
@@ -1471,7 +1471,7 @@
 # CONFIG_IWM is not set
 # CONFIG_LIBERTAS is not set
 # CONFIG_MWIFIEX is not set
-CONFIG_BCMDHD_4335=m
+CONFIG_BCMDHD_4335=y
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -1633,6 +1633,7 @@
 CONFIG_INPUT_GPIO=y
 CONFIG_POWER_KEY_LED=y
 CONFIG_POWER_KEY_CLR_RESET=y
+CONFIG_PWRKEY_WAKESRC_LOG=y
 # CONFIG_INPUT_ISA1200_FF_MEMLESS is not set
 # CONFIG_INPUT_PCF8574 is not set
 # CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
@@ -1733,7 +1734,8 @@
 CONFIG_SENSORS_R3GD20=y
 CONFIG_SENSORS_AK8963=y
 CONFIG_BOSCH_BMA250=y
-CONFIG_CIR_ALWAYS_READY=y
+CONFIG_SIG_MOTION=y
+CONFIG_BMA250_ENABLE_INT1=y
 # CONFIG_SENSORS_AKM8975 is not set
 # CONFIG_SENSORS_AKM8975_PANA_GYRO is not set
 # CONFIG_SENSORS_PANASONIC_GYRO is not set
@@ -2365,6 +2367,9 @@
 CONFIG_ION=y
 CONFIG_ION_MSM=y
 CONFIG_MSM_KGSL=y
+CONFIG_MSM_KGSL_MAINLINE=y
+# CONFIG_MSM_KGSL_JB_MR1 is not set
+# CONFIG_MSM_KGSL_JB_REL_RB31 is not set
 # CONFIG_MSM_KGSL_GPU_USAGE is not set
 # CONFIG_MSM_KGSL_CFF_DUMP is not set
 # CONFIG_MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL is not set
@@ -2623,6 +2628,7 @@
 CONFIG_SND_SOC_WCD9310=y
 CONFIG_SND_SOC_CS8427=y
 CONFIG_SND_SOC_MSM_STUB=y
+CONFIG_SND_HTC_Q6_NOBUG=y
 CONFIG_SUPPORT_USB_SPEAKER=y
 # CONFIG_SOUND_PRIME is not set
 CONFIG_HID_SUPPORT=y
@@ -3191,11 +3197,10 @@
 # CONFIG_EXT2_FS is not set
 # CONFIG_EXT3_FS is not set
 CONFIG_EXT4_FS=y
-CONFIG_FSYNC_DEBUG=y
 CONFIG_EXT4_USE_FOR_EXT23=y
 CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_SECURITY=y
 # CONFIG_EXT4_FS_POSIX_ACL is not set
-# CONFIG_EXT4_FS_SECURITY is not set
 # CONFIG_EXT4_DEBUG is not set
 CONFIG_EXT4_E2FSCK_RECOVER=y
 CONFIG_JBD2=y
@@ -3465,10 +3470,22 @@
 # CONFIG_SECURITY_DMESG_RESTRICT is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_SECURITY=""
+#CONFIG_DEFAULT_SECURITY_DAC=y
+#CONFIG_DEFAULT_SECURITY=""
 CONFIG_CRYPTO=y
 
+CONFIG_AUDIT=y
+CONFIG_SECURITY=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_IP_NF_SECURITY=y
+
 #
 # Crypto core or helper
 #
@@ -3571,11 +3588,11 @@
 CONFIG_CRYPTO_ANSI_CPRNG=m
 # CONFIG_CRYPTO_USER_API_HASH is not set
 # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-CONFIG_CRYPTO_HW=y
-CONFIG_CRYPTO_DEV_QCE40=y
-CONFIG_CRYPTO_DEV_QCRYPTO=m
-CONFIG_CRYPTO_DEV_QCE=m
-CONFIG_CRYPTO_DEV_QCEDEV=m
+CONFIG_CRYPTO_HW=n
+CONFIG_CRYPTO_DEV_QCE40=n
+CONFIG_CRYPTO_DEV_QCRYPTO=n
+CONFIG_CRYPTO_DEV_QCE=n
+CONFIG_CRYPTO_DEV_QCEDEV=n
 # CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
 # CONFIG_BINARY_PRINTF is not set
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/include/asm/setup.h monarudo-jb-3.4.10-e22f38b/arch/arm/include/asm/setup.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/include/asm/setup.h	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/include/asm/setup.h	2013-08-01 23:37:50.000000000 -0600
@@ -147,6 +147,16 @@
 	__u32 size;
 };
 
+#define ATAG_BATT_DATA	0x54410027
+
+struct tag_batt_data {
+	__s32 magic_num;
+	__s32 soc;
+	__s32 ocv;
+	__s32 cc;
+	__u32 currtime;
+};
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -165,6 +175,7 @@
 		struct tag_memclk	memclk;
 		struct tag_bldr_log	bldr_log;
 		struct tag_last_bldr_log last_bldr_log;
+		struct tag_batt_data	batt_data;
 	} u;
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/include/asm/signal.h monarudo-jb-3.4.10-e22f38b/arch/arm/include/asm/signal.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/include/asm/signal.h	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/include/asm/signal.h	2013-08-01 23:37:46.000000000 -0600
@@ -100,6 +100,7 @@
 	__sigrestore_t sa_restorer;
 	sigset_t sa_mask;		
 };
+#define __ARCH_HAS_SA_RESTORER
 
 struct k_sigaction {
 	struct sigaction sa;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/kernel/armksyms.c monarudo-jb-3.4.10-e22f38b/arch/arm/kernel/armksyms.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/kernel/armksyms.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/kernel/armksyms.c	2012-08-26 16:02:10.000000000 -0600
@@ -20,6 +20,11 @@
 #include <asm/checksum.h>
 #include <asm/ftrace.h>
 
+/*
+ * libgcc functions - functions that are used internally by the
+ * compiler...  (prototypes are not correct though, but that
+ * doesn't really matter since they're not versioned).
+ */
 extern void __ashldi3(void);
 extern void __ashrdi3(void);
 extern void __divsi3(void);
@@ -43,13 +48,17 @@
 
 extern void fpundefinstr(void);
 
-	
+	/* platform dependent support */
+EXPORT_SYMBOL(__udelay);
+EXPORT_SYMBOL(__const_udelay);
+
+	/* networking */
 EXPORT_SYMBOL(csum_partial);
 EXPORT_SYMBOL(csum_partial_copy_from_user);
 EXPORT_SYMBOL(csum_partial_copy_nocheck);
 EXPORT_SYMBOL(__csum_ipv6_magic);
 
-	
+	/* io */
 #ifndef __raw_readsb
 EXPORT_SYMBOL(__raw_readsb);
 #endif
@@ -69,7 +78,7 @@
 EXPORT_SYMBOL(__raw_writesl);
 #endif
 
-	
+	/* string / mem functions */
 EXPORT_SYMBOL(strchr);
 EXPORT_SYMBOL(strrchr);
 EXPORT_SYMBOL(memset);
@@ -78,7 +87,7 @@
 EXPORT_SYMBOL(memchr);
 EXPORT_SYMBOL(__memzero);
 
-	
+	/* user mem (segment) */
 EXPORT_SYMBOL(__strnlen_user);
 EXPORT_SYMBOL(__strncpy_from_user);
 
@@ -99,7 +108,7 @@
 EXPORT_SYMBOL(__put_user_8);
 #endif
 
-	
+	/* gcc lib functions */
 EXPORT_SYMBOL(__ashldi3);
 EXPORT_SYMBOL(__ashrdi3);
 EXPORT_SYMBOL(__divsi3);
@@ -123,7 +132,7 @@
 EXPORT_SYMBOL(__aeabi_ulcmp);
 #endif
 
-	
+	/* bitops */
 EXPORT_SYMBOL(_set_bit);
 EXPORT_SYMBOL(_test_and_set_bit);
 EXPORT_SYMBOL(_clear_bit);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/kernel/module.c monarudo-jb-3.4.10-e22f38b/arch/arm/kernel/module.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/kernel/module.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/kernel/module.c	2012-08-26 16:02:10.000000000 -0600
@@ -26,6 +26,12 @@
 #include <asm/unwind.h>
 
 #ifdef CONFIG_XIP_KERNEL
+/*
+ * The XIP kernel text is mapped in the module area for modules and
+ * some other stuff to work without any indirect relocations.
+ * MODULES_VADDR is redefined here and not in asm/memory.h to avoid
+ * recompiling the whole kernel when CONFIG_XIP_KERNEL is turned on/off.
+ */
 #undef MODULES_VADDR
 #define MODULES_VADDR	(((unsigned long)_etext + ~PMD_MASK) & PMD_MASK)
 #endif
@@ -79,7 +85,7 @@
 
 		switch (ELF32_R_TYPE(rel->r_info)) {
 		case R_ARM_NONE:
-			
+			/* ignore */
 			break;
 
 		case R_ARM_ABS32:
@@ -111,6 +117,10 @@
 			break;
 
 	       case R_ARM_V4BX:
+		       /* Preserve Rm and the condition code. Alter
+			* other bits to re-code instruction as
+			* MOV PC,Rm.
+			*/
 		       *(u32 *)loc &= 0xf000000f;
 		       *(u32 *)loc |= 0x01a0f000;
 		       break;
@@ -141,6 +151,19 @@
 			upper = *(u16 *)loc;
 			lower = *(u16 *)(loc + 2);
 
+			/*
+			 * 25 bit signed address range (Thumb-2 BL and B.W
+			 * instructions):
+			 *   S:I1:I2:imm10:imm11:0
+			 * where:
+			 *   S     = upper[10]   = offset[24]
+			 *   I1    = ~(J1 ^ S)   = offset[23]
+			 *   I2    = ~(J2 ^ S)   = offset[22]
+			 *   imm10 = upper[9:0]  = offset[21:12]
+			 *   imm11 = lower[10:0] = offset[11:1]
+			 *   J1    = lower[13]
+			 *   J2    = lower[11]
+			 */
 			sign = (upper >> 10) & 1;
 			j1 = (lower >> 13) & 1;
 			j2 = (lower >> 11) & 1;
@@ -152,6 +175,15 @@
 				offset -= 0x02000000;
 			offset += sym->st_value - loc;
 
+			/*
+			 * For function symbols, only Thumb addresses are
+			 * allowed (no interworking).
+			 *
+			 * For non-function symbols, the destination
+			 * has no specific ARM/Thumb disposition, so
+			 * the branch is resolved under the assumption
+			 * that interworking is not required.
+			 */
 			if ((ELF32_ST_TYPE(sym->st_info) == STT_FUNC &&
 				!(offset & 1)) ||
 			    offset <= (s32)0xff000000 ||
@@ -178,6 +210,16 @@
 			upper = *(u16 *)loc;
 			lower = *(u16 *)(loc + 2);
 
+			/*
+			 * MOVT/MOVW instructions encoding in Thumb-2:
+			 *
+			 * i	= upper[10]
+			 * imm4	= upper[3:0]
+			 * imm3	= lower[14:12]
+			 * imm8	= lower[7:0]
+			 *
+			 * imm16 = imm4:i:imm3:imm8
+			 */
 			offset = ((upper & 0x000f) << 12) |
 				((upper & 0x0400) << 1) |
 				((lower & 0x7000) >> 4) | (lower & 0x00ff);
@@ -254,8 +296,6 @@
 			maps[ARM_SEC_EXIT].unw_sec = s;
 		else if (strcmp(".ARM.exidx.devexit.text", secname) == 0)
 			maps[ARM_SEC_DEVEXIT].unw_sec = s;
-		else if (strcmp(".ARM.exidx.text.unlikely", secname) == 0)  
-			maps[ARM_SEC_UNLIKELY].unw_sec = s;
 		else if (strcmp(".init.text", secname) == 0)
 			maps[ARM_SEC_INIT].txt_sec = s;
 		else if (strcmp(".devinit.text", secname) == 0)
@@ -266,8 +306,6 @@
 			maps[ARM_SEC_EXIT].txt_sec = s;
 		else if (strcmp(".devexit.text", secname) == 0)
 			maps[ARM_SEC_DEVEXIT].txt_sec = s;
-		else if (strcmp(".text.unlikely", secname) == 0)  
-			maps[ARM_SEC_UNLIKELY].txt_sec = s;
 	}
 
 	for (i = 0; i < ARM_SEC_MAX; i++)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/acpuclock-8064.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/acpuclock-8064.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/acpuclock-8064.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/acpuclock-8064.c	2013-08-01 23:37:52.000000000 -0600
@@ -131,7 +131,6 @@
 	[12] = { { 1026000, HFPLL, 1, 0x26 }, 1150000, 1150000, 5 },
 	[13] = { { 1080000, HFPLL, 1, 0x28 }, 1150000, 1150000, 5 },
 	[14] = { { 1134000, HFPLL, 1, 0x2A }, 1150000, 1150000, 5 },
-	[15] = { { 1188000, HFPLL, 1, 0x2C }, 1150000, 1150000, 5 },
 	{ }
 };
 
@@ -373,14 +372,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   962500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   975000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1000000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1025000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1037500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1062500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1100000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1125000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1175000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1225000 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1287500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1025000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1037500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1062500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1100000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1125000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1175000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1225000 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1287500 },
 	{ 0, { 0 } }
 };
 
@@ -392,14 +391,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   937500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   950000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   975000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1000000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1012500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1037500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1075000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1100000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1137500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1187500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1250000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1000000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1012500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1037500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1075000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1100000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1137500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1187500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1250000 },
 	{ 0, { 0 } }
 };
 
@@ -411,14 +410,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   912500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   925000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   950000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  975000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  987500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1012500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1050000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1075000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1112500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1162500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1212500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  975000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  987500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1012500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1050000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1075000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1112500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1162500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1212500 },
 	{ 0, { 0 } }
 };
 
@@ -430,14 +429,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   900000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   912500 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   937500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  962500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  975000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1000000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1025000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1050000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1087500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1137500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  962500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  975000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1000000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1025000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1050000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1087500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1137500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1175000 },
 	{ 0, { 0 } }
 };
 
@@ -449,14 +448,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  950000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  962500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  975000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1000000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1037500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1075000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1112500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1150000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  950000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  962500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  975000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1000000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1037500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1075000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1112500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1150000 },
 	{ 0, { 0 } }
 };
 
@@ -468,14 +467,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  987500 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1012500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1050000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1087500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1125000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  987500 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1012500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1050000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1087500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1125000 },
 	{ 0, { 0 } }
 };
 
@@ -487,14 +486,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  975000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1000000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1025000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1062500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1100000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  975000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1000000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1025000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1062500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1100000 },
 	{ 0, { 0 } }
 };
 
@@ -578,7 +577,7 @@
 		msm8064_perf_acpu_table[PERF_LOCK_HIGHEST] = 1566000000;
 	
 	else if(speed == 2)
-		msm8064_perf_acpu_table[PERF_LOCK_HIGHEST] = 1512000000;
+		msm8064_perf_acpu_table[PERF_LOCK_HIGHEST] = 1566000000;
 	
 	else
 		msm8064_perf_acpu_table[PERF_LOCK_HIGHEST] = 1512000000;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo.c	2013-08-01 23:37:56.000000000 -0600
@@ -129,11 +129,7 @@
 
 #define MSM_PMEM_ADSP_SIZE         0x8600000
 #define MSM_PMEM_AUDIO_SIZE        0x4CF000
-#ifdef CONFIG_FB_MSM_HDMI_AS_PRIMARY
-#define MSM_PMEM_SIZE 0x8200000 
-#else
-#define MSM_PMEM_SIZE 0x8200000 
-#endif
+#define MSM_PMEM_SIZE              0x0 
 
 #ifdef CONFIG_MSM_MULTIMEDIA_USE_ION
 #define HOLE_SIZE		0x20000
@@ -143,7 +139,7 @@
 #define MSM_PMEM_KERNEL_EBI1_SIZE  0x6400000
 #endif
 
-#define MSM_ION_KGSL_SIZE	0x6400000
+#define MSM_ION_KGSL_SIZE	0x0
 #define MSM_ION_SF_SIZE		(MSM_PMEM_SIZE + MSM_ION_KGSL_SIZE)
 #define MSM_ION_MM_FW_SIZE	(0x200000 - HOLE_SIZE) 
 #define MSM_ION_MM_SIZE		MSM_PMEM_ADSP_SIZE
@@ -895,6 +891,7 @@
 	.critical_alarm_vol_cols = sizeof(critical_alarm_voltage_mv) / sizeof(int),
 	.overload_vol_thr_mv = 4000,
 	.overload_curr_thr_ma = 0,
+	.smooth_chg_full_delay_min = 1,
 	
 	.icharger.name = "pm8921",
 	.icharger.set_limit_charge_enable = pm8921_limit_charge_enable,
@@ -1074,6 +1071,8 @@
 	.rbatt_est_ocv_lut	= &rbatt_est_ocv_id_1,
 	.default_rbatt_mohm	= 250,
 	.delta_rbatt_mohm	= 0,
+	.level_ocv_update_stop_begin	= 10,
+	.level_ocv_update_stop_end		= 20,
 };
 
 
@@ -1187,6 +1186,8 @@
 	.rbatt_est_ocv_lut	= &rbatt_est_ocv_id_2,
 	.default_rbatt_mohm	= 250,
 	.delta_rbatt_mohm	= 0,
+	.level_ocv_update_stop_begin	= 10,
+	.level_ocv_update_stop_end		= 20,
 };
 
 static struct htc_battery_cell htc_battery_cells[] = {
@@ -2237,6 +2238,7 @@
 		.tw_pin_mask = 0x0088,
 		.sensor_id = SENSOR_ID_CHECKING_EN | 0x0,
 		.psensor_detection = 1,
+		.reduce_report_level = {60, 60, 50, 0, 0},
 		.virtual_key = monarudo_vk_data,
 		.lpm_power = synaptics_power_LPM,
 		.config = {0x33, 0x32, 0x00, 0x08, 0x00, 0x7F, 0x03, 0x1E,
@@ -2298,6 +2300,7 @@
 		.tw_pin_mask = 0x0088,
 		.sensor_id = SENSOR_ID_CHECKING_EN | 0x80,
 		.psensor_detection = 1,
+		.reduce_report_level = {60, 60, 50, 0, 0},
 		.virtual_key = monarudo_vk_data,
 		.lpm_power = synaptics_power_LPM,
 		.config = {0x33, 0x32, 0x01, 0x08, 0x00, 0x7F, 0x03, 0x1E,
@@ -2359,6 +2362,7 @@
 		.tw_pin_mask = 0x0088,
 		.sensor_id = SENSOR_ID_CHECKING_EN | 0x08,
 		.psensor_detection = 1,
+		.reduce_report_level = {60, 60, 50, 0, 0},
 		.virtual_key = monarudo_vk_data,
 		.lpm_power = synaptics_power_LPM,
 		.config = {0x33, 0x32, 0x02, 0x08, 0x00, 0x7F, 0x03, 0x1E,
@@ -3375,16 +3379,17 @@
 	.ps1_thd_set = 0x15,
 	.ps1_thd_no_cal = 0x90,
 	.ps1_thd_with_cal = 0xD,
+	.ps_th_add = 5,
 	.ps_calibration_rule = 1,
-	.ps_conf1_val = CM3629_PS_DR_1_320 | CM3629_PS_IT_1_6T |
-			CM3629_PS1_PERS_3,
+	.ps_conf1_val = CM3629_PS_DR_1_40 | CM3629_PS_IT_1_6T |
+			CM3629_PS1_PERS_2,
 	.ps_conf2_val = CM3629_PS_ITB_1 | CM3629_PS_ITR_1 |
 			CM3629_PS2_INT_DIS | CM3629_PS1_INT_DIS,
 	.ps_conf3_val = CM3629_PS2_PROL_32,
 	.dark_level = 1,
-        .dynamical_threshold = 1,
-        .mapping_table = cm3629_mapping_table,
-        .mapping_size = ARRAY_SIZE(cm3629_mapping_table),
+	.dynamical_threshold = 1,
+	.mapping_table = cm3629_mapping_table,
+	.mapping_size = ARRAY_SIZE(cm3629_mapping_table),
 };
 
 
@@ -3411,16 +3416,17 @@
 	.ps1_thd_set = 0x15,
 	.ps1_thd_no_cal = 0x90,
 	.ps1_thd_with_cal = 0xD,
+	.ps_th_add = 5,
 	.ps_calibration_rule = 1,
-	.ps_conf1_val = CM3629_PS_DR_1_320 | CM3629_PS_IT_1_6T |
-			CM3629_PS1_PERS_3,
+	.ps_conf1_val = CM3629_PS_DR_1_40 | CM3629_PS_IT_1_6T |
+			CM3629_PS1_PERS_2,
 	.ps_conf2_val = CM3629_PS_ITB_1 | CM3629_PS_ITR_1 |
 			CM3629_PS2_INT_DIS | CM3629_PS1_INT_DIS,
 	.ps_conf3_val = CM3629_PS2_PROL_32,
 	.dark_level = 1,
-        .dynamical_threshold = 1,
-        .mapping_table = cm3629_mapping_table,
-        .mapping_size = ARRAY_SIZE(cm3629_mapping_table),
+	.dynamical_threshold = 1,
+	.mapping_table = cm3629_mapping_table,
+	.mapping_size = ARRAY_SIZE(cm3629_mapping_table),
 };
 
 
@@ -4638,6 +4644,8 @@
 #endif
 	&apq_compr_dsp,
 	&apq_multi_ch_pcm,
+	&apq_lowlatency_pcm,
+
 };
 
 static struct platform_device *cdp_devices[] __initdata = {
@@ -5385,12 +5393,11 @@
 #ifdef CONFIG_SUPPORT_USB_SPEAKER
 	pm_qos_add_request(&pm_qos_req_dma, PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
 #endif
-#if 1 
-	if (get_kernel_flag() & KERNEL_FLAG_PM_MONITOR){
+
+	if (get_kernel_flag() & KERNEL_FLAG_PM_MONITOR) {
 		htc_monitor_init();
 		htc_pm_monitor_init();
 	}
-#endif
 }
 
 static void __init monarudo_allocate_memory_regions(void)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-camera.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-camera.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-camera.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-camera.c	2013-08-01 23:37:57.000000000 -0600
@@ -2241,6 +2241,7 @@
 	.vcm_enable	= 1,
 	.csi_lane_params = &vd6869_csi_lane_params,
 	.sensor_mount_angle = ANGLE_90, 
+	.ews_enable = false,
 };
 
 static struct camera_led_est msm_camera_sensor_vd6869_led_table[] = {
@@ -2372,7 +2373,7 @@
 
 };
 
-#if defined(CONFIG_RUMBAS_ACT) || defined(CONFIG_TI201_ACT)
+#if defined(CONFIG_RUMBAS_ACT) || defined(CONFIG_TI201_ACT) || defined(CONFIG_LC898212_ACT)
 static struct msm_actuator_info *vd6869_actuator_table[] = {
 #if defined(CONFIG_RUMBAS_ACT)
     &rumbas_actuator_info,
@@ -2422,27 +2423,6 @@
 	int rc =0;
 	pr_info("%s\n", __func__);
 
-	
-	rc = camera_sensor_power_enable("8921_l9", 2800000, &reg_8921_l9);
-	if (rc < 0) {
-		pr_err("[CAM] sensor_power_enable(\"8921_l9\", 2.8V) FAILED %d\n", rc);
-		goto enable_ov4688_vcm_fail;
-	}
-	mdelay(1);
-
-	
-	rc = gpio_set (CAM_PIN_GPIO_CAM_VCM_PD,1);
-	if (rc < 0) {
-		goto enable_ov4688_vcm_pd_fail;
-	}
-
-	
-	rc = camera_sensor_power_enable("8921_l8", 2800000, &reg_8921_l8);
-	if (rc < 0) {
-		pr_err("[CAM] sensor_power_enable(\"8038_l8\", 2.8V) FAILED %d\n", rc);
-		goto enable_ov4688_l8_fail;
-	}
-	udelay(50);
 
 	
 	pr_info("%s: 8921_lvs4 1800000\n", __func__);
@@ -2454,36 +2434,61 @@
 		goto enable_ov4688_io1v8_fail;
 	}
 	mdelay(5);
+
+	
+	rc = camera_sensor_power_enable("8921_l8", 2900000, &reg_8921_l8);
+	if (rc < 0) {
+		pr_err("[CAM] sensor_power_enable(\"8038_l8\", 2.9V) FAILED %d\n", rc);
+		goto enable_ov4688_l8_fail;
+	}
+	mdelay(5);
+
 	
 	rc = gpio_set (CAM_PIN_GPIO_MCAM_D1V2_EN,1);
 	if (rc < 0)
 		goto enable_ov4688_d1v2_fail;
+	mdelay(2);
+
+	
+	rc = camera_sensor_power_enable("8921_l9", 2800000, &reg_8921_l9);
+	if (rc < 0) {
+		pr_err("[CAM] sensor_power_enable(\"8921_l9\", 2.8V) FAILED %d\n", rc);
+		goto enable_ov4688_vcm_fail;
+	}
+	mdelay(1);
+
+	
+	rc = gpio_set (CAM_PIN_GPIO_CAM_VCM_PD,1);
+	if (rc < 0) {
+		goto enable_ov4688_vcm_pd_fail;
+	}
 
 	return rc;
 
-enable_ov4688_d1v2_fail:
-	rc = camera_sensor_power_disable(reg_8921_lvs4);
+enable_ov4688_vcm_pd_fail:
+	rc = camera_sensor_power_disable(reg_8921_l9);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
-			(\"8921_lvs4\") FAILED %d\n", rc);
+			(\"8921_l9\") FAILED %d\n", rc);
 
-enable_ov4688_io1v8_fail:
+enable_ov4688_vcm_fail:
+	rc= gpio_set (CAM_PIN_GPIO_MCAM_D1V2_EN,0);
+	if (rc < 0)
+		pr_err("Set D1V2 fail\n");
+
+enable_ov4688_d1v2_fail:
 	rc = camera_sensor_power_disable(reg_8921_l8);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
 			(\"8921_l8\") FAILED %d\n", rc);
 
 enable_ov4688_l8_fail:
-	rc= gpio_set (CAM_PIN_GPIO_CAM_VCM_PD,0);
-	if (rc < 0)
-		pr_err("Set VCM PD fail\n");
-
-enable_ov4688_vcm_pd_fail:
-	rc = camera_sensor_power_disable(reg_8921_l9);
+	rc = camera_sensor_power_disable(reg_8921_lvs4);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
-			(\"8921_l9\") FAILED %d\n", rc);
-enable_ov4688_vcm_fail:
+			(\"8921_lvs4\") FAILED %d\n", rc);
+
+enable_ov4688_io1v8_fail:
 
 	return rc;
 }
@@ -2492,29 +2497,39 @@
 {
 	int rc = 0;
 	pr_info("%s\n", __func__);
-	rc = gpio_set (CAM_PIN_GPIO_MCAM_D1V2_EN,0);
+
+	
+	rc = gpio_set (CAM_PIN_GPIO_CAM_VCM_PD,0);
+	if (rc < 0)
+		pr_err("Set VCM PD fail\n");
+	mdelay(10);
+
+	
+	rc = camera_sensor_power_disable(reg_8921_l9);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
-				(\"CAM_PIN_GPIO_MCAM_D1V2_EN\") FAILED %d\n", rc);
+			(\"8921_l9\") FAILED %d\n", rc);
 
-	rc = camera_sensor_power_disable(reg_8921_lvs4);
+	
+	rc = gpio_set (CAM_PIN_GPIO_MCAM_D1V2_EN,0);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
-				(\"8921_lvs4\") FAILED %d\n", rc);
-	mdelay(5);
+				(\"CAM_PIN_GPIO_MCAM_D1V2_EN\") FAILED %d\n", rc);
+	mdelay(10);
+
+	
 	rc = camera_sensor_power_disable(reg_8921_l8);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
 			(\"8921_l8\") FAILED %d\n", rc);
+	mdelay(10);
 
-	rc = gpio_set (CAM_PIN_GPIO_CAM_VCM_PD,0);
-	if (rc < 0)
-		pr_err("Set VCM PD fail\n");
-
-	rc = camera_sensor_power_disable(reg_8921_l9);
+	
+	rc = camera_sensor_power_disable(reg_8921_lvs4);
 	if (rc < 0)
 		pr_err("sensor_power_disable\
-			(\"8921_l9\") FAILED %d\n", rc);
+				(\"8921_lvs4\") FAILED %d\n", rc);
+	mdelay(20);
 
 	return rc;
 }
@@ -2530,7 +2545,7 @@
 #ifdef CONFIG_CAMERA_IMAGE_NONE_BOARD
 	.mirror_flip = CAMERA_SENSOR_MIRROR_FLIP,
 #else
-	.mirror_flip = CAMERA_SENSOR_NONE, 
+	.mirror_flip = CAMERA_SENSOR_FLIP, 
 #endif
 	.sensor_reset_enable = 0,
 	.sensor_reset = 0,
@@ -2668,6 +2683,21 @@
 
 };
 
+
+#if defined(CONFIG_RUMBAS_ACT) || defined(CONFIG_TI201_ACT) || defined(CONFIG_LC898212_ACT)
+static struct msm_actuator_info *ov4688_actuator_table[] = {
+#if defined(CONFIG_RUMBAS_ACT)
+    &rumbas_actuator_info,
+#endif
+#if defined(CONFIG_TI201_ACT)
+    &ti201_actuator_info,
+#endif
+#if defined(CONFIG_LC898212_ACT)
+    &lc898212_actuator_info,
+#endif
+};
+#endif
+
 static struct msm_camera_sensor_info msm_camera_sensor_ov4688_data = {
 	.sensor_name	= "ov4688",
 	.camera_power_on = monarudo_ov4688_vreg_on,
@@ -2679,6 +2709,12 @@
 	.gpio_conf = &ov4688_back_cam_gpio_conf,
 	.csi_if	= 1,
 	.camera_type = BACK_CAMERA_2D,
+
+#if defined(CONFIG_RUMBAS_ACT) || defined(CONFIG_TI201_ACT) || defined(CONFIG_LC898212_ACT)
+	.num_actuator_info_table = ARRAY_SIZE(ov4688_actuator_table),
+	.actuator_info_table = &ov4688_actuator_table[0],
+#endif
+
 #if defined(CONFIG_RUMBAS_ACT)
 	.actuator_info = &rumbas_actuator_info,
 #endif
@@ -4160,18 +4196,34 @@
 #endif
 };
 
-struct i2c_board_info monarudo_camera_i2c_boardinfo_ov4688_s5k6a2ya[] = {
+struct i2c_board_info monarudo_camera_i2c_boardinfo_ov4688_0x6c_ov2722[] = {
+
+#ifdef CONFIG_OV4688
+		{
+		I2C_BOARD_INFO("ov4688_0x6c", 0x20 >> 1),
+		.platform_data = &msm_camera_sensor_ov4688_data,
+		},
+#endif
+#ifdef CONFIG_OV2722
+		{
+		I2C_BOARD_INFO("ov2722", 0x6c >> 1),
+		.platform_data = &msm_camera_sensor_ov2722_data,
+		}
+#endif
+};
+
+struct i2c_board_info monarudo_camera_i2c_boardinfo_ov4688_0x20_ov2722[] = {
 
 #ifdef CONFIG_OV4688
 		{
-		I2C_BOARD_INFO("ov4688", 0x6c >> 1),
+		I2C_BOARD_INFO("ov4688_0x20", 0x20 >> 1),
 		.platform_data = &msm_camera_sensor_ov4688_data,
 		},
 #endif
-#ifdef CONFIG_S5K6A2YA
+#ifdef CONFIG_OV2722
 		{
-		I2C_BOARD_INFO("s5k6a2ya", 0x78 >> 1),
-		.platform_data = &msm_camera_sensor_s5k6a2ya_data,
+		I2C_BOARD_INFO("ov2722", 0x6c >> 1),
+		.platform_data = &msm_camera_sensor_ov2722_data,
 		}
 #endif
 };
@@ -4558,6 +4610,7 @@
 	pr_info("main_camera id = %d\n", main_camera_id);
 
 	pr_info("engineerid=%d\n",engineerid);
+	pr_info("system_rev=%d\n",system_rev);
 #ifdef CONFIG_I2C
 	if ( (((engineerid&1)==0) && (system_rev < 2)) ||
 	     (((engineerid&1)==1) && (system_rev >= 2)) ) {
@@ -4579,7 +4632,7 @@
 				monarudo_camera_i2c_boardinfo_imx135_ar0260,
 				ARRAY_SIZE(monarudo_camera_i2c_boardinfo_imx135_ar0260));
 
-			update_yushanII_flag(HTC_CAMERA_IMAGE_NONE_BOARD);
+			update_yushanII_flag(HTC_CAMERA_IMAGE_YUSHANII_BOARD);
 		}
 	} else {
 		
@@ -4591,9 +4644,15 @@
 
 			update_yushanII_flag(HTC_CAMERA_IMAGE_YUSHANII_BOARD);
 		} else if(main_camera_id == CAMERA_SENSOR_ID_OV_4M){
-			i2c_register_board_info(APQ_8064_GSBI4_QUP_I2C_BUS_ID,
-				monarudo_camera_i2c_boardinfo_ov4688_s5k6a2ya,
-				ARRAY_SIZE(monarudo_camera_i2c_boardinfo_ov4688_s5k6a2ya));
+			if(1){
+				i2c_register_board_info(APQ_8064_GSBI4_QUP_I2C_BUS_ID,
+					monarudo_camera_i2c_boardinfo_ov4688_0x20_ov2722,
+					ARRAY_SIZE(monarudo_camera_i2c_boardinfo_ov4688_0x20_ov2722));
+			}else{
+				i2c_register_board_info(APQ_8064_GSBI4_QUP_I2C_BUS_ID,
+					monarudo_camera_i2c_boardinfo_ov4688_0x6c_ov2722,
+					ARRAY_SIZE(monarudo_camera_i2c_boardinfo_ov4688_0x6c_ov2722));
+			}
 			update_yushanII_flag(HTC_CAMERA_IMAGE_YUSHANII_BOARD);
 		}
 		else {
@@ -4606,7 +4665,7 @@
 				monarudo_camera_i2c_boardinfo_imx135_ov2722,
 				ARRAY_SIZE(monarudo_camera_i2c_boardinfo_imx135_ov2722));
 
-			update_yushanII_flag(HTC_CAMERA_IMAGE_NONE_BOARD);
+			update_yushanII_flag(HTC_CAMERA_IMAGE_YUSHANII_BOARD);
 		}
 	}
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-display.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-display.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-display.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-display.c	2013-08-01 23:37:52.000000000 -0600
@@ -248,13 +248,6 @@
 };
 #endif
 
-static int mdp_core_clk_rate_table[] = {
-	200000000,
-	200000000,
-	200000000,
-	200000000,
-};
-
 struct mdp_reg *mdp_gamma = NULL;
 int mdp_gamma_count = 0;
 struct mdp_reg mdp_gamma_jdi[] = {
@@ -789,9 +782,6 @@
 
 static struct msm_panel_common_pdata mdp_pdata = {
 	.gpio = MDP_VSYNC_GPIO,
-	.mdp_core_clk_rate = 200000000,
-	.mdp_core_clk_table = mdp_core_clk_rate_table,
-	.num_mdp_clk = ARRAY_SIZE(mdp_core_clk_rate_table),
 #ifdef CONFIG_MSM_BUS_SCALING
 	.mdp_bus_scale_table = &mdp_bus_scale_pdata,
 #endif
@@ -1476,7 +1466,7 @@
        0x82, 0x94, 0xA8, 0xB9,
        0xCB, 0xDB, 0xE9, 0xF5,
        0xFC, 0xFF, 0x04, 0xD3, 
-       0x06, 0x06, 0x54, 0x24};
+       0x00, 0x00, 0x54, 0x24};
 
 static char cabc_still[] = {0xB9, 0x03, 0x82, 0x3C, 0x10, 0x3C, 0x87};
 static char cabc_movie[] = {0xBA, 0x03, 0x78, 0x64, 0x10, 0x64, 0xB4};
@@ -1689,6 +1679,8 @@
 	cmdreq.cmds = display_on_cmds;
 	cmdreq.cmds_cnt = display_on_cmds_count;
 	cmdreq.flags = CMD_REQ_COMMIT;
+	if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+		cmdreq.flags |= CMD_CLK_CTRL;
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
@@ -1702,6 +1694,9 @@
 	cmdreq.cmds = display_off_cmds;
 	cmdreq.cmds_cnt = display_off_cmds_count;
 	cmdreq.flags = CMD_REQ_COMMIT;
+	if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+		cmdreq.flags |= CMD_CLK_CTRL;
+
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
@@ -1727,6 +1722,9 @@
 	cmdreq.cmds_cnt = dim_on_cmds_count;
 
 	cmdreq.flags = CMD_REQ_COMMIT;
+	if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+		cmdreq.flags |= CMD_CLK_CTRL;
+
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 	mipi_dsi_cmdlist_put(&cmdreq);
@@ -1796,10 +1794,6 @@
 {
 	int rc;
 
-	if (mdp4_overlay_dsi_state_get() <= ST_DSI_SUSPEND) {
-		return;
-	}
-
 	if ((panel_type == PANEL_ID_monarudo_JDI_SAMSUNG) ||
 		(panel_type == PANEL_ID_monarudo_JDI_SAMSUNG_C2) ||
 		(panel_type == PANEL_ID_monarudo_JDI_SAMSUNG_C2_1) ||
@@ -1864,6 +1858,9 @@
 		cmdreq.cmds = dim_off_cmds;
 		cmdreq.cmds_cnt = dim_off_cmds_count;
 		cmdreq.flags = CMD_REQ_COMMIT;
+		if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+			cmdreq.flags |= CMD_CLK_CTRL;
+
 		cmdreq.rlen = 0;
 		cmdreq.cb = NULL;
 
@@ -1874,6 +1871,9 @@
 	cmdreq.cmds = backlight_cmds;
 	cmdreq.cmds_cnt = backlight_cmds_count;
 	cmdreq.flags = CMD_REQ_COMMIT;
+	if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+		cmdreq.flags |= CMD_CLK_CTRL;
+
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
@@ -1935,6 +1935,9 @@
 		cmdreq.cmds = color_en_on_cmds;
 		cmdreq.cmds_cnt = color_en_on_cmds_count;
 		cmdreq.flags = CMD_REQ_COMMIT;
+		if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+			cmdreq.flags |= CMD_CLK_CTRL;
+
 		cmdreq.rlen = 0;
 		cmdreq.cb = NULL;
 
@@ -1945,6 +1948,9 @@
 		cmdreq.cmds = color_en_off_cmds;
 		cmdreq.cmds_cnt = color_en_off_cmds_count;
 		cmdreq.flags = CMD_REQ_COMMIT;
+		if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+			cmdreq.flags |= CMD_CLK_CTRL;
+
 		cmdreq.rlen = 0;
 		cmdreq.cb = NULL;
 
@@ -2105,6 +2111,9 @@
 		}
 
 		cmdreq.flags = CMD_REQ_COMMIT;
+		if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+			cmdreq.flags |= CMD_CLK_CTRL;
+
 		cmdreq.rlen = 0;
 		cmdreq.cb = NULL;
 		mipi_dsi_cmdlist_put(&cmdreq);
@@ -2196,6 +2205,9 @@
 
 		if (cur_cabc_mode != req_cabc_zoe_mode) {
 			cmdreq.flags = CMD_REQ_COMMIT;
+			if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+				cmdreq.flags |= CMD_CLK_CTRL;
+
 			cmdreq.rlen = 0;
 			cmdreq.cb = NULL;
 			mipi_dsi_cmdlist_put(&cmdreq);
@@ -2211,6 +2223,9 @@
 	}
 
 	cmdreq.flags = CMD_REQ_COMMIT;
+	if (mfd && mfd->panel_info.type == MIPI_CMD_PANEL)
+		cmdreq.flags |= CMD_CLK_CTRL;
+
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-pmic.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-pmic.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/board-monarudo-pmic.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/board-monarudo-pmic.c	2013-08-01 23:37:52.000000000 -0600
@@ -510,11 +510,11 @@
 	.max_voltage		= MAX_VOLTAGE_MV,
 	.min_voltage		= 3200,
 	.resume_voltage_delta	= 50,
-	.term_current		= 75,
+	.term_current		= 230,
 	.cool_temp		= 0,
 	.warm_temp		= 48,
 	.temp_check_period	= 1,
-	.max_bat_chg_current	= 1025,
+	.max_bat_chg_current	= 1525,
 	.cool_bat_chg_current	= 1025,
 	.warm_bat_chg_current	= 1025,
 	.cool_bat_voltage	= 4200,
@@ -523,6 +523,9 @@
 	.cable_in_irq		= PM8921_GPIO_IRQ(PM8921_IRQ_BASE, CABLE_IN_N),
 	.cable_in_gpio		= PM8921_GPIO_PM_TO_SYS(CABLE_IN_N),
 	.is_embeded_batt	= 1,
+	.eoc_ibat_thre_ma	= 50,
+	.ichg_threshold_ua = -1200000,
+	.ichg_regulation_thr_ua 	= -375000,
 	.thermal_mitigation	= monarudo_pm8921_therm_mitigation,
 	.thermal_levels		= ARRAY_SIZE(monarudo_pm8921_therm_mitigation),
 	.cold_thr = PM_SMBC_BATT_TEMP_COLD_THR__HIGH,
@@ -544,8 +547,6 @@
 	.v_failure		= 3000,
 	.max_voltage_uv		= MAX_VOLTAGE_MV * 1000,
 	.rconn_mohm		= 0,
-	.level_ocv_update_stop_begin	= 10,
-	.level_ocv_update_stop_end		= 20,
 	.criteria_sw_est_ocv			= 86400000, 
 	.rconn_mohm_sw_est_ocv		= 10,
 };
@@ -570,7 +571,7 @@
 static struct pm8xxx_vibrator_platform_data pm8xxx_vib_pdata = {
 	.initial_vibrate_ms = 0,
 	.max_timeout_ms = 15000,
-	.level_mV = 2700,
+	.level_mV = 2000,
 	.threshold = 500,
 	};
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/clock-8960.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/clock-8960.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/clock-8960.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/clock-8960.c	2013-08-01 23:37:52.000000000 -0600
@@ -5816,6 +5816,9 @@
 	CLK_LOOKUP("core_clk",		gsbi3_qup_clk.c,	"qup_i2c.3"),
 	CLK_LOOKUP("core_clk",		gsbi4_qup_clk.c,	"qup_i2c.4"),
 	CLK_LOOKUP("core_clk",		gsbi5_qup_clk.c,	"spi_qsd.0"),
+#ifdef CONFIG_FPR_SPI
+	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c,	"spi_qsd.1"),
+#endif
 	CLK_LOOKUP("core_clk",		gsbi5_qup_clk.c,	"qup_i2c.5"),
 	CLK_LOOKUP("core_clk",		gsbi6_qup_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi7_qup_clk.c,	"qup_i2c.7"),
@@ -5865,6 +5868,9 @@
 #endif
 	CLK_LOOKUP("iface_clk",		gsbi4_p_clk.c,		"qup_i2c.4"),
 	CLK_LOOKUP("iface_clk",		gsbi5_p_clk.c,		"spi_qsd.0"),
+#ifdef CONFIG_FPR_SPI
+	CLK_LOOKUP("iface_clk",		gsbi1_p_clk.c,		"spi_qsd.1"),
+#endif
 	CLK_LOOKUP("iface_clk",		gsbi5_p_clk.c,		"qup_i2c.5"),
 	CLK_LOOKUP("iface_clk",		gsbi6_p_clk.c,		"msm_serial_hs.0"),
 #ifdef CONFIG_BT
@@ -5942,6 +5948,7 @@
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0036"),
 	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"msm_camera_ar0260.0"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0048"),
+	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"2-0048"),
 
 	CLK_LOOKUP("core_clk",		gfx3d_clk.c,	"kgsl-3d0.0"),
 	CLK_LOOKUP("core_clk",		gfx3d_clk.c,	"footswitch-8x60.2"),
@@ -6206,7 +6213,7 @@
 	CLK_LOOKUP("core_clk",		gsbi11_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi12_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c,	"spi_qsd.0"),
-	CLK_LOOKUP("core_clk",		gsbi2_qup_clk.c,	""),
+	CLK_LOOKUP("core_clk",		gsbi2_qup_clk.c,	"qup_i2c.2"),
 	CLK_LOOKUP("core_clk",		gsbi3_qup_clk.c,	"qup_i2c.3"),
 	CLK_LOOKUP("core_clk",		gsbi4_qup_clk.c,	"qup_i2c.4"),
 	CLK_LOOKUP("core_clk",		gsbi5_qup_clk.c,	"qup_i2c.5"),
@@ -6246,7 +6253,7 @@
 	CLK_LOOKUP("core_clk",		ce1_core_clk.c,		"qcrypto.0"),
 	CLK_LOOKUP("dma_bam_pclk",	dma_bam_p_clk.c,	NULL),
 	CLK_LOOKUP("iface_clk",		gsbi1_p_clk.c,		"spi_qsd.0"),
-	CLK_LOOKUP("iface_clk",		gsbi2_p_clk.c,		""),
+	CLK_LOOKUP("iface_clk",		gsbi2_p_clk.c,		"qup_i2c.2"),
 	CLK_LOOKUP("iface_clk",		gsbi3_p_clk.c,		"qup_i2c.3"),
 	CLK_LOOKUP("iface_clk",		gsbi3_p_clk.c,		"msm_serial_hsl.1"),
 	CLK_LOOKUP("iface_clk",		gsbi4_p_clk.c,		"qup_i2c.4"),
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-8064.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-8064.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-8064.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-8064.c	2013-08-01 23:37:53.000000000 -0600
@@ -452,6 +452,34 @@
 	.resource	= resources_qup_i2c_gsbi4,
 };
 
+static struct resource resources_qup_spi_gsbi1[] = {
+	{
+		.name   = "spi_base",
+		.start  = MSM_GSBI1_QUP_PHYS,
+		.end    = MSM_GSBI1_QUP_PHYS + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "gsbi_base",
+		.start  = MSM_GSBI1_PHYS,
+		.end    = MSM_GSBI1_PHYS + 4 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "spi_irq_in",
+		.start  = APQ8064_GSBI1_QUP_IRQ,
+		.end    = APQ8064_GSBI1_QUP_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device apq8064_device_qup_spi_gsbi1 = {
+	.name		= "spi_qsd",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(resources_qup_spi_gsbi1),
+	.resource	= resources_qup_spi_gsbi1,
+};
+
 static struct resource resources_qup_spi_gsbi5[] = {
 	{
 		.name   = "spi_base",
@@ -717,6 +745,11 @@
 	.id     = -1,
 };
 
+struct platform_device apq_lowlatency_pcm = {
+   .name   = "msm-lowlatency-pcm-dsp",
+   .id     = -1,
+};
+
 struct platform_device apq_pcm_hostless = {
 	.name	= "msm-pcm-hostless",
 	.id	= -1,
@@ -941,12 +974,6 @@
 		.flags	= IORESOURCE_IO,
 	},
 	{
-		.start	= MDM2AP_ERRFATAL,
-		.end	= MDM2AP_ERRFATAL,
-		.name	= "MDM2AP_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
 		.start	= MDM2AP_STATUS,
 		.end	= MDM2AP_STATUS,
 		.name	= "MDM2AP_STATUS",
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-8960.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-8960.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-8960.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-8960.c	2013-08-01 23:37:56.000000000 -0600
@@ -2207,6 +2207,11 @@
 	.id	= -1,
 };
 
+struct platform_device msm_lowlatency_pcm = {
+   .name   = "msm-lowlatency-pcm-dsp",
+   .id = -1,
+};
+
 struct platform_device msm_pcm_routing = {
 	.name	= "msm-pcm-routing",
 	.id	= -1,
@@ -2233,8 +2238,13 @@
 };
 
 struct msm_mi2s_pdata mi2s_data = {
+#ifdef CONFIG_MACH_ZIP_CL_MI2S_DATA_SWITCH
+	.rx_sd_lines = MSM_MI2S_SD3 ,   
+	.tx_sd_lines = MSM_MI2S_SD0 ,   
+#else
 	.rx_sd_lines = MSM_MI2S_SD0 ,   
 	.tx_sd_lines = MSM_MI2S_SD3 ,   
+#endif
 };
 
 struct platform_device msm_cpudai_mi2s = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices.h	2013-08-01 23:37:52.000000000 -0600
@@ -104,6 +104,7 @@
 extern struct platform_device apq8064_device_qup_i2c_gsbi3;
 extern struct platform_device apq8064_device_qup_i2c_gsbi4;
 extern struct platform_device apq8064_device_qup_i2c_gsbi7;
+extern struct platform_device apq8064_device_qup_spi_gsbi1;
 extern struct platform_device apq8064_device_qup_spi_gsbi5;
 extern struct platform_device apq8064_slim_ctrl;
 extern struct platform_device apq8064_device_ssbi_pmic1;
@@ -222,6 +223,7 @@
 
 extern struct platform_device msm_pcm;
 extern struct platform_device msm_multi_ch_pcm;
+extern struct platform_device msm_lowlatency_pcm;
 extern struct platform_device msm_pcm_routing;
 extern struct platform_device msm_cpudai0;
 extern struct platform_device msm_cpudai1;
@@ -288,6 +290,7 @@
 extern struct platform_device apq_lpa_pcm;
 extern struct platform_device apq_compr_dsp;
 extern struct platform_device apq_multi_ch_pcm;
+extern struct platform_device apq_lowlatency_pcm;
 extern struct platform_device apq_pcm_hostless;
 extern struct platform_device apq_cpudai_afe_01_rx;
 extern struct platform_device apq_cpudai_afe_01_tx;
@@ -341,6 +344,7 @@
 extern struct platform_device msm_device_touchscreen;
 
 extern int gy_type;
+extern int compass_type;
 
 extern struct platform_device led_pdev;
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices_htc.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices_htc.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices_htc.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices_htc.c	2013-08-01 23:37:56.000000000 -0600
@@ -216,6 +216,40 @@
 }
 __tagtable(ATAG_CAM, parse_tag_cam);
 
+int batt_stored_magic_num;
+int batt_stored_soc;
+int batt_stored_ocv_uv;
+int batt_stored_cc_uv;
+unsigned long batt_stored_time_ms;
+
+static int __init parse_tag_stored_batt_data(const struct tag *tags)
+{
+	int find = 0;
+	struct tag *t = (struct tag *)tags;
+
+	for (; t->hdr.size; t = tag_next(t)) {
+		if (t->hdr.tag == ATAG_BATT_DATA) {
+			printk(KERN_DEBUG "find the stored batt data tag\n");
+			find = 1;
+			break;
+		}
+	}
+
+	if (find) {
+		batt_stored_magic_num = t->u.batt_data.magic_num;
+		batt_stored_soc = t->u.batt_data.soc;
+		batt_stored_ocv_uv = t->u.batt_data.ocv;
+		batt_stored_cc_uv = t->u.batt_data.cc;
+		batt_stored_time_ms = t->u.batt_data.currtime;
+		printk(KERN_INFO "batt_data: magic_num=%x, soc=%d, "
+			"ocv_uv=%x, cc_uv=%x, stored_time=%ld\n",
+			batt_stored_magic_num, batt_stored_soc, batt_stored_ocv_uv,
+			batt_stored_cc_uv, batt_stored_time_ms);
+	}
+	return 0;
+}
+__tagtable(ATAG_BATT_DATA, parse_tag_stored_batt_data);
+
 #define ATAG_GRYO_GSENSOR	0x54410020
 unsigned char gyro_gsensor_kvalue[37];
 EXPORT_SYMBOL(gyro_gsensor_kvalue);
@@ -415,7 +449,22 @@
 }
 __tagtable(ATAG_GY_TYPE, tag_gy_parsing);
 
-#define ATAG_SMLOG     0x54410023
+#define ATAG_COMPASS_TYPE 0x4d534D79
+int compass_type;
+EXPORT_SYMBOL(compass_type);
+int __init tag_compass_parsing(const struct tag *tags)
+{
+        compass_type = tags->u.revision.rev;
+
+        printk(KERN_DEBUG "%s: Compass type = 0x%x\n", __func__,
+                compass_type);
+
+        return compass_type;
+}
+__tagtable(ATAG_COMPASS_TYPE, tag_compass_parsing);
+
+
+#define ATAG_SMLOG     0x54410026
 
 int __init parse_tag_smlog(const struct tag *tags)
 {
@@ -455,6 +504,38 @@
 	return radio_flag;
 }
 
+static unsigned long radio_flag_ex1;
+int __init radio_flag_ex1_init(char *s)
+{
+	int ret = 0;
+	ret = strict_strtoul(s, 16, &radio_flag_ex1);
+	if (ret != 0)
+		pr_err("%s: radio flag ex1 cannot be parsed from `%s'\r\n", __func__, s);
+	return 1;
+}
+__setup("radioflagex1=", radio_flag_ex1_init);
+
+unsigned int get_radio_flag_ex1(void)
+{
+	return radio_flag_ex1;
+}
+
+static unsigned long radio_flag_ex2;
+int __init radio_flag_ex2_init(char *s)
+{
+	int ret = 0;
+	ret = strict_strtoul(s, 16, &radio_flag_ex2);
+	if (ret != 0)
+		pr_err("%s: radio flag ex2 cannot be parsed from `%s'\r\n", __func__, s);
+	return 1;
+}
+__setup("radioflagex2=", radio_flag_ex2_init);
+
+unsigned int get_radio_flag_ex2(void)
+{
+	return radio_flag_ex2;
+}
+
 static unsigned long kernel_flag;
 int __init kernel_flag_init(char *s)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-iommu.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-iommu.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/devices-iommu.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/devices-iommu.c	2013-08-01 23:37:55.000000000 -0600
@@ -365,25 +365,41 @@
 static struct msm_iommu_dev gfx3d_iommu = {
 	.name = "gfx3d",
 	.ncb = 3,
+#ifdef CONFIG_MSM_KGSL_JB_MR1
 	.ttbr_split = 1,
+#else
+	.ttbr_split = 0,
+#endif
 };
 
 static struct msm_iommu_dev gfx3d1_iommu = {
 	.name = "gfx3d1",
 	.ncb = 3,
+#ifdef CONFIG_MSM_KGSL_JB_MR1
 	.ttbr_split = 1,
+#else
+	.ttbr_split = 0,
+#endif
 };
 
 static struct msm_iommu_dev gfx2d0_iommu = {
 	.name = "gfx2d0",
 	.ncb = 2,
+#ifdef CONFIG_MSM_KGSL_JB_MR1
 	.ttbr_split = 1,
+#else
+	.ttbr_split = 0,
+#endif
 };
 
 static struct msm_iommu_dev gfx2d1_iommu = {
 	.name = "gfx2d1",
 	.ncb = 2,
+#ifdef CONFIG_MSM_KGSL_JB_MR1
 	.ttbr_split = 1,
+#else
+	.ttbr_split = 0,
+#endif
 };
 
 static struct msm_iommu_dev vcap_iommu = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/gpiomux.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/gpiomux.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/gpiomux.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/gpiomux.c	2013-08-01 23:37:55.000000000 -0600
@@ -83,6 +83,25 @@
 }
 EXPORT_SYMBOL(msm_gpiomux_get);
 
+int msm_gpiomux_read(unsigned gpio)
+{
+	unsigned long irq_flags;
+	unsigned ret = 0;
+
+	if (!msm_gpiomux_recs)
+		return -EFAULT;
+
+	if (gpio >= msm_gpiomux_ngpio)
+		return -EINVAL;
+
+	spin_lock_irqsave(&gpiomux_lock, irq_flags);
+		ret = __msm_gpiomux_read(gpio);
+	spin_unlock_irqrestore(&gpiomux_lock, irq_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(msm_gpiomux_read);
+
 int msm_gpiomux_put(unsigned gpio)
 {
 	struct msm_gpiomux_rec *rec = msm_gpiomux_recs + gpio;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/gpiomux-v2.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/gpiomux-v2.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/gpiomux-v2.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/gpiomux-v2.c	2013-08-01 23:37:57.000000000 -0600
@@ -30,3 +30,13 @@
 	__raw_writel(bits, GPIO_CFG(gpio));
 	mb();
 }
+
+unsigned __msm_gpiomux_read(unsigned gpio)
+{
+	int in_out, cfg;
+
+	in_out = __raw_readl(GPIO_IN_OUT(gpio));
+	cfg = __raw_readl(GPIO_CFG(gpio));
+
+	return (in_out <<16) | cfg;
+}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_acoustic_8960.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_acoustic_8960.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_acoustic_8960.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_acoustic_8960.c	2013-08-01 23:37:55.000000000 -0600
@@ -25,6 +25,7 @@
 #include <linux/switch.h>
 #include <mach/htc_acoustic_8960.h>
 #include <mach/subsystem_restart.h>
+#include <linux/sched.h>
 
 #define ACOUSTIC_IOCTL_MAGIC 'p'
 #define ACOUSTIC_SET_Q6_EFFECT		_IOW(ACOUSTIC_IOCTL_MAGIC, 43, unsigned)
@@ -35,6 +36,7 @@
 #define ACOUSTIC_UPDATE_LISTEN_NOTIFICATION	_IOW(ACOUSTIC_IOCTL_MAGIC, 48, unsigned)
 #define ACOUSTIC_SET_CSD_CLIENT   	_IOW(ACOUSTIC_IOCTL_MAGIC, 49, unsigned)
 #define ACOUSTIC_GET_CSD_CLIENT   	_IOW(ACOUSTIC_IOCTL_MAGIC, 50, unsigned)
+#define ACOUSTIC_KILL_PID		_IOW(ACOUSTIC_IOCTL_MAGIC, 88, unsigned)
 
 #define ACOUSTIC_RAMDUMP		_IOW(ACOUSTIC_IOCTL_MAGIC, 99, unsigned)
 #define D(fmt, args...) printk(KERN_INFO "[AUD] htc-acoustic: "fmt, ##args)
@@ -202,6 +204,28 @@
 			break;
 		}
 
+		case ACOUSTIC_KILL_PID: {
+			int pid = 0;
+			struct pid *pid_struct = NULL;
+
+			if (copy_from_user(&pid, (void *)arg, sizeof(pid))) {
+				rc = -EFAULT;
+				break;
+			}
+
+			D("ACOUSTIC_KILL_PID: %d\n", pid);
+
+			if (pid <= 0)
+				break;
+
+			pid_struct = find_get_pid(pid);
+			if (pid_struct) {
+				kill_pid(pid_struct, SIGKILL, 1);
+				D("kill pid: %d", pid);
+			}
+			break;
+		}
+
 	default:
 		rc = -EINVAL;
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_battery_8960.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_battery_8960.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_battery_8960.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_battery_8960.c	2013-08-01 23:37:56.000000000 -0600
@@ -148,7 +148,7 @@
 	int critical_alarm_vol_cols;
 	int overload_vol_thr_mv;
 	int overload_curr_thr_ma;
-
+	int smooth_chg_full_delay_min;
 	struct kobject batt_timer_kobj;
 	struct kobject batt_cable_kobj;
 
@@ -211,6 +211,21 @@
 struct mutex batt_set_alarm_lock;
 #endif
 
+struct max_level_by_current_ma {
+	int threshold_ma;
+	int level_boundary;
+};
+static struct max_level_by_current_ma limit_level_curr_table[] = { {-800, 92},
+							{-700, 93},
+							{-600, 94},
+							{-500, 95},
+							{-400, 96},
+							{-300, 97},
+							{-200, 98},
+							{-100, 99},};
+
+static const int LIMIT_LEVEL_CURR_TABLE_SIZE = sizeof(limit_level_curr_table) / sizeof (limit_level_curr_table[0]);
+
 int htc_gauge_get_battery_voltage(int *result)
 {
 	if (htc_batt_info.igauge && htc_batt_info.igauge->get_battery_voltage)
@@ -1233,13 +1248,17 @@
 	static int critical_low_enter = 0;
 	int prev_level, drop_level;
 	int is_full = 0;
+	int i, prev_current, measured_current;
 	const struct battery_info_reply *prev_batt_info_rep =
 						htc_battery_core_get_batt_info_rep();
 
-	if (!first)
+	if (!first) {
 		prev_level = prev_batt_info_rep->level;
-	else
+		prev_current = prev_batt_info_rep->batt_current;
+	} else {
 		prev_level = htc_batt_info.rep.level;
+		prev_current = htc_batt_info.rep.batt_current;
+	}
 	drop_level = prev_level - htc_batt_info.rep.level;
 
 	if (!prev_batt_info_rep->charging_enabled &&
@@ -1314,11 +1333,51 @@
 	} else {
 		if (htc_batt_info.igauge->is_battery_full) {
 			htc_batt_info.igauge->is_battery_full(&is_full);
-			if (!is_full) {
+			if (is_full != 0) {
+				if (htc_batt_info.smooth_chg_full_delay_min
+					&& prev_level < 100) {
+					htc_batt_info.rep.level = prev_level + 1;
+				} else {
+					htc_batt_info.rep.level = 100; 
+				}
+			} else {
 				if (99 < htc_batt_info.rep.level)
 					htc_batt_info.rep.level = 99; 
-			} else
-				htc_batt_info.rep.level = 100; 
+				if (!htc_batt_info.smooth_chg_full_delay_min) {
+					if (htc_batt_info.rep.level > limit_level_curr_table[0].level_boundary
+						&& prev_level < htc_batt_info.rep.level) {
+
+						measured_current = htc_batt_info.rep.batt_current;
+						if (measured_current <= 0) {
+							if (prev_current > 0 || prev_current < measured_current)
+								measured_current = prev_current;
+						}
+
+						if (measured_current <= 0) {
+							for (i = 0; i < LIMIT_LEVEL_CURR_TABLE_SIZE; i++) {
+								if (measured_current <
+									limit_level_curr_table[i].threshold_ma * 1000) {
+									break;
+								}
+							}
+						} else {
+							i = 0;
+						}
+
+						if (i < LIMIT_LEVEL_CURR_TABLE_SIZE
+							&& htc_batt_info.rep.level >= limit_level_curr_table[i].level_boundary) {
+							if (prev_level >= limit_level_curr_table[i].level_boundary)
+								htc_batt_info.rep.level = prev_level;
+							else
+								htc_batt_info.rep.level = limit_level_curr_table[i].level_boundary - 1;
+							pr_info("[BATT] limit battery level to %d(prev=%d) by (%d,%d) "
+								       "with measured current %d\n",
+								htc_batt_info.rep.level, prev_level, limit_level_curr_table[i].level_boundary,
+								limit_level_curr_table[i].threshold_ma,	measured_current);
+						}
+					}
+				}
+			}
 		}
 		critical_low_enter = 0;
 	}
@@ -2075,6 +2134,7 @@
 	}
 	htc_batt_info.overload_vol_thr_mv = pdata->overload_vol_thr_mv;
 	htc_batt_info.overload_curr_thr_ma = pdata->overload_curr_thr_ma;
+	htc_batt_info.smooth_chg_full_delay_min = pdata->smooth_chg_full_delay_min;
 	chg_limit_active_mask = pdata->chg_limit_active_mask;
 	htc_batt_info.igauge = &pdata->igauge;
 	htc_batt_info.icharger = &pdata->icharger;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_battery_core.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_battery_core.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_battery_core.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_battery_core.c	2013-08-01 23:37:53.000000000 -0600
@@ -82,6 +82,7 @@
 static struct work_struct batt_charger_ctrl_work;
 struct workqueue_struct *batt_charger_ctrl_wq;
 static unsigned int charger_ctrl_stat;
+static unsigned int phone_call_stat;
 
 static int test_power_monitor;
 
@@ -372,6 +373,17 @@
 	return count;
 }
 
+static ssize_t htc_battery_phone_call_stat(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	int i = 0;
+
+	i += scnprintf(buf + i, PAGE_SIZE - i, "%u\n", phone_call_stat);
+
+	return i;
+}
+
 static ssize_t htc_battery_set_phone_call(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
@@ -395,6 +407,8 @@
 	else
 		battery_core_info.func.func_context_event_handler(EVENT_TALK_STOP);
 
+	 phone_call_stat = phone_call;
+
 	return count;
 }
 static ssize_t htc_battery_set_network_search(struct device *dev,
@@ -531,7 +545,7 @@
 		htc_battery_charger_switch),
 	__ATTR(charger_timer, S_IWUSR | S_IWGRP, NULL,
 		htc_battery_charger_ctrl_timer),
-	__ATTR(phone_call, S_IWUSR | S_IWGRP, NULL,
+	__ATTR(phone_call, S_IWUSR | S_IWGRP, htc_battery_phone_call_stat,
 		htc_battery_set_phone_call),
 	__ATTR(network_search, S_IWUSR | S_IWGRP, NULL,
 		htc_battery_set_network_search),
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_headset_mgr.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_headset_mgr.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_headset_mgr.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_headset_mgr.c	2013-08-01 23:37:55.000000000 -0600
@@ -260,6 +260,10 @@
 		HS_LOG("Register 1WIRE_REPORT_TYPE notifier");
 		hs_mgr_notifier.hs_1wire_report_type = notifier->func;
 		break;
+	case HEADSET_REG_HS_INSERT:
+		HS_LOG("Register HS_INSERT notifier");
+		hs_mgr_notifier.hs_insert = notifier->func;
+		break;
 	default:
 		HS_LOG("Unknown register ID");
 		return 0;
@@ -677,6 +681,7 @@
 	case HEADSET_NO_MIC:
 		new_state |= BIT_HEADSET_NO_MIC;
 		HS_LOG("HEADSET_NO_MIC");
+		set_35mm_hw_state(0);
 		break;
 	case HEADSET_MIC:
 		new_state |= BIT_HEADSET;
@@ -721,9 +726,11 @@
 	} else
 		HS_LOG("MIC status has not changed");
 
+if (mic != HEADSET_NO_MIC)
+	{
 	if (hs_mgr_notifier.key_int_enable)
 		hs_mgr_notifier.key_int_enable(1);
-
+	}
 	mutex_unlock(&hi->mutex_lock);
 }
 
@@ -953,6 +960,7 @@
 	case HEADSET_NO_MIC:
 		new_state |= BIT_HEADSET_NO_MIC;
 		HS_LOG_TIME("HEADSET_NO_MIC");
+		set_35mm_hw_state(0);
 		break;
 	case HEADSET_MIC:
 		new_state |= BIT_HEADSET;
@@ -1000,10 +1008,11 @@
 	switch_set_state(&hi->sdev_h2w, new_state);
 	hpin_report++;
 
-
-	if (hs_mgr_notifier.key_int_enable)
-		hs_mgr_notifier.key_int_enable(1);
-
+	if (mic != HEADSET_NO_MIC)
+		{
+			if (hs_mgr_notifier.key_int_enable)
+				hs_mgr_notifier.key_int_enable(1);
+		}
 	mutex_unlock(&hi->mutex_lock);
 
 #ifdef HTC_HEADSET_CONFIG_QUICK_BOOT
@@ -1032,6 +1041,9 @@
 	hi->is_ext_insert = insert;
 	mutex_unlock(&hi->mutex_lock);
 
+	if (hs_mgr_notifier.hs_insert)
+		hs_mgr_notifier.hs_insert(insert);
+
 	cancel_delayed_work_sync(&mic_detect_work);
 	ret = cancel_delayed_work_sync(&insert_detect_work);
 	if (ret && hs_mgr_notifier.key_int_enable) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_headset_one_wire.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_headset_one_wire.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_headset_one_wire.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_headset_one_wire.c	2013-08-01 23:37:56.000000000 -0600
@@ -277,7 +277,7 @@
 	char *hs_type[] = {
 		"headset_beats_20",
 		"headset_mic_midtier",
-		"headset_beats_solo_20",
+		"headset_mic_oneseg",
 	};
 	hi->aid &= 0x7f;
 	HS_LOG("[1wire]AID = 0x%x", hi->aid);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_util.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_util.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/htc_util.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/htc_util.c	2013-08-01 23:37:52.000000000 -0600
@@ -704,6 +704,9 @@
 	struct task_cputime cputime;
 	int dump_top_stack = 0;
 	int pid_cnt = 0;    
+#ifdef CONFIG_DEBUG_KSWAPD
+	struct task_struct *kswapd_t = NULL;
+#endif
 
 	if (task_ptr_array == NULL ||
 			curr_proc_delta == NULL ||
@@ -761,8 +764,20 @@
 				top_loading[i],
 				task_ptr_array[top_loading[i]]->comm,
 				curr_proc_delta[top_loading[i]]);
+#ifdef CONFIG_DEBUG_KSWAPD
+		if (task_ptr_array[top_loading[i]] && task_ptr_array[top_loading[i]]->flags & PF_KSWAPD)
+			kswapd_t = task_ptr_array[top_loading[i]];
+#endif
 	}
 
+#ifdef CONFIG_DEBUG_KSWAPD
+	if (kswapd_t) {
+		printk("\n[K][DEBUG] ###pid:%d name:%s state:%lu ppid:%d stime:%lu utime:%lu\n",
+				kswapd_t->pid, kswapd_t->comm, kswapd_t->state, kswapd_t->real_parent->pid, kswapd_t->stime, kswapd_t->utime);
+		show_stack(kswapd_t, NULL);
+	}
+#endif
+
 	
 	if (dump_top_stack) {
 	   struct task_struct *t;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/board.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/board.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/board.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/board.h	2013-08-01 23:37:52.000000000 -0600
@@ -337,6 +337,7 @@
 	enum sensor_flip_mirror_info mirror_flip;
 	void *privacy_light_info;
 	enum sensor_mount_angle sensor_mount_angle; 
+	bool ews_enable;
 	
 };
 
@@ -539,11 +540,19 @@
 	void (*panel_config_gpio)(int);
 	int (*vga_switch)(int select_vga);
 	int *gpio_num;
+#ifdef CONFIG_FB_MSM_412
 	int mdp_core_clk_rate;
 	unsigned num_mdp_clk;
 	int *mdp_core_clk_table;
 	u32 mdp_max_clk;
 	u32 mdp_min_clk;
+#else
+	u32 mdp_max_clk;
+	u32 mdp_max_bw;
+	u32 mdp_bw_ab_factor;
+	u32 mdp_bw_ib_factor;
+#endif
+
 #ifdef CONFIG_MSM_BUS_SCALING
 	struct msm_bus_scale_pdata *mdp_bus_scale_table;
 #endif
@@ -552,6 +561,8 @@
 	u32 ov1_wb_size;  
 	u32 mem_hid;
 	char cont_splash_enabled;
+	u32 splash_screen_addr;
+	u32 splash_screen_size;
 	char mdp_iommu_split_domain;
 	int (*mdp_color_enhance)(void);
 	int (*mdp_gamma)(void);
@@ -619,6 +630,7 @@
 	char dlane_swap;
 	void (*dsi_pwm_cfg)(void);
 	char enable_wled_bl_ctrl;
+	void (*gpio_set_backlight)(int bl_level);
 	unsigned char (*shrink_pwm)(int val);
 };
 
@@ -634,6 +646,7 @@
 struct msm_fb_platform_data {
 	int (*detect_client)(const char *name);
 	int mddi_prescan;
+	unsigned char ext_resolution;
 	int (*allow_set_offset)(void);
 	char prim_panel_name[PANEL_NAME_MAX_LEN];
 	char ext_panel_name[PANEL_NAME_MAX_LEN];
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/camera.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/camera.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/camera.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/camera.h	2013-08-01 23:38:00.000000000 -0600
@@ -362,7 +362,11 @@
 	int (*a_create_subdevice)(void *, void *);
 	int (*a_config)(void __user *);
 	int is_ois_supported;
-    int is_cal_supported; 
+	int is_cal_supported; 
+	int small_step_damping;
+	int medium_step_damping;
+	int big_step_damping;
+	int is_af_infinity_supported;
 	
 	void (*do_vcm_on_cb)(void);
 	void (*do_vcm_off_cb)(void);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/event_timer.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/event_timer.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/event_timer.h	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/event_timer.h	2013-08-01 23:38:01.000000000 -0600
@@ -0,0 +1,49 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MSM_EVENT_TIMER_H
+#define __ARCH_ARM_MACH_MSM_EVENT_TIMER_H
+
+#include <linux/hrtimer.h>
+
+struct event_timer_info;
+
+#ifdef CONFIG_MSM_EVENT_TIMER
+struct event_timer_info *add_event_timer(void (*function)(void *), void *data);
+
+void activate_event_timer(struct event_timer_info *event, ktime_t event_time);
+
+void deactivate_event_timer(struct event_timer_info *event);
+
+void destroy_event_timer(struct event_timer_info *event);
+
+ktime_t get_next_event_time(void);
+#else
+static inline void *add_event_timer(void (*function)(void *), void *data)
+{
+	return NULL;
+}
+
+static inline void activate_event_timer(void *event, ktime_t event_time) {}
+
+static inline void deactivate_event_timer(void *event) {}
+
+static inline void destroy_event_timer(void *event) {}
+
+static inline ktime_t get_next_event_time(void)
+{
+	return ns_to_ktime(0);
+}
+
+#endif 
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/gpiomux.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/gpiomux.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/gpiomux.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/gpiomux.h	2013-08-01 23:37:52.000000000 -0600
@@ -91,6 +91,8 @@
 
 int msm_gpiomux_put(unsigned gpio);
 
+int msm_gpiomux_read(unsigned gpio);
+
 /* Install a new setting in a gpio.  To erase a slot, use NULL.
  * The old setting that was overwritten can be passed back to the caller
  * old_setting can be NULL if the caller is not interested in the previous
@@ -103,6 +105,7 @@
 	struct gpiomux_setting *setting, struct gpiomux_setting *old_setting);
 
 void __msm_gpiomux_write(unsigned gpio, struct gpiomux_setting val);
+unsigned __msm_gpiomux_read(unsigned gpio);
 #else
 static inline int msm_gpiomux_init(size_t ngpio)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/htc_battery_8960.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/htc_battery_8960.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/htc_battery_8960.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/htc_battery_8960.h	2013-08-01 23:37:56.000000000 -0600
@@ -117,6 +117,7 @@
 	int critical_alarm_vol_cols;
 	int overload_vol_thr_mv;
 	int overload_curr_thr_ma;
+	int smooth_chg_full_delay_min;
 	struct htc_gauge igauge;
 	struct htc_charger icharger;
 	int (*get_thermal_sensor_temp)(int sensor_num, unsigned long *temp);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/htc_headset_mgr.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/htc_headset_mgr.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/htc_headset_mgr.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/htc_headset_mgr.h	2013-08-01 23:37:55.000000000 -0600
@@ -215,6 +215,7 @@
 	HEADSET_REG_1WIRE_READ_KEY,
 	HEADSET_REG_1WIRE_DEINIT,
 	HEADSET_REG_1WIRE_REPORT_TYPE,
+	HEADSET_REG_HS_INSERT,
 };
 
 enum {
@@ -292,6 +293,7 @@
 	int (*hs_1wire_read_key)(void);
 	int (*hs_1wire_deinit)(void);
 	int (*hs_1wire_report_type)(char **);
+	int (*hs_insert)(int);
 };
 
 struct htc_headset_mgr_platform_data {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/iommu.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/iommu.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/iommu.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/iommu.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -119,7 +119,6 @@
 }
 #endif
 
-#endif
 
 static inline int msm_soc_version_supports_iommu_v1(void)
 {
@@ -143,3 +142,4 @@
 	}
 	return 1;
 }
+#endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/msm_iomap-8960.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/msm_iomap-8960.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/msm_iomap-8960.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/msm_iomap-8960.h	2013-08-01 23:37:51.000000000 -0600
@@ -130,7 +130,7 @@
 
 #else 
 
-  #if defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY)
+  #if defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY)
     #define MSM_HTC_RAM_CONSOLE_PHYS	0x8D900000	
   #else
     #define MSM_HTC_RAM_CONSOLE_PHYS	0x8F100000
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/msm_serial_hs.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/msm_serial_hs.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/msm_serial_hs.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/msm_serial_hs.h	2013-08-01 23:37:56.000000000 -0600
@@ -35,4 +35,8 @@
 void msm_hs_request_clock_on(struct uart_port *uport);
 void msm_hs_set_mctrl(struct uart_port *uport,
 				    unsigned int mctrl);
+
+void dump_uart_ringbuffer(void);
+void DbgBuffer_printRaw( void *raw, int size, const char *msg);
+void DbgBuffer_printLog( const char * fmt, ...);
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/panel_id.h monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/panel_id.h
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/include/mach/panel_id.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/include/mach/panel_id.h	2013-08-01 23:37:52.000000000 -0600
@@ -63,123 +63,6 @@
 
 #define	PANEL_ID_START		0x0F
 
-#define PANEL_ID_SAG_SONY	(0x10 | BL_SPI	| IF_LCDC | DEPTH_RGB666)
-#define PANEL_ID_SPADE_AUO_N90	(0x11 | BL_UP | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_SPADE_SHA_N90	(0x12 | BL_UP | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_SAG_HITACHI	(0x13 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_ICON_SHARP	(0x14 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_FLR_SMD_XC	(0x15 | BL_UP	| IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_ICON_TPO	(0x16 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_VIVOW_HITACHI	(0x17 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_BLS_HITACHI	(0x17 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_BLSC_HITACHI	(0x17 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_FLR_LG_XC	(0x18 | BL_UP	| IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_FLR_LG_WS2	(0x19 | BL_UP	| IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_PYD_SHARP_WVGA	(0x20 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PYD_SHARP	(0x21 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PYD_AUO_NT	(0x22 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PYD_AUO_OTM	(0x23 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_DOT_SONY	(0x24 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_DOT_SONY_C3	(0x24 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_DOT_HITACHI	(0x25 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_SHR_SHARP_NT	(0x26 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_EXP_SMD	(0x27 | BL_UP | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_EXP_LG		(0x28 | BL_UP | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_VERDI_AUO	(0x29 | BL_PMIC | IF_LCDC | DEPTH_RGB666)
-#define PANEL_ID_VERDI_AUO_RGB888	(0x29 | BL_PMIC | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_VERDI_SAMSUNG	(0x2A | BL_PMIC | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_VERDI_SAMSUNG	(0x2A | BL_PMIC | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_VERDILTE_AUO      (0x29 | BL_PMIC | IF_LCDC | DEPTH_RGB666)
-#define PANEL_ID_VERDILTE_AUO_RGB888      (0x29 | BL_PMIC | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_VERDILTE_SAMSUNG  (0x2A | BL_PMIC | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_KIM_SONY	(0x2B | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_KIM_SONY_C2	(0x2B | BL_MDDI | IF_MDDI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_RIR_SHARP_NT (0x2C | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_SHR_SHARP_OTM (0x2D | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_SHR_SHARP_OTM_C2 (0x2D | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_RIR_AUO_OTM (0x2E | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_RIR_AUO_OTM_C2 (0x2E | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_RIR_AUO_OTM_C3 (0x2E | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_HOY_SONY_OTM (0x2F | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_EXP_LG_WS2	(0x30 | BL_UP | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_RIR_SHARP_OTM (0x31 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_RIR_AUO_NT    (0x32 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_RUBY_SHARP    (0x33 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PIO_AUO    (0x34 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PIO_SAMSUNG    (0x35 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PIO_SAMSUNG_C2    (0x35 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_KIM_SAMSUNG	(0x36 | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_BLS_SONY	(0x37 | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_BLSC_SONY	(0x37 | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_RUY_SHARP_NT	(0X38 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_RUY_SHARP_NT_C2 (0X38 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_RUY_SHARP_NT_C2O (0X38 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_VIG_SHARP_HX	(0x39 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_VIG_SHARP_HX_C2	(0x39 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_VIG_SHARP_HX_C25	(0x39 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_VIG_SHARP_HX_C3	(0x39 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_3)
-#define PANEL_ID_RUE_SONY_NT	(0x3A | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_VIG_CHIMEI_HX (0x3B | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_VIG_CHIMEI_HX_C25	(0x3B | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_VIG_CHIMEI_HX_C3	(0x3B | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_TAGH_HITACHI  (0x40 | BL_MDDI | IF_MDDI | DEPTH_RGB666)
-#define PANEL_ID_TAGH_HITACHI_LT       (0x40 | BL_MDDI | IF_MDDI | DEPTH_RGB666 | REV_1)
-#define PANEL_ID_POP_SAMSUNG    (0x41 | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_POP_PIOSMD     (0x42 | BL_MDDI | IF_MDDI | DEPTH_RGB888)
-#define PANEL_ID_VILLE_SAMSUNG_SG (0x43 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_VILLE_SAMSUNG_SG_C2 (0x43 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_VILLEC2_SAMSUNG_SG  (0x43 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_FIGHTER_SAMSUNG_NT	(0x44 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_FIGHTER_SAMSUNG_NT_C2	(0x44 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_FIGHTER_SAMSUNG_NT_C3	(0x44 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_FIGHTER_SONY_OTM (0x45 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_FIGHTER_SONY_OTM_C1_1 (0x45 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_FIGHTER_SONY_OTM_MP (0x45 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_FIGHTER_LG_NT (0x46 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_FIGHTER_LG_NT_C2 (0x46 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_FIGHTER_LG_NT_MP (0x46 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_ELITE_SONY_NT (0x47 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_ELITE_SONY_NT_C1 (0x47 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_ELITE_SONY_NT_C2 (0x47 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_ELITE_SHARP_HX (0x48 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_TAI_HITACHI_NT (0x49 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_TAI_HITACHI_NT_C1 (0x49 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_ELITE_AUO_NT (0x4A | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_JET_SONY_NT (0x4B | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_JET_SONY_NT_C1 (0x4B | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_JET_SONY_NT_C2 (0x4B | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_JET_AUO_NT (0x4C | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_JET_AUO_NT_C2 (0x4C | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_JET_AUO_NT_C3 (0x4C | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_3)
-#define PANEL_ID_JET_AUO_NT_C3_1    (0x4C | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_4)
-#define PANEL_ID_VALENTE_SAMSUNG_SG (0x4D | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_VALENTE_SAMSUNG_SG_C2 (0x4D | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_VALENTE_SAMSUNG_SG_C3 (0x4D | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_ELITE_SHARP_NT (0x4E | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_ELITE_SHARP_NT_C1 (0x4E | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1)
-#define PANEL_ID_ELITE_SHARP_NT_C2 (0x4E | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_2)
-#define PANEL_ID_PRIMODS_SONY    (0x4F | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PRIMODS_LG    (0x50 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_PRIMODD_SONY    (0x51 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_PRIMODD_LG    (0x52 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_VILLE_AUO (0x53 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_GOLFU_AUO (0x54 | BL_MIPI | IF_MIPI | DEPTH_RGB565)
-#define PANEL_ID_PROTD_LG       (0x56 | BL_SPI | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_PROTD_HITACHI  (0x57 | BL_SPI | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_PRIMODD_SHARP (0x58 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_PRIMODD_SHARP_C1 (0x58 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_PRIMODS_SHARP (0x59 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_PRIMODS_SHARP_C1 (0x59 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_1 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_PROTD_SHARP  (0x5A | BL_SPI | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_DLX_SHARP_RENESAS  (0x5B | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_DLX_SONY_RENESAS  (0x5C | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_K2_WL_AUO (0x5C | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_K2_WL_AUO_C2 (0x5C | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY |REV_1)
-#define PANEL_ID_K2_WL_JDI_NT (0x5D | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_K2_WL_JDI_NT_T02 (0x5D | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY |REV_1)
-#define PANEL_ID_IMN_SHARP_HX (0x60 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_MAGNIDS_SHARP    (0x61 | BL_SPI | IF_LCDC | DEPTH_RGB888)
-#define PANEL_ID_MAGNIDS_AUO    (0x62 | BL_SPI | IF_LCDC | DEPTH_RGB888)
 #define PANEL_ID_DLXJ_SHARP_RENESAS  (0x63 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 #define PANEL_ID_DLXJ_SONY_RENESAS  (0x64 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 #define PANEL_ID_monarudo_JDI_SAMSUNG  (0x65 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
@@ -188,20 +71,8 @@
 #define PANEL_ID_monarudo_JDI_SAMSUNG_C2_2  (0x65 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | REV_3)
 #define PANEL_ID_monarudo_SHARP_NT  (0x66 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 #define PANEL_ID_monarudo_SHARP_RENESAS  (0x67 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_IMN_SHARP_NT  (0x68 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 #define PANEL_ID_monarudo_SHARP_RENESAS_C1  (0X69 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_OPA_SHARP_HX_ROTA  (0x6A | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_OPA_SHARP_HX (0x6B | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_OPA_SHARP_NT_ROTA  (0x70 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_OPA_SHARP_NT (0x71 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_monarudoCHINA_SHARP_NT  (0x72 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_CP3_SONY_ORISE (0x73 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 #define PANEL_ID_monarudo_JDI_RENESAS (0x74 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_CP3_LG_NOVATEK (0x75 | BL_MIPI | IF_MIPI | DEPTH_RGB888 | MIPI_VIDEO_ONLY)
-#define PANEL_ID_KIWI_SHARP_HX (0x76 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_KIWI_AUO_NT (0x77 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_ANDROMEDA_SHARP_HX (0x78 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
-#define PANEL_ID_ANDROMEDA_AUO_NT (0x79 | BL_MIPI | IF_MIPI | DEPTH_RGB888)
 
 #define	PANEL_ID_END		0xFFFF
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/Kconfig monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -146,6 +146,7 @@
 	select MSM_RUN_QUEUE_STATS
 	select ARM_HAS_SG_CHAIN
 	select MSM_KRAIT_WFE_FIXUP
+	select MSM_IOMMU_GPU_SYNC
 
 config ARCH_MSM8930
 	bool "MSM8930"
@@ -458,6 +459,10 @@
         default n
         bool "HTC Performance Lock"
 
+config DEBUG_KSWAPD
+        default n
+        bool "HTC Debug Kswapd busy"
+
 config PERFLOCK_FIX_UP
         depends on CPU_FREQ
         depends on PERFLOCK
@@ -2676,23 +2681,23 @@
 	help
 	  Support for the HTC APQ8064 MONARUDO.
 
-config MACH_monarudo_UL
+config MACH_DELUXE_J
         depends on ARCH_APQ8064
-        bool "APQ8064 monarudo_UL"
+        bool "APQ8064 DELUXE_J"
         help
-          Support for the HTC APQ8064 monarudo_UL.
+          Support for the HTC APQ8064 DELUXE_J.
 
-config MACH_monarudo_DXG
+config MACH_IMPRESSION_J
         depends on ARCH_APQ8064
-        bool "APQ8064 monarudo_DXG"
+        bool "APQ8064 IMPRESSION_J"
         help
-          Support for the HTC APQ8064 monarudo_DXG.
+          Support for the HTC APQ8064 IMPRESSION_J.
 
-config MACH_T6_DXG
+config MACH_monarudo_UL
         depends on ARCH_APQ8064
-        bool "APQ8064 T6_DXG"
+        bool "APQ8064 monarudo_UL"
         help
-          Support for the HTC APQ8064 T6_DXG.
+          Support for the HTC APQ8064 monarudo_UL.
 
 config QSC_MODEM
         default n
@@ -2755,5 +2760,10 @@
 	  stand alone power collapse operation. Selecting this option
 	  ensures that they are always off.
 
+config QUALCOMM_WLAN_PXO
+	default n
+	bool "Use PXO for WLAN clock source"
+	help
+	  Use PXO for clock source of WLAN chip
 endif
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/Makefile monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -224,6 +224,8 @@
 
 ifdef CONFIG_BT
 	obj-$(CONFIG_MACH_MONARUDO) += board-monarudo-rfkill.o  htc_bdaddress.o
+	obj-$(CONFIG_MACH_DELUXE_J) += board-deluxe_j-rfkill.o  htc_bdaddress.o
+	obj-$(CONFIG_MACH_IMPRESSION_J) += board-impression_j-rfkill.o  htc_bdaddress.o
 	obj-$(CONFIG_MACH_monarudo_UL) += board-monarudo-rfkill.o  htc_bdaddress.o htc_4335_wl_reg.o
 endif
 
@@ -292,13 +294,20 @@
 board-elite-all-objs += board-elite.o board-elite-gpiomux.o devices-8960.o board-8960-storage.o
 # board-monarudo-all-objs += board-monarudo.o board-monarudo-pmic.o board-monarudo-storage.o board-monarudo-gpiomux.o board-monarudo-display.o board-monarudo-gpu.o board-monarudo-keypad.o board-monarudo-wifi.o
 board-monarudo-all-objs += board-monarudo.o board-monarudo-pmic.o board-monarudo-storage.o board-monarudo-gpiomux.o board-monarudo-display.o board-monarudo-gpu.o board-monarudo-keypad.o board-monarudo-wifi.o  board-monarudo-audio.o
+board-deluxe_j-all-objs += board-deluxe_j.o board-deluxe_j-pmic.o board-deluxe_j-storage.o board-deluxe_j-gpiomux.o board-deluxe_j-keypad.o board-deluxe_j-wifi.o board-deluxe_j-audio.o
+board-impression_j-all-objs += board-impression_j.o board-impression_j-pmic.o board-impression_j-storage.o board-impression_j-gpiomux.o board-impression_j-keypad.o board-impression_j-wifi.o board-impression_j-audio.o
 board-monarudo-all-objs += board-monarudo.o board-monarudo-pmic.o board-monarudo-storage.o board-monarudo-gpiomux.o board-monarudo-keypad.o board-monarudo-wifi.o board-monarudo-audio.o
 
 ifdef CONFIG_FB_MSM
+board-deluxe_j-all-objs += board-deluxe_j-display.o board-deluxe_j-gpu.o
+board-impression_j-all-objs += board-impression_j-display.o board-impression_j-gpu.o
 board-monarudo-all-objs += board-monarudo-display.o board-monarudo-gpu.o
 endif
+
 ifdef CONFIG_MSM_CAMERA
 board-monarudo-all-objs += board-monarudo-camera.o
+board-deluxe_j-all-objs += board-deluxe_j-camera.o
+board-impression_j-all-objs += board-impression_j-camera.o
 board-monarudo-all-objs += board-monarudo-camera.o
 endif
 obj-$(CONFIG_MACH_MSM8960_SIM) += board-8960-all.o board-8960-regulator.o
@@ -318,9 +327,13 @@
 obj-$(CONFIG_MACH_MPQ8064_HRD) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_MPQ8064_DTV) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_MONARUDO) += board-monarudo-all.o board-monarudo-regulator.o
+obj-$(CONFIG_MACH_DELUXE_J) += board-deluxe_j-all.o board-deluxe_j-regulator.o
+obj-$(CONFIG_MACH_IMPRESSION_J) += board-impression_j-all.o board-impression_j-regulator.o
 obj-$(CONFIG_MACH_monarudo_UL) += board-monarudo-all.o board-monarudo-regulator.o
 
 obj-$(CONFIG_MACH_MONARUDO) += htc_util.o
+obj-$(CONFIG_MACH_DELUXE_J) += htc_util.o ADP5585_ioextender.o
+obj-$(CONFIG_MACH_IMPRESSION_J) += htc_util.o ADP5585_ioextender.o
 obj-$(CONFIG_MACH_monarudo_UL) += htc_util.o
 obj-$(CONFIG_MACH_ELITE) += board-elite.o board-elite-regulator.o board-elite-gpiomux.o board-elite-storage.o board-elite-audio.o board-elite-camera.o
 obj-$(CONFIG_MACH_ELITE) += board-elite-keypad.o
@@ -345,6 +358,8 @@
 
 
 
+
+
 
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/mdm_common.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/mdm_common.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/mdm_common.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/mdm_common.c	2013-08-01 23:37:56.000000000 -0600
@@ -128,6 +128,7 @@
 	char modem_errmsg[RD_BUF_SIZE];
 };
 int mdm_msr_index = 0;
+static spinlock_t msr_info_lock;
 static struct mdm_msr_info msr_info_list[MODEM_ERRMSG_LIST_LEN];
 #endif
 
@@ -162,7 +163,27 @@
 static ssize_t modem_silent_reset_info_store(struct device *dev,
 		struct device_attribute *attr,	const char *buf, size_t count)
 {
-	return -EPERM;
+	int len = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&msr_info_lock, flags);
+
+	msr_info_list[mdm_msr_index].valid = 1;
+	msr_info_list[mdm_msr_index].msr_time = current_kernel_time();
+	snprintf(msr_info_list[mdm_msr_index].modem_errmsg, RD_BUF_SIZE, "%s", buf);
+	len = strlen(msr_info_list[mdm_msr_index].modem_errmsg);
+	if(msr_info_list[mdm_msr_index].modem_errmsg[len-1] == '\n')
+	{
+		msr_info_list[mdm_msr_index].modem_errmsg[len-1] = '\0';
+	}
+
+	if(++mdm_msr_index >= MODEM_ERRMSG_LIST_LEN) {
+		mdm_msr_index = 0;
+	}
+
+	spin_unlock_irqrestore(&msr_info_lock, flags);
+
+	return count;
 }
 
 static ssize_t modem_silent_reset_info_show(struct device *dev,
@@ -170,6 +191,9 @@
 {
 	int i = 0;
 	char tmp[RD_BUF_SIZE+30];
+	unsigned long flags;
+
+	spin_lock_irqsave(&msr_info_lock, flags);
 
 	for( i=0; i<MODEM_ERRMSG_LIST_LEN; i++ ) {
 		if( msr_info_list[i].valid != 0 ) {
@@ -183,20 +207,28 @@
 	}
 	strcat(buf, "\n\r\0");
 
+	spin_unlock_irqrestore(&msr_info_lock, flags);
+
 	return strlen(buf);
 }
-static DEVICE_ATTR(msr_info, S_IRUSR | S_IROTH | S_IRGRP,
+static DEVICE_ATTR(msr_info, S_IRUSR | S_IROTH | S_IRGRP | S_IWUSR,
 	modem_silent_reset_info_show, modem_silent_reset_info_store);
 
 static int modem_silent_reset_info_sysfs_attrs(struct platform_device *pdev)
 {
 	int i = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&msr_info_lock, flags);
+
 	mdm_msr_index = 0;
 	for( i=0; i<MODEM_ERRMSG_LIST_LEN; i++ ) {
 		msr_info_list[i].valid = 0;
 		memset(msr_info_list[i].modem_errmsg, 0, RD_BUF_SIZE);
 	}
 
+	spin_unlock_irqrestore(&msr_info_lock, flags);
+
 	return device_create_file(&pdev->dev, &dev_attr_msr_info);
 }
 #endif
@@ -206,6 +238,9 @@
 {
 	int ret, ntries = 0;
 	char sfr_buf[RD_BUF_SIZE];
+#ifdef CONFIG_HTC_STORE_MODEM_RESET_INFO
+	unsigned long flags;
+#endif
 
 	do {
 		msleep(SFR_RETRY_INTERVAL);
@@ -218,12 +253,16 @@
 		} else {
 			pr_err("mdm restart reason: %s\n", sfr_buf);
 #ifdef CONFIG_HTC_STORE_MODEM_RESET_INFO
+			spin_lock_irqsave(&msr_info_lock, flags);
+
 			msr_info_list[mdm_msr_index].valid = 1;
 			msr_info_list[mdm_msr_index].msr_time = current_kernel_time();
 			snprintf(msr_info_list[mdm_msr_index].modem_errmsg, RD_BUF_SIZE, "%s", sfr_buf);
 			if(++mdm_msr_index >= MODEM_ERRMSG_LIST_LEN) {
 				mdm_msr_index = 0;
 			}
+
+			spin_unlock_irqrestore(&msr_info_lock, flags);
 #endif
 			break;
 		}
@@ -590,10 +629,11 @@
 
 static irqreturn_t mdm_errfatal(int irq, void *dev_id)
 {
-	pr_err("%s: mdm got errfatal interrupt\n", __func__);
+	pr_err("%s: detect mdm errfatal pin rising\n", __func__);
 
 	if (mdm_drv->mdm_ready &&
 		(gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 1)) {
+		pr_err("%s: mdm got errfatal interrupt\n", __func__);
 		pr_debug("%s: scheduling work now\n", __func__);
 		queue_work_on(0, mdm_queue, &mdm_fatal_work);	
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/msm_watchdog.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/msm_watchdog.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/msm_watchdog.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/msm_watchdog.c	2013-08-01 23:37:56.000000000 -0600
@@ -214,6 +214,7 @@
 	__raw_writel(1, msm_tmr0_base + WDT0_RST);
 	last_pet = sched_clock();
 	mb();
+	set_dog_pet_footprint();
 	set_WDT_EN_footprint(1);
 	printk(KERN_DEBUG "msm_watchdog_resume\n");
 	mb();
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/peripheral-loader.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/peripheral-loader.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/peripheral-loader.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/peripheral-loader.c	2013-08-01 23:37:52.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/jiffies.h>
 #include <linux/wakelock.h>
 #include <linux/delay.h>
+#include <linux/completion.h>
 
 #include <asm/uaccess.h>
 #include <asm/setup.h>
@@ -62,6 +63,8 @@
 
 #define to_pil_device(d) container_of(d, struct pil_device, dev)
 
+extern struct completion pil_work_finished;
+
 static ssize_t name_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
@@ -388,6 +391,13 @@
 	pil->count++;
 	pil_set_state(pil, PIL_ONLINE);
 	mutex_unlock(&pil->lock);
+#if defined(CONFIG_MSM8930_ONLY)
+	if (!strcmp("modem", name)) {
+		complete_all(&pil_work_finished);
+	}
+#elif defined(CONFIG_ARCH_APQ8064)
+		complete_all(&pil_work_finished);
+#endif
 out:
 	return retval;
 err_load:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/pil-riva.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/pil-riva.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/pil-riva.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/pil-riva.c	2013-08-01 23:37:56.000000000 -0600
@@ -128,6 +128,7 @@
   CLOCK_SOURCE_PLL13  
 };
 
+#ifdef CONFIG_QUALCOMM_WLAN_PXO
 static bool Clock_WaitForPLLActive (u32 nPLL)
 {
   u32 nLoops = 100;
@@ -165,6 +166,7 @@
   return FALSE;
 
 } 
+#endif
 
 static bool cxo_is_needed(struct riva_data *drv)
 {
@@ -214,11 +216,13 @@
 static int pil_riva_reset(struct pil_desc *pil)
 {
 	u32 reg, sel;
-	u32 nLoopCount = 5;
 	struct riva_data *drv = dev_get_drvdata(pil->dev);
 	void __iomem *base = drv->base;
 	unsigned long start_addr = drv->start_addr;
 	bool use_cxo = cxo_is_needed(drv);
+#ifdef CONFIG_QUALCOMM_WLAN_PXO
+	u32 nLoopCount = 5;
+#endif
 
 	
 	reg = readl_relaxed(base + RIVA_PMU_A2XB_CFG);
@@ -260,6 +264,7 @@
 	usleep_range(50, 100);
 
 	
+#ifdef CONFIG_QUALCOMM_WLAN_PXO
 	printk("[WLAN][SSR] Wait for PLL warm-up\n");
 	while(nLoopCount > 0) 
 	{
@@ -270,7 +275,10 @@
 	}
 
 	if(nLoopCount == 0)
-	{return -1;}
+	{
+		printk("[WLAN][SSR] PLL lock detection failed!\n");
+		return -1;
+	}
 	printk("[WLAN][SSR] Check PLL lock detection passed\n");
 
 	HWIO_RIVA_PLL_MODE_OUTM(0x1, (u32)(1) << (0x0)); 
@@ -278,9 +286,9 @@
 	if (Clock_WaitForPLLActive(CLOCK_SOURCE_PLL13) == FALSE)
 	{return -1;}
 	printk("[WLAN][SSR] Wait for PLL Active ...OK!\n");
+#endif
 	
 
-
 	
 	sel = readl_relaxed(base + RIVA_PMU_ROOT_CLK_SEL);
 	reg = readl_relaxed(base + RIVA_PMU_CLK_ROOT3);
@@ -321,11 +329,13 @@
 	writel_relaxed(reg, base + RIVA_PMU_OVRD_VAL);
 
 	
+#ifdef CONFIG_QUALCOMM_WLAN_PXO
 	printk("[WLAN][SSR] Use PXO for RIVA\n");
 
 	HWIO_RIVA_RESET_OUTM((0x2),(u32)(1) << (0x1)); 
 	HWIO_RIVA_XO_SRC_CLK_CTL_OUTM((0x00000004), (u32)(1) << (0x2)); 
 	HWIO_RIVA_RESET_OUTM((0x2),(u32)(0) << (0x1)); 
+#endif
 	
 
 	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/qdsp6v2/apr.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/qdsp6v2/apr.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/qdsp6v2/apr.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/qdsp6v2/apr.c	2013-08-01 23:37:53.000000000 -0600
@@ -36,11 +36,6 @@
 #include <mach/subsystem_notif.h>
 #include <mach/subsystem_restart.h>
 
-#undef pr_info
-#undef pr_err
-#define pr_info(fmt, ...) pr_aud_info(fmt, ##__VA_ARGS__)
-#define pr_err(fmt, ...) pr_aud_err(fmt, ##__VA_ARGS__)
-
 struct apr_q6 q6;
 struct apr_client client[APR_DEST_MAX][APR_CLIENT_MAX];
 static atomic_t dsp_state;
@@ -61,7 +56,7 @@
 
 static void apr_q6_check_worker(struct work_struct *work)
 {
-	pr_info("%s: %d\n", __func__, q6.state);
+	pr_info("[AUD] %s: %d\n", __func__, q6.state);
 
 	
 	if (q6.state != APR_Q6_LOADED) {
@@ -388,7 +383,7 @@
 	mutex_lock(&q6.lock);
 	if (q6.state == APR_Q6_NOIMG) {
 
-		pr_info("%s: Load Q6 image\n", __func__);
+		pr_info("[AUD] %s: Load Q6 image\n", __func__);
 		cancel_delayed_work_sync(&apr_q6_check_work);
 		queue_delayed_work(apr_reset_workqueue, &apr_q6_check_work,
 							msecs_to_jiffies(APR_Q6_CHECK_TIMEOUT));
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/qdsp6v2/apr_tal.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/qdsp6v2/apr_tal.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/qdsp6v2/apr_tal.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/qdsp6v2/apr_tal.c	2013-08-01 23:37:53.000000000 -0600
@@ -28,11 +28,6 @@
 #include <mach/msm_smd.h>
 #include <mach/qdsp6v2/apr_tal.h>
 
-#undef pr_info
-#undef pr_err
-#define pr_info(fmt, ...) pr_aud_info(fmt, ##__VA_ARGS__)
-#define pr_err(fmt, ...) pr_aud_err(fmt, ##__VA_ARGS__)
-
 static char *svc_names[APR_DEST_MAX][APR_CLIENT_MAX] = {
 	{
 		"apr_audio_svc",
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/subsystem_restart.c monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/subsystem_restart.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mach-msm/subsystem_restart.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mach-msm/subsystem_restart.c	2013-08-01 23:37:56.000000000 -0600
@@ -508,9 +508,6 @@
 	#endif 
 	
 
-#ifdef CONFIG_QSC_MODEM
-	crashed_modem = 0;
-#endif
 	mutex_unlock(powerup_lock);
 
 	mutex_unlock(&soc_order_reg_lock);
@@ -552,6 +549,9 @@
 		     __func__, subsys->name, rc);
 }
 
+#ifdef CONFIG_SERIAL_MSM_HS_DEBUG_RINGBUFFER
+void dump_uart_ringbuffer(void);
+#endif
 int subsystem_restart(const char *subsys_name)
 {
 	struct subsys_data *subsys;
@@ -580,6 +580,16 @@
 	#endif 
 	
 
+	pr_info("Restart sequence requested for %s, restart_level = %d.\n",
+		subsys_name, restart_level);
+
+	subsys = _find_subsystem(subsys_name);
+
+	if (!subsys) {
+		pr_warn("Unregistered subsystem %s!\n", subsys_name);
+		return -EINVAL;
+	}
+
 #ifdef CONFIG_QSC_MODEM
 	if(strcmp(subsys_name, "external_modem") == 0){
 		crashed_modem = 1;
@@ -591,15 +601,11 @@
 	}
 #endif
 
-	pr_info("Restart sequence requested for %s, restart_level = %d.\n",
-		subsys_name, restart_level);
-
-	subsys = _find_subsystem(subsys_name);
-
-	if (!subsys) {
-		pr_warn("Unregistered subsystem %s!\n", subsys_name);
-		return -EINVAL;
+#ifdef CONFIG_SERIAL_MSM_HS_DEBUG_RINGBUFFER
+	if(strcmp(subsys_name, "qsc_modem") == 0){
+		dump_uart_ringbuffer();
 	}
+#endif
 
 	switch (restart_level) {
 
@@ -713,7 +719,7 @@
 	}
 
 	if (cpu_is_msm8960() || cpu_is_msm8930() || cpu_is_msm8930aa() ||
-	    cpu_is_msm9615() || cpu_is_apq8064() || cpu_is_msm8627()) {
+	    cpu_is_msm9615() || cpu_is_apq8064() || cpu_is_msm8627() || is_qsc_dsda()) {
 		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE) {
 			restart_orders = restart_orders_8960_sglte;
 			n_restart_orders =
@@ -728,7 +734,7 @@
 			n_restart_orders = ARRAY_SIZE(restart_orders_8960);
 		}
 		
-#if defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY)
+#if defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY)
 		if (!0) { 
 			restart_orders = restart_orders_8064_dsda;
 			n_restart_orders =
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mm/proc-syms.c monarudo-jb-3.4.10-e22f38b/arch/arm/mm/proc-syms.c
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/mm/proc-syms.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/mm/proc-syms.c	2012-08-26 16:02:10.000000000 -0600
@@ -41,6 +41,11 @@
 #endif
 #endif
 
+/*
+ * No module should need to touch the TLB (and currently
+ * no modules do.  We export this for "loadkernel" support
+ * (booting a new kernel from within a running kernel.)
+ */
 #ifdef MULTI_TLB
 EXPORT_SYMBOL(cpu_tlb);
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/arch/arm/tools/mach-types monarudo-jb-3.4.10-e22f38b/arch/arm/tools/mach-types
--- monarudo-jb-crc-3.4.10-7edee3c/arch/arm/tools/mach-types	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/arch/arm/tools/mach-types	2013-08-01 23:38:05.000000000 -0600
@@ -1197,5 +1197,6 @@
 msm8625_ffa		MACH_MSM8625_FFA	MSM8625_FFA		4166
 msm8625_evt		MACH_MSM8625_EVT	MSM8625_EVT		4193
 monarudo		MACH_MONARUDO		MONARUDO		4060
+deluxe_j		MACH_DELUXE_J		DELUXE_J		4201
+impression_j		MACH_IMPRESSION_J	IMPRESSION_J		4280
 monarudo_ul           MACH_monarudo_UL          monarudo_UL           4308
-
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/block/blk-core.c monarudo-jb-3.4.10-e22f38b/block/blk-core.c
--- monarudo-jb-crc-3.4.10-7edee3c/block/blk-core.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/block/blk-core.c	2013-08-01 23:37:57.000000000 -0600
@@ -1121,12 +1121,9 @@
 			err = 0;
 			goto wp_end_io;
 		} else if (atomic_read(&emmc_reboot) && (bio->bi_rw & WRITE)) {
-			pr_info("%s: Attempt to write eMMC, %s block %Lu \n", __func__,
+			pr_info("%s: Attempt to write eMMC, %s block %Lu \n", current->comm,
 				bdevname(bio->bi_bdev, b), (unsigned long long)bio->bi_sector);
-			if (!strncmp(current->comm, "jdb", 3))
-				err = 0;
-			else
-				err = 0;
+			err = -EROFS;
 			goto wp_end_io;
 		}
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/base/module.c monarudo-jb-3.4.10-e22f38b/drivers/base/module.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/base/module.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/base/module.c	2012-08-26 16:02:10.000000000 -0600
@@ -44,13 +44,13 @@
 	else if (drv->mod_name) {
 		struct kobject *mkobj;
 
-		
+		/* Lookup built-in module entry in /sys/modules */
 		mkobj = kset_find_obj(module_kset, drv->mod_name);
 		if (mkobj) {
 			mk = container_of(mkobj, struct module_kobject, kobj);
-			
+			/* remember our module structure */
 			drv->p->mkobj = mk;
-			
+			/* kset_find_obj took a reference */
 			kobject_put(mkobj);
 		}
 	}
@@ -58,7 +58,7 @@
 	if (!mk)
 		return;
 
-	
+	/* Don't check return codes; these calls are idempotent */
 	no_warn = sysfs_create_link(&drv->p->kobj, &mk->kobj, "module");
 	driver_name = make_driver_name(drv);
 	if (driver_name) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/base/power/runtime.c monarudo-jb-3.4.10-e22f38b/drivers/base/power/runtime.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/base/power/runtime.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/base/power/runtime.c	2013-08-01 23:38:03.000000000 -0600
@@ -150,7 +150,7 @@
 	retval = rpm_check_suspend_allowed(dev);
 	
 	
-	#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+	#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 	if (msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 		dev_info(dev,"%s: rpm_check_suspend_allowed return %d\n", __func__, retval);
 	}
@@ -1182,7 +1182,7 @@
 		if (!atomic_dec_and_test(&dev->power.usage_count)) {
 			
 			
-			#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+			#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 			if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 				dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 					atomic_read(&dev->power.usage_count));
@@ -1196,7 +1196,7 @@
 
 		
 		
-		#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+		#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 		if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 			dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 				atomic_read(&dev->power.usage_count));
@@ -1225,7 +1225,7 @@
 		if (!atomic_dec_and_test(&dev->power.usage_count)) {
 			
 			
-			#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+			#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 			if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 				dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 					atomic_read(&dev->power.usage_count));
@@ -1238,7 +1238,7 @@
 
 		
 		
-		#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+		#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 		if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 			dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 				atomic_read(&dev->power.usage_count));
@@ -1280,7 +1280,7 @@
 
 		
 		
-		#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+		#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 		if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 			dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 				atomic_read(&dev->power.usage_count));
@@ -1505,7 +1505,7 @@
 
 	
 	
-	#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+	#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 	if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 		dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 			atomic_read(&dev->power.usage_count));
@@ -1533,7 +1533,7 @@
 
 	
 	
-	#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+	#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 	if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 		dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 			atomic_read(&dev->power.usage_count));
@@ -1580,7 +1580,7 @@
 
 			
 			
-			#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+			#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 			if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 				dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 					atomic_read(&dev->power.usage_count));
@@ -1602,7 +1602,7 @@
 
 			
 			
-			#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+			#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 			if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
 				dev_info(dev, "%s[%d] usage_count[%d]\n", __func__, __LINE__,
 					atomic_read(&dev->power.usage_count));
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/base/sync.c monarudo-jb-3.4.10-e22f38b/drivers/base/sync.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/base/sync.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/base/sync.c	2013-08-01 23:38:03.000000000 -0600
@@ -584,9 +584,11 @@
 	}
 
 	if (fence->status == 0) {
-		pr_info("fence timeout on [%p] after %dms\n", fence,
-			jiffies_to_msecs(timeout));
-		sync_dump();
+		if (timeout > 0) {
+			pr_info("fence timeout on [%p] after %dms\n", fence,
+				jiffies_to_msecs(timeout));
+			sync_dump();
+		}
 		return -ETIME;
 	}
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/char/diag/diagfwd_smux.c monarudo-jb-3.4.10-e22f38b/drivers/char/diag/diagfwd_smux.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/char/diag/diagfwd_smux.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/char/diag/diagfwd_smux.c	2013-08-01 23:38:02.000000000 -0600
@@ -77,6 +77,10 @@
 int diag_get_rx_buffer(void *priv, void **pkt_priv, void **buffer, int size)
 {
 	if (!driver->in_busy_smux) {
+		if (!driver->smux_connected) {
+			pr_err("diag: received data in disconnect\n");
+			return -EINVAL;
+		}
 		*pkt_priv = (void *)0x1234;
 		*buffer = driver->buf_in_smux;
 		pr_debug("diag: set in_busy_smux as 1\n");
@@ -191,6 +195,8 @@
 	driver->in_busy_smux = 1;
 	kfree(driver->buf_in_smux);
 	driver->buf_in_smux = NULL;
+
+	pr_info("diag: SMUX removed\n");
 	return 0;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_ondemand.c monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_ondemand.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_ondemand.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_ondemand.c	2013-08-01 23:38:03.000000000 -0600
@@ -31,6 +31,7 @@
 #include <trace/events/cpufreq_interactive.h>
 
 
+#define DEF_SAMPLING_RATE				(50000)
 #define DEF_FREQUENCY_DOWN_DIFFERENTIAL		(10)
 #define DEF_FREQUENCY_UP_THRESHOLD		(80)
 #define DEF_SAMPLING_DOWN_FACTOR		(1)
@@ -498,6 +499,8 @@
 	ret = sscanf(buf, "%u", &input);
 	if (ret != 1)
 		return -EINVAL;
+	if (input == dbs_tuners_ins.origin_sampling_rate)
+		return count;
 	update_sampling_rate(input);
 	dbs_tuners_ins.origin_sampling_rate = dbs_tuners_ins.sampling_rate;
 	return count;
@@ -1355,6 +1358,8 @@
 			dbs_tuners_ins.sampling_rate =
 				max(min_sampling_rate,
 				    latency * LATENCY_MULTIPLIER);
+			if (dbs_tuners_ins.sampling_rate < DEF_SAMPLING_RATE)
+				dbs_tuners_ins.sampling_rate = DEF_SAMPLING_RATE;
 			dbs_tuners_ins.origin_sampling_rate = dbs_tuners_ins.sampling_rate;
 			dbs_tuners_ins.io_is_busy = should_io_be_busy();
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_stats.c monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_stats.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_stats.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_stats.c	2013-08-01 23:38:03.000000000 -0600
@@ -30,6 +30,19 @@
 	.show = _show,\
 };
 
+#ifdef CONFIG_ARCH_APQ8064
+static cputime64_t cpu1_time_in_state[32] = {0};
+static cputime64_t cpu2_time_in_state[32] = {0};
+static cputime64_t cpu3_time_in_state[32] = {0};
+
+static unsigned int cpu1_total_trans;
+static unsigned int cpu2_total_trans;
+static unsigned int cpu3_total_trans;
+#elif defined(CONFIG_ARCH_MSM8960)
+static cputime64_t cpu1_time_in_state[32] = {0};
+static unsigned int cpu1_total_trans;
+#endif
+
 struct cpufreq_stats {
 	unsigned int cpu;
 	unsigned int total_trans;
@@ -59,9 +72,33 @@
 	cur_time = get_jiffies_64();
 	spin_lock(&cpufreq_stats_lock);
 	stat = per_cpu(cpufreq_stats_table, cpu);
+	if (!stat || stat->last_index == -1) {
+		spin_unlock(&cpufreq_stats_lock);
+		return 0;
+	}
+
 	if (stat->time_in_state)
 		stat->time_in_state[stat->last_index] +=
 			cur_time - stat->last_time;
+
+#ifdef CONFIG_ARCH_APQ8064
+   if (cpu == 1)
+	cpu1_time_in_state[stat->last_index] +=
+			cur_time - stat->last_time;
+
+   if (cpu == 2)
+	cpu2_time_in_state[stat->last_index] +=
+			cur_time - stat->last_time;
+
+   if (cpu == 3)
+	cpu3_time_in_state[stat->last_index] +=
+			cur_time - stat->last_time;
+#elif defined(CONFIG_ARCH_MSM8960)
+	if (cpu == 1)
+		cpu1_time_in_state[stat->last_index] +=
+			cur_time - stat->last_time;
+#endif
+
 	stat->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
@@ -76,6 +113,28 @@
 			per_cpu(cpufreq_stats_table, stat->cpu)->total_trans);
 }
 
+#ifdef CONFIG_ARCH_APQ8064
+static ssize_t show_cpu1_total_trans(struct cpufreq_policy *policy, char *buf)
+{
+       return sprintf(buf, "%d\n", cpu1_total_trans);
+}
+
+static ssize_t show_cpu2_total_trans(struct cpufreq_policy *policy, char *buf)
+{
+       return sprintf(buf, "%d\n", cpu2_total_trans);
+}
+
+static ssize_t show_cpu3_total_trans(struct cpufreq_policy *policy, char *buf)
+{
+       return sprintf(buf, "%d\n", cpu3_total_trans);
+}
+#elif defined(CONFIG_ARCH_MSM8960)
+static ssize_t show_cpu1_total_trans(struct cpufreq_policy *policy, char *buf)
+{
+       return sprintf(buf, "%d\n", cpu1_total_trans);
+}
+#endif
+
 static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
 	ssize_t len = 0;
@@ -92,6 +151,80 @@
 	return len;
 }
 
+#ifdef CONFIG_ARCH_APQ8064
+static ssize_t show_cpu1_time_in_state(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i;
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, 1);
+	if (stat)
+		cpufreq_stats_update(1);
+	else
+		stat = per_cpu(cpufreq_stats_table, 0);
+	if (!stat)
+		return 0;
+	for (i = 0; i < stat->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
+			(unsigned long long)cputime64_to_clock_t(cpu1_time_in_state[i]));
+	}
+	return len;
+}
+
+static ssize_t show_cpu2_time_in_state(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i;
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, 2);
+	if (stat)
+		cpufreq_stats_update(2);
+	else
+		stat = per_cpu(cpufreq_stats_table, 0);
+	if (!stat)
+		return 0;
+	for (i = 0; i < stat->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
+			(unsigned long long)cputime64_to_clock_t(cpu2_time_in_state[i]));
+	}
+	return len;
+}
+
+static ssize_t show_cpu3_time_in_state(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i;
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, 3);
+	if (stat)
+		cpufreq_stats_update(3);
+	else
+		stat = per_cpu(cpufreq_stats_table, 0);
+	if (!stat)
+		return 0;
+	for (i = 0; i < stat->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
+			(unsigned long long)cputime64_to_clock_t(cpu3_time_in_state[i]));
+	}
+	return len;
+}
+#elif defined(CONFIG_ARCH_MSM8960)
+static ssize_t show_cpu1_time_in_state(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i;
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, 1);
+	if (stat)
+		cpufreq_stats_update(1);
+	else
+		stat = per_cpu(cpufreq_stats_table, 0);
+	if (!stat)
+		return 0;
+	for (i = 0; i < stat->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
+			(unsigned long long)cputime64_to_clock_t(cpu1_time_in_state[i]));
+	}
+	return len;
+}
+#endif
+
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
@@ -140,11 +273,39 @@
 #endif
 
 CPUFREQ_STATDEVICE_ATTR(total_trans, 0444, show_total_trans);
+
+#ifdef CONFIG_ARCH_APQ8064
+CPUFREQ_STATDEVICE_ATTR(cpu1_total_trans, 0444, show_cpu1_total_trans);
+CPUFREQ_STATDEVICE_ATTR(cpu2_total_trans, 0444, show_cpu2_total_trans);
+CPUFREQ_STATDEVICE_ATTR(cpu3_total_trans, 0444, show_cpu3_total_trans);
+#elif defined(CONFIG_ARCH_MSM8960)
+CPUFREQ_STATDEVICE_ATTR(cpu1_total_trans, 0444, show_cpu1_total_trans);
+#endif
+
 CPUFREQ_STATDEVICE_ATTR(time_in_state, 0444, show_time_in_state);
 
+#ifdef CONFIG_ARCH_APQ8064
+CPUFREQ_STATDEVICE_ATTR(cpu1_time_in_state, 0444, show_cpu1_time_in_state);
+CPUFREQ_STATDEVICE_ATTR(cpu2_time_in_state, 0444, show_cpu2_time_in_state);
+CPUFREQ_STATDEVICE_ATTR(cpu3_time_in_state, 0444, show_cpu3_time_in_state);
+#elif defined(CONFIG_ARCH_MSM8960)
+CPUFREQ_STATDEVICE_ATTR(cpu1_time_in_state, 0444, show_cpu1_time_in_state);
+#endif
+
 static struct attribute *default_attrs[] = {
 	&_attr_total_trans.attr,
 	&_attr_time_in_state.attr,
+#ifdef CONFIG_ARCH_APQ8064
+	&_attr_cpu1_time_in_state.attr,
+	&_attr_cpu1_total_trans.attr,
+	&_attr_cpu2_time_in_state.attr,
+	&_attr_cpu2_total_trans.attr,
+	&_attr_cpu3_time_in_state.attr,
+	&_attr_cpu3_total_trans.attr,
+#elif defined(CONFIG_ARCH_MSM8960)
+	&_attr_cpu1_time_in_state.attr,
+	&_attr_cpu1_total_trans.attr,
+#endif
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	&_attr_trans_table.attr,
 #endif
@@ -158,28 +319,33 @@
 static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 {
 	int index;
+	if ( NULL == stat->freq_table ) {
+		printk(KERN_ERR "cpufreq: freq_table is null !!!\n");
+		return -1;
+	}
 	for (index = 0; index < stat->max_state; index++)
 		if (stat->freq_table[index] == freq)
 			return index;
 	return -1;
 }
 
-/* should be called late in the CPU removal sequence so that the stats
- * memory is still available in case someone tries to use it.
- */
 static void cpufreq_stats_free_table(unsigned int cpu)
 {
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
+	struct cpufreq_stats *stat = NULL;
+	spin_lock(&cpufreq_stats_lock);
+	stat = per_cpu(cpufreq_stats_table, cpu);
+	per_cpu(cpufreq_stats_table, cpu) = NULL;
+	spin_unlock(&cpufreq_stats_lock);
+
 	if (stat) {
+#if defined(CONFIG_ARCH_APQ8064) || defined(CONFIG_ARCH_MSM8960)
+		cpufreq_stats_update(cpu);
+#endif
 		kfree(stat->time_in_state);
 		kfree(stat);
 	}
-	per_cpu(cpufreq_stats_table, cpu) = NULL;
 }
 
-/* must be called early in the CPU removal sequence (before
- * cpufreq_remove_dev) so that policy is still valid.
- */
 static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
@@ -290,32 +456,70 @@
 	if (val != CPUFREQ_POSTCHANGE)
 		return 0;
 
+	cpufreq_stats_update(freq->cpu);
+
+	spin_lock(&cpufreq_stats_lock);
 	stat = per_cpu(cpufreq_stats_table, freq->cpu);
-	if (!stat)
+	if (!stat) {
+		spin_unlock(&cpufreq_stats_lock);
 		return 0;
+	}
 
 	old_index = stat->last_index;
 	new_index = freq_table_get_index(stat, freq->new);
 
-	/* We can't do stat->time_in_state[-1]= .. */
-	if (old_index == -1 || new_index == -1)
+	
+	if (old_index == -1 || new_index == -1) {
+		spin_unlock(&cpufreq_stats_lock);
 		return 0;
+	}
 
-	cpufreq_stats_update(freq->cpu);
-
-	if (old_index == new_index)
+	if (old_index == new_index) {
+		spin_unlock(&cpufreq_stats_lock);
 		return 0;
+	}
 
-	spin_lock(&cpufreq_stats_lock);
 	stat->last_index = new_index;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stat->trans_table[old_index * stat->max_state + new_index]++;
 #endif
 	stat->total_trans++;
+#ifdef CONFIG_ARCH_APQ8064
+	if (freq->cpu == 1)
+		cpu1_total_trans++;
+	if (freq->cpu == 2)
+		cpu2_total_trans++;
+	if (freq->cpu == 3)
+		cpu3_total_trans++;
+#elif defined(CONFIG_ARCH_MSM8960)
+	if (freq->cpu == 1)
+		cpu1_total_trans++;
+#endif
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 }
 
+static int cpufreq_stats_create_table_cpu(unsigned int cpu)
+{
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *table;
+	int ret = -ENODEV;
+
+	policy = cpufreq_cpu_get(cpu);
+	if (!policy)
+		return -ENODEV;
+
+	table = cpufreq_frequency_get_table(cpu);
+	if (!table)
+		goto out;
+
+	ret = cpufreq_stats_create_table(policy, table);
+
+out:
+	cpufreq_cpu_put(policy);
+	return ret;
+}
+
 static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					       unsigned long action,
 					       void *hcpu)
@@ -328,17 +532,21 @@
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
 		break;
 	case CPU_DEAD:
 	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
+		cpufreq_stats_create_table_cpu(cpu);
+		break;
 	}
 	return NOTIFY_OK;
 }
 
-/* priority=1 so this will get called before cpufreq_remove_dev */
 static struct notifier_block cpufreq_stat_cpu_notifier __refdata = {
 	.notifier_call = cpufreq_stat_cpu_callback,
 	.priority = 1,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_userspace.c monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_userspace.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/cpufreq/cpufreq_userspace.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/cpufreq/cpufreq_userspace.c	2013-08-01 23:38:03.000000000 -0600
@@ -23,13 +23,11 @@
 #include <linux/fs.h>
 #include <linux/sysfs.h>
 #include <linux/mutex.h>
-#include <linux/suspend.h>
 
 static DEFINE_PER_CPU(unsigned int, cpu_max_freq);
 static DEFINE_PER_CPU(unsigned int, cpu_min_freq);
 static DEFINE_PER_CPU(unsigned int, cpu_cur_freq); 
 static DEFINE_PER_CPU(unsigned int, cpu_set_freq); 
-static DEFINE_PER_CPU(unsigned int, cpu_pre_freq);
 static DEFINE_PER_CPU(unsigned int, cpu_is_managed);
 
 static DEFINE_MUTEX(userspace_mutex);
@@ -53,35 +51,10 @@
 	return 0;
 }
 
-static int user_cpufreq_pm_event(struct notifier_block *this,
-                                unsigned long event, void *ptr)
-{
-	int cpu = 0;
-	switch (event) {
-	case PM_POST_HIBERNATION:
-	case PM_POST_SUSPEND:
-		for_each_present_cpu(cpu) {
-			per_cpu(cpu_set_freq, cpu) = per_cpu(cpu_pre_freq, cpu);
-			cpufreq_update_policy(cpu);
-		}
-	case PM_HIBERNATION_PREPARE:
-	case PM_SUSPEND_PREPARE:
-		for_each_present_cpu(cpu)
-			per_cpu(cpu_pre_freq, cpu) = per_cpu(cpu_cur_freq, cpu);
-	default:
-		return NOTIFY_DONE;
-        }
-}
-
 static struct notifier_block userspace_cpufreq_notifier_block = {
 	.notifier_call  = userspace_cpufreq_notifier
 };
 
-static struct notifier_block __refdata user_cpufreq_pm_notifier = {
-        .notifier_call = user_cpufreq_pm_event,
-        .priority = -1
-};
-
 
 static int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)
 {
@@ -130,7 +103,6 @@
 			cpufreq_register_notifier(
 					&userspace_cpufreq_notifier_block,
 					CPUFREQ_TRANSITION_NOTIFIER);
-			register_pm_notifier(&user_cpufreq_pm_notifier);
 		}
 		cpus_using_userspace_governor++;
 
@@ -155,7 +127,6 @@
 			cpufreq_unregister_notifier(
 					&userspace_cpufreq_notifier_block,
 					CPUFREQ_TRANSITION_NOTIFIER);
-			unregister_pm_notifier(&user_cpufreq_pm_notifier);
 		}
 
 		per_cpu(cpu_is_managed, cpu) = 0;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce40.c monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce40.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce40.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce40.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,2536 +0,0 @@
-/* Qualcomm Crypto Engine driver.
- *
- * Copyright (c) 2011 - 2012, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mod_devicetable.h>
-#include <linux/device.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/dma-mapping.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/crypto.h>
-#include <linux/qcedev.h>
-#include <linux/bitops.h>
-#include <crypto/hash.h>
-#include <crypto/sha.h>
-#include <mach/dma.h>
-#include <mach/clk.h>
-#include <mach/socinfo.h>
-
-#include "qce.h"
-#include "qce40.h"
-#include "qcryptohw_40.h"
-
-#define LI_SG_CMD  (1 << 31)    
-#define SRC_INDEX_SG_CMD(index) ((index & 0x3fff) << 16)
-#define DST_INDEX_SG_CMD(index) (index & 0x3fff)
-#define ADM_DESC_LAST  (1 << 31)
-#define QCE_FIFO_SIZE  0x8000
-
-struct qce_device {
-	struct device *pdev;        
-
-	unsigned char *coh_vmem;    
-	dma_addr_t coh_pmem;	    
-	int memsize;				
-
-	void __iomem *iobase;	    
-	unsigned int phy_iobase;    
-
-	struct clk *ce_core_src_clk;	
-	struct clk *ce_core_clk;	
-	struct clk *ce_clk;		
-
-	qce_comp_func_ptr_t qce_cb;	
-
-	int assoc_nents;
-	int ivsize;
-	int authsize;
-	int src_nents;
-	int dst_nents;
-
-	void *areq;
-	enum qce_cipher_mode_enum mode;
-	struct ce_dm_data ce_dm;
-};
-
-static uint8_t  _std_init_vector_sha1_uint8[] =   {
-	0x67, 0x45, 0x23, 0x01, 0xEF, 0xCD, 0xAB, 0x89,
-	0x98, 0xBA, 0xDC, 0xFE, 0x10, 0x32, 0x54, 0x76,
-	0xC3, 0xD2, 0xE1, 0xF0
-};
-
-static uint8_t _std_init_vector_sha256_uint8[] = {
-	0x6A, 0x09, 0xE6, 0x67, 0xBB, 0x67, 0xAE, 0x85,
-	0x3C, 0x6E, 0xF3, 0x72, 0xA5, 0x4F, 0xF5, 0x3A,
-	0x51, 0x0E, 0x52, 0x7F, 0x9B, 0x05, 0x68, 0x8C,
-	0x1F, 0x83, 0xD9, 0xAB, 0x5B, 0xE0, 0xCD, 0x19
-};
-
-static void _byte_stream_swap_to_net_words(uint32_t *iv, unsigned char *b,
-		unsigned int len)
-{
-	unsigned i, j;
-	unsigned char swap_iv[AES_IV_LENGTH];
-
-	memset(swap_iv, 0, AES_IV_LENGTH);
-	for (i = (AES_IV_LENGTH-len), j = len-1;  i < AES_IV_LENGTH; i++, j--)
-		swap_iv[i] = b[j];
-	memcpy(iv, swap_iv, AES_IV_LENGTH);
-}
-
-static int count_sg(struct scatterlist *sg, int nbytes)
-{
-	int i;
-
-	for (i = 0; nbytes > 0; i++, sg = sg_next(sg))
-		nbytes -= sg->length;
-	return i;
-}
-
-static int dma_map_pmem_sg(struct buf_info *pmem, unsigned entries,
-						struct scatterlist *sg)
-{
-	int i;
-	for (i = 0; i < entries; i++) {
-
-		sg->dma_address = (dma_addr_t)pmem->offset;
-		sg++;
-		pmem++;
-	}
-	return 0;
-}
-
-static int _probe_ce_engine(struct qce_device *pce_dev)
-{
-	unsigned int val;
-	unsigned int rev;
-	unsigned int ret;
-
-	val = (uint32_t)(*((uint32_t *)pce_dev->ce_dm.buffer.version));
-	if (((val & 0xfffffff) != 0x0000043) &&
-			((val & 0xfffffff) != 0x0000042) &&
-			((val & 0xfffffff) != 0x0000040)) {
-		dev_err(pce_dev->pdev,
-				"Unknown Qualcomm crypto device at 0x%x 0x%x\n",
-				pce_dev->phy_iobase, val);
-		return -EIO;
-	};
-	rev = (val & CRYPTO_CORE_REV_MASK);
-	if (rev >= 0x42) {
-		dev_info(pce_dev->pdev,
-				"Qualcomm Crypto 4.2 device found at 0x%x\n",
-				pce_dev->phy_iobase);
-		pce_dev->ce_dm.ce_block_size = 64;
-
-
-		ret = readl_relaxed(pce_dev->iobase + CRYPTO_CONFIG_REG);
-		if (ret) {
-			val = BIT(CRYPTO_MASK_DOUT_INTR) |
-					BIT(CRYPTO_MASK_DIN_INTR) |
-					BIT(CRYPTO_MASK_OP_DONE_INTR) |
-					BIT(CRYPTO_MASK_ERR_INTR) |
-					(CRYPTO_REQ_SIZE_ENUM_64_BYTES <<
-						CRYPTO_REQ_SIZE) |
-					(CRYPTO_FIFO_ENUM_64_BYTES <<
-						CRYPTO_FIFO_THRESHOLD);
-
-			writel_relaxed(val, pce_dev->iobase +
-					CRYPTO_CONFIG_REG);
-		} 
-	} else {
-		if (rev == 0x40) {
-			dev_info(pce_dev->pdev,
-				"Qualcomm Crypto 4.0 device found at 0x%x\n",
-							pce_dev->phy_iobase);
-			pce_dev->ce_dm.ce_block_size = 16;
-		}
-	}
-
-	dev_info(pce_dev->pdev,
-			"IO base 0x%x\n, ce_in channel %d     , "
-			"ce_out channel %d\n, "
-			"crci_in %d, crci_out %d\n",
-			(unsigned int) pce_dev->iobase,
-			pce_dev->ce_dm.chan_ce_in, pce_dev->ce_dm.chan_ce_out,
-			pce_dev->ce_dm.crci_in, pce_dev->ce_dm.crci_out);
-
-	return 0;
-};
-
-
-static void _check_probe_done_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_in_status = -1;
-	} else {
-		_probe_ce_engine(pce_dev);
-		pce_dev->ce_dm.chan_ce_in_status = 0;
-	}
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-};
-
-static int _init_ce_engine(struct qce_device *pce_dev)
-{
-	int status;
-	
-	clk_reset(pce_dev->ce_core_clk, CLK_RESET_ASSERT);
-	clk_reset(pce_dev->ce_core_clk, CLK_RESET_DEASSERT);
-
-	mb();
-
-	status = readl_relaxed(pce_dev->iobase + CRYPTO_STATUS_REG);
-	*((uint32_t *)(pce_dev->ce_dm.buffer.status)) = status & (~0x40000);
-	mb();
-
-	pce_dev->ce_dm.chan_ce_in_cmd->complete_func =
-				_check_probe_done_call_back;
-	pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-				pce_dev->ce_dm.cmdptrlist.probe_ce_hw;
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IN_PROG;
-	pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_COMP;
-	msm_dmov_enqueue_cmd(pce_dev->ce_dm.chan_ce_in,
-					pce_dev->ce_dm.chan_ce_in_cmd);
-
-	return 0;
-};
-
-static int _ce_setup_hash_cmdrptrlist(struct qce_device *pce_dev,
-						struct qce_sha_req *sreq)
-{
-	struct ce_cmdptrlists_ops *cmdptrlist = &pce_dev->ce_dm.cmdptrlist;
-
-	switch (sreq->alg) {
-	case QCE_HASH_SHA1:
-		pce_dev->ce_dm.chan_ce_in_cmd->cmdptr = cmdptrlist->auth_sha1;
-		break;
-
-	case QCE_HASH_SHA256:
-		pce_dev->ce_dm.chan_ce_in_cmd->cmdptr = cmdptrlist->auth_sha256;
-		break;
-	case QCE_HASH_SHA1_HMAC:
-		pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->auth_sha1_hmac;
-			break;
-
-	case QCE_HASH_SHA256_HMAC:
-		pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->auth_sha256_hmac;
-		break;
-	case QCE_HASH_AES_CMAC:
-		if (sreq->authklen == AES128_KEY_SIZE)
-			pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-				cmdptrlist->auth_aes_128_cmac;
-		else
-			pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-				cmdptrlist->auth_aes_256_cmac;
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int _ce_setup_hash(struct qce_device *pce_dev, struct qce_sha_req *sreq)
-{
-	uint32_t diglen;
-	int i;
-	uint32_t auth_cfg = 0;
-	bool sha1 = false;
-
-	if (sreq->alg ==  QCE_HASH_AES_CMAC) {
-
-		memcpy(pce_dev->ce_dm.buffer.auth_key, sreq->authkey,
-						sreq->authklen);
-		auth_cfg |= (1 << CRYPTO_LAST);
-		auth_cfg |= (CRYPTO_AUTH_MODE_CMAC << CRYPTO_AUTH_MODE);
-		auth_cfg |= (CRYPTO_AUTH_SIZE_ENUM_16_BYTES <<
-							CRYPTO_AUTH_SIZE);
-		auth_cfg |= CRYPTO_AUTH_ALG_AES << CRYPTO_AUTH_ALG;
-
-		switch (sreq->authklen) {
-		case AES128_KEY_SIZE:
-			auth_cfg |= (CRYPTO_AUTH_KEY_SZ_AES128 <<
-						CRYPTO_AUTH_KEY_SIZE);
-			break;
-		case AES256_KEY_SIZE:
-			auth_cfg |= (CRYPTO_AUTH_KEY_SZ_AES256 <<
-					CRYPTO_AUTH_KEY_SIZE);
-			break;
-		default:
-			break;
-		}
-
-		goto go_proc;
-	}
-
-	
-	if (sreq->last_blk == 0 && (sreq->size % SHA256_BLOCK_SIZE))
-		return -EIO;
-
-	switch (sreq->alg) {
-	case QCE_HASH_SHA1:
-	case QCE_HASH_SHA1_HMAC:
-		diglen = SHA1_DIGEST_SIZE;
-		sha1 = true;
-		break;
-	case QCE_HASH_SHA256:
-	case QCE_HASH_SHA256_HMAC:
-		diglen = SHA256_DIGEST_SIZE;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if ((sreq->alg == QCE_HASH_SHA1_HMAC) ||
-				(sreq->alg == QCE_HASH_SHA256_HMAC)) {
-
-		memcpy(pce_dev->ce_dm.buffer.auth_key, sreq->authkey,
-						sreq->authklen);
-		auth_cfg |= (CRYPTO_AUTH_MODE_HMAC << CRYPTO_AUTH_MODE);
-	} else {
-		auth_cfg |= (CRYPTO_AUTH_MODE_HASH << CRYPTO_AUTH_MODE);
-	}
-
-	
-	if (sreq->first_blk) {
-		if (sha1)
-			memcpy(pce_dev->ce_dm.buffer.auth_iv,
-				_std_init_vector_sha1_uint8, diglen);
-		else
-			memcpy(pce_dev->ce_dm.buffer.auth_iv,
-				_std_init_vector_sha256_uint8, diglen);
-	} else {
-		memcpy(pce_dev->ce_dm.buffer.auth_iv, sreq->digest,
-								diglen);
-	}
-
-	
-	for (i = 0; i < 4; i++)
-		*(((uint32_t *)(pce_dev->ce_dm.buffer.auth_byte_count) + i)) =
-						sreq->auth_data[i];
-
-	
-	if (sha1)
-		auth_cfg |= (CRYPTO_AUTH_SIZE_SHA1 << CRYPTO_AUTH_SIZE);
-	else
-		auth_cfg |= (CRYPTO_AUTH_SIZE_SHA256 << CRYPTO_AUTH_SIZE);
-
-	if (sreq->last_blk)
-		auth_cfg |= 1 << CRYPTO_LAST;
-
-	auth_cfg |= CRYPTO_AUTH_ALG_SHA << CRYPTO_AUTH_ALG;
-
-go_proc:
-	auth_cfg |= (CRYPTO_AUTH_POS_BEFORE << CRYPTO_AUTH_POS);
-
-	
-	*((uint32_t *)(pce_dev->ce_dm.buffer.auth_seg_cfg_size_start)) =
-								auth_cfg;
-	
-	*((uint32_t *)(pce_dev->ce_dm.buffer.auth_seg_cfg_size_start) + 1) =
-								sreq->size;
-
-	
-	*((uint32_t *)(pce_dev->ce_dm.buffer.auth_seg_cfg_size_start)+2) = 0;
-
-	
-	*((uint32_t *)(pce_dev->ce_dm.buffer.seg_size)) = sreq->size;
-
-	_ce_setup_hash_cmdrptrlist(pce_dev, sreq);
-
-	return 0;
-}
-
-static int _ce_setup_cipher_cmdrptrlist(struct qce_device *pce_dev,
-							struct qce_req *creq)
-{
-	struct ce_cmdptrlists_ops *cmdptrlist =
-				&pce_dev->ce_dm.cmdptrlist;
-
-	if (creq->alg != CIPHER_ALG_AES) {
-		switch (creq->alg) {
-		case CIPHER_ALG_DES:
-			if (creq->mode ==  QCE_MODE_ECB) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_des_ecb;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_des_cbc;
-			}
-			break;
-
-		case CIPHER_ALG_3DES:
-			if (creq->mode ==  QCE_MODE_ECB) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->cipher_3des_ecb;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->cipher_3des_cbc;
-			}
-			break;
-		default:
-			break;
-		}
-	} else {
-		switch (creq->mode) {
-		case QCE_MODE_ECB:
-			if (creq->encklen ==  AES128_KEY_SIZE) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->cipher_aes_128_ecb;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-						cmdptrlist->cipher_aes_256_ecb;
-			}
-			break;
-
-		case QCE_MODE_CBC:
-			if (creq->encklen ==  AES128_KEY_SIZE) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_128_cbc_ctr;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_256_cbc_ctr;
-			}
-			break;
-
-		case QCE_MODE_CTR:
-			if (creq->encklen ==  AES128_KEY_SIZE) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_128_cbc_ctr;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_256_cbc_ctr;
-			}
-			break;
-
-		case QCE_MODE_XTS:
-			if (creq->encklen ==  AES128_KEY_SIZE) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_128_xts;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->cipher_aes_256_xts;
-			}
-			break;
-		case QCE_MODE_CCM:
-			if (creq->encklen ==  AES128_KEY_SIZE) {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->aead_aes_128_ccm;
-			} else {
-				pce_dev->ce_dm.chan_ce_in_cmd->cmdptr =
-					cmdptrlist->aead_aes_256_ccm;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	switch (creq->mode) {
-	case QCE_MODE_CCM:
-		pce_dev->ce_dm.chan_ce_out_cmd->cmdptr =
-					cmdptrlist->aead_ce_out;
-		break;
-	case QCE_MODE_ECB:
-		pce_dev->ce_dm.chan_ce_out_cmd->cmdptr =
-					cmdptrlist->cipher_ce_out;
-		break;
-	default:
-		pce_dev->ce_dm.chan_ce_out_cmd->cmdptr =
-					cmdptrlist->cipher_ce_out_get_iv;
-		break;
-	}
-
-	return 0;
-}
-
-static int _ce_setup_cipher(struct qce_device *pce_dev, struct qce_req *creq,
-		uint32_t totallen_in, uint32_t coffset)
-{
-	uint32_t enck_size_in_word = creq->encklen / sizeof(uint32_t);
-	uint32_t encr_cfg = 0;
-	uint32_t ivsize = creq->ivsize;
-	struct ce_reg_buffer_addr *buffer = &pce_dev->ce_dm.buffer;
-
-	if (creq->mode ==  QCE_MODE_XTS)
-		memcpy(buffer->encr_key, creq->enckey,
-						creq->encklen/2);
-	else
-		memcpy(buffer->encr_key, creq->enckey, creq->encklen);
-
-	if ((creq->op == QCE_REQ_AEAD) && (creq->mode == QCE_MODE_CCM)) {
-		uint32_t noncelen32 = MAX_NONCE/sizeof(uint32_t);
-		uint32_t auth_cfg = 0;
-
-		
-		memcpy(buffer->auth_nonce_info, creq->nonce, MAX_NONCE);
-		memcpy(buffer->auth_key, creq->enckey, creq->encklen);
-
-		auth_cfg |= (noncelen32 << CRYPTO_AUTH_NONCE_NUM_WORDS);
-		auth_cfg &= ~(1 << CRYPTO_USE_HW_KEY_AUTH);
-		auth_cfg |= (1 << CRYPTO_LAST);
-		if (creq->dir == QCE_ENCRYPT)
-			auth_cfg |= (CRYPTO_AUTH_POS_BEFORE << CRYPTO_AUTH_POS);
-		else
-			auth_cfg |= (CRYPTO_AUTH_POS_AFTER << CRYPTO_AUTH_POS);
-		auth_cfg |= (((creq->authsize >> 1) - 2) << CRYPTO_AUTH_SIZE);
-		auth_cfg |= (CRYPTO_AUTH_MODE_CCM << CRYPTO_AUTH_MODE);
-		if (creq->authklen ==  AES128_KEY_SIZE)
-			auth_cfg |= (CRYPTO_AUTH_KEY_SZ_AES128 <<
-						CRYPTO_AUTH_KEY_SIZE);
-		else {
-			if (creq->authklen ==  AES256_KEY_SIZE)
-				auth_cfg |= (CRYPTO_AUTH_KEY_SZ_AES256 <<
-							CRYPTO_AUTH_KEY_SIZE);
-		}
-		auth_cfg |= (CRYPTO_AUTH_ALG_AES << CRYPTO_AUTH_ALG);
-		*((uint32_t *)(buffer->auth_seg_cfg_size_start)) = auth_cfg;
-
-		if (creq->dir == QCE_ENCRYPT)
-			*((uint32_t *)(buffer->auth_seg_cfg_size_start) + 1) =
-								totallen_in;
-		else
-			*((uint32_t *)(buffer->auth_seg_cfg_size_start) + 1) =
-						(totallen_in - creq->authsize);
-		*((uint32_t *)(buffer->auth_seg_cfg_size_start) + 2) = 0;
-	}
-
-	*((uint32_t *)(buffer->auth_seg_cfg_size_start) + 2) = 0;
-
-	switch (creq->mode) {
-	case QCE_MODE_ECB:
-		encr_cfg |= (CRYPTO_ENCR_MODE_ECB << CRYPTO_ENCR_MODE);
-		break;
-
-	case QCE_MODE_CBC:
-		encr_cfg |= (CRYPTO_ENCR_MODE_CBC << CRYPTO_ENCR_MODE);
-		break;
-
-	case QCE_MODE_XTS:
-		encr_cfg |= (CRYPTO_ENCR_MODE_XTS << CRYPTO_ENCR_MODE);
-		break;
-
-	case QCE_MODE_CCM:
-		encr_cfg |= (CRYPTO_ENCR_MODE_CCM << CRYPTO_ENCR_MODE);
-		break;
-
-	case QCE_MODE_CTR:
-	default:
-		encr_cfg |= (CRYPTO_ENCR_MODE_CTR << CRYPTO_ENCR_MODE);
-		break;
-	}
-	pce_dev->mode = creq->mode;
-
-	switch (creq->alg) {
-	case CIPHER_ALG_DES:
-		if (creq->mode !=  QCE_MODE_ECB)
-			memcpy(buffer->encr_cntr_iv, creq->iv, ivsize);
-
-		encr_cfg |= ((CRYPTO_ENCR_KEY_SZ_DES << CRYPTO_ENCR_KEY_SZ)  |
-				(CRYPTO_ENCR_ALG_DES << CRYPTO_ENCR_ALG));
-		break;
-
-	case CIPHER_ALG_3DES:
-		if (creq->mode !=  QCE_MODE_ECB)
-			memcpy(buffer->encr_cntr_iv, creq->iv, ivsize);
-
-		encr_cfg |= ((CRYPTO_ENCR_KEY_SZ_3DES << CRYPTO_ENCR_KEY_SZ)  |
-				(CRYPTO_ENCR_ALG_DES << CRYPTO_ENCR_ALG));
-		break;
-
-	case CIPHER_ALG_AES:
-	default:
-		if (creq->mode ==  QCE_MODE_XTS) {
-			memcpy(buffer->encr_xts_key, (creq->enckey +
-					creq->encklen/2), creq->encklen/2);
-			*((uint32_t *)(buffer->encr_xts_du_size)) =
-							creq->cryptlen;
-
-		}
-		if (creq->mode !=  QCE_MODE_ECB) {
-			if (creq->mode ==  QCE_MODE_XTS)
-				_byte_stream_swap_to_net_words(
-					(uint32_t *)(buffer->encr_cntr_iv),
-							creq->iv, ivsize);
-			else
-				memcpy(buffer->encr_cntr_iv, creq->iv,
-								ivsize);
-		}
-		
-		*((uint32_t *)(buffer->encr_mask)) = (uint32_t)0xffffffff;
-
-		if (creq->op == QCE_REQ_ABLK_CIPHER_NO_KEY) {
-				encr_cfg |= (CRYPTO_ENCR_KEY_SZ_AES128 <<
-						CRYPTO_ENCR_KEY_SZ);
-			encr_cfg |= CRYPTO_ENCR_ALG_AES << CRYPTO_ENCR_ALG;
-		} else {
-			uint32_t key_size;
-
-			if (creq->mode == QCE_MODE_XTS) {
-				key_size = creq->encklen/2;
-				enck_size_in_word = key_size/sizeof(uint32_t);
-			} else {
-				key_size = creq->encklen;
-			}
-
-			switch (key_size) {
-			case AES128_KEY_SIZE:
-				encr_cfg |= (CRYPTO_ENCR_KEY_SZ_AES128 <<
-							CRYPTO_ENCR_KEY_SZ);
-				break;
-			case AES256_KEY_SIZE:
-			default:
-				encr_cfg |= (CRYPTO_ENCR_KEY_SZ_AES256 <<
-							CRYPTO_ENCR_KEY_SZ);
-				break;
-			} 
-
-			encr_cfg |= CRYPTO_ENCR_ALG_AES << CRYPTO_ENCR_ALG;
-		} 
-		break;
-	} 
-
-	
-	encr_cfg |= ((creq->dir == QCE_ENCRYPT) ? 1 : 0) << CRYPTO_ENCODE;
-
-	
-	*((uint32_t *)(buffer->encr_seg_cfg_size_start)) = encr_cfg;
-	
-	if ((creq->mode == QCE_MODE_CCM) && (creq->dir == QCE_DECRYPT))
-		*((uint32_t *)(buffer->encr_seg_cfg_size_start) + 1) =
-					(creq->cryptlen + creq->authsize);
-	else
-		*((uint32_t *)(buffer->encr_seg_cfg_size_start) + 1) =
-							creq->cryptlen;
-
-
-	*((uint32_t *)(buffer->encr_seg_cfg_size_start) + 2) =
-						(coffset & 0xffff);
-
-	*((uint32_t *)(buffer->seg_size)) = totallen_in;
-
-	_ce_setup_cipher_cmdrptrlist(pce_dev, creq);
-	return 0;
-};
-
-static int _aead_complete(struct qce_device *pce_dev)
-{
-	struct aead_request *areq;
-
-	areq = (struct aead_request *) pce_dev->areq;
-
-	if (areq->src != areq->dst) {
-		dma_unmap_sg(pce_dev->pdev, areq->dst, pce_dev->dst_nents,
-					DMA_FROM_DEVICE);
-	}
-	dma_unmap_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-			(areq->src == areq->dst) ? DMA_BIDIRECTIONAL :
-							DMA_TO_DEVICE);
-
-	dma_unmap_sg(pce_dev->pdev, areq->assoc, pce_dev->assoc_nents,
-			DMA_TO_DEVICE);
-
-	
-	if (pce_dev->mode == QCE_MODE_CCM) {
-		uint32_t result;
-
-		result =
-			(uint32_t)(*((uint32_t *)pce_dev->ce_dm.buffer.status));
-		result &= (1 << CRYPTO_MAC_FAILED);
-		result |= (pce_dev->ce_dm.chan_ce_in_status |
-					pce_dev->ce_dm.chan_ce_out_status);
-		pce_dev->qce_cb(areq, pce_dev->ce_dm.buffer.auth_result, NULL,
-							result);
-	}
-	return 0;
-};
-
-static void _sha_complete(struct qce_device *pce_dev)
-{
-	struct ahash_request *areq;
-
-	areq = (struct ahash_request *) pce_dev->areq;
-	dma_unmap_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-				DMA_TO_DEVICE);
-
-	pce_dev->qce_cb(areq,  pce_dev->ce_dm.buffer.auth_result,
-				pce_dev->ce_dm.buffer.auth_byte_count,
-				pce_dev->ce_dm.chan_ce_in_status);
-
-};
-
-static int _ablk_cipher_complete(struct qce_device *pce_dev)
-{
-	struct ablkcipher_request *areq;
-
-	areq = (struct ablkcipher_request *) pce_dev->areq;
-
-	if (areq->src != areq->dst) {
-		dma_unmap_sg(pce_dev->pdev, areq->dst,
-			pce_dev->dst_nents, DMA_FROM_DEVICE);
-	}
-	dma_unmap_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-		(areq->src == areq->dst) ? DMA_BIDIRECTIONAL :
-						DMA_TO_DEVICE);
-
-	if (pce_dev->mode == QCE_MODE_ECB) {
-		pce_dev->qce_cb(areq, NULL, NULL,
-					pce_dev->ce_dm.chan_ce_in_status |
-					pce_dev->ce_dm.chan_ce_out_status);
-	} else {
-
-		pce_dev->qce_cb(areq, NULL, pce_dev->ce_dm.buffer.encr_cntr_iv,
-			pce_dev->ce_dm.chan_ce_in_status |
-			pce_dev->ce_dm.chan_ce_out_status);
-	}
-
-	return 0;
-};
-
-static int _ablk_cipher_use_pmem_complete(struct qce_device *pce_dev)
-{
-	struct ablkcipher_request *areq;
-
-	areq = (struct ablkcipher_request *) pce_dev->areq;
-
-	if (pce_dev->mode == QCE_MODE_ECB) {
-		pce_dev->qce_cb(areq, NULL, NULL,
-					pce_dev->ce_dm.chan_ce_in_status |
-					pce_dev->ce_dm.chan_ce_out_status);
-	} else {
-		pce_dev->qce_cb(areq, NULL, pce_dev->ce_dm.buffer.encr_cntr_iv,
-					pce_dev->ce_dm.chan_ce_in_status |
-					pce_dev->ce_dm.chan_ce_out_status);
-	}
-
-	return 0;
-};
-
-static int qce_split_and_insert_dm_desc(struct dmov_desc *pdesc,
-			unsigned int plen, unsigned int paddr, int *index)
-{
-	while (plen > QCE_FIFO_SIZE) {
-		pdesc->len = QCE_FIFO_SIZE;
-		if (paddr > 0) {
-			pdesc->addr = paddr;
-			paddr += QCE_FIFO_SIZE;
-		}
-		plen -= pdesc->len;
-		if (plen > 0) {
-			*index = (*index) + 1;
-			if ((*index) >= QCE_MAX_NUM_DESC)
-				return -ENOMEM;
-			pdesc++;
-		}
-	}
-	if ((plen > 0) && (plen <= QCE_FIFO_SIZE)) {
-		pdesc->len = plen;
-		if (paddr > 0)
-			pdesc->addr = paddr;
-	}
-
-	return 0;
-}
-
-static int _chain_sg_buffer_in(struct qce_device *pce_dev,
-		struct scatterlist *sg, unsigned int nbytes)
-{
-	unsigned int len;
-	unsigned int dlen;
-	struct dmov_desc *pdesc;
-
-	pdesc = pce_dev->ce_dm.ce_in_src_desc +
-				pce_dev->ce_dm.ce_in_src_desc_index;
-	while (nbytes > 0) {
-		len = min(nbytes, sg_dma_len(sg));
-		dlen = pdesc->len & ADM_DESC_LENGTH_MASK;
-		nbytes -= len;
-		if (dlen == 0) {
-			pdesc->addr  = sg_dma_address(sg);
-			pdesc->len = len;
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					sg_dma_address(sg),
-					&pce_dev->ce_dm.ce_in_src_desc_index);
-		} else if (sg_dma_address(sg) == (pdesc->addr + dlen)) {
-			pdesc->len  = dlen + len;
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					pdesc->addr,
-					&pce_dev->ce_dm.ce_in_src_desc_index);
-		} else {
-			pce_dev->ce_dm.ce_in_src_desc_index++;
-			if (pce_dev->ce_dm.ce_in_src_desc_index >=
-							QCE_MAX_NUM_DESC)
-				return -ENOMEM;
-			pdesc++;
-			pdesc->len = len;
-			pdesc->addr = sg_dma_address(sg);
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					sg_dma_address(sg),
-					&pce_dev->ce_dm.ce_in_src_desc_index);
-		}
-		if (nbytes > 0)
-			sg = sg_next(sg);
-	}
-	return 0;
-}
-
-static int _chain_pm_buffer_in(struct qce_device *pce_dev,
-		unsigned int pmem, unsigned int nbytes)
-{
-	unsigned int dlen;
-	struct dmov_desc *pdesc;
-
-	pdesc = pce_dev->ce_dm.ce_in_src_desc +
-				pce_dev->ce_dm.ce_in_src_desc_index;
-	dlen = pdesc->len & ADM_DESC_LENGTH_MASK;
-	if (dlen == 0) {
-		pdesc->addr  = pmem;
-		pdesc->len = nbytes;
-	} else if (pmem == (pdesc->addr + dlen)) {
-		pdesc->len  = dlen + nbytes;
-	} else {
-		pce_dev->ce_dm.ce_in_src_desc_index++;
-		if (pce_dev->ce_dm.ce_in_src_desc_index >=
-						QCE_MAX_NUM_DESC)
-			return -ENOMEM;
-		pdesc++;
-		pdesc->len = nbytes;
-		pdesc->addr = pmem;
-	}
-	return 0;
-}
-
-static void _chain_buffer_in_init(struct qce_device *pce_dev)
-{
-	struct dmov_desc *pdesc;
-
-	pce_dev->ce_dm.ce_in_src_desc_index = 0;
-	pce_dev->ce_dm.ce_in_dst_desc_index = 0;
-	pdesc = pce_dev->ce_dm.ce_in_src_desc;
-	pdesc->len = 0;
-}
-
-static void _ce_in_final(struct qce_device *pce_dev, unsigned total)
-{
-	struct dmov_desc *pdesc;
-	dmov_sg *pcmd;
-
-	pdesc = pce_dev->ce_dm.ce_in_src_desc +
-				pce_dev->ce_dm.ce_in_src_desc_index;
-	pdesc->len |= ADM_DESC_LAST;
-
-	pdesc = pce_dev->ce_dm.ce_in_dst_desc;
-	if (total > QCE_FIFO_SIZE) {
-		qce_split_and_insert_dm_desc(pdesc, total, 0,
-				&pce_dev->ce_dm.ce_in_dst_desc_index);
-		pdesc = pce_dev->ce_dm.ce_in_dst_desc +
-					pce_dev->ce_dm.ce_in_dst_desc_index;
-		pdesc->len |= ADM_DESC_LAST;
-	} else
-		pdesc->len = ADM_DESC_LAST | total;
-
-	pcmd = (dmov_sg *) pce_dev->ce_dm.cmdlist.ce_data_in;
-	pcmd->cmd |= CMD_LC;
-
-}
-
-#ifdef QCE_DEBUG
-static void _ce_in_dump(struct qce_device *pce_dev)
-{
-	int i;
-	struct dmov_desc *pdesc;
-
-	dev_info(pce_dev->pdev, "_ce_in_dump: src\n");
-	for (i = 0; i <= pce_dev->ce_dm.ce_in_src_desc_index; i++) {
-		pdesc = pce_dev->ce_dm.ce_in_src_desc + i;
-		dev_info(pce_dev->pdev, "%x , %x\n", pdesc->addr,
-				pdesc->len);
-	}
-	dev_info(pce_dev->pdev, "_ce_in_dump: dst\n");
-	for (i = 0; i <= pce_dev->ce_dm.ce_in_dst_desc_index; i++) {
-		pdesc = pce_dev->ce_dm.ce_in_dst_desc + i;
-		dev_info(pce_dev->pdev, "%x , %x\n", pdesc->addr,
-				pdesc->len);
-	}
-};
-
-static void _ce_out_dump(struct qce_device *pce_dev)
-{
-	int i;
-	struct dmov_desc *pdesc;
-
-	dev_info(pce_dev->pdev, "_ce_out_dump: src\n");
-	for (i = 0; i <= pce_dev->ce_dm.ce_out_src_desc_index; i++) {
-		pdesc = pce_dev->ce_dm.ce_out_src_desc + i;
-		dev_info(pce_dev->pdev, "%x , %x\n", pdesc->addr,
-				pdesc->len);
-	}
-
-	dev_info(pce_dev->pdev, "_ce_out_dump: dst\n");
-	for (i = 0; i <= pce_dev->ce_dm.ce_out_dst_desc_index; i++) {
-		pdesc = pce_dev->ce_dm.ce_out_dst_desc + i;
-		dev_info(pce_dev->pdev, "%x , %x\n", pdesc->addr,
-				pdesc->len);
-	}
-};
-
-#else
-
-static void _ce_in_dump(struct qce_device *pce_dev)
-{
-};
-
-static void _ce_out_dump(struct qce_device *pce_dev)
-{
-};
-
-#endif
-
-static int _chain_sg_buffer_out(struct qce_device *pce_dev,
-		struct scatterlist *sg, unsigned int nbytes)
-{
-	unsigned int len;
-	unsigned int dlen;
-	struct dmov_desc *pdesc;
-
-	pdesc = pce_dev->ce_dm.ce_out_dst_desc +
-				pce_dev->ce_dm.ce_out_dst_desc_index;
-	while (nbytes > 0) {
-		len = min(nbytes, sg_dma_len(sg));
-		dlen = pdesc->len & ADM_DESC_LENGTH_MASK;
-		nbytes -= len;
-		if (dlen == 0) {
-			pdesc->addr  = sg_dma_address(sg);
-			pdesc->len = len;
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					sg_dma_address(sg),
-					&pce_dev->ce_dm.ce_out_dst_desc_index);
-		} else if (sg_dma_address(sg) == (pdesc->addr + dlen)) {
-			pdesc->len  = dlen + len;
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					pdesc->addr,
-					&pce_dev->ce_dm.ce_out_dst_desc_index);
-
-		} else {
-			pce_dev->ce_dm.ce_out_dst_desc_index++;
-			if (pce_dev->ce_dm.ce_out_dst_desc_index >=
-							QCE_MAX_NUM_DESC)
-				return -EIO;
-			pdesc++;
-			pdesc->len = len;
-			pdesc->addr = sg_dma_address(sg);
-			if (pdesc->len > QCE_FIFO_SIZE)
-				qce_split_and_insert_dm_desc(pdesc, pdesc->len,
-					sg_dma_address(sg),
-					&pce_dev->ce_dm.ce_out_dst_desc_index);
-
-		}
-		if (nbytes > 0)
-			sg = sg_next(sg);
-	}
-	return 0;
-}
-
-static int _chain_pm_buffer_out(struct qce_device *pce_dev,
-		unsigned int pmem, unsigned int nbytes)
-{
-	unsigned int dlen;
-	struct dmov_desc *pdesc;
-
-	pdesc = pce_dev->ce_dm.ce_out_dst_desc +
-				pce_dev->ce_dm.ce_out_dst_desc_index;
-	dlen = pdesc->len & ADM_DESC_LENGTH_MASK;
-
-	if (dlen == 0) {
-		pdesc->addr  = pmem;
-		pdesc->len = nbytes;
-	} else if (pmem == (pdesc->addr + dlen)) {
-		pdesc->len  = dlen + nbytes;
-	} else {
-		pce_dev->ce_dm.ce_out_dst_desc_index++;
-		if (pce_dev->ce_dm.ce_out_dst_desc_index >= QCE_MAX_NUM_DESC)
-			return -EIO;
-		pdesc++;
-		pdesc->len = nbytes;
-		pdesc->addr = pmem;
-	}
-	return 0;
-};
-
-static void _chain_buffer_out_init(struct qce_device *pce_dev)
-{
-	struct dmov_desc *pdesc;
-
-	pce_dev->ce_dm.ce_out_dst_desc_index = 0;
-	pce_dev->ce_dm.ce_out_src_desc_index = 0;
-	pdesc = pce_dev->ce_dm.ce_out_dst_desc;
-	pdesc->len = 0;
-};
-
-static void _ce_out_final(struct qce_device *pce_dev, unsigned total)
-{
-	struct dmov_desc *pdesc;
-	dmov_sg *pcmd;
-
-	pdesc = pce_dev->ce_dm.ce_out_dst_desc +
-				pce_dev->ce_dm.ce_out_dst_desc_index;
-	pdesc->len |= ADM_DESC_LAST;
-
-	pdesc = pce_dev->ce_dm.ce_out_src_desc +
-				pce_dev->ce_dm.ce_out_src_desc_index;
-	if (total > QCE_FIFO_SIZE) {
-		qce_split_and_insert_dm_desc(pdesc, total, 0,
-				&pce_dev->ce_dm.ce_out_src_desc_index);
-		pdesc = pce_dev->ce_dm.ce_out_src_desc +
-				pce_dev->ce_dm.ce_out_src_desc_index;
-		pdesc->len |= ADM_DESC_LAST;
-	} else
-		pdesc->len = ADM_DESC_LAST | total;
-
-	pcmd = (dmov_sg *) pce_dev->ce_dm.cmdlist.ce_data_out;
-	pcmd->cmd |= CMD_LC;
-};
-
-static void _aead_ce_in_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-							result);
-		pce_dev->ce_dm.chan_ce_in_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_in_status = 0;
-	}
-
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_out_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_aead_complete(pce_dev);
-	}
-};
-
-static void _aead_ce_out_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-							result);
-		pce_dev->ce_dm.chan_ce_out_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_out_status = 0;
-	};
-
-	pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_in_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_aead_complete(pce_dev);
-	}
-
-};
-
-static void _sha_ce_in_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_in_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_in_status = 0;
-	}
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-	_sha_complete(pce_dev);
-};
-
-static void _ablk_cipher_ce_in_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_in_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_in_status = 0;
-	}
-
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_out_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_ablk_cipher_complete(pce_dev);
-	}
-};
-
-static void _ablk_cipher_ce_out_call_back(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_out_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_out_status = 0;
-	};
-
-	pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_in_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_ablk_cipher_complete(pce_dev);
-	}
-};
-
-
-static void _ablk_cipher_ce_in_call_back_pmem(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_in_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_in_status = 0;
-	}
-
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_out_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_ablk_cipher_use_pmem_complete(pce_dev);
-	}
-};
-
-static void _ablk_cipher_ce_out_call_back_pmem(struct msm_dmov_cmd *cmd_ptr,
-		unsigned int result, struct msm_dmov_errdata *err)
-{
-	struct qce_device *pce_dev;
-
-	pce_dev = (struct qce_device *) cmd_ptr->user;
-	if (result != ADM_STATUS_OK) {
-		dev_err(pce_dev->pdev, "Qualcomm ADM status error %x\n",
-						result);
-		pce_dev->ce_dm.chan_ce_out_status = -1;
-	} else {
-		pce_dev->ce_dm.chan_ce_out_status = 0;
-	};
-
-	pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_COMP;
-	if (pce_dev->ce_dm.chan_ce_in_state == QCE_CHAN_STATE_COMP) {
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-
-		
-		_ablk_cipher_use_pmem_complete(pce_dev);
-	}
-};
-
-static int qce_setup_cmd_buffers(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	struct ce_reg_buffers *addr = (struct ce_reg_buffers *)(*pvaddr);
-	struct ce_reg_buffer_addr *buffer = &pce_dev->ce_dm.buffer;
-
-	buffer->reset_buf_64 = addr->reset_buf_64;
-	buffer->version = addr->version;
-	buffer->encr_seg_cfg_size_start = addr->encr_seg_cfg_size_start;
-	buffer->encr_key = addr->encr_key;
-	buffer->encr_xts_key = addr->encr_xts_key;
-	buffer->encr_xts_du_size = addr->encr_xts_du_size;
-	buffer->encr_cntr_iv = addr->encr_cntr_iv;
-	buffer->encr_mask = addr->encr_mask;
-	buffer->auth_seg_cfg_size_start = addr->auth_seg_cfg_size_start;
-	buffer->auth_key = addr->auth_key;
-	buffer->auth_iv = addr->auth_iv;
-	buffer->auth_result = addr->auth_result;
-	buffer->auth_nonce_info = addr->auth_nonce_info;
-	buffer->auth_byte_count = addr->auth_byte_count;
-	buffer->seg_size = addr->seg_size;
-	buffer->go_proc = addr->go_proc;
-	buffer->status = addr->status;
-	buffer->pad = addr->pad;
-
-	memset(buffer->reset_buf_64, 0, 64);
-	*((uint32_t *)buffer->encr_mask) = (uint32_t)(0xffffffff);
-	*((uint32_t *)buffer->go_proc) = (uint32_t)(1 << CRYPTO_GO);
-
-	*pvaddr += sizeof(struct ce_reg_buffers);
-
-	return 0;
-
-}
-
-static int _setup_cipher_cmdlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	dmov_s  *pscmd = (dmov_s  *)(*pvaddr);
-
-	pce_dev->ce_dm.cmdlist.set_cipher_cfg = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_SEG_CFG_REG +
-					pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 3;
-	pscmd->src =
-		GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_seg_cfg_size_start);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_aes_128_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_aes_256_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_des_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 2;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_3des_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 6;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_aes_128_xts_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_XTS_KEY0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_xts_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_aes_256_xts_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-					CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_XTS_KEY0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_xts_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_xts_du_size = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_XTS_DU_SIZE_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_xts_du_size);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_aes_iv = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-					CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_CNTR0_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_cntr_iv);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_des_iv = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_CNTR0_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 2;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_cntr_iv);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.get_cipher_iv = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_CNTR0_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_cntr_iv);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_cipher_mask = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_CNTR_MASK_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.encr_mask);
-	pscmd++;
-
-	
-
-	pce_dev->ce_dm.cmdlist.reset_cipher_key  = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.reset_cipher_xts_key  = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_XTS_KEY0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.reset_cipher_iv  = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_CNTR0_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.reset_cipher_cfg  = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_ENCR_SEG_CFG_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	*pvaddr = (unsigned char *) pscmd;
-
-	return 0;
-}
-
-static int _setup_auth_cmdlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	dmov_s  *pscmd = (dmov_s  *)(*pvaddr);
-
-	pce_dev->ce_dm.cmdlist.set_auth_cfg = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_SEG_CFG_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 3;
-	pscmd->src =
-		GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_seg_cfg_size_start);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_key_128 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_key_256 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_key_512 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 16;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_key);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_iv_16 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_iv);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.get_auth_result_16 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_result);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_iv_20 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 5;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_iv);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.get_auth_result_20 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 5;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_result);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_iv_32 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_iv);
-	pscmd++;
-
-
-	pce_dev->ce_dm.cmdlist.get_auth_result_32 = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 8;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_result);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_byte_count = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_BYTECNT0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_byte_count);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.get_auth_byte_count = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_AUTH_BYTECNT0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_byte_count);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.set_auth_nonce_info = pscmd;
-	pscmd->cmd = CMD_LC | CMD_SRC_SWAP_BYTES |
-				CMD_SRC_SWAP_SHORTS | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_INFO_NONCE0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.auth_nonce_info);
-	pscmd++;
-
-	
-
-	pce_dev->ce_dm.cmdlist.reset_auth_key = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_KEY0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 16;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.reset_auth_iv = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_IV0_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 16;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	pce_dev->ce_dm.cmdlist.reset_auth_cfg = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_SEG_CFG_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-
-	pce_dev->ce_dm.cmdlist.reset_auth_byte_count = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_AUTH_BYTECNT0_REG +
-							pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE * 4;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.reset_buf_64);
-	pscmd++;
-
-	
-
-	pce_dev->ce_dm.cmdlist.get_status_wait = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->src = (unsigned) (CRYPTO_STATUS_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.status);
-	pscmd++;
-
-	*pvaddr = (unsigned char *) pscmd;
-
-	return 0;
-}
-
-static int qce_setup_cmdlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	dmov_sg *pcmd;
-	dmov_s  *pscmd;
-	unsigned char *vaddr = *pvaddr;
-	struct dmov_desc *pdesc;
-	int i = 0;
-
-	vaddr = (unsigned char *) ALIGN(((unsigned int)vaddr), 16);
-	*pvaddr = (unsigned char *) vaddr;
-
-	_setup_cipher_cmdlists(pce_dev, pvaddr);
-	_setup_auth_cmdlists(pce_dev, pvaddr);
-
-	pscmd = (dmov_s  *)(*pvaddr);
-
-	
-	pce_dev->ce_dm.cmdlist.get_hw_version = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE | CMD_OCB;
-	pscmd->src = (unsigned) (CRYPTO_VERSION_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.version);
-	pscmd++;
-
-
-	
-	pce_dev->ce_dm.cmdlist.set_seg_size_ocb = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE | CMD_OCB;
-	pscmd->dst = (unsigned) (CRYPTO_SEG_SIZE_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.seg_size);
-	pscmd++;
-
-
-	
-	pce_dev->ce_dm.cmdlist.get_status_ocu = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE | CMD_OCU;
-	pscmd->src = (unsigned) (CRYPTO_STATUS_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->dst = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.status);
-	pscmd++;
-
-	
-	pce_dev->ce_dm.cmdlist.clear_status = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE | CMD_OCU;
-	pscmd->dst = (unsigned) (CRYPTO_STATUS_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.status);
-	pscmd++;
-
-	
-	pce_dev->ce_dm.cmdlist.set_go_proc = pscmd;
-	pscmd->cmd = CMD_LC | CMD_MODE_SINGLE;
-	pscmd->dst = (unsigned) (CRYPTO_GOPROC_REG + pce_dev->phy_iobase);
-	pscmd->len = CRYPTO_REG_SIZE;
-	pscmd->src = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.go_proc);
-	pscmd++;
-
-	pcmd = (dmov_sg  *)pscmd;
-	pce_dev->ce_dm.cmdlist.ce_data_in = pcmd;
-	
-	pcmd->cmd = CMD_DST_SWAP_BYTES | CMD_DST_SWAP_SHORTS |
-			CMD_DST_CRCI(pce_dev->ce_dm.crci_in) | CMD_MODE_SG;
-
-	pdesc = pce_dev->ce_dm.ce_in_src_desc;
-	pdesc->addr = 0;	
-	pdesc->len = 0;		
-
-	pdesc = pce_dev->ce_dm.ce_in_dst_desc;
-	for (i = 0; i < QCE_MAX_NUM_DESC; i++) {
-		pdesc->addr = (CRYPTO_DATA_SHADOW0 + pce_dev->phy_iobase);
-		pdesc->len = 0; 
-		pdesc++;
-	}
-	pcmd->src_dscr = GET_PHYS_ADDR(pce_dev->ce_dm.ce_in_src_desc);
-	pcmd->dst_dscr = GET_PHYS_ADDR(pce_dev->ce_dm.ce_in_dst_desc);
-	pcmd->_reserved = LI_SG_CMD | SRC_INDEX_SG_CMD(0) |
-						DST_INDEX_SG_CMD(0);
-
-
-	pcmd++;
-	pce_dev->ce_dm.cmdlist.ce_data_out = pcmd;
-	
-	pcmd->cmd =   CMD_SRC_SWAP_BYTES | CMD_SRC_SWAP_SHORTS |
-			CMD_SRC_CRCI(pce_dev->ce_dm.crci_out) | CMD_MODE_SG;
-
-	pdesc = pce_dev->ce_dm.ce_out_src_desc;
-	for (i = 0; i < QCE_MAX_NUM_DESC; i++) {
-		pdesc->addr = (CRYPTO_DATA_SHADOW0 + pce_dev->phy_iobase);
-		pdesc->len = 0;  
-		pdesc++;
-	}
-
-	pdesc = pce_dev->ce_dm.ce_out_dst_desc;
-	pdesc->addr = 0;  
-	pdesc->len = 0;   
-
-	pcmd->src_dscr = GET_PHYS_ADDR(pce_dev->ce_dm.ce_out_src_desc);
-	pcmd->dst_dscr = GET_PHYS_ADDR(pce_dev->ce_dm.ce_out_dst_desc);
-	pcmd->_reserved = LI_SG_CMD | SRC_INDEX_SG_CMD(0) |
-						DST_INDEX_SG_CMD(0);
-	pcmd++;
-
-	*pvaddr = (unsigned char *) pcmd;
-
-	return 0;
-}
-
-static int _setup_cipher_cmdptrlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	uint32_t * cmd_ptr_vaddr = (uint32_t *)(*pvaddr);
-	struct ce_cmdlists *cmdlist = &pce_dev->ce_dm.cmdlist;
-	struct ce_cmdptrlists_ops *cmdptrlist = &pce_dev->ce_dm.cmdptrlist;
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_128_cbc_ctr = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_128_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_256_cbc_ctr = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_256_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_128_ecb = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_128_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *)ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_256_ecb = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_256_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *)ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_128_xts = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_128_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_128_xts_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_xts_du_size);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_aes_256_xts = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_256_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_256_xts_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_xts_du_size);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *)ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_des_cbc = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_des_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_des_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *)ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_des_ecb = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_des_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_3des_cbc = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_3des_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_des_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_3des_ecb = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_3des_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_ce_out = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_out);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->cipher_ce_out_get_iv = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_out);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_cipher_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	*pvaddr = (unsigned char *) cmd_ptr_vaddr;
-
-	return 0;
-}
-
-static int _setup_auth_cmdptrlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	uint32_t * cmd_ptr_vaddr = (uint32_t *)(*pvaddr);
-	struct ce_cmdlists *cmdlist = &pce_dev->ce_dm.cmdlist;
-	struct ce_cmdptrlists_ops *cmdptrlist = &pce_dev->ce_dm.cmdptrlist;
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_sha1 = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_iv_20);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_20);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_sha256 = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_iv_32);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_32);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_sha1_hmac = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_512);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_iv_20);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_20);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_sha256_hmac = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_512);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_iv_32);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_32);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_aes_128_cmac = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_128);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_16);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->auth_aes_256_cmac = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_256);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_in);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_auth_result_16);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	*pvaddr = (unsigned char *) cmd_ptr_vaddr;
-
-	return 0;
-}
-
-static int _setup_aead_cmdptrlists(struct qce_device *pce_dev,
-						unsigned char **pvaddr)
-{
-	uint32_t * cmd_ptr_vaddr = (uint32_t *)(*pvaddr);
-	struct ce_cmdlists *cmdlist = &pce_dev->ce_dm.cmdlist;
-	struct ce_cmdptrlists_ops *cmdptrlist = &pce_dev->ce_dm.cmdptrlist;
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->aead_aes_128_ccm = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_128);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_nonce_info);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_128_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->aead_aes_256_ccm = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_seg_size_ocb);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->reset_auth_byte_count);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_key_256);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_nonce_info);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_auth_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_cfg);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_256_key);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_aes_iv);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_cipher_mask);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->set_go_proc);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->ce_data_in);
-
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->aead_ce_out = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->ce_data_out);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_status_wait);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	*pvaddr = (unsigned char *) cmd_ptr_vaddr;
-
-	return 0;
-}
-
-static int qce_setup_cmdptrlists(struct qce_device *pce_dev,
-					unsigned char **pvaddr)
-{
-	uint32_t * cmd_ptr_vaddr = (uint32_t *)(*pvaddr);
-	struct ce_cmdlists *cmdlist = &pce_dev->ce_dm.cmdlist;
-	struct ce_cmdptrlists_ops *cmdptrlist = &pce_dev->ce_dm.cmdptrlist;
-	cmd_ptr_vaddr = (uint32_t *) ALIGN(((unsigned int) cmd_ptr_vaddr), 16);
-	cmdptrlist->probe_ce_hw = QCE_SET_CMD_PTR(cmd_ptr_vaddr);
-
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->get_hw_version);
-	*cmd_ptr_vaddr++ = QCE_SET_CMD_PTR(cmdlist->clear_status);
-	*cmd_ptr_vaddr++ = QCE_SET_LAST_CMD_PTR(cmdlist->get_status_ocu);
-
-	*pvaddr = (unsigned char *) cmd_ptr_vaddr;
-
-	_setup_cipher_cmdptrlists(pce_dev, pvaddr);
-	_setup_auth_cmdptrlists(pce_dev, pvaddr);
-	_setup_aead_cmdptrlists(pce_dev, pvaddr);
-
-	return 0;
-}
-
-
-static int qce_setup_ce_dm_data(struct qce_device *pce_dev)
-{
-	unsigned char *vaddr;
-
-	
-	vaddr = pce_dev->coh_vmem;
-	vaddr = (unsigned char *) ALIGN(((unsigned int)vaddr),  16);
-	pce_dev->ce_dm.ce_in_src_desc = (struct dmov_desc *) vaddr;
-	vaddr = vaddr + (sizeof(struct dmov_desc) * QCE_MAX_NUM_DESC);
-
-	
-	vaddr = (unsigned char *) ALIGN(((unsigned int)vaddr), 16);
-	pce_dev->ce_dm.ce_in_dst_desc = (struct dmov_desc *) vaddr;
-	vaddr = vaddr + (sizeof(struct dmov_desc) * QCE_MAX_NUM_DESC);
-
-
-	
-	vaddr = (unsigned char *) ALIGN(((unsigned int)vaddr), 16);
-	pce_dev->ce_dm.ce_out_src_desc = (struct dmov_desc *) vaddr;
-	vaddr = vaddr + (sizeof(struct dmov_desc) * QCE_MAX_NUM_DESC);
-
-	
-	vaddr = (unsigned char *) ALIGN(((unsigned int)vaddr), 16);
-	pce_dev->ce_dm.ce_out_dst_desc = (struct dmov_desc *) vaddr;
-	vaddr = vaddr + (sizeof(struct dmov_desc) * QCE_MAX_NUM_DESC);
-
-	qce_setup_cmd_buffers(pce_dev, &vaddr);
-	qce_setup_cmdlists(pce_dev, &vaddr);
-	qce_setup_cmdptrlists(pce_dev, &vaddr);
-
-	pce_dev->ce_dm.buffer.ignore_data = vaddr;
-
-	pce_dev->ce_dm.phy_ce_pad = GET_PHYS_ADDR(pce_dev->ce_dm.buffer.pad);
-	pce_dev->ce_dm.phy_ce_out_ignore  =
-			GET_PHYS_ADDR(pce_dev->ce_dm.buffer.ignore_data);
-
-	pce_dev->ce_dm.chan_ce_in_cmd->user = (void *) pce_dev;
-	pce_dev->ce_dm.chan_ce_in_cmd->exec_func = NULL;
-
-	pce_dev->ce_dm.chan_ce_out_cmd->user = (void *) pce_dev;
-	pce_dev->ce_dm.chan_ce_out_cmd->exec_func = NULL;
-
-	return 0;
-}
-
-static int _qce_start_dma(struct qce_device *pce_dev, bool ce_in, bool ce_out)
-{
-
-	if (ce_in)
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IN_PROG;
-	else
-		pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_COMP;
-
-	if (ce_out)
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IN_PROG;
-	else
-		pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_COMP;
-
-	if (ce_in)
-		msm_dmov_enqueue_cmd(pce_dev->ce_dm.chan_ce_in,
-					pce_dev->ce_dm.chan_ce_in_cmd);
-	if (ce_out)
-		msm_dmov_enqueue_cmd(pce_dev->ce_dm.chan_ce_out,
-					pce_dev->ce_dm.chan_ce_out_cmd);
-
-	return 0;
-};
-
-int qce_aead_req(void *handle, struct qce_req *q_req)
-{
-	struct qce_device *pce_dev = (struct qce_device *) handle;
-	struct aead_request *areq = (struct aead_request *) q_req->areq;
-	uint32_t authsize = q_req->authsize;
-	uint32_t totallen_in, totallen_out, out_len;
-	uint32_t pad_len_in, pad_len_out;
-	int rc = 0;
-	int ce_block_size;
-
-	ce_block_size = pce_dev->ce_dm.ce_block_size;
-	if (q_req->dir == QCE_ENCRYPT) {
-		uint32_t pad_mac_len_out;
-
-		q_req->cryptlen = areq->cryptlen;
-		totallen_in = q_req->cryptlen + areq->assoclen;
-		pad_len_in = ALIGN(totallen_in, ce_block_size) - totallen_in;
-
-		out_len = areq->cryptlen + authsize;
-		totallen_out = q_req->cryptlen + authsize + areq->assoclen;
-		pad_mac_len_out = ALIGN(authsize, ce_block_size) - authsize;
-		totallen_out += pad_mac_len_out;
-		pad_len_out = ALIGN(totallen_out, ce_block_size) -
-					totallen_out + pad_mac_len_out;
-
-	} else {
-		q_req->cryptlen = areq->cryptlen - authsize;
-		totallen_in = areq->cryptlen + areq->assoclen;
-		pad_len_in = ALIGN(totallen_in, ce_block_size) - totallen_in;
-
-		out_len = q_req->cryptlen;
-		totallen_out = totallen_in;
-		pad_len_out = ALIGN(totallen_out, ce_block_size) - totallen_out;
-		pad_len_out += authsize;
-	}
-
-	_chain_buffer_in_init(pce_dev);
-	_chain_buffer_out_init(pce_dev);
-
-	pce_dev->assoc_nents = 0;
-	pce_dev->src_nents = 0;
-	pce_dev->dst_nents = 0;
-	pce_dev->ivsize = q_req->ivsize;
-	pce_dev->authsize = q_req->authsize;
-
-	
-	pce_dev->assoc_nents = count_sg(areq->assoc, areq->assoclen);
-	dma_map_sg(pce_dev->pdev, areq->assoc, pce_dev->assoc_nents,
-					 DMA_TO_DEVICE);
-	if (_chain_sg_buffer_in(pce_dev, areq->assoc, areq->assoclen) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-	
-	pce_dev->src_nents = count_sg(areq->src, areq->cryptlen);
-	dma_map_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-			(areq->src == areq->dst) ? DMA_BIDIRECTIONAL :
-							DMA_TO_DEVICE);
-	if (_chain_sg_buffer_in(pce_dev, areq->src, areq->cryptlen) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-	
-	if (pad_len_in) {
-		if (_chain_pm_buffer_in(pce_dev, pce_dev->ce_dm.phy_ce_pad,
-						pad_len_in) < 0) {
-			rc = -ENOMEM;
-			goto bad;
-		}
-	}
-
-	
-	if (_chain_pm_buffer_out(pce_dev, pce_dev->ce_dm.phy_ce_out_ignore,
-				areq->assoclen) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-	
-	if (areq->src != areq->dst) {
-		pce_dev->dst_nents = count_sg(areq->dst, out_len);
-		dma_map_sg(pce_dev->pdev, areq->dst, pce_dev->dst_nents,
-				DMA_FROM_DEVICE);
-	};
-	if (_chain_sg_buffer_out(pce_dev, areq->dst, out_len) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-	
-	if (pad_len_out) {
-		if (_chain_pm_buffer_out(pce_dev, pce_dev->ce_dm.phy_ce_pad,
-						pad_len_out) < 0) {
-			rc = -ENOMEM;
-			goto bad;
-		}
-	}
-
-	
-	_ce_in_final(pce_dev, ALIGN(totallen_in, ce_block_size));
-	_ce_out_final(pce_dev, ALIGN(totallen_out, ce_block_size));
-
-	
-	rc = _ce_setup_cipher(pce_dev, q_req, totallen_in, areq->assoclen);
-	if (rc < 0)
-		goto bad;
-
-	
-	pce_dev->areq = q_req->areq;
-	pce_dev->qce_cb = q_req->qce_cb;
-
-	pce_dev->ce_dm.chan_ce_in_cmd->complete_func = _aead_ce_in_call_back;
-	pce_dev->ce_dm.chan_ce_out_cmd->complete_func = _aead_ce_out_call_back;
-
-	_ce_in_dump(pce_dev);
-	_ce_out_dump(pce_dev);
-
-	rc = _qce_start_dma(pce_dev, true, true);
-	if (rc == 0)
-		return 0;
-bad:
-	if (pce_dev->assoc_nents) {
-		dma_unmap_sg(pce_dev->pdev, areq->assoc, pce_dev->assoc_nents,
-				DMA_TO_DEVICE);
-	}
-
-	if (pce_dev->src_nents) {
-		dma_unmap_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-				(areq->src == areq->dst) ? DMA_BIDIRECTIONAL :
-								DMA_TO_DEVICE);
-	}
-	if (pce_dev->dst_nents) {
-		dma_unmap_sg(pce_dev->pdev, areq->dst, pce_dev->dst_nents,
-				DMA_FROM_DEVICE);
-	}
-	return rc;
-}
-EXPORT_SYMBOL(qce_aead_req);
-
-int qce_ablk_cipher_req(void *handle, struct qce_req *c_req)
-{
-	int rc = 0;
-	struct qce_device *pce_dev = (struct qce_device *) handle;
-	struct ablkcipher_request *areq = (struct ablkcipher_request *)
-						c_req->areq;
-
-	uint32_t pad_len = ALIGN(areq->nbytes, pce_dev->ce_dm.ce_block_size)
-						- areq->nbytes;
-
-	_chain_buffer_in_init(pce_dev);
-	_chain_buffer_out_init(pce_dev);
-
-	pce_dev->src_nents = 0;
-	pce_dev->dst_nents = 0;
-
-	
-	pce_dev->src_nents = count_sg(areq->src, areq->nbytes);
-
-	if (c_req->use_pmem != 1)
-		dma_map_sg(pce_dev->pdev, areq->src, pce_dev->src_nents,
-			(areq->src == areq->dst) ? DMA_BIDIRECTIONAL :
-								DMA_TO_DEVICE);
-	else
-		dma_map_pmem_sg(&c_req->pmem->src[0], pce_dev->src_nents,
-								areq->src);
-
-	if (_chain_sg_buffer_in(pce_dev, areq->src, areq->nbytes) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-
-	
-	if (areq->src != areq->dst) {
-		pce_dev->dst_nents = count_sg(areq->dst, areq->nbytes);
-		if (c_req->use_pmem != 1)
-			dma_map_sg(pce_dev->pdev, areq->dst, pce_dev->dst_nents,
-							DMA_FROM_DEVICE);
-		else
-			dma_map_pmem_sg(&c_req->pmem->dst[0],
-					pce_dev->dst_nents, areq->dst);
-	};
-	if (_chain_sg_buffer_out(pce_dev, areq->dst, areq->nbytes) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-
-	
-	if (pad_len) {
-		if (_chain_pm_buffer_in(pce_dev, pce_dev->ce_dm.phy_ce_pad,
-						pad_len) < 0) {
-			rc = -ENOMEM;
-			goto bad;
-		}
-		if (_chain_pm_buffer_out(pce_dev, pce_dev->ce_dm.phy_ce_pad,
-						pad_len) < 0) {
-			rc = -ENOMEM;
-			goto bad;
-		}
-	}
-
-	
-	_ce_in_final(pce_dev, areq->nbytes + pad_len);
-	_ce_out_final(pce_dev, areq->nbytes + pad_len);
-
-	_ce_in_dump(pce_dev);
-	_ce_out_dump(pce_dev);
-
-	
-	rc = _ce_setup_cipher(pce_dev, c_req, areq->nbytes, 0);
-	if (rc < 0)
-		goto bad;
-
-	
-	pce_dev->areq = areq;
-	pce_dev->qce_cb = c_req->qce_cb;
-	if (c_req->use_pmem == 1) {
-		pce_dev->ce_dm.chan_ce_in_cmd->complete_func =
-					_ablk_cipher_ce_in_call_back_pmem;
-		pce_dev->ce_dm.chan_ce_out_cmd->complete_func =
-					_ablk_cipher_ce_out_call_back_pmem;
-	} else {
-		pce_dev->ce_dm.chan_ce_in_cmd->complete_func =
-					_ablk_cipher_ce_in_call_back;
-		pce_dev->ce_dm.chan_ce_out_cmd->complete_func =
-					_ablk_cipher_ce_out_call_back;
-	}
-	rc = _qce_start_dma(pce_dev, true, true);
-
-	if (rc == 0)
-		return 0;
-bad:
-	if (c_req->use_pmem != 1) {
-			if (pce_dev->dst_nents) {
-				dma_unmap_sg(pce_dev->pdev, areq->dst,
-				pce_dev->dst_nents, DMA_FROM_DEVICE);
-			}
-		if (pce_dev->src_nents) {
-			dma_unmap_sg(pce_dev->pdev, areq->src,
-					pce_dev->src_nents,
-					(areq->src == areq->dst) ?
-						DMA_BIDIRECTIONAL :
-						DMA_TO_DEVICE);
-		}
-	}
-	return rc;
-}
-EXPORT_SYMBOL(qce_ablk_cipher_req);
-
-int qce_process_sha_req(void *handle, struct qce_sha_req *sreq)
-{
-	struct qce_device *pce_dev = (struct qce_device *) handle;
-	int rc;
-	uint32_t pad_len = ALIGN(sreq->size, pce_dev->ce_dm.ce_block_size) -
-								sreq->size;
-	struct ahash_request *areq = (struct ahash_request *)sreq->areq;
-
-	_chain_buffer_in_init(pce_dev);
-	pce_dev->src_nents = count_sg(sreq->src, sreq->size);
-	dma_map_sg(pce_dev->pdev, sreq->src, pce_dev->src_nents,
-							DMA_TO_DEVICE);
-
-	if (_chain_sg_buffer_in(pce_dev, sreq->src, sreq->size) < 0) {
-		rc = -ENOMEM;
-		goto bad;
-	}
-
-	if (pad_len) {
-		if (_chain_pm_buffer_in(pce_dev, pce_dev->ce_dm.phy_ce_pad,
-						pad_len) < 0) {
-				rc = -ENOMEM;
-				goto bad;
-			}
-	}
-	 _ce_in_final(pce_dev, sreq->size + pad_len);
-
-	_ce_in_dump(pce_dev);
-
-	rc = _ce_setup_hash(pce_dev, sreq);
-
-	if (rc < 0)
-		goto bad;
-
-	pce_dev->areq = areq;
-	pce_dev->qce_cb = sreq->qce_cb;
-	pce_dev->ce_dm.chan_ce_in_cmd->complete_func = _sha_ce_in_call_back;
-
-	rc =  _qce_start_dma(pce_dev, true, false);
-
-	if (rc == 0)
-		return 0;
-bad:
-	if (pce_dev->src_nents) {
-		dma_unmap_sg(pce_dev->pdev, sreq->src,
-				pce_dev->src_nents, DMA_TO_DEVICE);
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(qce_process_sha_req);
-
-void *qce_open(struct platform_device *pdev, int *rc)
-{
-	struct qce_device *pce_dev;
-	struct resource *resource;
-	struct clk *ce_core_clk;
-	struct clk *ce_clk;
-	struct clk *ce_core_src_clk;
-	int ret = 0;
-
-	pce_dev = kzalloc(sizeof(struct qce_device), GFP_KERNEL);
-	if (!pce_dev) {
-		*rc = -ENOMEM;
-		dev_err(&pdev->dev, "Can not allocate memory\n");
-		return NULL;
-	}
-	pce_dev->pdev = &pdev->dev;
-
-	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!resource) {
-		*rc = -ENXIO;
-		dev_err(pce_dev->pdev, "Missing MEM resource\n");
-		goto err_pce_dev;
-	};
-	pce_dev->phy_iobase = resource->start;
-	pce_dev->iobase = ioremap_nocache(resource->start,
-				resource->end - resource->start + 1);
-	if (!pce_dev->iobase) {
-		*rc = -ENOMEM;
-		dev_err(pce_dev->pdev, "Can not map io memory\n");
-		goto err_pce_dev;
-	}
-
-	pce_dev->ce_dm.chan_ce_in_cmd = kzalloc(sizeof(struct msm_dmov_cmd),
-			GFP_KERNEL);
-	pce_dev->ce_dm.chan_ce_out_cmd = kzalloc(sizeof(struct msm_dmov_cmd),
-			GFP_KERNEL);
-	if (pce_dev->ce_dm.chan_ce_in_cmd == NULL ||
-			pce_dev->ce_dm.chan_ce_out_cmd == NULL) {
-		dev_err(pce_dev->pdev, "Can not allocate memory\n");
-		*rc = -ENOMEM;
-		goto err_dm_chan_cmd;
-	}
-
-	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
-					"crypto_channels");
-	if (!resource) {
-		*rc = -ENXIO;
-		dev_err(pce_dev->pdev, "Missing DMA channel resource\n");
-		goto err_dm_chan_cmd;
-	};
-	pce_dev->ce_dm.chan_ce_in = resource->start;
-	pce_dev->ce_dm.chan_ce_out = resource->end;
-	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
-				"crypto_crci_in");
-	if (!resource) {
-		*rc = -ENXIO;
-		dev_err(pce_dev->pdev, "Missing DMA crci in resource\n");
-		goto err_dm_chan_cmd;
-	};
-	pce_dev->ce_dm.crci_in = resource->start;
-	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
-				"crypto_crci_out");
-	if (!resource) {
-		*rc = -ENXIO;
-		dev_err(pce_dev->pdev, "Missing DMA crci out resource\n");
-		goto err_dm_chan_cmd;
-	};
-	pce_dev->ce_dm.crci_out = resource->start;
-	pce_dev->memsize = 2 * PAGE_SIZE;
-	pce_dev->coh_vmem = dma_alloc_coherent(pce_dev->pdev,
-			pce_dev->memsize, &pce_dev->coh_pmem, GFP_KERNEL);
-
-	if (pce_dev->coh_vmem == NULL) {
-		*rc = -ENOMEM;
-		dev_err(pce_dev->pdev, "Can not allocate coherent memory.\n");
-		goto err;
-	}
-
-	
-	ce_core_src_clk = clk_get(pce_dev->pdev, "ce3_core_src_clk");
-	if (!IS_ERR(ce_core_src_clk)) {
-		pce_dev->ce_core_src_clk = ce_core_src_clk;
-
-		
-		ret = clk_set_rate(pce_dev->ce_core_src_clk, 100000000);
-		if (ret) {
-			clk_put(pce_dev->ce_core_src_clk);
-			goto err;
-		}
-	} else
-		pce_dev->ce_core_src_clk = NULL;
-
-	
-	ce_core_clk = clk_get(pce_dev->pdev, "core_clk");
-	if (IS_ERR(ce_core_clk)) {
-		*rc = PTR_ERR(ce_core_clk);
-		if (pce_dev->ce_core_src_clk != NULL)
-			clk_put(pce_dev->ce_core_src_clk);
-		goto err;
-	}
-	pce_dev->ce_core_clk = ce_core_clk;
-	
-	ce_clk = clk_get(pce_dev->pdev, "iface_clk");
-	if (IS_ERR(ce_clk)) {
-		*rc = PTR_ERR(ce_clk);
-		if (pce_dev->ce_core_src_clk != NULL)
-			clk_put(pce_dev->ce_core_src_clk);
-		clk_put(pce_dev->ce_core_clk);
-		goto err;
-	}
-	pce_dev->ce_clk = ce_clk;
-
-	
-	*rc = clk_prepare_enable(pce_dev->ce_core_clk);
-	if (*rc) {
-		if (pce_dev->ce_core_src_clk != NULL)
-			clk_put(pce_dev->ce_core_src_clk);
-		clk_put(pce_dev->ce_core_clk);
-		clk_put(pce_dev->ce_clk);
-		goto err;
-	} else {
-		
-		*rc = clk_prepare_enable(pce_dev->ce_clk);
-		if (*rc) {
-			clk_disable_unprepare(pce_dev->ce_core_clk);
-			if (pce_dev->ce_core_src_clk != NULL)
-				clk_put(pce_dev->ce_core_src_clk);
-			clk_put(pce_dev->ce_core_clk);
-			clk_put(pce_dev->ce_clk);
-			goto err;
-
-		}
-	}
-	qce_setup_ce_dm_data(pce_dev);
-
-	pce_dev->ce_dm.chan_ce_in_state = QCE_CHAN_STATE_IDLE;
-	pce_dev->ce_dm.chan_ce_out_state = QCE_CHAN_STATE_IDLE;
-	if (_init_ce_engine(pce_dev)) {
-		*rc = -ENXIO;
-		goto err;
-	}
-	*rc = 0;
-	return pce_dev;
-
-err:
-	if (pce_dev->coh_vmem)
-		dma_free_coherent(pce_dev->pdev, pce_dev->memsize,
-			pce_dev->coh_vmem, pce_dev->coh_pmem);
-err_dm_chan_cmd:
-	kfree(pce_dev->ce_dm.chan_ce_in_cmd);
-	kfree(pce_dev->ce_dm.chan_ce_out_cmd);
-	if (pce_dev->iobase)
-		iounmap(pce_dev->iobase);
-
-err_pce_dev:
-
-	kfree(pce_dev);
-
-	return NULL;
-}
-EXPORT_SYMBOL(qce_open);
-
-int qce_close(void *handle)
-{
-	struct qce_device *pce_dev = (struct qce_device *) handle;
-
-	if (handle == NULL)
-		return -ENODEV;
-	if (pce_dev->iobase)
-		iounmap(pce_dev->iobase);
-
-	if (pce_dev->coh_vmem)
-		dma_free_coherent(pce_dev->pdev, pce_dev->memsize,
-				pce_dev->coh_vmem, pce_dev->coh_pmem);
-	clk_disable_unprepare(pce_dev->ce_clk);
-	clk_disable_unprepare(pce_dev->ce_core_clk);
-
-	if (pce_dev->ce_core_src_clk != NULL)
-		clk_put(pce_dev->ce_core_src_clk);
-
-	clk_put(pce_dev->ce_clk);
-	clk_put(pce_dev->ce_core_clk);
-
-	kfree(pce_dev->ce_dm.chan_ce_in_cmd);
-	kfree(pce_dev->ce_dm.chan_ce_out_cmd);
-	kfree(handle);
-
-	return 0;
-}
-EXPORT_SYMBOL(qce_close);
-
-int qce_hw_support(void *handle, struct ce_hw_support *ce_support)
-{
-	if (ce_support == NULL)
-		return -EINVAL;
-
-	ce_support->sha1_hmac_20 = false;
-	ce_support->sha1_hmac = false;
-	ce_support->sha256_hmac = false;
-	ce_support->sha_hmac = false;
-	ce_support->cmac  = true;
-	ce_support->aes_key_192 = false;
-	ce_support->aes_xts = true;
-	ce_support->aes_ccm = true;
-	ce_support->ota = false;
-	return 0;
-}
-EXPORT_SYMBOL(qce_hw_support);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Mona Hossain <mhossain@codeaurora.org>");
-MODULE_DESCRIPTION("Crypto Engine driver");
-MODULE_VERSION("2.17");
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce40.h monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce40.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce40.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce40.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,226 +0,0 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef _DRIVERS_CRYPTO_MSM_QCE40_H_
-#define _DRIVERS_CRYPTO_MSM_QCE40_H_
-
-
-#define GET_VIRT_ADDR(x)  \
-		((uint32_t)pce_dev->coh_vmem +			\
-		((uint32_t)x - pce_dev->coh_pmem))
-#define GET_PHYS_ADDR(x)  \
-		(pce_dev->coh_pmem + ((unsigned char *)x -	\
-		pce_dev->coh_vmem))
-
-#define QCE_SET_CMD_PTR(x)  \
-		(uint32_t)(DMOV_CMD_ADDR(GET_PHYS_ADDR((unsigned char *)x)))
-
-#define SET_LAST_CMD_PTR(x) \
-		((DMOV_CMD_ADDR(x)) | CMD_PTR_LP)
-
-#define QCE_SET_LAST_CMD_PTR(x) \
-		SET_LAST_CMD_PTR((GET_PHYS_ADDR((unsigned char *)x)))
-
-
-#define MAX_ADM_CE_BLOCK_SIZE  64
-#define ADM_DESC_LENGTH_MASK 0xffff
-#define ADM_DESC_LENGTH(x)  (x & ADM_DESC_LENGTH_MASK)
-
-#define ADM_STATUS_OK 0x80000002
-
-#define QCE_MAX_NUM_DESC    128
-
-#define CRYPTO_REG_SIZE                 0x4
-
-struct dmov_desc {
-	uint32_t addr;
-	uint32_t len;
-};
-
-enum qce_chan_st_enum {
-	QCE_CHAN_STATE_IDLE = 0,
-	QCE_CHAN_STATE_IN_PROG = 1,
-	QCE_CHAN_STATE_COMP = 2,
-	QCE_CHAN_STATE_LAST
-};
-
-struct ce_reg_buffer_addr {
-
-	unsigned char *reset_buf_64;
-	unsigned char *version;
-
-	unsigned char *encr_seg_cfg_size_start;
-	unsigned char *encr_key;
-	unsigned char *encr_xts_key;
-	unsigned char *encr_cntr_iv;
-	unsigned char *encr_mask;
-	unsigned char *encr_xts_du_size;
-
-	unsigned char *auth_seg_cfg_size_start;
-	unsigned char *auth_key;
-	unsigned char *auth_iv;
-	unsigned char *auth_result;
-	unsigned char *auth_nonce_info;
-	unsigned char *auth_byte_count;
-
-	unsigned char *seg_size;
-	unsigned char *go_proc;
-	unsigned char *status;
-
-	unsigned char *pad;
-	unsigned char *ignore_data;
-};
-
-struct ce_reg_buffers {
-
-	unsigned char reset_buf_64[64];
-	unsigned char version[CRYPTO_REG_SIZE];
-
-	unsigned char encr_seg_cfg_size_start[3 * CRYPTO_REG_SIZE];
-	unsigned char encr_key[8 * CRYPTO_REG_SIZE];
-	unsigned char encr_xts_key[8 * CRYPTO_REG_SIZE];
-	unsigned char encr_cntr_iv[4 * CRYPTO_REG_SIZE];
-	unsigned char encr_mask[CRYPTO_REG_SIZE];
-	unsigned char encr_xts_du_size[CRYPTO_REG_SIZE];
-
-	unsigned char auth_seg_cfg_size_start[3 * CRYPTO_REG_SIZE];
-	unsigned char auth_key[16 * CRYPTO_REG_SIZE];
-	unsigned char auth_iv[16 * CRYPTO_REG_SIZE];
-	unsigned char auth_result[16 * CRYPTO_REG_SIZE];
-	unsigned char auth_nonce_info[4 * CRYPTO_REG_SIZE];
-	unsigned char auth_byte_count[4 * CRYPTO_REG_SIZE];
-
-	unsigned char seg_size[CRYPTO_REG_SIZE];
-	unsigned char go_proc[CRYPTO_REG_SIZE];
-	unsigned char status[CRYPTO_REG_SIZE];
-
-	unsigned char pad[2 * MAX_ADM_CE_BLOCK_SIZE];
-};
-
-struct ce_cmdlists {
-	dmov_s *get_hw_version;
-	dmov_s *clear_status;
-	dmov_s *get_status_ocu;
-
-	dmov_s *set_cipher_cfg;
-
-	dmov_s *set_cipher_aes_128_key;
-	dmov_s *set_cipher_aes_256_key;
-	dmov_s *set_cipher_des_key;
-	dmov_s *set_cipher_3des_key;
-
-	dmov_s *set_cipher_aes_128_xts_key;
-	dmov_s *set_cipher_aes_256_xts_key;
-	dmov_s *set_cipher_xts_du_size;
-
-	dmov_s *set_cipher_aes_iv;
-	dmov_s *set_cipher_aes_xts_iv;
-	dmov_s *set_cipher_des_iv;
-	dmov_s *get_cipher_iv;
-
-	dmov_s *set_cipher_mask;
-
-	dmov_s *set_auth_cfg;
-	dmov_s *set_auth_key_128;
-	dmov_s *set_auth_key_256;
-	dmov_s *set_auth_key_512;
-	dmov_s *set_auth_iv_16;
-	dmov_s *get_auth_result_16;
-	dmov_s *set_auth_iv_20;
-	dmov_s *get_auth_result_20;
-	dmov_s *set_auth_iv_32;
-	dmov_s *get_auth_result_32;
-	dmov_s *set_auth_byte_count;
-	dmov_s *get_auth_byte_count;
-
-	dmov_s *set_auth_nonce_info;
-
-	dmov_s *reset_cipher_key;
-	dmov_s *reset_cipher_xts_key;
-	dmov_s *reset_cipher_iv;
-	dmov_s *reset_cipher_cfg;
-	dmov_s *reset_auth_key;
-	dmov_s *reset_auth_iv;
-	dmov_s *reset_auth_cfg;
-	dmov_s *reset_auth_byte_count;
-
-	dmov_s *set_seg_size_ocb;
-	dmov_s *get_status_wait;
-	dmov_s *set_go_proc;
-
-	dmov_sg *ce_data_in;
-	dmov_sg *ce_data_out;
-};
-
-struct ce_cmdptrlists_ops {
-
-	uint32_t probe_ce_hw;
-	uint32_t cipher_aes_128_cbc_ctr;
-	uint32_t cipher_aes_256_cbc_ctr;
-	uint32_t cipher_aes_128_ecb;
-	uint32_t cipher_aes_256_ecb;
-	uint32_t cipher_aes_128_xts;
-	uint32_t cipher_aes_256_xts;
-	uint32_t cipher_des_cbc;
-	uint32_t cipher_des_ecb;
-	uint32_t cipher_3des_cbc;
-	uint32_t cipher_3des_ecb;
-	uint32_t auth_sha1;
-	uint32_t auth_sha256;
-	uint32_t auth_sha1_hmac;
-	uint32_t auth_sha256_hmac;
-	uint32_t auth_aes_128_cmac;
-	uint32_t auth_aes_256_cmac;
-	uint32_t aead_aes_128_ccm;
-	uint32_t aead_aes_256_ccm;
-
-	uint32_t cipher_ce_out;
-	uint32_t cipher_ce_out_get_iv;
-	uint32_t aead_ce_out;
-};
-
-struct ce_dm_data {
-	unsigned int chan_ce_in;	
-	unsigned int chan_ce_out;	
-
-	unsigned int crci_in;		
-	unsigned int crci_out;		
-
-	enum qce_chan_st_enum chan_ce_in_state;		
-	enum qce_chan_st_enum chan_ce_out_state;	
-
-	int chan_ce_in_status;				
-	int chan_ce_out_status;				
-
-	struct dmov_desc *ce_out_src_desc;
-	struct dmov_desc *ce_out_dst_desc;
-	struct dmov_desc *ce_in_src_desc;
-	struct dmov_desc *ce_in_dst_desc;
-
-	int ce_out_src_desc_index;
-	int ce_out_dst_desc_index;
-	int ce_in_src_desc_index;
-	int ce_in_dst_desc_index;
-
-	int ce_block_size;
-
-	dma_addr_t phy_ce_out_ignore;
-	dma_addr_t phy_ce_pad;
-
-	struct ce_reg_buffer_addr buffer;
-	struct ce_cmdlists cmdlist;
-	struct ce_cmdptrlists_ops cmdptrlist;
-
-	struct msm_dmov_cmd  *chan_ce_in_cmd;
-	struct msm_dmov_cmd  *chan_ce_out_cmd;
-};
-#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcedev.c monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcedev.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcedev.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcedev.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,2215 +0,0 @@
-/* Qualcomm CE device driver.
- *
- * Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/mman.h>
-#include <linux/android_pmem.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/kernel.h>
-#include <linux/dmapool.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
-#include <linux/uaccess.h>
-#include <linux/debugfs.h>
-#include <linux/scatterlist.h>
-#include <linux/crypto.h>
-#include <crypto/hash.h>
-#include <linux/platform_data/qcom_crypto_device.h>
-#include <mach/scm.h>
-#include <mach/msm_bus.h>
-#include <linux/qcedev.h>
-#include "qce.h"
-
-
-#define CACHE_LINE_SIZE 32
-#define CE_SHA_BLOCK_SIZE SHA256_BLOCK_SIZE
-
-static uint8_t  _std_init_vector_sha1_uint8[] =   {
-	0x67, 0x45, 0x23, 0x01, 0xEF, 0xCD, 0xAB, 0x89,
-	0x98, 0xBA, 0xDC, 0xFE, 0x10, 0x32, 0x54, 0x76,
-	0xC3, 0xD2, 0xE1, 0xF0
-};
-static uint8_t _std_init_vector_sha256_uint8[] = {
-	0x6A, 0x09, 0xE6, 0x67, 0xBB, 0x67, 0xAE, 0x85,
-	0x3C, 0x6E, 0xF3, 0x72, 0xA5, 0x4F, 0xF5, 0x3A,
-	0x51, 0x0E, 0x52, 0x7F, 0x9B, 0x05, 0x68, 0x8C,
-	0x1F, 0x83, 0xD9, 0xAB, 0x5B, 0xE0, 0xCD, 0x19
-};
-
-enum qcedev_crypto_oper_type {
-  QCEDEV_CRYPTO_OPER_CIPHER	= 0,
-  QCEDEV_CRYPTO_OPER_SHA	= 1,
-  QCEDEV_CRYPTO_OPER_LAST
-};
-
-struct qcedev_handle;
-
-struct qcedev_cipher_req {
-	struct ablkcipher_request creq;
-	void *cookie;
-};
-
-struct qcedev_sha_req {
-	struct ahash_request sreq;
-	void *cookie;
-};
-
-struct	qcedev_sha_ctxt {
-	uint32_t	auth_data[4];
-	uint8_t		digest[QCEDEV_MAX_SHA_DIGEST];
-	uint32_t	diglen;
-	uint8_t		trailing_buf[64];
-	uint32_t	trailing_buf_len;
-	uint8_t		first_blk;
-	uint8_t		last_blk;
-	uint8_t		authkey[QCEDEV_MAX_SHA_BLOCK_SIZE];
-};
-
-struct qcedev_async_req {
-	struct list_head			list;
-	struct completion			complete;
-	enum qcedev_crypto_oper_type		op_type;
-	union {
-		struct qcedev_cipher_op_req	cipher_op_req;
-		struct qcedev_sha_op_req	sha_op_req;
-	};
-	union{
-		struct qcedev_cipher_req	cipher_req;
-		struct qcedev_sha_req		sha_req;
-	};
-	struct qcedev_handle			*handle;
-	int					err;
-};
-
-static DEFINE_MUTEX(send_cmd_lock);
-static DEFINE_MUTEX(sent_bw_req);
-
-
-#define QCEDEV_DEV	"qcedev"
-
-struct qcedev_control{
-
-	
-	struct msm_ce_hw_support platform_support;
-
-	uint32_t ce_lock_count;
-	uint32_t high_bw_req_count;
-
-	
-	struct ce_hw_support ce_support;
-
-	uint32_t  bus_scale_handle;
-
-	
-	struct miscdevice miscdevice;
-
-	
-	void *qce;
-
-	
-	struct platform_device *pdev;
-
-	unsigned magic;
-
-	struct list_head ready_commands;
-	struct qcedev_async_req *active_command;
-	spinlock_t lock;
-	struct tasklet_struct done_tasklet;
-};
-
-struct qcedev_handle {
-	
-	struct qcedev_control *cntl;
-	
-	struct	qcedev_sha_ctxt sha_ctxt;
-};
-
-#define QCEDEV_CMD_ID				1
-#define QCEDEV_CE_LOCK_CMD			1
-#define QCEDEV_CE_UNLOCK_CMD			0
-#define NUM_RETRY				1000
-#define CE_BUSY					55
-
-static int qcedev_scm_cmd(int resource, int cmd, int *response)
-{
-#ifdef CONFIG_MSM_SCM
-
-	struct {
-		int resource;
-		int cmd;
-	} cmd_buf;
-
-	cmd_buf.resource = resource;
-	cmd_buf.cmd = cmd;
-
-	return scm_call(SCM_SVC_TZ, QCEDEV_CMD_ID, &cmd_buf,
-		sizeof(cmd_buf), response, sizeof(*response));
-
-#else
-	return 0;
-#endif
-}
-
-static void qcedev_ce_high_bw_req(struct qcedev_control *podev,
-							bool high_bw_req)
-{
-	int ret = 0;
-
-	mutex_lock(&sent_bw_req);
-	if (high_bw_req) {
-		if (podev->high_bw_req_count == 0)
-			ret = msm_bus_scale_client_update_request(
-					podev->bus_scale_handle, 1);
-		if (ret)
-			pr_err("%s Unable to set to high bandwidth\n",
-							__func__);
-		podev->high_bw_req_count++;
-	} else {
-		if (podev->high_bw_req_count == 1)
-			ret = msm_bus_scale_client_update_request(
-					podev->bus_scale_handle, 0);
-		if (ret)
-			pr_err("%s Unable to set to low bandwidth\n",
-							__func__);
-		podev->high_bw_req_count--;
-	}
-	mutex_unlock(&sent_bw_req);
-}
-
-
-static int qcedev_unlock_ce(struct qcedev_control *podev)
-{
-	int ret = 0;
-
-	mutex_lock(&send_cmd_lock);
-	if (podev->ce_lock_count == 1) {
-		int response = 0;
-
-		if (qcedev_scm_cmd(podev->platform_support.shared_ce_resource,
-					QCEDEV_CE_UNLOCK_CMD, &response)) {
-			pr_err("Failed to release CE lock\n");
-			ret = -EIO;
-		}
-	}
-	if (ret == 0) {
-		if (podev->ce_lock_count)
-			podev->ce_lock_count--;
-		else {
-			
-			ret = -EIO;
-			pr_err("CE hardware is already unlocked\n");
-		}
-	}
-	mutex_unlock(&send_cmd_lock);
-
-	return ret;
-}
-
-static int qcedev_lock_ce(struct qcedev_control *podev)
-{
-	int ret = 0;
-
-	mutex_lock(&send_cmd_lock);
-	if (podev->ce_lock_count == 0) {
-		int response = -CE_BUSY;
-		int i = 0;
-
-		do {
-			if (qcedev_scm_cmd(
-				podev->platform_support.shared_ce_resource,
-				QCEDEV_CE_LOCK_CMD, &response)) {
-				response = -EINVAL;
-				break;
-			}
-		} while ((response == -CE_BUSY) && (i++ < NUM_RETRY));
-
-		if ((response == -CE_BUSY) && (i >= NUM_RETRY)) {
-			ret = -EUSERS;
-		} else {
-			if (response < 0)
-				ret = -EINVAL;
-		}
-	}
-	if (ret == 0)
-		podev->ce_lock_count++;
-	mutex_unlock(&send_cmd_lock);
-	return ret;
-}
-
-#define QCEDEV_MAGIC 0x56434544 
-
-static long qcedev_ioctl(struct file *file, unsigned cmd, unsigned long arg);
-static int qcedev_open(struct inode *inode, struct file *file);
-static int qcedev_release(struct inode *inode, struct file *file);
-static int start_cipher_req(struct qcedev_control *podev);
-static int start_sha_req(struct qcedev_control *podev);
-
-static const struct file_operations qcedev_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = qcedev_ioctl,
-	.open = qcedev_open,
-	.release = qcedev_release,
-};
-
-static struct qcedev_control qce_dev[] = {
-	{
-		.miscdevice = {
-			.minor = MISC_DYNAMIC_MINOR,
-			.name = "qce",
-			.fops = &qcedev_fops,
-		},
-		.magic = QCEDEV_MAGIC,
-	},
-};
-
-#define MAX_QCE_DEVICE ARRAY_SIZE(qce_dev)
-#define DEBUG_MAX_FNAME  16
-#define DEBUG_MAX_RW_BUF 1024
-
-struct qcedev_stat {
-	u32 qcedev_dec_success;
-	u32 qcedev_dec_fail;
-	u32 qcedev_enc_success;
-	u32 qcedev_enc_fail;
-	u32 qcedev_sha_success;
-	u32 qcedev_sha_fail;
-};
-
-static struct qcedev_stat _qcedev_stat[MAX_QCE_DEVICE];
-static struct dentry *_debug_dent;
-static char _debug_read_buf[DEBUG_MAX_RW_BUF];
-static int _debug_qcedev[MAX_QCE_DEVICE];
-
-static struct qcedev_control *qcedev_minor_to_control(unsigned n)
-{
-	int i;
-
-	for (i = 0; i < MAX_QCE_DEVICE; i++) {
-		if (qce_dev[i].miscdevice.minor == n)
-			return &qce_dev[i];
-	}
-	return NULL;
-}
-
-static int qcedev_open(struct inode *inode, struct file *file)
-{
-	struct qcedev_handle *handle;
-	struct qcedev_control *podev;
-
-	podev = qcedev_minor_to_control(MINOR(inode->i_rdev));
-	if (podev == NULL) {
-		pr_err("%s: no such device %d\n", __func__,
-					MINOR(inode->i_rdev));
-		return -ENOENT;
-	}
-
-	handle = kzalloc(sizeof(struct qcedev_handle), GFP_KERNEL);
-	if (handle == NULL) {
-		pr_err("Failed to allocate memory %ld\n",
-					PTR_ERR(handle));
-		return -ENOMEM;
-	}
-
-	handle->cntl = podev;
-	file->private_data = handle;
-	if (podev->platform_support.bus_scale_table != NULL)
-		qcedev_ce_high_bw_req(podev, true);
-	return 0;
-}
-
-static int qcedev_release(struct inode *inode, struct file *file)
-{
-	struct qcedev_control *podev;
-	struct qcedev_handle *handle;
-
-	handle =  file->private_data;
-	podev =  handle->cntl;
-	if (podev != NULL && podev->magic != QCEDEV_MAGIC) {
-		pr_err("%s: invalid handle %p\n",
-					__func__, podev);
-	}
-	kzfree(handle);
-	file->private_data = NULL;
-	if (podev != NULL && podev->platform_support.bus_scale_table != NULL)
-		qcedev_ce_high_bw_req(podev, false);
-	return 0;
-}
-
-static void req_done(unsigned long data)
-{
-	struct qcedev_control *podev = (struct qcedev_control *)data;
-	struct qcedev_async_req *areq;
-	unsigned long flags = 0;
-	struct qcedev_async_req *new_req = NULL;
-	int ret = 0;
-
-	spin_lock_irqsave(&podev->lock, flags);
-	areq = podev->active_command;
-	podev->active_command = NULL;
-
-again:
-	if (!list_empty(&podev->ready_commands)) {
-		new_req = container_of(podev->ready_commands.next,
-						struct qcedev_async_req, list);
-		list_del(&new_req->list);
-		podev->active_command = new_req;
-		new_req->err = 0;
-		if (new_req->op_type == QCEDEV_CRYPTO_OPER_CIPHER)
-			ret = start_cipher_req(podev);
-		else
-			ret = start_sha_req(podev);
-	}
-
-	spin_unlock_irqrestore(&podev->lock, flags);
-
-	if (areq)
-		complete(&areq->complete);
-
-	if (new_req && ret) {
-		complete(&new_req->complete);
-		spin_lock_irqsave(&podev->lock, flags);
-		podev->active_command = NULL;
-		areq = NULL;
-		ret = 0;
-		new_req = NULL;
-		goto again;
-	}
-
-	return;
-}
-
-static void qcedev_sha_req_cb(void *cookie, unsigned char *digest,
-	unsigned char *authdata, int ret)
-{
-	struct qcedev_sha_req *areq;
-	struct qcedev_control *pdev;
-	struct qcedev_handle *handle;
-
-	uint32_t *auth32 = (uint32_t *)authdata;
-
-	areq = (struct qcedev_sha_req *) cookie;
-	handle = (struct qcedev_handle *) areq->cookie;
-	pdev = handle->cntl;
-
-	if (digest)
-		memcpy(&handle->sha_ctxt.digest[0], digest, 32);
-
-	if (authdata) {
-		handle->sha_ctxt.auth_data[0] = auth32[0];
-		handle->sha_ctxt.auth_data[1] = auth32[1];
-		handle->sha_ctxt.auth_data[2] = auth32[2];
-		handle->sha_ctxt.auth_data[3] = auth32[3];
-	}
-
-	tasklet_schedule(&pdev->done_tasklet);
-};
-
-
-static void qcedev_cipher_req_cb(void *cookie, unsigned char *icv,
-	unsigned char *iv, int ret)
-{
-	struct qcedev_cipher_req *areq;
-	struct qcedev_handle *handle;
-	struct qcedev_control *podev;
-	struct qcedev_async_req *qcedev_areq;
-
-	areq = (struct qcedev_cipher_req *) cookie;
-	handle = (struct qcedev_handle *) areq->cookie;
-	podev = handle->cntl;
-	qcedev_areq = podev->active_command;
-
-	if (iv)
-		memcpy(&qcedev_areq->cipher_op_req.iv[0], iv,
-					qcedev_areq->cipher_op_req.ivlen);
-	tasklet_schedule(&podev->done_tasklet);
-};
-
-static int start_cipher_req(struct qcedev_control *podev)
-{
-	struct qcedev_async_req *qcedev_areq;
-	struct qce_req creq;
-	int ret = 0;
-
-	
-	qcedev_areq = podev->active_command;
-
-	qcedev_areq->cipher_req.cookie = qcedev_areq->handle;
-	creq.use_pmem = qcedev_areq->cipher_op_req.use_pmem;
-	if (qcedev_areq->cipher_op_req.use_pmem == QCEDEV_USE_PMEM)
-		creq.pmem = &qcedev_areq->cipher_op_req.pmem;
-	else
-		creq.pmem = NULL;
-
-	switch (qcedev_areq->cipher_op_req.alg) {
-	case QCEDEV_ALG_DES:
-		creq.alg = CIPHER_ALG_DES;
-		break;
-	case QCEDEV_ALG_3DES:
-		creq.alg = CIPHER_ALG_3DES;
-		break;
-	case QCEDEV_ALG_AES:
-		creq.alg = CIPHER_ALG_AES;
-		break;
-	default:
-		return -EINVAL;
-	};
-
-	switch (qcedev_areq->cipher_op_req.mode) {
-	case QCEDEV_AES_MODE_CBC:
-	case QCEDEV_DES_MODE_CBC:
-		creq.mode = QCE_MODE_CBC;
-		break;
-	case QCEDEV_AES_MODE_ECB:
-	case QCEDEV_DES_MODE_ECB:
-		creq.mode = QCE_MODE_ECB;
-		break;
-	case QCEDEV_AES_MODE_CTR:
-		creq.mode = QCE_MODE_CTR;
-		break;
-	case QCEDEV_AES_MODE_XTS:
-		creq.mode = QCE_MODE_XTS;
-		break;
-	default:
-		return -EINVAL;
-	};
-
-	if ((creq.alg == CIPHER_ALG_AES) &&
-		(creq.mode == QCE_MODE_CTR)) {
-		creq.dir = QCE_ENCRYPT;
-	} else {
-		if (QCEDEV_OPER_ENC == qcedev_areq->cipher_op_req.op)
-			creq.dir = QCE_ENCRYPT;
-		else
-			creq.dir = QCE_DECRYPT;
-	}
-
-	creq.iv = &qcedev_areq->cipher_op_req.iv[0];
-	creq.ivsize = qcedev_areq->cipher_op_req.ivlen;
-
-	creq.enckey =  &qcedev_areq->cipher_op_req.enckey[0];
-	creq.encklen = qcedev_areq->cipher_op_req.encklen;
-
-	creq.cryptlen = qcedev_areq->cipher_op_req.data_len;
-
-	if (qcedev_areq->cipher_op_req.encklen == 0) {
-		if ((qcedev_areq->cipher_op_req.op == QCEDEV_OPER_ENC_NO_KEY)
-			|| (qcedev_areq->cipher_op_req.op ==
-				QCEDEV_OPER_DEC_NO_KEY))
-			creq.op = QCE_REQ_ABLK_CIPHER_NO_KEY;
-		else {
-			int i;
-
-			for (i = 0; i < QCEDEV_MAX_KEY_SIZE; i++) {
-				if (qcedev_areq->cipher_op_req.enckey[i] != 0)
-					break;
-			}
-
-			if ((podev->platform_support.hw_key_support == 1) &&
-						(i == QCEDEV_MAX_KEY_SIZE))
-				creq.op = QCE_REQ_ABLK_CIPHER;
-			else {
-				ret = -EINVAL;
-				goto unsupported;
-			}
-		}
-	} else {
-		creq.op = QCE_REQ_ABLK_CIPHER;
-	}
-
-	creq.qce_cb = qcedev_cipher_req_cb;
-	creq.areq = (void *)&qcedev_areq->cipher_req;
-
-	ret = qce_ablk_cipher_req(podev->qce, &creq);
-unsupported:
-	if (ret)
-		qcedev_areq->err = -ENXIO;
-	else
-		qcedev_areq->err = 0;
-	return ret;
-};
-
-static int start_sha_req(struct qcedev_control *podev)
-{
-	struct qcedev_async_req *qcedev_areq;
-	struct qce_sha_req sreq;
-	int ret = 0;
-	struct qcedev_handle *handle;
-
-	
-	qcedev_areq = podev->active_command;
-	handle = qcedev_areq->handle;
-
-	switch (qcedev_areq->sha_op_req.alg) {
-	case QCEDEV_ALG_SHA1:
-		sreq.alg = QCE_HASH_SHA1;
-		break;
-	case QCEDEV_ALG_SHA256:
-		sreq.alg = QCE_HASH_SHA256;
-		break;
-	case QCEDEV_ALG_SHA1_HMAC:
-		if (podev->ce_support.sha_hmac) {
-			sreq.alg = QCE_HASH_SHA1_HMAC;
-			sreq.authkey = &handle->sha_ctxt.authkey[0];
-
-		} else {
-			sreq.alg = QCE_HASH_SHA1;
-			sreq.authkey = NULL;
-		}
-		break;
-	case QCEDEV_ALG_SHA256_HMAC:
-		if (podev->ce_support.sha_hmac) {
-			sreq.alg = QCE_HASH_SHA256_HMAC;
-			sreq.authkey = &handle->sha_ctxt.authkey[0];
-
-		} else {
-			sreq.alg = QCE_HASH_SHA256;
-			sreq.authkey = NULL;
-		}
-		break;
-	case QCEDEV_ALG_AES_CMAC:
-		sreq.alg = QCE_HASH_AES_CMAC;
-		sreq.authkey = &handle->sha_ctxt.authkey[0];
-		sreq.authklen = qcedev_areq->sha_op_req.authklen;
-		break;
-	default:
-		break;
-	};
-
-	qcedev_areq->sha_req.cookie = handle;
-
-	sreq.qce_cb = qcedev_sha_req_cb;
-	if (qcedev_areq->sha_op_req.alg != QCEDEV_ALG_AES_CMAC) {
-		sreq.auth_data[0] = handle->sha_ctxt.auth_data[0];
-		sreq.auth_data[1] = handle->sha_ctxt.auth_data[1];
-		sreq.auth_data[2] = handle->sha_ctxt.auth_data[2];
-		sreq.auth_data[3] = handle->sha_ctxt.auth_data[3];
-		sreq.digest = &handle->sha_ctxt.digest[0];
-		sreq.first_blk = handle->sha_ctxt.first_blk;
-		sreq.last_blk = handle->sha_ctxt.last_blk;
-	}
-	sreq.size = qcedev_areq->sha_req.sreq.nbytes;
-	sreq.src = qcedev_areq->sha_req.sreq.src;
-	sreq.areq = (void *)&qcedev_areq->sha_req;
-
-	ret = qce_process_sha_req(podev->qce, &sreq);
-
-	if (ret)
-		qcedev_areq->err = -ENXIO;
-	else
-		qcedev_areq->err = 0;
-	return ret;
-};
-
-static int submit_req(struct qcedev_async_req *qcedev_areq,
-					struct qcedev_handle *handle)
-{
-	struct qcedev_control *podev;
-	unsigned long flags = 0;
-	int ret = 0;
-	struct qcedev_stat *pstat;
-
-	qcedev_areq->err = 0;
-	podev = handle->cntl;
-
-	if (podev->platform_support.ce_shared) {
-		ret = qcedev_lock_ce(podev);
-		if (ret)
-			return ret;
-	}
-
-	spin_lock_irqsave(&podev->lock, flags);
-
-	if (podev->active_command == NULL) {
-		podev->active_command = qcedev_areq;
-		if (qcedev_areq->op_type == QCEDEV_CRYPTO_OPER_CIPHER)
-			ret = start_cipher_req(podev);
-		else
-			ret = start_sha_req(podev);
-	} else {
-		list_add_tail(&qcedev_areq->list, &podev->ready_commands);
-	}
-
-	if (ret != 0)
-		podev->active_command = NULL;
-
-	spin_unlock_irqrestore(&podev->lock, flags);
-
-	if (ret == 0)
-		wait_for_completion(&qcedev_areq->complete);
-
-	if (podev->platform_support.ce_shared)
-		ret = qcedev_unlock_ce(podev);
-
-	if (ret)
-		qcedev_areq->err = -EIO;
-
-	pstat = &_qcedev_stat[podev->pdev->id];
-	if (qcedev_areq->op_type == QCEDEV_CRYPTO_OPER_CIPHER) {
-		switch (qcedev_areq->cipher_op_req.op) {
-		case QCEDEV_OPER_DEC:
-			if (qcedev_areq->err)
-				pstat->qcedev_dec_fail++;
-			else
-				pstat->qcedev_dec_success++;
-			break;
-		case QCEDEV_OPER_ENC:
-			if (qcedev_areq->err)
-				pstat->qcedev_enc_fail++;
-			else
-				pstat->qcedev_enc_success++;
-			break;
-		default:
-			break;
-		};
-	} else {
-		if (qcedev_areq->err)
-			pstat->qcedev_sha_fail++;
-		else
-			pstat->qcedev_sha_success++;
-	}
-
-	return qcedev_areq->err;
-}
-
-static int qcedev_sha_init(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle)
-{
-	struct qcedev_sha_ctxt *sha_ctxt = &handle->sha_ctxt;
-
-	memset(sha_ctxt, 0, sizeof(struct qcedev_sha_ctxt));
-	sha_ctxt->first_blk = 1;
-
-	if ((areq->sha_op_req.alg == QCEDEV_ALG_SHA1) ||
-			(areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC)) {
-		memcpy(&sha_ctxt->digest[0],
-			&_std_init_vector_sha1_uint8[0], SHA1_DIGEST_SIZE);
-		sha_ctxt->diglen = SHA1_DIGEST_SIZE;
-	} else {
-		if ((areq->sha_op_req.alg == QCEDEV_ALG_SHA256) ||
-			(areq->sha_op_req.alg == QCEDEV_ALG_SHA256_HMAC)) {
-			memcpy(&sha_ctxt->digest[0],
-					&_std_init_vector_sha256_uint8[0],
-					SHA256_DIGEST_SIZE);
-			sha_ctxt->diglen = SHA256_DIGEST_SIZE;
-		}
-	}
-	return 0;
-}
-
-
-static int qcedev_sha_update_max_xfer(struct qcedev_async_req *qcedev_areq,
-				struct qcedev_handle *handle)
-{
-	int err = 0;
-	int i = 0;
-	struct scatterlist sg_src[2];
-	uint32_t total;
-
-	uint8_t *user_src = NULL;
-	uint8_t *k_src = NULL;
-	uint8_t *k_buf_src = NULL;
-	uint8_t *k_align_src = NULL;
-
-	uint32_t sha_pad_len = 0;
-	uint32_t trailing_buf_len = 0;
-	uint32_t t_buf = handle->sha_ctxt.trailing_buf_len;
-	uint32_t sha_block_size;
-
-	total = qcedev_areq->sha_op_req.data_len + t_buf;
-
-	if (qcedev_areq->sha_op_req.alg == QCEDEV_ALG_SHA1)
-		sha_block_size = SHA1_BLOCK_SIZE;
-	else
-		sha_block_size = SHA256_BLOCK_SIZE;
-
-	if (total <= sha_block_size) {
-		uint32_t len =  qcedev_areq->sha_op_req.data_len;
-
-		i = 0;
-
-		k_src = &handle->sha_ctxt.trailing_buf[t_buf];
-
-		
-		while (len > 0) {
-			user_src =
-			(void __user *)qcedev_areq->sha_op_req.data[i].vaddr;
-			if (user_src && __copy_from_user(k_src,
-				(void __user *)user_src,
-				qcedev_areq->sha_op_req.data[i].len))
-				return -EFAULT;
-
-			len -= qcedev_areq->sha_op_req.data[i].len;
-			k_src += qcedev_areq->sha_op_req.data[i].len;
-			i++;
-		}
-		handle->sha_ctxt.trailing_buf_len = total;
-
-		return 0;
-	}
-
-
-	k_buf_src = kmalloc(total + CACHE_LINE_SIZE * 2,
-				GFP_KERNEL);
-	if (k_buf_src == NULL) {
-		pr_err("%s: Can't Allocate memory: k_buf_src 0x%x\n",
-			__func__, (uint32_t)k_buf_src);
-		return -ENOMEM;
-	}
-
-	k_align_src = (uint8_t *) ALIGN(((unsigned int)k_buf_src),
-							CACHE_LINE_SIZE);
-	k_src = k_align_src;
-
-	
-	if (t_buf > 0) {
-		memcpy(k_src, &handle->sha_ctxt.trailing_buf[0],
-								t_buf);
-		k_src += t_buf;
-	}
-
-	
-	user_src = (void __user *)qcedev_areq->sha_op_req.data[0].vaddr;
-	if (user_src && __copy_from_user(k_src,
-				(void __user *)user_src,
-				qcedev_areq->sha_op_req.data[0].len)) {
-		kfree(k_buf_src);
-		return -EFAULT;
-	}
-	k_src += qcedev_areq->sha_op_req.data[0].len;
-	for (i = 1; i < qcedev_areq->sha_op_req.entries; i++) {
-		user_src = (void __user *)qcedev_areq->sha_op_req.data[i].vaddr;
-		if (user_src && __copy_from_user(k_src,
-					(void __user *)user_src,
-					qcedev_areq->sha_op_req.data[i].len)) {
-			kfree(k_buf_src);
-			return -EFAULT;
-		}
-		k_src += qcedev_areq->sha_op_req.data[i].len;
-	}
-
-	
-	sha_pad_len = ALIGN(total, CE_SHA_BLOCK_SIZE) - total;
-	trailing_buf_len =  CE_SHA_BLOCK_SIZE - sha_pad_len;
-
-	qcedev_areq->sha_req.sreq.src = (struct scatterlist *) &sg_src[0];
-	sg_set_buf(qcedev_areq->sha_req.sreq.src, k_align_src,
-						total-trailing_buf_len);
-	sg_mark_end(qcedev_areq->sha_req.sreq.src);
-
-	qcedev_areq->sha_req.sreq.nbytes = total - trailing_buf_len;
-
-	
-	if (trailing_buf_len > 0) {
-		memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
-		memcpy(&handle->sha_ctxt.trailing_buf[0],
-			(k_src - trailing_buf_len),
-			trailing_buf_len);
-	}
-	handle->sha_ctxt.trailing_buf_len = trailing_buf_len;
-
-	err = submit_req(qcedev_areq, handle);
-
-	handle->sha_ctxt.last_blk = 0;
-	handle->sha_ctxt.first_blk = 0;
-
-	kfree(k_buf_src);
-	return err;
-}
-
-static int qcedev_sha_update(struct qcedev_async_req *qcedev_areq,
-				struct qcedev_handle *handle)
-{
-	int err = 0;
-	int i = 0;
-	int j = 0;
-	int k = 0;
-	int num_entries = 0;
-	uint32_t total = 0;
-
-	
-	for (i = 0; i < qcedev_areq->sha_op_req.entries; i++)
-		if (!access_ok(VERIFY_READ,
-			(void __user *)qcedev_areq->sha_op_req.data[i].vaddr,
-			qcedev_areq->sha_op_req.data[i].len))
-			return -EFAULT;
-
-	if (qcedev_areq->sha_op_req.data_len > QCE_MAX_OPER_DATA) {
-
-		struct	qcedev_sha_op_req *saved_req;
-		struct	qcedev_sha_op_req req;
-		struct	qcedev_sha_op_req *sreq = &qcedev_areq->sha_op_req;
-
-		
-		saved_req =
-			kmalloc(sizeof(struct qcedev_sha_op_req), GFP_KERNEL);
-		if (saved_req == NULL) {
-			pr_err("%s:Can't Allocate mem:saved_req 0x%x\n",
-			__func__, (uint32_t)saved_req);
-			return -ENOMEM;
-		}
-		memcpy(&req, sreq, sizeof(struct qcedev_sha_op_req));
-		memcpy(saved_req, sreq, sizeof(struct qcedev_sha_op_req));
-
-		i = 0;
-		
-		while ((i < req.entries) && (err == 0)) {
-			if (sreq->data[i].len > QCE_MAX_OPER_DATA) {
-				sreq->data[0].len = QCE_MAX_OPER_DATA;
-				if (i > 0) {
-					sreq->data[0].vaddr =
-							sreq->data[i].vaddr;
-				}
-
-				sreq->data_len = QCE_MAX_OPER_DATA;
-				sreq->entries = 1;
-
-				err = qcedev_sha_update_max_xfer(qcedev_areq,
-									handle);
-
-				sreq->data[i].len = req.data[i].len -
-							QCE_MAX_OPER_DATA;
-				sreq->data[i].vaddr = req.data[i].vaddr +
-							QCE_MAX_OPER_DATA;
-				req.data[i].vaddr = sreq->data[i].vaddr;
-				req.data[i].len = sreq->data[i].len;
-			} else {
-				total = 0;
-				for (j = i; j < req.entries; j++) {
-					num_entries++;
-					if ((total + sreq->data[j].len) >=
-							QCE_MAX_OPER_DATA) {
-						sreq->data[j].len =
-						(QCE_MAX_OPER_DATA - total);
-						total = QCE_MAX_OPER_DATA;
-						break;
-					}
-					total += sreq->data[j].len;
-				}
-
-				sreq->data_len = total;
-				if (i > 0)
-					for (k = 0; k < num_entries; k++) {
-						sreq->data[k].len =
-							sreq->data[i+k].len;
-						sreq->data[k].vaddr =
-							sreq->data[i+k].vaddr;
-					}
-				sreq->entries = num_entries;
-
-				i = j;
-				err = qcedev_sha_update_max_xfer(qcedev_areq,
-									handle);
-				num_entries = 0;
-
-				sreq->data[i].vaddr = req.data[i].vaddr +
-							sreq->data[i].len;
-				sreq->data[i].len = req.data[i].len -
-							sreq->data[i].len;
-				req.data[i].vaddr = sreq->data[i].vaddr;
-				req.data[i].len = sreq->data[i].len;
-
-				if (sreq->data[i].len == 0)
-					i++;
-			}
-		} 
-
-		
-		for (i = 0; i < saved_req->entries; i++) {
-			sreq->data[i].len = saved_req->data[i].len;
-			sreq->data[i].vaddr = saved_req->data[i].vaddr;
-		}
-		sreq->entries = saved_req->entries;
-		sreq->data_len = saved_req->data_len;
-		kfree(saved_req);
-	} else
-		err = qcedev_sha_update_max_xfer(qcedev_areq, handle);
-
-	return err;
-}
-
-static int qcedev_sha_final(struct qcedev_async_req *qcedev_areq,
-				struct qcedev_handle *handle)
-{
-	int err = 0;
-	struct scatterlist sg_src;
-	uint32_t total;
-
-	uint8_t *k_buf_src = NULL;
-	uint8_t *k_align_src = NULL;
-
-	handle->sha_ctxt.first_blk = 0;
-	handle->sha_ctxt.last_blk = 1;
-
-	total = handle->sha_ctxt.trailing_buf_len;
-
-	if (total) {
-		k_buf_src = kmalloc(total + CACHE_LINE_SIZE * 2,
-					GFP_KERNEL);
-		if (k_buf_src == NULL) {
-			pr_err("%s: Can't Allocate memory: k_buf_src 0x%x\n",
-			__func__, (uint32_t)k_buf_src);
-			return -ENOMEM;
-		}
-
-		k_align_src = (uint8_t *) ALIGN(((unsigned int)k_buf_src),
-							CACHE_LINE_SIZE);
-		memcpy(k_align_src, &handle->sha_ctxt.trailing_buf[0], total);
-	}
-	handle->sha_ctxt.last_blk = 1;
-	handle->sha_ctxt.first_blk = 0;
-
-	qcedev_areq->sha_req.sreq.src = (struct scatterlist *) &sg_src;
-	sg_set_buf(qcedev_areq->sha_req.sreq.src, k_align_src, total);
-	sg_mark_end(qcedev_areq->sha_req.sreq.src);
-
-	qcedev_areq->sha_req.sreq.nbytes = total;
-
-	err = submit_req(qcedev_areq, handle);
-
-	handle->sha_ctxt.first_blk = 0;
-	handle->sha_ctxt.last_blk = 0;
-	handle->sha_ctxt.auth_data[0] = 0;
-	handle->sha_ctxt.auth_data[1] = 0;
-	handle->sha_ctxt.trailing_buf_len = 0;
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
-
-	kfree(k_buf_src);
-	return err;
-}
-
-static int qcedev_hash_cmac(struct qcedev_async_req *qcedev_areq,
-					struct qcedev_handle *handle)
-{
-	int err = 0;
-	int i = 0;
-	struct scatterlist sg_src[2];
-	uint32_t total;
-
-	uint8_t *user_src = NULL;
-	uint8_t *k_src = NULL;
-	uint8_t *k_buf_src = NULL;
-
-	total = qcedev_areq->sha_op_req.data_len;
-
-	
-	for (i = 0; i < qcedev_areq->sha_op_req.entries; i++)
-		if (!access_ok(VERIFY_READ,
-			(void __user *)qcedev_areq->sha_op_req.data[i].vaddr,
-			qcedev_areq->sha_op_req.data[i].len))
-			return -EFAULT;
-
-	
-	if (!access_ok(VERIFY_READ,
-				(void __user *)qcedev_areq->sha_op_req.authkey,
-				qcedev_areq->sha_op_req.authklen))
-			return -EFAULT;
-	if (__copy_from_user(&handle->sha_ctxt.authkey[0],
-				(void __user *)qcedev_areq->sha_op_req.authkey,
-				qcedev_areq->sha_op_req.authklen))
-		return -EFAULT;
-
-
-	k_buf_src = kmalloc(total, GFP_KERNEL);
-	if (k_buf_src == NULL) {
-		pr_err("%s: Can't Allocate memory: k_buf_src 0x%x\n",
-			__func__, (uint32_t)k_buf_src);
-		return -ENOMEM;
-	}
-
-	k_src = k_buf_src;
-
-	
-	user_src = (void __user *)qcedev_areq->sha_op_req.data[0].vaddr;
-	for (i = 0; i < qcedev_areq->sha_op_req.entries; i++) {
-		user_src =
-			(void __user *)qcedev_areq->sha_op_req.data[i].vaddr;
-		if (user_src && __copy_from_user(k_src, (void __user *)user_src,
-				qcedev_areq->sha_op_req.data[i].len)) {
-			kfree(k_buf_src);
-			return -EFAULT;
-		}
-		k_src += qcedev_areq->sha_op_req.data[i].len;
-	}
-
-	qcedev_areq->sha_req.sreq.src = (struct scatterlist *) &sg_src[0];
-	sg_set_buf(qcedev_areq->sha_req.sreq.src, k_buf_src, total);
-	sg_mark_end(qcedev_areq->sha_req.sreq.src);
-
-	qcedev_areq->sha_req.sreq.nbytes = total;
-	handle->sha_ctxt.diglen = qcedev_areq->sha_op_req.diglen;
-	err = submit_req(qcedev_areq, handle);
-
-	kfree(k_buf_src);
-	return err;
-}
-
-static int qcedev_set_hmac_auth_key(struct qcedev_async_req *areq,
-					struct qcedev_handle *handle)
-{
-	int err = 0;
-
-	if (areq->sha_op_req.authklen <= QCEDEV_MAX_KEY_SIZE) {
-		
-		if (!access_ok(VERIFY_READ,
-				(void __user *)areq->sha_op_req.authkey,
-				areq->sha_op_req.authklen))
-			return -EFAULT;
-		if (__copy_from_user(&handle->sha_ctxt.authkey[0],
-				(void __user *)areq->sha_op_req.authkey,
-				areq->sha_op_req.authklen))
-			return -EFAULT;
-	} else {
-		struct qcedev_async_req authkey_areq;
-
-		init_completion(&authkey_areq.complete);
-
-		authkey_areq.sha_op_req.entries = 1;
-		authkey_areq.sha_op_req.data[0].vaddr =
-						areq->sha_op_req.authkey;
-		authkey_areq.sha_op_req.data[0].len = areq->sha_op_req.authklen;
-		authkey_areq.sha_op_req.data_len = areq->sha_op_req.authklen;
-		authkey_areq.sha_op_req.diglen = 0;
-		memset(&authkey_areq.sha_op_req.digest[0], 0,
-						QCEDEV_MAX_SHA_DIGEST);
-		if (areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC)
-				authkey_areq.sha_op_req.alg = QCEDEV_ALG_SHA1;
-		if (areq->sha_op_req.alg == QCEDEV_ALG_SHA256_HMAC)
-				authkey_areq.sha_op_req.alg = QCEDEV_ALG_SHA256;
-
-		authkey_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;
-
-		qcedev_sha_init(&authkey_areq, handle);
-		err = qcedev_sha_update(&authkey_areq, handle);
-		if (!err)
-			err = qcedev_sha_final(&authkey_areq, handle);
-		else
-			return err;
-		memcpy(&handle->sha_ctxt.authkey[0],
-				&handle->sha_ctxt.digest[0],
-				handle->sha_ctxt.diglen);
-	}
-	return err;
-}
-
-static int qcedev_hmac_get_ohash(struct qcedev_async_req *qcedev_areq,
-				struct qcedev_handle *handle)
-{
-	int err = 0;
-	struct scatterlist sg_src;
-	uint8_t *k_src = NULL;
-	uint32_t sha_block_size = 0;
-	uint32_t sha_digest_size = 0;
-
-	if (qcedev_areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC) {
-		sha_digest_size = SHA1_DIGEST_SIZE;
-		sha_block_size = SHA1_BLOCK_SIZE;
-	} else {
-		if (qcedev_areq->sha_op_req.alg == QCEDEV_ALG_SHA256_HMAC) {
-			sha_digest_size = SHA256_DIGEST_SIZE;
-			sha_block_size = SHA256_BLOCK_SIZE;
-		}
-	}
-	k_src = kmalloc(sha_block_size, GFP_KERNEL);
-	if (k_src == NULL) {
-		pr_err("%s: Can't Allocate memory: k_src 0x%x\n",
-			__func__, (uint32_t)k_src);
-		return -ENOMEM;
-	}
-
-	
-	memcpy(k_src, &handle->sha_ctxt.trailing_buf[0],
-			handle->sha_ctxt.trailing_buf_len);
-
-	qcedev_areq->sha_req.sreq.src = (struct scatterlist *) &sg_src;
-	sg_set_buf(qcedev_areq->sha_req.sreq.src, k_src, sha_block_size);
-	sg_mark_end(qcedev_areq->sha_req.sreq.src);
-
-	qcedev_areq->sha_req.sreq.nbytes = sha_block_size;
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
-	memcpy(&handle->sha_ctxt.trailing_buf[0], &handle->sha_ctxt.digest[0],
-					sha_digest_size);
-	handle->sha_ctxt.trailing_buf_len = sha_digest_size;
-
-	handle->sha_ctxt.first_blk = 1;
-	handle->sha_ctxt.last_blk = 0;
-	handle->sha_ctxt.auth_data[0] = 0;
-	handle->sha_ctxt.auth_data[1] = 0;
-
-	if (qcedev_areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC) {
-		memcpy(&handle->sha_ctxt.digest[0],
-			&_std_init_vector_sha1_uint8[0], SHA1_DIGEST_SIZE);
-		handle->sha_ctxt.diglen = SHA1_DIGEST_SIZE;
-	}
-
-	if (qcedev_areq->sha_op_req.alg == QCEDEV_ALG_SHA256_HMAC) {
-		memcpy(&handle->sha_ctxt.digest[0],
-			&_std_init_vector_sha256_uint8[0], SHA256_DIGEST_SIZE);
-		handle->sha_ctxt.diglen = SHA256_DIGEST_SIZE;
-	}
-	err = submit_req(qcedev_areq, handle);
-
-	handle->sha_ctxt.last_blk = 0;
-	handle->sha_ctxt.first_blk = 0;
-
-	kfree(k_src);
-	return err;
-}
-
-static int qcedev_hmac_update_iokey(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle, bool ikey)
-{
-	int i;
-	uint32_t constant;
-	uint32_t sha_block_size;
-
-	if (ikey)
-		constant = 0x36;
-	else
-		constant = 0x5c;
-
-	if (areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC)
-		sha_block_size = SHA1_BLOCK_SIZE;
-	else
-		sha_block_size = SHA256_BLOCK_SIZE;
-
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
-	for (i = 0; i < sha_block_size; i++)
-		handle->sha_ctxt.trailing_buf[i] =
-				(handle->sha_ctxt.authkey[i] ^ constant);
-
-	handle->sha_ctxt.trailing_buf_len = sha_block_size;
-	return 0;
-}
-
-static int qcedev_hmac_init(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle)
-{
-	int err;
-	struct qcedev_control *podev = handle->cntl;
-
-	qcedev_sha_init(areq, handle);
-	err = qcedev_set_hmac_auth_key(areq, handle);
-	if (err)
-		return err;
-	if (!podev->ce_support.sha_hmac)
-		qcedev_hmac_update_iokey(areq, handle, true);
-	return 0;
-}
-
-static int qcedev_hmac_final(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle)
-{
-	int err;
-	struct qcedev_control *podev = handle->cntl;
-
-	err = qcedev_sha_final(areq, handle);
-	if (podev->ce_support.sha_hmac)
-		return err;
-
-	qcedev_hmac_update_iokey(areq, handle, false);
-	err = qcedev_hmac_get_ohash(areq, handle);
-	if (err)
-		return err;
-	err = qcedev_sha_final(areq, handle);
-
-	return err;
-}
-
-static int qcedev_hash_init(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle)
-{
-	if ((areq->sha_op_req.alg == QCEDEV_ALG_SHA1) ||
-			(areq->sha_op_req.alg == QCEDEV_ALG_SHA256))
-		return qcedev_sha_init(areq, handle);
-	else
-		return qcedev_hmac_init(areq, handle);
-}
-
-static int qcedev_hash_update(struct qcedev_async_req *qcedev_areq,
-				struct qcedev_handle *handle)
-{
-	return qcedev_sha_update(qcedev_areq, handle);
-}
-
-static int qcedev_hash_final(struct qcedev_async_req *areq,
-				struct qcedev_handle *handle)
-{
-	if ((areq->sha_op_req.alg == QCEDEV_ALG_SHA1) ||
-			(areq->sha_op_req.alg == QCEDEV_ALG_SHA256))
-		return qcedev_sha_final(areq, handle);
-	else
-		return qcedev_hmac_final(areq, handle);
-}
-
-#ifdef CONFIG_ANDROID_PMEM
-static int qcedev_pmem_ablk_cipher_max_xfer(struct qcedev_async_req *areq,
-						struct qcedev_handle *handle)
-{
-	int i = 0;
-	int err = 0;
-	struct scatterlist *sg_src = NULL;
-	struct scatterlist *sg_dst = NULL;
-	struct scatterlist *sg_ndex = NULL;
-	struct file *file_src = NULL;
-	struct file *file_dst = NULL;
-	unsigned long paddr;
-	unsigned long kvaddr;
-	unsigned long len;
-
-	sg_src = kmalloc((sizeof(struct scatterlist) *
-				areq->cipher_op_req.entries),	GFP_KERNEL);
-	if (sg_src == NULL) {
-		pr_err("%s: Can't Allocate memory:sg_src 0x%x\n",
-			__func__, (uint32_t)sg_src);
-		return -ENOMEM;
-
-	}
-	memset(sg_src, 0, (sizeof(struct scatterlist) *
-				areq->cipher_op_req.entries));
-	sg_ndex = sg_src;
-	areq->cipher_req.creq.src = sg_src;
-
-	
-	get_pmem_file(areq->cipher_op_req.pmem.fd_src, &paddr,
-					&kvaddr, &len, &file_src);
-
-	for (i = 0; i < areq->cipher_op_req.entries; i++) {
-		sg_set_buf(sg_ndex,
-		((uint8_t *)(areq->cipher_op_req.pmem.src[i].offset) + kvaddr),
-		areq->cipher_op_req.pmem.src[i].len);
-		sg_ndex++;
-	}
-	sg_mark_end(--sg_ndex);
-
-	for (i = 0; i < areq->cipher_op_req.entries; i++)
-		areq->cipher_op_req.pmem.src[i].offset += (uint32_t)paddr;
-
-	
-	
-	if (areq->cipher_op_req.in_place_op != 1) {
-		sg_dst = kmalloc((sizeof(struct scatterlist) *
-				areq->cipher_op_req.entries), GFP_KERNEL);
-		if (sg_dst == NULL) {
-			pr_err("%s: Can't Allocate memory: sg_dst 0x%x\n",
-			__func__, (uint32_t)sg_dst);
-			return -ENOMEM;
-		}
-		memset(sg_dst, 0, (sizeof(struct scatterlist) *
-					areq->cipher_op_req.entries));
-		areq->cipher_req.creq.dst = sg_dst;
-		sg_ndex = sg_dst;
-
-		get_pmem_file(areq->cipher_op_req.pmem.fd_dst, &paddr,
-					&kvaddr, &len, &file_dst);
-		for (i = 0; i < areq->cipher_op_req.entries; i++)
-			sg_set_buf(sg_ndex++,
-			((uint8_t *)(areq->cipher_op_req.pmem.dst[i].offset)
-			+ kvaddr), areq->cipher_op_req.pmem.dst[i].len);
-		sg_mark_end(--sg_ndex);
-
-		for (i = 0; i < areq->cipher_op_req.entries; i++)
-			areq->cipher_op_req.pmem.dst[i].offset +=
-							(uint32_t)paddr;
-	} else {
-		areq->cipher_req.creq.dst = sg_src;
-		for (i = 0; i < areq->cipher_op_req.entries; i++) {
-			areq->cipher_op_req.pmem.dst[i].offset =
-				areq->cipher_op_req.pmem.src[i].offset;
-			areq->cipher_op_req.pmem.dst[i].len =
-				areq->cipher_op_req.pmem.src[i].len;
-		}
-	}
-
-	areq->cipher_req.creq.nbytes = areq->cipher_op_req.data_len;
-	areq->cipher_req.creq.info = areq->cipher_op_req.iv;
-
-	err = submit_req(areq, handle);
-
-	kfree(sg_src);
-	kfree(sg_dst);
-
-	if (file_dst)
-		put_pmem_file(file_dst);
-	if (file_src)
-		put_pmem_file(file_src);
-
-	return err;
-};
-
-
-static int qcedev_pmem_ablk_cipher(struct qcedev_async_req *qcedev_areq,
-						struct qcedev_handle *handle)
-{
-	int err = 0;
-	int i = 0;
-	int j = 0;
-	int k = 0;
-	int num_entries = 0;
-	uint32_t total = 0;
-	struct qcedev_cipher_op_req *saved_req;
-	struct qcedev_cipher_op_req *creq = &qcedev_areq->cipher_op_req;
-
-	saved_req = kmalloc(sizeof(struct qcedev_cipher_op_req), GFP_KERNEL);
-	if (saved_req == NULL) {
-		pr_err(KERN_ERR "%s:Can't Allocate mem:saved_req 0x%x\n",
-		__func__, (uint32_t)saved_req);
-		return -ENOMEM;
-	}
-	memcpy(saved_req, creq, sizeof(struct qcedev_cipher_op_req));
-
-	if (qcedev_areq->cipher_op_req.data_len > QCE_MAX_OPER_DATA) {
-
-		struct qcedev_cipher_op_req req;
-
-		
-		memcpy(&req, creq, sizeof(struct qcedev_cipher_op_req));
-
-		i = 0;
-		
-		while ((i < req.entries) && (err == 0)) {
-			if (creq->pmem.src[i].len > QCE_MAX_OPER_DATA) {
-				creq->pmem.src[0].len =	QCE_MAX_OPER_DATA;
-				if (i > 0) {
-					creq->pmem.src[0].offset =
-						creq->pmem.src[i].offset;
-				}
-
-				creq->data_len = QCE_MAX_OPER_DATA;
-				creq->entries = 1;
-
-				err =
-				qcedev_pmem_ablk_cipher_max_xfer(qcedev_areq,
-								handle);
-
-				creq->pmem.src[i].len =	req.pmem.src[i].len -
-							QCE_MAX_OPER_DATA;
-				creq->pmem.src[i].offset =
-						req.pmem.src[i].offset +
-						QCE_MAX_OPER_DATA;
-				req.pmem.src[i].offset =
-						creq->pmem.src[i].offset;
-				req.pmem.src[i].len = creq->pmem.src[i].len;
-			} else {
-				total = 0;
-				for (j = i; j < req.entries; j++) {
-					num_entries++;
-					if ((total + creq->pmem.src[j].len)
-							>= QCE_MAX_OPER_DATA) {
-						creq->pmem.src[j].len =
-						QCE_MAX_OPER_DATA - total;
-						total = QCE_MAX_OPER_DATA;
-						break;
-					}
-					total += creq->pmem.src[j].len;
-				}
-
-				creq->data_len = total;
-				if (i > 0)
-					for (k = 0; k < num_entries; k++) {
-						creq->pmem.src[k].len =
-						creq->pmem.src[i+k].len;
-						creq->pmem.src[k].offset =
-						creq->pmem.src[i+k].offset;
-					}
-				creq->entries =  num_entries;
-
-				i = j;
-				err =
-				qcedev_pmem_ablk_cipher_max_xfer(qcedev_areq,
-								handle);
-				num_entries = 0;
-
-					creq->pmem.src[i].offset =
-						req.pmem.src[i].offset +
-						creq->pmem.src[i].len;
-					creq->pmem.src[i].len =
-						req.pmem.src[i].len -
-						creq->pmem.src[i].len;
-					req.pmem.src[i].offset =
-						creq->pmem.src[i].offset;
-					req.pmem.src[i].len =
-						creq->pmem.src[i].len;
-
-				if (creq->pmem.src[i].len == 0)
-					i++;
-			}
-
-		} 
-
-	} else
-		err = qcedev_pmem_ablk_cipher_max_xfer(qcedev_areq, handle);
-
-	
-	for (i = 0; i < saved_req->entries; i++) {
-		creq->pmem.src[i].len = saved_req->pmem.src[i].len;
-		creq->pmem.src[i].offset = saved_req->pmem.src[i].offset;
-	}
-	creq->entries = saved_req->entries;
-	creq->data_len = saved_req->data_len;
-	kfree(saved_req);
-
-	return err;
-
-}
-#else
-static int qcedev_pmem_ablk_cipher(struct qcedev_async_req *qcedev_areq,
-						struct qcedev_handle *handle)
-{
-	return -EPERM;
-}
-#endif
-
-static int qcedev_vbuf_ablk_cipher_max_xfer(struct qcedev_async_req *areq,
-				int *di, struct qcedev_handle *handle,
-				uint8_t *k_align_src)
-{
-	int err = 0;
-	int i = 0;
-	int dst_i = *di;
-	struct scatterlist sg_src;
-	uint32_t byteoffset = 0;
-	uint8_t *user_src = NULL;
-	uint8_t *k_align_dst = k_align_src;
-	struct	qcedev_cipher_op_req *creq = &areq->cipher_op_req;
-
-
-	if (areq->cipher_op_req.mode == QCEDEV_AES_MODE_CTR)
-		byteoffset = areq->cipher_op_req.byteoffset;
-
-	user_src = (void __user *)areq->cipher_op_req.vbuf.src[0].vaddr;
-	if (user_src && __copy_from_user((k_align_src + byteoffset),
-				(void __user *)user_src,
-				areq->cipher_op_req.vbuf.src[0].len))
-		return -EFAULT;
-
-	k_align_src += areq->cipher_op_req.vbuf.src[0].len;
-
-	for (i = 1; i < areq->cipher_op_req.entries; i++) {
-		user_src =
-			(void __user *)areq->cipher_op_req.vbuf.src[i].vaddr;
-		if (user_src && __copy_from_user(k_align_src,
-					(void __user *)user_src,
-					areq->cipher_op_req.vbuf.src[i].len)) {
-			return -EFAULT;
-		}
-		k_align_src += areq->cipher_op_req.vbuf.src[i].len;
-	}
-
-	
-	k_align_src = k_align_dst;
-	areq->cipher_op_req.data_len += byteoffset;
-
-	areq->cipher_req.creq.src = (struct scatterlist *) &sg_src;
-	areq->cipher_req.creq.dst = (struct scatterlist *) &sg_src;
-
-	
-	sg_set_buf(areq->cipher_req.creq.src,
-					k_align_dst,
-					areq->cipher_op_req.data_len);
-	sg_mark_end(areq->cipher_req.creq.src);
-
-	areq->cipher_req.creq.nbytes = areq->cipher_op_req.data_len;
-	areq->cipher_req.creq.info = areq->cipher_op_req.iv;
-	areq->cipher_op_req.entries = 1;
-
-	err = submit_req(areq, handle);
-
-	
-	creq->data_len -= byteoffset;
-
-	while (creq->data_len > 0) {
-		if (creq->vbuf.dst[dst_i].len <= creq->data_len) {
-			if (err == 0 && __copy_to_user(
-				(void __user *)creq->vbuf.dst[dst_i].vaddr,
-					(k_align_dst + byteoffset),
-					creq->vbuf.dst[dst_i].len))
-					return -EFAULT;
-
-			k_align_dst += creq->vbuf.dst[dst_i].len +
-						byteoffset;
-			creq->data_len -= creq->vbuf.dst[dst_i].len;
-			dst_i++;
-		} else {
-				if (err == 0 && __copy_to_user(
-				(void __user *)creq->vbuf.dst[dst_i].vaddr,
-				(k_align_dst + byteoffset),
-				creq->data_len))
-					return -EFAULT;
-
-			k_align_dst += creq->data_len;
-			creq->vbuf.dst[dst_i].len -= creq->data_len;
-			creq->vbuf.dst[dst_i].vaddr += creq->data_len;
-			creq->data_len = 0;
-		}
-	}
-	*di = dst_i;
-
-	return err;
-};
-
-static int qcedev_vbuf_ablk_cipher(struct qcedev_async_req *areq,
-						struct qcedev_handle *handle)
-{
-	int err = 0;
-	int di = 0;
-	int i = 0;
-	int j = 0;
-	int k = 0;
-	uint32_t byteoffset = 0;
-	int num_entries = 0;
-	uint32_t total = 0;
-	uint32_t len;
-	uint8_t *k_buf_src = NULL;
-	uint8_t *k_align_src = NULL;
-	uint32_t max_data_xfer;
-	struct qcedev_cipher_op_req *saved_req;
-	struct	qcedev_cipher_op_req *creq = &areq->cipher_op_req;
-
-	
-	for (i = 0; i < areq->cipher_op_req.entries; i++)
-		if (!access_ok(VERIFY_READ,
-			(void __user *)areq->cipher_op_req.vbuf.src[i].vaddr,
-					areq->cipher_op_req.vbuf.src[i].len))
-			return -EFAULT;
-
-	
-	if (areq->cipher_op_req.in_place_op != 1)
-		for (i = 0; i < areq->cipher_op_req.entries; i++)
-			if (!access_ok(VERIFY_READ,
-			(void __user *)areq->cipher_op_req.vbuf.dst[i].vaddr,
-					areq->cipher_op_req.vbuf.dst[i].len))
-				return -EFAULT;
-
-	if (areq->cipher_op_req.mode == QCEDEV_AES_MODE_CTR)
-		byteoffset = areq->cipher_op_req.byteoffset;
-	k_buf_src = kmalloc(QCE_MAX_OPER_DATA + CACHE_LINE_SIZE * 2,
-				GFP_KERNEL);
-	if (k_buf_src == NULL) {
-		pr_err("%s: Can't Allocate memory: k_buf_src 0x%x\n",
-			__func__, (uint32_t)k_buf_src);
-		return -ENOMEM;
-	}
-	k_align_src = (uint8_t *) ALIGN(((unsigned int)k_buf_src),
-							CACHE_LINE_SIZE);
-	max_data_xfer = QCE_MAX_OPER_DATA - byteoffset;
-
-	saved_req = kmalloc(sizeof(struct qcedev_cipher_op_req), GFP_KERNEL);
-	if (saved_req == NULL) {
-		pr_err("%s: Can't Allocate memory:saved_req 0x%x\n",
-			__func__, (uint32_t)saved_req);
-		kfree(k_buf_src);
-		return -ENOMEM;
-
-	}
-	memcpy(saved_req, creq, sizeof(struct qcedev_cipher_op_req));
-
-	if (areq->cipher_op_req.data_len > max_data_xfer) {
-		struct qcedev_cipher_op_req req;
-
-		
-		memcpy(&req, creq, sizeof(struct qcedev_cipher_op_req));
-
-		i = 0;
-		
-		while ((i < req.entries) && (err == 0)) {
-			if (creq->vbuf.src[i].len > max_data_xfer) {
-				creq->vbuf.src[0].len =	max_data_xfer;
-				if (i > 0) {
-					creq->vbuf.src[0].vaddr =
-						creq->vbuf.src[i].vaddr;
-				}
-
-				creq->data_len = max_data_xfer;
-				creq->entries = 1;
-
-				err = qcedev_vbuf_ablk_cipher_max_xfer(areq,
-						&di, handle, k_align_src);
-				if (err < 0) {
-					kfree(k_buf_src);
-					kfree(saved_req);
-					return err;
-				}
-
-				creq->vbuf.src[i].len =	req.vbuf.src[i].len -
-							max_data_xfer;
-				creq->vbuf.src[i].vaddr =
-						req.vbuf.src[i].vaddr +
-						max_data_xfer;
-				req.vbuf.src[i].vaddr =
-						creq->vbuf.src[i].vaddr;
-				req.vbuf.src[i].len = creq->vbuf.src[i].len;
-
-			} else {
-				total = areq->cipher_op_req.byteoffset;
-				for (j = i; j < req.entries; j++) {
-					num_entries++;
-					if ((total + creq->vbuf.src[j].len)
-							>= max_data_xfer) {
-						creq->vbuf.src[j].len =
-						max_data_xfer - total;
-						total = max_data_xfer;
-						break;
-					}
-					total += creq->vbuf.src[j].len;
-				}
-
-				creq->data_len = total;
-				if (i > 0)
-					for (k = 0; k < num_entries; k++) {
-						creq->vbuf.src[k].len =
-						creq->vbuf.src[i+k].len;
-						creq->vbuf.src[k].vaddr =
-						creq->vbuf.src[i+k].vaddr;
-					}
-				creq->entries =  num_entries;
-
-				i = j;
-				err = qcedev_vbuf_ablk_cipher_max_xfer(areq,
-						&di, handle, k_align_src);
-				if (err < 0) {
-					kfree(k_buf_src);
-					kfree(saved_req);
-					return err;
-				}
-
-				num_entries = 0;
-				areq->cipher_op_req.byteoffset = 0;
-
-				creq->vbuf.src[i].vaddr = req.vbuf.src[i].vaddr
-					+ creq->vbuf.src[i].len;
-				creq->vbuf.src[i].len =	req.vbuf.src[i].len -
-							creq->vbuf.src[i].len;
-
-				req.vbuf.src[i].vaddr =
-						creq->vbuf.src[i].vaddr;
-				req.vbuf.src[i].len = creq->vbuf.src[i].len;
-
-				if (creq->vbuf.src[i].len == 0)
-					i++;
-			}
-
-			areq->cipher_op_req.byteoffset = 0;
-			max_data_xfer = QCE_MAX_OPER_DATA;
-			byteoffset = 0;
-
-		} 
-	} else
-		err = qcedev_vbuf_ablk_cipher_max_xfer(areq, &di, handle,
-								k_align_src);
-
-	
-	for (i = 0; i < saved_req->entries; i++) {
-		creq->vbuf.src[i].len = saved_req->vbuf.src[i].len;
-		creq->vbuf.src[i].vaddr = saved_req->vbuf.src[i].vaddr;
-	}
-	for (len = 0, i = 0; len < saved_req->data_len; i++) {
-		creq->vbuf.dst[i].len = saved_req->vbuf.dst[i].len;
-		creq->vbuf.dst[i].vaddr = saved_req->vbuf.dst[i].vaddr;
-		len += saved_req->vbuf.dst[i].len;
-	}
-	creq->entries = saved_req->entries;
-	creq->data_len = saved_req->data_len;
-	creq->byteoffset = saved_req->byteoffset;
-
-	kfree(saved_req);
-	kfree(k_buf_src);
-	return err;
-
-}
-
-static int qcedev_check_cipher_params(struct qcedev_cipher_op_req *req,
-						struct qcedev_control *podev)
-{
-	if ((req->entries == 0) || (req->data_len == 0))
-		goto error;
-	if ((req->alg >= QCEDEV_ALG_LAST) ||
-		(req->mode >= QCEDEV_AES_DES_MODE_LAST))
-		goto error;
-	if (req->alg == QCEDEV_ALG_AES) {
-		if ((req->mode == QCEDEV_AES_MODE_XTS) &&
-					(!podev->ce_support.aes_xts))
-			goto error;
-		if (req->encklen == 0) {
-			int i;
-			for (i = 0; i < QCEDEV_MAX_KEY_SIZE; i++)
-				if (req->enckey[i])
-					goto error;
-			if ((req->op != QCEDEV_OPER_ENC_NO_KEY) &&
-				(req->op != QCEDEV_OPER_DEC_NO_KEY))
-				if (!podev->platform_support.hw_key_support)
-					goto error;
-		} else {
-			if (req->encklen == QCEDEV_AES_KEY_192) {
-				if (!podev->ce_support.aes_key_192)
-					goto error;
-			} else {
-				if (!((req->encklen == QCEDEV_AES_KEY_128) ||
-					(req->encklen == QCEDEV_AES_KEY_256)))
-					goto error;
-			}
-		}
-	}
-	
-	if (req->byteoffset) {
-		if (req->mode != QCEDEV_AES_MODE_CTR)
-			goto error;
-		else { 
-			if (req->use_pmem)
-				goto error;
-		}
-	}
-	
-	if (req->use_pmem) {
-		if (!req->in_place_op)
-			goto error;
-	}
-	
-	if (req->ivlen != 0) {
-		if ((req->mode == QCEDEV_AES_MODE_ECB) ||
-				(req->mode == QCEDEV_DES_MODE_ECB))
-			goto error;
-	} else {
-		if ((req->mode != QCEDEV_AES_MODE_ECB) &&
-				(req->mode != QCEDEV_DES_MODE_ECB))
-			goto error;
-	}
-
-	return 0;
-error:
-	return -EINVAL;
-
-}
-
-static int qcedev_check_sha_params(struct qcedev_sha_op_req *req,
-						struct qcedev_control *podev)
-{
-	if ((req->alg == QCEDEV_ALG_AES_CMAC) &&
-				(!podev->ce_support.cmac))
-		goto sha_error;
-
-	if ((req->entries == 0) || (req->data_len == 0))
-		goto sha_error;
-
-	if (req->alg >= QCEDEV_ALG_SHA_ALG_LAST)
-		goto sha_error;
-
-	return 0;
-sha_error:
-	return -EINVAL;
-}
-
-static long qcedev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
-{
-	int err = 0;
-	struct qcedev_handle *handle;
-	struct qcedev_control *podev;
-	struct qcedev_async_req qcedev_areq;
-	struct qcedev_stat *pstat;
-
-	handle =  file->private_data;
-	podev =  handle->cntl;
-	qcedev_areq.handle = handle;
-	if (podev == NULL || podev->magic != QCEDEV_MAGIC) {
-		pr_err("%s: invalid handle %p\n",
-			__func__, podev);
-		return -ENOENT;
-	}
-
-	
-	if (_IOC_TYPE(cmd) != QCEDEV_IOC_MAGIC)
-		return -ENOTTY;
-
-	init_completion(&qcedev_areq.complete);
-	pstat = &_qcedev_stat[podev->pdev->id];
-
-	switch (cmd) {
-	case QCEDEV_IOCTL_LOCK_CE:
-		if (podev->platform_support.ce_shared)
-			err = qcedev_lock_ce(podev);
-		else
-			err = -ENOTTY;
-		break;
-	case QCEDEV_IOCTL_UNLOCK_CE:
-		if (podev->platform_support.ce_shared)
-			err = qcedev_unlock_ce(podev);
-		else
-			err = -ENOTTY;
-		break;
-	case QCEDEV_IOCTL_ENC_REQ:
-	case QCEDEV_IOCTL_DEC_REQ:
-		if (!access_ok(VERIFY_WRITE, (void __user *)arg,
-				sizeof(struct qcedev_cipher_op_req)))
-			return -EFAULT;
-
-		if (__copy_from_user(&qcedev_areq.cipher_op_req,
-				(void __user *)arg,
-				sizeof(struct qcedev_cipher_op_req)))
-			return -EFAULT;
-		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_CIPHER;
-
-		if (qcedev_check_cipher_params(&qcedev_areq.cipher_op_req,
-				podev))
-			return -EINVAL;
-
-		if (qcedev_areq.cipher_op_req.use_pmem)
-			err = qcedev_pmem_ablk_cipher(&qcedev_areq, handle);
-		else
-			err = qcedev_vbuf_ablk_cipher(&qcedev_areq, handle);
-		if (err)
-			return err;
-		if (__copy_to_user((void __user *)arg,
-					&qcedev_areq.cipher_op_req,
-					sizeof(struct qcedev_cipher_op_req)))
-				return -EFAULT;
-		break;
-
-	case QCEDEV_IOCTL_SHA_INIT_REQ:
-
-		if (!access_ok(VERIFY_WRITE, (void __user *)arg,
-				sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-
-		if (__copy_from_user(&qcedev_areq.sha_op_req,
-					(void __user *)arg,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		if (qcedev_check_sha_params(&qcedev_areq.sha_op_req, podev))
-			return -EINVAL;
-		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;
-		err = qcedev_hash_init(&qcedev_areq, handle);
-		if (err)
-			return err;
-		if (__copy_to_user((void __user *)arg, &qcedev_areq.sha_op_req,
-					sizeof(struct qcedev_sha_op_req)))
-				return -EFAULT;
-		break;
-	case QCEDEV_IOCTL_GET_CMAC_REQ:
-		if (!podev->ce_support.cmac)
-			return -ENOTTY;
-	case QCEDEV_IOCTL_SHA_UPDATE_REQ:
-		if (!access_ok(VERIFY_WRITE, (void __user *)arg,
-				sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-
-		if (__copy_from_user(&qcedev_areq.sha_op_req,
-					(void __user *)arg,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		if (qcedev_check_sha_params(&qcedev_areq.sha_op_req, podev))
-			return -EINVAL;
-		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;
-
-		if (qcedev_areq.sha_op_req.alg == QCEDEV_ALG_AES_CMAC) {
-			err = qcedev_hash_cmac(&qcedev_areq, handle);
-			if (err)
-				return err;
-		} else {
-			err = qcedev_hash_update(&qcedev_areq, handle);
-			if (err)
-				return err;
-		}
-
-		memcpy(&qcedev_areq.sha_op_req.digest[0],
-				&handle->sha_ctxt.digest[0],
-				handle->sha_ctxt.diglen);
-		if (__copy_to_user((void __user *)arg, &qcedev_areq.sha_op_req,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		break;
-
-	case QCEDEV_IOCTL_SHA_FINAL_REQ:
-
-		if (!access_ok(VERIFY_WRITE, (void __user *)arg,
-				sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-
-		if (__copy_from_user(&qcedev_areq.sha_op_req,
-					(void __user *)arg,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		if (qcedev_check_sha_params(&qcedev_areq.sha_op_req, podev))
-			return -EINVAL;
-		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;
-		err = qcedev_hash_final(&qcedev_areq, handle);
-		if (err)
-			return err;
-		qcedev_areq.sha_op_req.diglen = handle->sha_ctxt.diglen;
-		memcpy(&qcedev_areq.sha_op_req.digest[0],
-				&handle->sha_ctxt.digest[0],
-				handle->sha_ctxt.diglen);
-		if (__copy_to_user((void __user *)arg, &qcedev_areq.sha_op_req,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		break;
-
-	case QCEDEV_IOCTL_GET_SHA_REQ:
-
-		if (!access_ok(VERIFY_WRITE, (void __user *)arg,
-				sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-
-		if (__copy_from_user(&qcedev_areq.sha_op_req,
-					(void __user *)arg,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		if (qcedev_check_sha_params(&qcedev_areq.sha_op_req, podev))
-			return -EINVAL;
-		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;
-		qcedev_hash_init(&qcedev_areq, handle);
-		err = qcedev_hash_update(&qcedev_areq, handle);
-		if (err)
-			return err;
-		err = qcedev_hash_final(&qcedev_areq, handle);
-		if (err)
-			return err;
-		qcedev_areq.sha_op_req.diglen =	handle->sha_ctxt.diglen;
-		memcpy(&qcedev_areq.sha_op_req.digest[0],
-				&handle->sha_ctxt.digest[0],
-				handle->sha_ctxt.diglen);
-		if (__copy_to_user((void __user *)arg, &qcedev_areq.sha_op_req,
-					sizeof(struct qcedev_sha_op_req)))
-			return -EFAULT;
-		break;
-
-	default:
-		return -ENOTTY;
-	}
-
-	return err;
-}
-
-static int qcedev_probe(struct platform_device *pdev)
-{
-	void *handle = NULL;
-	int rc = 0;
-	struct qcedev_control *podev;
-	struct msm_ce_hw_support *platform_support;
-
-	if (pdev->id >= MAX_QCE_DEVICE) {
-		pr_err("%s: device id %d  exceeds allowed %d\n",
-			__func__, pdev->id, MAX_QCE_DEVICE);
-		return -ENOENT;
-	}
-	podev = &qce_dev[pdev->id];
-
-	platform_support = (struct msm_ce_hw_support *)pdev->dev.platform_data;
-	podev->platform_support.ce_shared = platform_support->ce_shared;
-	podev->platform_support.shared_ce_resource =
-				platform_support->shared_ce_resource;
-	podev->platform_support.hw_key_support =
-				platform_support->hw_key_support;
-	podev->platform_support.bus_scale_table =
-				platform_support->bus_scale_table;
-	podev->ce_lock_count = 0;
-	podev->high_bw_req_count = 0;
-	INIT_LIST_HEAD(&podev->ready_commands);
-	podev->active_command = NULL;
-
-	spin_lock_init(&podev->lock);
-
-	tasklet_init(&podev->done_tasklet, req_done, (unsigned long)podev);
-
-	
-	handle = qce_open(pdev, &rc);
-	if (handle == NULL) {
-		platform_set_drvdata(pdev, NULL);
-		return rc;
-	}
-
-	podev->qce = handle;
-	podev->pdev = pdev;
-	platform_set_drvdata(pdev, podev);
-	qce_hw_support(podev->qce, &podev->ce_support);
-
-	if (podev->platform_support.bus_scale_table != NULL) {
-		podev->bus_scale_handle =
-			msm_bus_scale_register_client(
-				(struct msm_bus_scale_pdata *)
-				podev->platform_support.bus_scale_table);
-		if (!podev->bus_scale_handle) {
-			printk(KERN_ERR "%s not able to get bus scale\n",
-								__func__);
-			rc =  -ENOMEM;
-			goto err;
-		}
-	}
-	rc = misc_register(&podev->miscdevice);
-
-	if (rc >= 0)
-		return 0;
-	else
-		if (podev->platform_support.bus_scale_table != NULL)
-			msm_bus_scale_unregister_client(
-						podev->bus_scale_handle);
-err:
-
-	if (handle)
-		qce_close(handle);
-	platform_set_drvdata(pdev, NULL);
-	podev->qce = NULL;
-	podev->pdev = NULL;
-	return rc;
-};
-
-static int qcedev_remove(struct platform_device *pdev)
-{
-	struct qcedev_control *podev;
-
-	podev = platform_get_drvdata(pdev);
-	if (!podev)
-		return 0;
-	if (podev->qce)
-		qce_close(podev->qce);
-
-	if (podev->platform_support.bus_scale_table != NULL)
-		msm_bus_scale_unregister_client(podev->bus_scale_handle);
-
-	if (podev->miscdevice.minor != MISC_DYNAMIC_MINOR)
-		misc_deregister(&podev->miscdevice);
-	tasklet_kill(&podev->done_tasklet);
-	return 0;
-};
-
-static struct platform_driver qcedev_plat_driver = {
-	.probe = qcedev_probe,
-	.remove = qcedev_remove,
-	.driver = {
-		.name = "qce",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int _disp_stats(int id)
-{
-	struct qcedev_stat *pstat;
-	int len = 0;
-
-	pstat = &_qcedev_stat[id];
-	len = snprintf(_debug_read_buf, DEBUG_MAX_RW_BUF - 1,
-			"\nQualcomm QCE dev driver %d Statistics:\n",
-				id + 1);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   Encryption operation success       : %d\n",
-					pstat->qcedev_enc_success);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   Encryption operation fail   : %d\n",
-					pstat->qcedev_enc_fail);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   Decryption operation success     : %d\n",
-					pstat->qcedev_dec_success);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   Encryption operation fail          : %d\n",
-					pstat->qcedev_dec_fail);
-
-	return len;
-}
-
-static int _debug_stats_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t _debug_stats_read(struct file *file, char __user *buf,
-			size_t count, loff_t *ppos)
-{
-	int rc = -EINVAL;
-	int qcedev = *((int *) file->private_data);
-	int len;
-
-	len = _disp_stats(qcedev);
-
-	rc = simple_read_from_buffer((void __user *) buf, len,
-			ppos, (void *) _debug_read_buf, len);
-
-	return rc;
-}
-
-static ssize_t _debug_stats_write(struct file *file, const char __user *buf,
-			size_t count, loff_t *ppos)
-{
-
-	int qcedev = *((int *) file->private_data);
-
-	memset((char *)&_qcedev_stat[qcedev], 0, sizeof(struct qcedev_stat));
-	return count;
-};
-
-static const struct file_operations _debug_stats_ops = {
-	.open =         _debug_stats_open,
-	.read =         _debug_stats_read,
-	.write =        _debug_stats_write,
-};
-
-static int _qcedev_debug_init(void)
-{
-	int rc;
-	char name[DEBUG_MAX_FNAME];
-	int i;
-	struct dentry *dent;
-
-	_debug_dent = debugfs_create_dir("qcedev", NULL);
-	if (IS_ERR(_debug_dent)) {
-		pr_err("qcedev debugfs_create_dir fail, error %ld\n",
-				PTR_ERR(_debug_dent));
-		return PTR_ERR(_debug_dent);
-	}
-
-	for (i = 0; i < MAX_QCE_DEVICE; i++) {
-		snprintf(name, DEBUG_MAX_FNAME-1, "stats-%d", i+1);
-		_debug_qcedev[i] = i;
-		dent = debugfs_create_file(name, 0644, _debug_dent,
-				&_debug_qcedev[i], &_debug_stats_ops);
-		if (dent == NULL) {
-			pr_err("qcedev debugfs_create_file fail, error %ld\n",
-					PTR_ERR(dent));
-			rc = PTR_ERR(dent);
-			goto err;
-		}
-	}
-	return 0;
-err:
-	debugfs_remove_recursive(_debug_dent);
-	return rc;
-}
-
-static int qcedev_init(void)
-{
-	int rc;
-
-	rc = _qcedev_debug_init();
-	if (rc)
-		return rc;
-	return platform_driver_register(&qcedev_plat_driver);
-}
-
-static void qcedev_exit(void)
-{
-	debugfs_remove_recursive(_debug_dent);
-	platform_driver_unregister(&qcedev_plat_driver);
-}
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Mona Hossain <mhossain@codeaurora.org>");
-MODULE_DESCRIPTION("Qualcomm DEV Crypto driver");
-MODULE_VERSION("1.26");
-
-module_init(qcedev_init);
-module_exit(qcedev_exit);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce.h monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qce.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qce.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,148 +0,0 @@
-/* Qualcomm Crypto Engine driver API
- *
- * Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-
-#ifndef __CRYPTO_MSM_QCE_H
-#define __CRYPTO_MSM_QCE_H
-
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/crypto.h>
-
-#include <crypto/algapi.h>
-#include <crypto/aes.h>
-#include <crypto/des.h>
-#include <crypto/sha.h>
-#include <crypto/aead.h>
-#include <crypto/authenc.h>
-#include <crypto/scatterwalk.h>
-
-#define SHA256_DIGESTSIZE		32
-#define SHA1_DIGESTSIZE			20
-
-#define HMAC_KEY_SIZE			(SHA1_DIGESTSIZE)    
-#define SHA_HMAC_KEY_SIZE		64
-#define DES_KEY_SIZE			8
-#define TRIPLE_DES_KEY_SIZE		24
-#define AES128_KEY_SIZE			16
-#define AES192_KEY_SIZE			24
-#define AES256_KEY_SIZE			32
-#define MAX_CIPHER_KEY_SIZE		AES256_KEY_SIZE
-
-#define AES_IV_LENGTH			16
-#define DES_IV_LENGTH                   8
-#define MAX_IV_LENGTH			AES_IV_LENGTH
-
-#define QCE_MAX_OPER_DATA		0xFF00
-
-#define MAX_NONCE  16
-
-typedef void (*qce_comp_func_ptr_t)(void *areq,
-		unsigned char *icv, unsigned char *iv, int ret);
-
-enum qce_cipher_alg_enum {
-	CIPHER_ALG_DES = 0,
-	CIPHER_ALG_3DES = 1,
-	CIPHER_ALG_AES = 2,
-	CIPHER_ALG_LAST
-};
-
-enum qce_hash_alg_enum {
-	QCE_HASH_SHA1   = 0,
-	QCE_HASH_SHA256 = 1,
-	QCE_HASH_SHA1_HMAC   = 2,
-	QCE_HASH_SHA256_HMAC = 3,
-	QCE_HASH_AES_CMAC = 4,
-	QCE_HASH_LAST
-};
-
-enum qce_cipher_dir_enum {
-	QCE_ENCRYPT = 0,
-	QCE_DECRYPT = 1,
-	QCE_CIPHER_DIR_LAST
-};
-
-enum qce_cipher_mode_enum {
-	QCE_MODE_CBC = 0,
-	QCE_MODE_ECB = 1,
-	QCE_MODE_CTR = 2,
-	QCE_MODE_XTS = 3,
-	QCE_MODE_CCM = 4,
-	QCE_CIPHER_MODE_LAST
-};
-
-enum qce_req_op_enum {
-	QCE_REQ_ABLK_CIPHER = 0,
-	QCE_REQ_ABLK_CIPHER_NO_KEY = 1,
-	QCE_REQ_AEAD = 2,
-	QCE_REQ_LAST
-};
-
-struct ce_hw_support {
-	bool sha1_hmac_20; 
-	bool sha1_hmac; 
-	bool sha256_hmac; 
-	bool sha_hmac; 
-	bool cmac;
-	bool aes_key_192;
-	bool aes_xts;
-	bool aes_ccm;
-	bool ota;
-};
-
-struct qce_sha_req {
-	qce_comp_func_ptr_t qce_cb;	
-	enum qce_hash_alg_enum alg;	
-	unsigned char *digest;		
-	struct scatterlist *src;	
-	uint32_t  auth_data[4];		
-	unsigned char *authkey;		
-	unsigned int  authklen;		
-	bool first_blk;			
-	bool last_blk;			
-	unsigned int size;		
-	void *areq;
-};
-
-struct qce_req {
-	enum qce_req_op_enum op;	
-	qce_comp_func_ptr_t qce_cb;	
-	void *areq;
-	enum qce_cipher_alg_enum   alg;	
-	enum qce_cipher_dir_enum dir;	
-	enum qce_cipher_mode_enum mode;	
-	unsigned char *authkey;		
-	unsigned int authklen;		
-	unsigned int authsize;		
-	unsigned char  nonce[MAX_NONCE];
-	unsigned char *assoc;		
-	unsigned int assoclen;		
-	struct scatterlist *asg;	
-	unsigned char *enckey;		
-	unsigned int encklen;		
-	unsigned char *iv;		
-	unsigned int ivsize;		
-	unsigned int cryptlen;		
-	unsigned int use_pmem;		
-	struct qcedev_pmem_info *pmem;	
-};
-
-void *qce_open(struct platform_device *pdev, int *rc);
-int qce_close(void *handle);
-int qce_aead_req(void *handle, struct qce_req *req);
-int qce_ablk_cipher_req(void *handle, struct qce_req *req);
-int qce_hw_support(void *handle, struct ce_hw_support *support);
-int qce_process_sha_req(void *handle, struct qce_sha_req *s_req);
-
-#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcrypto.c monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcrypto.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcrypto.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcrypto.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,3338 +0,0 @@
-/* Qualcomm Crypto driver
- *
- * Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/clk.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmapool.h>
-#include <linux/crypto.h>
-#include <linux/kernel.h>
-#include <linux/rtnetlink.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/debugfs.h>
-
-#include <crypto/ctr.h>
-#include <crypto/des.h>
-#include <crypto/aes.h>
-#include <crypto/sha.h>
-#include <crypto/hash.h>
-#include <crypto/algapi.h>
-#include <crypto/aead.h>
-#include <crypto/authenc.h>
-#include <crypto/scatterwalk.h>
-#include <crypto/internal/hash.h>
-
-#include <mach/scm.h>
-#include <linux/platform_data/qcom_crypto_device.h>
-#include <mach/msm_bus.h>
-#include "qce.h"
-
-
-#define MAX_CRYPTO_DEVICE 3
-#define DEBUG_MAX_FNAME  16
-#define DEBUG_MAX_RW_BUF 1024
-
-struct crypto_stat {
-	u32 aead_sha1_aes_enc;
-	u32 aead_sha1_aes_dec;
-	u32 aead_sha1_des_enc;
-	u32 aead_sha1_des_dec;
-	u32 aead_sha1_3des_enc;
-	u32 aead_sha1_3des_dec;
-	u32 aead_op_success;
-	u32 aead_op_fail;
-	u32 ablk_cipher_aes_enc;
-	u32 ablk_cipher_aes_dec;
-	u32 ablk_cipher_des_enc;
-	u32 ablk_cipher_des_dec;
-	u32 ablk_cipher_3des_enc;
-	u32 ablk_cipher_3des_dec;
-	u32 ablk_cipher_op_success;
-	u32 ablk_cipher_op_fail;
-	u32 sha1_digest;
-	u32 sha256_digest;
-	u32 sha_op_success;
-	u32 sha_op_fail;
-	u32 sha1_hmac_digest;
-	u32 sha256_hmac_digest;
-	u32 sha_hmac_op_success;
-	u32 sha_hmac_op_fail;
-};
-static struct crypto_stat _qcrypto_stat[MAX_CRYPTO_DEVICE];
-static struct dentry *_debug_dent;
-static char _debug_read_buf[DEBUG_MAX_RW_BUF];
-
-struct crypto_priv {
-	
-	struct msm_ce_hw_support platform_support;
-
-	
-	struct ce_hw_support ce_support;
-
-	uint32_t  bus_scale_handle;
-	
-	spinlock_t lock;
-
-	
-	void *qce;
-
-	
-	struct list_head alg_list;
-
-	
-	struct platform_device *pdev;
-
-	
-	struct crypto_async_request *req;
-	int res;
-
-	
-	struct crypto_queue queue;
-
-	uint32_t ce_lock_count;
-	uint32_t high_bw_req_count;
-
-	struct work_struct unlock_ce_ws;
-
-	struct tasklet_struct done_tasklet;
-};
-
-
-#define QCRYPTO_CMD_ID				1
-#define QCRYPTO_CE_LOCK_CMD			1
-#define QCRYPTO_CE_UNLOCK_CMD			0
-#define NUM_RETRY				1000
-#define CE_BUSY				        55
-
-static DEFINE_MUTEX(sent_bw_req);
-
-static int qcrypto_scm_cmd(int resource, int cmd, int *response)
-{
-#ifdef CONFIG_MSM_SCM
-
-	struct {
-		int resource;
-		int cmd;
-	} cmd_buf;
-
-	cmd_buf.resource = resource;
-	cmd_buf.cmd = cmd;
-
-	return scm_call(SCM_SVC_TZ, QCRYPTO_CMD_ID, &cmd_buf,
-		sizeof(cmd_buf), response, sizeof(*response));
-
-#else
-	return 0;
-#endif
-}
-
-static void qcrypto_unlock_ce(struct work_struct *work)
-{
-	int response = 0;
-	unsigned long flags;
-	struct crypto_priv *cp = container_of(work, struct crypto_priv,
-							unlock_ce_ws);
-	if (cp->ce_lock_count == 1)
-		BUG_ON(qcrypto_scm_cmd(cp->platform_support.shared_ce_resource,
-				QCRYPTO_CE_UNLOCK_CMD, &response) != 0);
-	spin_lock_irqsave(&cp->lock, flags);
-	cp->ce_lock_count--;
-	spin_unlock_irqrestore(&cp->lock, flags);
-}
-
-static int qcrypto_lock_ce(struct crypto_priv *cp)
-{
-	unsigned long flags;
-	int response = -CE_BUSY;
-	int i = 0;
-
-	if (cp->ce_lock_count == 0) {
-		do {
-			if (qcrypto_scm_cmd(
-				cp->platform_support.shared_ce_resource,
-				QCRYPTO_CE_LOCK_CMD, &response)) {
-				response = -EINVAL;
-				break;
-			}
-		} while ((response == -CE_BUSY) && (i++ < NUM_RETRY));
-
-		if ((response == -CE_BUSY) && (i >= NUM_RETRY))
-			return -EUSERS;
-		if (response < 0)
-			return -EINVAL;
-	}
-	spin_lock_irqsave(&cp->lock, flags);
-	cp->ce_lock_count++;
-	spin_unlock_irqrestore(&cp->lock, flags);
-
-
-	return 0;
-}
-
-enum qcrypto_alg_type {
-	QCRYPTO_ALG_CIPHER	= 0,
-	QCRYPTO_ALG_SHA	= 1,
-	QCRYPTO_ALG_LAST
-};
-
-struct qcrypto_alg {
-	struct list_head entry;
-	struct crypto_alg cipher_alg;
-	struct ahash_alg sha_alg;
-	enum qcrypto_alg_type alg_type;
-	struct crypto_priv *cp;
-};
-
-#define QCRYPTO_MAX_KEY_SIZE	64
-#define QCRYPTO_MAX_IV_LENGTH	16
-
-struct qcrypto_cipher_ctx {
-	u8 auth_key[QCRYPTO_MAX_KEY_SIZE];
-	u8 iv[QCRYPTO_MAX_IV_LENGTH];
-
-	u8 enc_key[QCRYPTO_MAX_KEY_SIZE];
-	unsigned int enc_key_len;
-
-	unsigned int authsize;
-	unsigned int auth_key_len;
-
-	struct crypto_priv *cp;
-};
-
-struct qcrypto_cipher_req_ctx {
-	u8 *iv;
-	unsigned int ivsize;
-	int  aead;
-	struct scatterlist asg;		
-	unsigned char *assoc;		
-	unsigned int assoclen;		
-	struct scatterlist *assoc_sg;	
-	enum qce_cipher_alg_enum alg;
-	enum qce_cipher_dir_enum dir;
-	enum qce_cipher_mode_enum mode;
-};
-
-#define SHA_MAX_BLOCK_SIZE      SHA256_BLOCK_SIZE
-#define SHA_MAX_STATE_SIZE	(SHA256_DIGEST_SIZE / sizeof(u32))
-#define SHA_MAX_DIGEST_SIZE	 SHA256_DIGEST_SIZE
-
-static uint8_t  _std_init_vector_sha1_uint8[] =   {
-	0x67, 0x45, 0x23, 0x01, 0xEF, 0xCD, 0xAB, 0x89,
-	0x98, 0xBA, 0xDC, 0xFE, 0x10, 0x32, 0x54, 0x76,
-	0xC3, 0xD2, 0xE1, 0xF0
-};
-
-static uint8_t _std_init_vector_sha256_uint8[] = {
-	0x6A, 0x09, 0xE6, 0x67, 0xBB, 0x67, 0xAE, 0x85,
-	0x3C, 0x6E, 0xF3, 0x72, 0xA5, 0x4F, 0xF5, 0x3A,
-	0x51, 0x0E, 0x52, 0x7F, 0x9B, 0x05, 0x68, 0x8C,
-	0x1F, 0x83, 0xD9, 0xAB, 0x5B, 0xE0, 0xCD, 0x19
-};
-
-struct qcrypto_sha_ctx {
-	enum qce_hash_alg_enum  alg;
-	uint32_t		byte_count[4];
-	uint8_t			digest[SHA_MAX_DIGEST_SIZE];
-	uint32_t		diglen;
-	uint8_t			*tmp_tbuf;
-	uint8_t			*trailing_buf;
-	uint8_t			*in_buf;
-	uint32_t		authkey_in_len;
-	uint32_t		trailing_buf_len;
-	uint8_t			first_blk;
-	uint8_t			last_blk;
-	uint8_t			authkey[SHA_MAX_BLOCK_SIZE];
-	struct ahash_request *ahash_req;
-	struct completion ahash_req_complete;
-	struct scatterlist *sg;
-	struct scatterlist tmp_sg;
-	struct crypto_priv *cp;
-};
-
-struct qcrypto_sha_req_ctx {
-	union {
-		struct sha1_state sha1_state_ctx;
-		struct sha256_state sha256_state_ctx;
-	};
-	struct scatterlist *src;
-	uint32_t nbytes;
-};
-
-static void _byte_stream_to_words(uint32_t *iv, unsigned char *b,
-		unsigned int len)
-{
-	unsigned n;
-
-	n = len  / sizeof(uint32_t) ;
-	for (; n > 0; n--) {
-		*iv =  ((*b << 24)      & 0xff000000) |
-				(((*(b+1)) << 16) & 0xff0000)   |
-				(((*(b+2)) << 8) & 0xff00)     |
-				(*(b+3)          & 0xff);
-		b += sizeof(uint32_t);
-		iv++;
-	}
-
-	n = len %  sizeof(uint32_t);
-	if (n == 3) {
-		*iv = ((*b << 24) & 0xff000000) |
-				(((*(b+1)) << 16) & 0xff0000)   |
-				(((*(b+2)) << 8) & 0xff00)     ;
-	} else if (n == 2) {
-		*iv = ((*b << 24) & 0xff000000) |
-				(((*(b+1)) << 16) & 0xff0000)   ;
-	} else if (n == 1) {
-		*iv = ((*b << 24) & 0xff000000) ;
-	}
-}
-
-static void _words_to_byte_stream(uint32_t *iv, unsigned char *b,
-		unsigned int len)
-{
-	unsigned n = len  / sizeof(uint32_t);
-
-	for (; n > 0; n--) {
-		*b++ = (unsigned char) ((*iv >> 24)   & 0xff);
-		*b++ = (unsigned char) ((*iv >> 16)   & 0xff);
-		*b++ = (unsigned char) ((*iv >> 8)    & 0xff);
-		*b++ = (unsigned char) (*iv           & 0xff);
-		iv++;
-	}
-	n = len % sizeof(uint32_t);
-	if (n == 3) {
-		*b++ = (unsigned char) ((*iv >> 24)   & 0xff);
-		*b++ = (unsigned char) ((*iv >> 16)   & 0xff);
-		*b =   (unsigned char) ((*iv >> 8)    & 0xff);
-	} else if (n == 2) {
-		*b++ = (unsigned char) ((*iv >> 24)   & 0xff);
-		*b =   (unsigned char) ((*iv >> 16)   & 0xff);
-	} else if (n == 1) {
-		*b =   (unsigned char) ((*iv >> 24)   & 0xff);
-	}
-}
-
-static void qcrypto_ce_high_bw_req(struct crypto_priv *cp, bool high_bw_req)
-{
-	int ret = 0;
-
-	mutex_lock(&sent_bw_req);
-	if (high_bw_req) {
-		if (cp->high_bw_req_count == 0)
-			ret = msm_bus_scale_client_update_request(
-				cp->bus_scale_handle, 1);
-		if (ret)
-			pr_err("%s Unable to set to high bandwidth\n",
-							__func__);
-		cp->high_bw_req_count++;
-	} else {
-		if (cp->high_bw_req_count == 1)
-			ret = msm_bus_scale_client_update_request(
-				cp->bus_scale_handle, 0);
-		if (ret)
-			pr_err("%s Unable to set to low bandwidth\n",
-							__func__);
-		cp->high_bw_req_count--;
-	}
-	mutex_unlock(&sent_bw_req);
-}
-
-static void _start_qcrypto_process(struct crypto_priv *cp);
-
-static struct qcrypto_alg *_qcrypto_sha_alg_alloc(struct crypto_priv *cp,
-		struct ahash_alg *template)
-{
-	struct qcrypto_alg *q_alg;
-	q_alg = kzalloc(sizeof(struct qcrypto_alg), GFP_KERNEL);
-	if (!q_alg) {
-		pr_err("qcrypto Memory allocation of q_alg FAIL, error %ld\n",
-				PTR_ERR(q_alg));
-		return ERR_PTR(-ENOMEM);
-	}
-
-	q_alg->alg_type = QCRYPTO_ALG_SHA;
-	q_alg->sha_alg = *template;
-	q_alg->cp = cp;
-
-	return q_alg;
-};
-
-static struct qcrypto_alg *_qcrypto_cipher_alg_alloc(struct crypto_priv *cp,
-		struct crypto_alg *template)
-{
-	struct qcrypto_alg *q_alg;
-
-	q_alg = kzalloc(sizeof(struct qcrypto_alg), GFP_KERNEL);
-	if (!q_alg) {
-		pr_err("qcrypto Memory allocation of q_alg FAIL, error %ld\n",
-				PTR_ERR(q_alg));
-		return ERR_PTR(-ENOMEM);
-	}
-
-	q_alg->alg_type = QCRYPTO_ALG_CIPHER;
-	q_alg->cipher_alg = *template;
-	q_alg->cp = cp;
-
-	return q_alg;
-};
-
-static int _qcrypto_cipher_cra_init(struct crypto_tfm *tfm)
-{
-	struct crypto_alg *alg = tfm->__crt_alg;
-	struct qcrypto_alg *q_alg;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-
-	q_alg = container_of(alg, struct qcrypto_alg, cipher_alg);
-
-	
-	ctx->cp = q_alg->cp;
-
-	
-	get_random_bytes(ctx->iv, QCRYPTO_MAX_IV_LENGTH);
-	if (ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(ctx->cp, true);
-
-	return 0;
-};
-
-static int _qcrypto_ahash_cra_init(struct crypto_tfm *tfm)
-{
-	struct crypto_ahash *ahash = __crypto_ahash_cast(tfm);
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(tfm);
-	struct ahash_alg *alg =	container_of(crypto_hash_alg_common(ahash),
-						struct ahash_alg, halg);
-	struct qcrypto_alg *q_alg = container_of(alg, struct qcrypto_alg,
-								sha_alg);
-
-	crypto_ahash_set_reqsize(ahash, sizeof(struct qcrypto_sha_req_ctx));
-	
-	sha_ctx->cp = q_alg->cp;
-	sha_ctx->sg = NULL;
-	sha_ctx->tmp_tbuf = kzalloc(SHA_MAX_BLOCK_SIZE +
-					SHA_MAX_DIGEST_SIZE, GFP_KERNEL);
-	if (sha_ctx->tmp_tbuf == NULL) {
-		pr_err("qcrypto Can't Allocate mem: sha_ctx->tmp_tbuf, error %ld\n",
-			PTR_ERR(sha_ctx->tmp_tbuf));
-		return -ENOMEM;
-	}
-
-	sha_ctx->trailing_buf = kzalloc(SHA_MAX_BLOCK_SIZE, GFP_KERNEL);
-	if (sha_ctx->trailing_buf == NULL) {
-		kfree(sha_ctx->tmp_tbuf);
-		sha_ctx->tmp_tbuf = NULL;
-		pr_err("qcrypto Can't Allocate mem: sha_ctx->trailing_buf, error %ld\n",
-			PTR_ERR(sha_ctx->trailing_buf));
-		return -ENOMEM;
-	}
-
-	sha_ctx->ahash_req = NULL;
-	if (sha_ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(sha_ctx->cp, true);
-
-	return 0;
-};
-
-static void _qcrypto_ahash_cra_exit(struct crypto_tfm *tfm)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(tfm);
-
-	kfree(sha_ctx->tmp_tbuf);
-	sha_ctx->tmp_tbuf = NULL;
-	kfree(sha_ctx->trailing_buf);
-	sha_ctx->trailing_buf = NULL;
-	if (sha_ctx->sg != NULL) {
-		kfree(sha_ctx->sg);
-		sha_ctx->sg = NULL;
-	}
-	if (sha_ctx->ahash_req != NULL) {
-		ahash_request_free(sha_ctx->ahash_req);
-		sha_ctx->ahash_req = NULL;
-	}
-	if (sha_ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(sha_ctx->cp, false);
-};
-
-
-static void _crypto_sha_hmac_ahash_req_complete(
-	struct crypto_async_request *req, int err);
-
-static int _qcrypto_ahash_hmac_cra_init(struct crypto_tfm *tfm)
-{
-	struct crypto_ahash *ahash = __crypto_ahash_cast(tfm);
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(tfm);
-	int ret = 0;
-
-	ret = _qcrypto_ahash_cra_init(tfm);
-	if (ret)
-		return ret;
-	sha_ctx->ahash_req = ahash_request_alloc(ahash, GFP_KERNEL);
-
-	if (sha_ctx->ahash_req == NULL) {
-		_qcrypto_ahash_cra_exit(tfm);
-		return -ENOMEM;
-	}
-
-	init_completion(&sha_ctx->ahash_req_complete);
-	ahash_request_set_callback(sha_ctx->ahash_req,
-				CRYPTO_TFM_REQ_MAY_BACKLOG,
-				_crypto_sha_hmac_ahash_req_complete,
-				&sha_ctx->ahash_req_complete);
-	crypto_ahash_clear_flags(ahash, ~0);
-
-	if (sha_ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(sha_ctx->cp, true);
-
-	return 0;
-};
-
-static int _qcrypto_cra_ablkcipher_init(struct crypto_tfm *tfm)
-{
-	tfm->crt_ablkcipher.reqsize = sizeof(struct qcrypto_cipher_req_ctx);
-	return _qcrypto_cipher_cra_init(tfm);
-};
-
-static int _qcrypto_cra_aead_init(struct crypto_tfm *tfm)
-{
-	tfm->crt_aead.reqsize = sizeof(struct qcrypto_cipher_req_ctx);
-	return _qcrypto_cipher_cra_init(tfm);
-};
-
-static void _qcrypto_cra_ablkcipher_exit(struct crypto_tfm *tfm)
-{
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-
-	if (ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(ctx->cp, false);
-};
-
-static void _qcrypto_cra_aead_exit(struct crypto_tfm *tfm)
-{
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-
-	if (ctx->cp->platform_support.bus_scale_table != NULL)
-		qcrypto_ce_high_bw_req(ctx->cp, false);
-};
-
-static int _disp_stats(int id)
-{
-	struct crypto_stat *pstat;
-	int len = 0;
-
-	pstat = &_qcrypto_stat[id];
-	len = snprintf(_debug_read_buf, DEBUG_MAX_RW_BUF - 1,
-			"\nQualcomm crypto accelerator %d Statistics:\n",
-				id + 1);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK AES CIPHER encryption   : %d\n",
-					pstat->ablk_cipher_aes_enc);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK AES CIPHER decryption   : %d\n",
-					pstat->ablk_cipher_aes_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK DES CIPHER encryption   : %d\n",
-					pstat->ablk_cipher_des_enc);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK DES CIPHER decryption   : %d\n",
-					pstat->ablk_cipher_des_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK 3DES CIPHER encryption  : %d\n",
-					pstat->ablk_cipher_3des_enc);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK 3DES CIPHER decryption  : %d\n",
-					pstat->ablk_cipher_3des_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK CIPHER operation success: %d\n",
-					pstat->ablk_cipher_op_success);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   ABLK CIPHER operation fail   : %d\n",
-					pstat->ablk_cipher_op_fail);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-AES encryption      : %d\n",
-					pstat->aead_sha1_aes_enc);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-AES decryption      : %d\n",
-					pstat->aead_sha1_aes_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-DES encryption      : %d\n",
-					pstat->aead_sha1_des_enc);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-DES decryption      : %d\n",
-					pstat->aead_sha1_des_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-3DES encryption     : %d\n",
-					pstat->aead_sha1_3des_enc);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD SHA1-3DES decryption     : %d\n",
-					pstat->aead_sha1_3des_dec);
-
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD operation success       : %d\n",
-					pstat->aead_op_success);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   AEAD operation fail          : %d\n",
-					pstat->aead_op_fail);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA1 digest			 : %d\n",
-					pstat->sha1_digest);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA256 digest		 : %d\n",
-					pstat->sha256_digest);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA  operation fail          : %d\n",
-					pstat->sha_op_fail);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA  operation success          : %d\n",
-					pstat->sha_op_success);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA1 HMAC digest			 : %d\n",
-					pstat->sha1_hmac_digest);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA256 HMAC digest		 : %d\n",
-					pstat->sha256_hmac_digest);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA HMAC operation fail          : %d\n",
-					pstat->sha_hmac_op_fail);
-	len += snprintf(_debug_read_buf + len, DEBUG_MAX_RW_BUF - len - 1,
-			"   SHA HMAC operation success          : %d\n",
-					pstat->sha_hmac_op_success);
-	return len;
-}
-
-static int _qcrypto_remove(struct platform_device *pdev)
-{
-	struct crypto_priv *cp;
-	struct qcrypto_alg *q_alg;
-	struct qcrypto_alg *n;
-
-	cp = platform_get_drvdata(pdev);
-
-	if (!cp)
-		return 0;
-
-	if (cp->platform_support.bus_scale_table != NULL)
-		msm_bus_scale_unregister_client(cp->bus_scale_handle);
-
-	list_for_each_entry_safe(q_alg, n, &cp->alg_list, entry) {
-		if (q_alg->alg_type == QCRYPTO_ALG_CIPHER)
-			crypto_unregister_alg(&q_alg->cipher_alg);
-		if (q_alg->alg_type == QCRYPTO_ALG_SHA)
-			crypto_unregister_ahash(&q_alg->sha_alg);
-		list_del(&q_alg->entry);
-		kfree(q_alg);
-	}
-
-	if (cp->qce)
-		qce_close(cp->qce);
-	tasklet_kill(&cp->done_tasklet);
-	kfree(cp);
-	return 0;
-};
-
-static int _qcrypto_setkey_aes(struct crypto_ablkcipher *cipher, const u8 *key,
-		unsigned int len)
-{
-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-	struct crypto_priv *cp = ctx->cp;
-
-	switch (len) {
-	case AES_KEYSIZE_128:
-	case AES_KEYSIZE_256:
-		break;
-	case AES_KEYSIZE_192:
-		if (cp->ce_support.aes_key_192)
-			break;
-	default:
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	};
-	ctx->enc_key_len = len;
-	memcpy(ctx->enc_key, key, len);
-	return 0;
-};
-
-static int _qcrypto_setkey_des(struct crypto_ablkcipher *cipher, const u8 *key,
-		unsigned int len)
-{
-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-	u32 tmp[DES_EXPKEY_WORDS];
-	int ret = des_ekey(tmp, key);
-
-	if (len != DES_KEY_SIZE) {
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	};
-
-	if (unlikely(ret == 0) && (tfm->crt_flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
-		tfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;
-		return -EINVAL;
-	}
-
-	ctx->enc_key_len = len;
-	memcpy(ctx->enc_key, key, len);
-	return 0;
-};
-
-static int _qcrypto_setkey_3des(struct crypto_ablkcipher *cipher, const u8 *key,
-		unsigned int len)
-{
-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-
-	if (len != DES3_EDE_KEY_SIZE) {
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	};
-	ctx->enc_key_len = len;
-	memcpy(ctx->enc_key, key, len);
-	return 0;
-};
-
-static void req_done(unsigned long data)
-{
-	struct crypto_async_request *areq;
-	struct crypto_priv *cp = (struct crypto_priv *)data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&cp->lock, flags);
-	areq = cp->req;
-	cp->req = NULL;
-	spin_unlock_irqrestore(&cp->lock, flags);
-
-	if (areq)
-		areq->complete(areq, cp->res);
-	_start_qcrypto_process(cp);
-};
-
-static void _update_sha1_ctx(struct ahash_request  *req)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha1_state *sha_state_ctx = &rctx->sha1_state_ctx;
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-
-	if (sha_ctx->last_blk == 1)
-		memset(sha_state_ctx, 0x00, sizeof(struct sha1_state));
-	else {
-		memset(sha_state_ctx->buffer, 0x00, SHA1_BLOCK_SIZE);
-		memcpy(sha_state_ctx->buffer, sha_ctx->trailing_buf,
-						sha_ctx->trailing_buf_len);
-		_byte_stream_to_words(sha_state_ctx->state , sha_ctx->digest,
-					SHA1_DIGEST_SIZE);
-	}
-	return;
-}
-
-static void _update_sha256_ctx(struct ahash_request  *req)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha256_state *sha_state_ctx = &rctx->sha256_state_ctx;
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-
-	if (sha_ctx->last_blk == 1)
-		memset(sha_state_ctx, 0x00, sizeof(struct sha256_state));
-	else {
-		memset(sha_state_ctx->buf, 0x00, SHA256_BLOCK_SIZE);
-		memcpy(sha_state_ctx->buf, sha_ctx->trailing_buf,
-						sha_ctx->trailing_buf_len);
-		_byte_stream_to_words(sha_state_ctx->state, sha_ctx->digest,
-					SHA256_DIGEST_SIZE);
-	}
-	return;
-}
-
-static void _qce_ahash_complete(void *cookie, unsigned char *digest,
-		unsigned char *authdata, int ret)
-{
-	struct ahash_request *areq = (struct ahash_request *) cookie;
-	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(areq);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-	uint32_t diglen = crypto_ahash_digestsize(ahash);
-	uint32_t *auth32 = (uint32_t *)authdata;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qce_ahash_complete: %p ret %d\n",
-				areq, ret);
-#endif
-
-	if (digest) {
-		memcpy(sha_ctx->digest, digest, diglen);
-		memcpy(areq->result, digest, diglen);
-	}
-	if (authdata) {
-		sha_ctx->byte_count[0] = auth32[0];
-		sha_ctx->byte_count[1] = auth32[1];
-		sha_ctx->byte_count[2] = auth32[2];
-		sha_ctx->byte_count[3] = auth32[3];
-	}
-	areq->src = rctx->src;
-	areq->nbytes = rctx->nbytes;
-
-	if (sha_ctx->sg != NULL) {
-		kfree(sha_ctx->sg);
-		sha_ctx->sg = NULL;
-	}
-
-	if (sha_ctx->alg == QCE_HASH_SHA1)
-		_update_sha1_ctx(areq);
-	if (sha_ctx->alg == QCE_HASH_SHA256)
-		_update_sha256_ctx(areq);
-
-	sha_ctx->last_blk = 0;
-	sha_ctx->first_blk = 0;
-
-	if (ret) {
-		cp->res = -ENXIO;
-		pstat->sha_op_fail++;
-	} else {
-		cp->res = 0;
-		pstat->sha_op_success++;
-	}
-
-	if (cp->platform_support.ce_shared)
-		schedule_work(&cp->unlock_ce_ws);
-	tasklet_schedule(&cp->done_tasklet);
-};
-
-static void _qce_ablk_cipher_complete(void *cookie, unsigned char *icb,
-		unsigned char *iv, int ret)
-{
-	struct ablkcipher_request *areq = (struct ablkcipher_request *) cookie;
-	struct crypto_ablkcipher *ablk = crypto_ablkcipher_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qce_ablk_cipher_complete: %p ret %d\n",
-				areq, ret);
-#endif
-	if (iv)
-		memcpy(ctx->iv, iv, crypto_ablkcipher_ivsize(ablk));
-
-	if (ret) {
-		cp->res = -ENXIO;
-		pstat->ablk_cipher_op_fail++;
-	} else {
-		cp->res = 0;
-		pstat->ablk_cipher_op_success++;
-	}
-	if (cp->platform_support.ce_shared)
-		schedule_work(&cp->unlock_ce_ws);
-	tasklet_schedule(&cp->done_tasklet);
-};
-
-
-static void _qce_aead_complete(void *cookie, unsigned char *icv,
-				unsigned char *iv, int ret)
-{
-	struct aead_request *areq = (struct aead_request *) cookie;
-	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(areq);
-
-	if (rctx->mode == QCE_MODE_CCM) {
-		kzfree(rctx->assoc);
-		areq->assoc = rctx->assoc_sg;
-		areq->assoclen = rctx->assoclen;
-		if (ret) {
-			if (ret == 0x2000000)
-				ret = -EBADMSG;
-			else
-				ret = -ENXIO;
-		}
-	} else {
-		if (ret == 0) {
-			if (rctx->dir  == QCE_ENCRYPT) {
-				
-				scatterwalk_map_and_copy(icv, areq->dst,
-						areq->cryptlen,
-						ctx->authsize, 1);
-
-			} else {
-				unsigned char tmp[SHA256_DIGESTSIZE] = {0};
-
-				
-				scatterwalk_map_and_copy(tmp,
-					areq->src, areq->cryptlen -
-					ctx->authsize, ctx->authsize, 0);
-				ret = memcmp(icv, tmp, ctx->authsize);
-				if (ret != 0)
-					ret = -EBADMSG;
-
-			}
-		} else {
-			ret = -ENXIO;
-		}
-
-		if (iv)
-			memcpy(ctx->iv, iv, crypto_aead_ivsize(aead));
-	}
-
-	if (ret)
-		pstat->aead_op_fail++;
-	else
-		pstat->aead_op_success++;
-
-	if (cp->platform_support.ce_shared)
-		schedule_work(&cp->unlock_ce_ws);
-	tasklet_schedule(&cp->done_tasklet);
-}
-
-static int aead_ccm_set_msg_len(u8 *block, unsigned int msglen, int csize)
-{
-	__be32 data;
-
-	memset(block, 0, csize);
-	block += csize;
-
-	if (csize >= 4)
-		csize = 4;
-	else if (msglen > (1 << (8 * csize)))
-		return -EOVERFLOW;
-
-	data = cpu_to_be32(msglen);
-	memcpy(block - csize, (u8 *)&data + 4 - csize, csize);
-
-	return 0;
-}
-
-static int qccrypto_set_aead_ccm_nonce(struct qce_req *qreq)
-{
-	struct aead_request *areq = (struct aead_request *) qreq->areq;
-	unsigned int i = ((unsigned int)qreq->iv[0]) + 1;
-
-	memcpy(&qreq->nonce[0] , qreq->iv, qreq->ivsize);
-	qreq->nonce[0] |= (8 * ((qreq->authsize - 2) / 2));
-	if (areq->assoclen)
-		qreq->nonce[0] |= 64;
-
-	if (i > MAX_NONCE)
-		return -EINVAL;
-
-	return aead_ccm_set_msg_len(qreq->nonce + 16 - i, qreq->cryptlen, i);
-}
-
-static int qcrypto_aead_ccm_format_adata(struct qce_req *qreq, uint32_t alen,
-						struct scatterlist *sg)
-{
-	unsigned char *adata;
-	uint32_t len, l;
-
-	qreq->assoc = kzalloc((alen + 0x64), (GFP_KERNEL | __GFP_DMA));
-	if (!qreq->assoc) {
-		pr_err("qcrypto Memory allocation of adata FAIL, error %ld\n",
-				PTR_ERR(qreq->assoc));
-		return -ENOMEM;
-	}
-	adata = qreq->assoc;
-	if (alen < 65280) {
-		*(__be16 *)adata = cpu_to_be16(alen);
-		len = 2;
-	} else {
-			if ((alen >= 65280) && (alen <= 0xffffffff)) {
-				*(__be16 *)adata = cpu_to_be16(0xfffe);
-				*(__be32 *)&adata[2] = cpu_to_be32(alen);
-				len = 6;
-		} else {
-				*(__be16 *)adata = cpu_to_be16(0xffff);
-				*(__be32 *)&adata[6] = cpu_to_be32(alen);
-				len = 10;
-		}
-	}
-	adata += len;
-	qreq->assoclen = ALIGN((alen + len), 16);
-	for (l = alen; l > 0; sg = sg_next(sg)) {
-		memcpy(adata, sg_virt(sg), sg->length);
-		l -= sg->length;
-		adata += sg->length;
-	}
-	return 0;
-}
-
-static void _start_qcrypto_process(struct crypto_priv *cp)
-{
-	struct crypto_async_request *async_req = NULL;
-	struct crypto_async_request *backlog = NULL;
-	unsigned long flags;
-	u32 type;
-	struct qce_req qreq;
-	int ret;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *cipher_ctx;
-	struct qcrypto_sha_ctx *sha_ctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-again:
-	spin_lock_irqsave(&cp->lock, flags);
-	if (cp->req == NULL) {
-		backlog = crypto_get_backlog(&cp->queue);
-		async_req = crypto_dequeue_request(&cp->queue);
-		cp->req = async_req;
-	}
-	spin_unlock_irqrestore(&cp->lock, flags);
-	if (!async_req)
-		return;
-	if (backlog)
-		backlog->complete(backlog, -EINPROGRESS);
-	type = crypto_tfm_alg_type(async_req->tfm);
-
-	if (type == CRYPTO_ALG_TYPE_ABLKCIPHER) {
-		struct ablkcipher_request *req;
-		struct crypto_ablkcipher *tfm;
-
-		req = container_of(async_req, struct ablkcipher_request, base);
-		cipher_ctx = crypto_tfm_ctx(async_req->tfm);
-		rctx = ablkcipher_request_ctx(req);
-		tfm = crypto_ablkcipher_reqtfm(req);
-
-		qreq.op = QCE_REQ_ABLK_CIPHER;
-		qreq.qce_cb = _qce_ablk_cipher_complete;
-		qreq.areq = req;
-		qreq.alg = rctx->alg;
-		qreq.dir = rctx->dir;
-		qreq.mode = rctx->mode;
-		qreq.enckey = cipher_ctx->enc_key;
-		qreq.encklen = cipher_ctx->enc_key_len;
-		qreq.iv = req->info;
-		qreq.ivsize = crypto_ablkcipher_ivsize(tfm);
-		qreq.cryptlen = req->nbytes;
-		qreq.use_pmem = 0;
-
-		if ((cipher_ctx->enc_key_len == 0) &&
-				(cp->platform_support.hw_key_support == 0))
-			ret = -EINVAL;
-		else
-			ret =  qce_ablk_cipher_req(cp->qce, &qreq);
-	} else {
-		if (type == CRYPTO_ALG_TYPE_AHASH) {
-
-			struct ahash_request *req;
-			struct qce_sha_req sreq;
-
-			req = container_of(async_req,
-						struct ahash_request, base);
-			sha_ctx = crypto_tfm_ctx(async_req->tfm);
-
-			sreq.qce_cb = _qce_ahash_complete;
-			sreq.digest =  &sha_ctx->digest[0];
-			sreq.src = req->src;
-			sreq.auth_data[0] = sha_ctx->byte_count[0];
-			sreq.auth_data[1] = sha_ctx->byte_count[1];
-			sreq.auth_data[2] = sha_ctx->byte_count[2];
-			sreq.auth_data[3] = sha_ctx->byte_count[3];
-			sreq.first_blk = sha_ctx->first_blk;
-			sreq.last_blk = sha_ctx->last_blk;
-			sreq.size = req->nbytes;
-			sreq.areq = req;
-
-			switch (sha_ctx->alg) {
-			case QCE_HASH_SHA1:
-				sreq.alg = QCE_HASH_SHA1;
-				sreq.authkey = NULL;
-				break;
-			case QCE_HASH_SHA256:
-				sreq.alg = QCE_HASH_SHA256;
-				sreq.authkey = NULL;
-				break;
-			case QCE_HASH_SHA1_HMAC:
-				sreq.alg = QCE_HASH_SHA1_HMAC;
-				sreq.authkey = &sha_ctx->authkey[0];
-				break;
-			case QCE_HASH_SHA256_HMAC:
-				sreq.alg = QCE_HASH_SHA256_HMAC;
-				sreq.authkey = &sha_ctx->authkey[0];
-				break;
-			default:
-				break;
-			};
-			ret =  qce_process_sha_req(cp->qce, &sreq);
-
-		} else {
-			struct aead_request *req = container_of(async_req,
-						struct aead_request, base);
-			struct crypto_aead *aead = crypto_aead_reqtfm(req);
-
-			rctx = aead_request_ctx(req);
-			cipher_ctx = crypto_tfm_ctx(async_req->tfm);
-
-			qreq.op = QCE_REQ_AEAD;
-			qreq.qce_cb = _qce_aead_complete;
-
-			qreq.areq = req;
-			qreq.alg = rctx->alg;
-			qreq.dir = rctx->dir;
-			qreq.mode = rctx->mode;
-			qreq.iv = rctx->iv;
-
-			qreq.enckey = cipher_ctx->enc_key;
-			qreq.encklen = cipher_ctx->enc_key_len;
-			qreq.authkey = cipher_ctx->auth_key;
-			qreq.authklen = cipher_ctx->auth_key_len;
-			qreq.authsize = crypto_aead_authsize(aead);
-			qreq.ivsize =  crypto_aead_ivsize(aead);
-			if (qreq.mode == QCE_MODE_CCM) {
-				if (qreq.dir == QCE_ENCRYPT)
-					qreq.cryptlen = req->cryptlen;
-				else
-					qreq.cryptlen = req->cryptlen -
-								qreq.authsize;
-				
-				ret = qccrypto_set_aead_ccm_nonce(&qreq);
-				if (ret)
-					goto done;
-				
-				ret = qcrypto_aead_ccm_format_adata(&qreq,
-								req->assoclen,
-								req->assoc);
-				if (ret)
-					goto done;
-				rctx->assoc_sg  = req->assoc;
-				rctx->assoclen  = req->assoclen;
-				rctx->assoc  = qreq.assoc;
-				req->assoc = &rctx->asg;
-				req->assoclen = qreq.assoclen;
-				sg_set_buf(req->assoc, qreq.assoc,
-							req->assoclen);
-				sg_mark_end(req->assoc);
-			}
-			ret =  qce_aead_req(cp->qce, &qreq);
-		}
-	};
-done:
-	if (ret) {
-
-		spin_lock_irqsave(&cp->lock, flags);
-		cp->req = NULL;
-		spin_unlock_irqrestore(&cp->lock, flags);
-
-		if (type == CRYPTO_ALG_TYPE_ABLKCIPHER)
-			pstat->ablk_cipher_op_fail++;
-		else
-			if (type == CRYPTO_ALG_TYPE_AHASH)
-				pstat->sha_op_fail++;
-			else
-				pstat->aead_op_fail++;
-
-		async_req->complete(async_req, ret);
-		goto again;
-	};
-};
-
-static int _qcrypto_queue_req(struct crypto_priv *cp,
-				struct crypto_async_request *req)
-{
-	int ret;
-	unsigned long flags;
-
-	if (cp->platform_support.ce_shared) {
-		ret = qcrypto_lock_ce(cp);
-		if (ret)
-			return ret;
-	}
-
-	spin_lock_irqsave(&cp->lock, flags);
-	ret = crypto_enqueue_request(&cp->queue, req);
-	spin_unlock_irqrestore(&cp->lock, flags);
-	_start_qcrypto_process(cp);
-
-	return ret;
-}
-
-static int _qcrypto_enc_aes_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_enc_aes_ecb: %p\n", req);
-#endif
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_aes_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_enc_aes_cbc: %p\n", req);
-#endif
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_aes_ctr(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-				CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_enc_aes_ctr: %p\n", req);
-#endif
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CTR;
-
-	pstat->ablk_cipher_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_aes_xts(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_XTS;
-
-	pstat->ablk_cipher_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_aead_encrypt_aes_ccm(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	if ((ctx->authsize > 16) || (ctx->authsize < 4) || (ctx->authsize & 1))
-		return  -EINVAL;
-	if ((ctx->auth_key_len != AES_KEYSIZE_128) &&
-		(ctx->auth_key_len != AES_KEYSIZE_256))
-		return  -EINVAL;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CCM;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_enc_des_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_des_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_3des_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_3des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_enc_3des_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_3des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_aes_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-				CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_dec_aes_ecb: %p\n", req);
-#endif
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_aes_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-				CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_dec_aes_cbc: %p\n", req);
-#endif
-
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_aes_ctr(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_dec_aes_ctr: %p\n", req);
-#endif
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->mode = QCE_MODE_CTR;
-
-	
-	rctx->dir = QCE_ENCRYPT;
-
-	pstat->ablk_cipher_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_des_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_des_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_3des_ecb(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_ECB;
-
-	pstat->ablk_cipher_3des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_3des_cbc(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-
-	pstat->ablk_cipher_3des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-static int _qcrypto_dec_aes_xts(struct ablkcipher_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	BUG_ON(crypto_tfm_alg_type(req->base.tfm) !=
-					CRYPTO_ALG_TYPE_ABLKCIPHER);
-	rctx = ablkcipher_request_ctx(req);
-	rctx->aead = 0;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->mode = QCE_MODE_XTS;
-	rctx->dir = QCE_DECRYPT;
-
-	pstat->ablk_cipher_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-};
-
-
-static int _qcrypto_aead_decrypt_aes_ccm(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	if ((ctx->authsize > 16) || (ctx->authsize < 4) || (ctx->authsize & 1))
-		return  -EINVAL;
-	if ((ctx->auth_key_len != AES_KEYSIZE_128) &&
-		(ctx->auth_key_len != AES_KEYSIZE_256))
-		return  -EINVAL;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CCM;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_setauthsize(struct crypto_aead *authenc,
-				unsigned int authsize)
-{
-	struct qcrypto_cipher_ctx *ctx = crypto_aead_ctx(authenc);
-
-	ctx->authsize = authsize;
-	return 0;
-}
-
-static int _qcrypto_aead_ccm_setauthsize(struct crypto_aead *authenc,
-				  unsigned int authsize)
-{
-	struct qcrypto_cipher_ctx *ctx = crypto_aead_ctx(authenc);
-
-	switch (authsize) {
-	case 4:
-	case 6:
-	case 8:
-	case 10:
-	case 12:
-	case 14:
-	case 16:
-		break;
-	default:
-		return -EINVAL;
-	}
-	ctx->authsize = authsize;
-	return 0;
-}
-
-static int _qcrypto_aead_setkey(struct crypto_aead *tfm, const u8 *key,
-			unsigned int keylen)
-{
-	struct qcrypto_cipher_ctx *ctx = crypto_aead_ctx(tfm);
-	struct rtattr *rta = (struct rtattr *)key;
-	struct crypto_authenc_key_param *param;
-
-	if (!RTA_OK(rta, keylen))
-		goto badkey;
-	if (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)
-		goto badkey;
-	if (RTA_PAYLOAD(rta) < sizeof(*param))
-		goto badkey;
-
-	param = RTA_DATA(rta);
-	ctx->enc_key_len = be32_to_cpu(param->enckeylen);
-
-	key += RTA_ALIGN(rta->rta_len);
-	keylen -= RTA_ALIGN(rta->rta_len);
-
-	if (keylen < ctx->enc_key_len)
-		goto badkey;
-
-	ctx->auth_key_len = keylen - ctx->enc_key_len;
-	if (ctx->enc_key_len >= QCRYPTO_MAX_KEY_SIZE ||
-				ctx->auth_key_len >= QCRYPTO_MAX_KEY_SIZE)
-		goto badkey;
-	memset(ctx->auth_key, 0, QCRYPTO_MAX_KEY_SIZE);
-	memcpy(ctx->enc_key, key + ctx->auth_key_len, ctx->enc_key_len);
-	memcpy(ctx->auth_key, key, ctx->auth_key_len);
-
-	return 0;
-badkey:
-	ctx->enc_key_len = 0;
-	crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
-	return -EINVAL;
-}
-
-static int _qcrypto_aead_ccm_setkey(struct crypto_aead *aead, const u8 *key,
-			unsigned int keylen)
-{
-	struct crypto_tfm *tfm = crypto_aead_tfm(aead);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
-	struct crypto_priv *cp = ctx->cp;
-
-	switch (keylen) {
-	case AES_KEYSIZE_128:
-	case AES_KEYSIZE_256:
-		break;
-	case AES_KEYSIZE_192:
-		if (cp->ce_support.aes_key_192)
-			break;
-	default:
-		ctx->enc_key_len = 0;
-		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	};
-	ctx->enc_key_len = keylen;
-	memcpy(ctx->enc_key, key, keylen);
-	ctx->auth_key_len = keylen;
-	memcpy(ctx->auth_key, key, keylen);
-
-	return 0;
-}
-
-static int _qcrypto_aead_encrypt_aes_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_aead_encrypt_aes_cbc: %p\n", req);
-#endif
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_decrypt_aes_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-#ifdef QCRYPTO_DEBUG
-	dev_info(&cp->pdev->dev, "_qcrypto_aead_decrypt_aes_cbc: %p\n", req);
-#endif
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_givencrypt_aes_cbc(struct aead_givcrypt_request *req)
-{
-	struct aead_request *areq = &req->areq;
-	struct crypto_aead *authenc = crypto_aead_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(areq);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->giv;	
-
-	memcpy(req->giv, ctx->iv, crypto_aead_ivsize(authenc));
-	 
-	*(__be64 *)req->giv ^= cpu_to_be64(req->seq);
-	pstat->aead_sha1_aes_enc++;
-	return _qcrypto_queue_req(cp, &areq->base);
-}
-
-#ifdef QCRYPTO_AEAD_AES_CTR
-static int _qcrypto_aead_encrypt_aes_ctr(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CTR;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_decrypt_aes_ctr(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-
-	
-	rctx->dir = QCE_ENCRYPT;
-
-	rctx->mode = QCE_MODE_CTR;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_aes_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_givencrypt_aes_ctr(struct aead_givcrypt_request *req)
-{
-	struct aead_request *areq = &req->areq;
-	struct crypto_aead *authenc = crypto_aead_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(areq);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_AES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CTR;
-	rctx->iv = req->giv;	
-
-	memcpy(req->giv, ctx->iv, crypto_aead_ivsize(authenc));
-	 
-	*(__be64 *)req->giv ^= cpu_to_be64(req->seq);
-	pstat->aead_sha1_aes_enc++;
-	return _qcrypto_queue_req(cp, &areq->base);
-};
-#endif 
-
-static int _qcrypto_aead_encrypt_des_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_decrypt_des_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_givencrypt_des_cbc(struct aead_givcrypt_request *req)
-{
-	struct aead_request *areq = &req->areq;
-	struct crypto_aead *authenc = crypto_aead_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(areq);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->giv;	
-
-	memcpy(req->giv, ctx->iv, crypto_aead_ivsize(authenc));
-	 
-	*(__be64 *)req->giv ^= cpu_to_be64(req->seq);
-	pstat->aead_sha1_des_enc++;
-	return _qcrypto_queue_req(cp, &areq->base);
-}
-
-static int _qcrypto_aead_encrypt_3des_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_3des_enc++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_decrypt_3des_cbc(struct aead_request *req)
-{
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(req);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_DECRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->iv;
-
-	pstat->aead_sha1_3des_dec++;
-	return _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _qcrypto_aead_givencrypt_3des_cbc(struct aead_givcrypt_request *req)
-{
-	struct aead_request *areq = &req->areq;
-	struct crypto_aead *authenc = crypto_aead_reqtfm(areq);
-	struct qcrypto_cipher_ctx *ctx = crypto_tfm_ctx(areq->base.tfm);
-	struct crypto_priv *cp = ctx->cp;
-	struct qcrypto_cipher_req_ctx *rctx;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	rctx = aead_request_ctx(areq);
-	rctx->aead = 1;
-	rctx->alg = CIPHER_ALG_3DES;
-	rctx->dir = QCE_ENCRYPT;
-	rctx->mode = QCE_MODE_CBC;
-	rctx->iv = req->giv;	
-
-	memcpy(req->giv, ctx->iv, crypto_aead_ivsize(authenc));
-	 
-	*(__be64 *)req->giv ^= cpu_to_be64(req->seq);
-	pstat->aead_sha1_3des_enc++;
-	return _qcrypto_queue_req(cp, &areq->base);
-}
-
-static int qcrypto_count_sg(struct scatterlist *sg, int nbytes)
-{
-	int i;
-
-	for (i = 0; nbytes > 0; i++, sg = sg_next(sg))
-		nbytes -= sg->length;
-
-	return i;
-}
-
-static int _sha_init(struct qcrypto_sha_ctx *ctx)
-{
-	ctx->first_blk = 1;
-	ctx->last_blk = 0;
-	ctx->byte_count[0] = 0;
-	ctx->byte_count[1] = 0;
-	ctx->byte_count[2] = 0;
-	ctx->byte_count[3] = 0;
-	ctx->trailing_buf_len = 0;
-
-	return 0;
-};
-
-static int _sha1_init(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	_sha_init(sha_ctx);
-	sha_ctx->alg = QCE_HASH_SHA1;
-
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
-						SHA1_DIGEST_SIZE);
-	sha_ctx->diglen = SHA1_DIGEST_SIZE;
-	_update_sha1_ctx(req);
-
-	pstat->sha1_digest++;
-	return 0;
-};
-
-static int _sha256_init(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-
-	_sha_init(sha_ctx);
-	sha_ctx->alg = QCE_HASH_SHA256;
-
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
-						SHA256_DIGEST_SIZE);
-	sha_ctx->diglen = SHA256_DIGEST_SIZE;
-	_update_sha256_ctx(req);
-
-	pstat->sha256_digest++;
-	return 0;
-};
-
-
-static int _sha1_export(struct ahash_request  *req, void *out)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha1_state *sha_state_ctx = &rctx->sha1_state_ctx;
-	struct sha1_state *out_ctx = (struct sha1_state *)out;
-
-	out_ctx->count = sha_state_ctx->count;
-	memcpy(out_ctx->state, sha_state_ctx->state, sizeof(out_ctx->state));
-	memcpy(out_ctx->buffer, sha_state_ctx->buffer, SHA1_BLOCK_SIZE);
-
-	return 0;
-};
-
-static int _sha1_import(struct ahash_request  *req, const void *in)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha1_state *sha_state_ctx = &rctx->sha1_state_ctx;
-	struct sha1_state *in_ctx = (struct sha1_state *)in;
-
-	sha_state_ctx->count = in_ctx->count;
-	memcpy(sha_state_ctx->state, in_ctx->state, sizeof(in_ctx->state));
-	memcpy(sha_state_ctx->buffer, in_ctx->buffer, SHA1_BLOCK_SIZE);
-	memcpy(sha_ctx->trailing_buf, in_ctx->buffer, SHA1_BLOCK_SIZE);
-
-	sha_ctx->byte_count[0] =  (uint32_t)(in_ctx->count & 0xFFFFFFC0);
-	sha_ctx->byte_count[1] =  (uint32_t)(in_ctx->count >> 32);
-	_words_to_byte_stream(in_ctx->state, sha_ctx->digest, sha_ctx->diglen);
-
-	sha_ctx->trailing_buf_len = (uint32_t)(in_ctx->count &
-						(SHA1_BLOCK_SIZE-1));
-
-	if (!(in_ctx->count))
-		sha_ctx->first_blk = 1;
-	else
-		sha_ctx->first_blk = 0;
-
-	return 0;
-}
-static int _sha256_export(struct ahash_request  *req, void *out)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha256_state *sha_state_ctx = &rctx->sha256_state_ctx;
-	struct sha256_state *out_ctx = (struct sha256_state *)out;
-
-	out_ctx->count = sha_state_ctx->count;
-	memcpy(out_ctx->state, sha_state_ctx->state, sizeof(out_ctx->state));
-	memcpy(out_ctx->buf, sha_state_ctx->buf, SHA256_BLOCK_SIZE);
-
-	return 0;
-};
-
-static int _sha256_import(struct ahash_request  *req, const void *in)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha256_state *sha_state_ctx = &rctx->sha256_state_ctx;
-	struct sha256_state *in_ctx = (struct sha256_state *)in;
-
-	sha_state_ctx->count = in_ctx->count;
-	memcpy(sha_state_ctx->state, in_ctx->state, sizeof(in_ctx->state));
-	memcpy(sha_state_ctx->buf, in_ctx->buf, SHA256_BLOCK_SIZE);
-	memcpy(sha_ctx->trailing_buf, in_ctx->buf, SHA256_BLOCK_SIZE);
-
-	sha_ctx->byte_count[0] =  (uint32_t)(in_ctx->count & 0xFFFFFFC0);
-	sha_ctx->byte_count[1] =  (uint32_t)(in_ctx->count >> 32);
-	_words_to_byte_stream(in_ctx->state, sha_ctx->digest, sha_ctx->diglen);
-
-	sha_ctx->trailing_buf_len = (uint32_t)(in_ctx->count &
-						(SHA256_BLOCK_SIZE-1));
-
-	if (!(in_ctx->count))
-		sha_ctx->first_blk = 1;
-	else
-		sha_ctx->first_blk = 0;
-
-	return 0;
-}
-
-
-static int _sha_update(struct ahash_request  *req, uint32_t sha_block_size)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	uint32_t total, len, i, num_sg;
-	uint8_t *k_src = NULL;
-	uint32_t sha_pad_len = 0;
-	uint32_t end_src = 0;
-	uint32_t trailing_buf_len = 0;
-	uint32_t nbytes, index = 0;
-	uint32_t saved_length = 0;
-	int ret = 0;
-
-	
-	total = req->nbytes + sha_ctx->trailing_buf_len;
-	len = req->nbytes;
-
-	if (total <= sha_block_size) {
-		i = 0;
-
-		k_src = &sha_ctx->trailing_buf[sha_ctx->trailing_buf_len];
-		while (len > 0) {
-			memcpy(k_src, sg_virt(&req->src[i]),
-							req->src[i].length);
-			len -= req->src[i].length;
-			k_src += req->src[i].length;
-			i++;
-		}
-		sha_ctx->trailing_buf_len = total;
-		if (sha_ctx->alg == QCE_HASH_SHA1)
-			_update_sha1_ctx(req);
-		if (sha_ctx->alg == QCE_HASH_SHA256)
-			_update_sha256_ctx(req);
-		return 0;
-	}
-
-	
-	rctx->src = req->src;
-	rctx->nbytes = req->nbytes;
-
-	memcpy(sha_ctx->tmp_tbuf, sha_ctx->trailing_buf,
-					sha_ctx->trailing_buf_len);
-	k_src = &sha_ctx->trailing_buf[0];
-	
-	sha_pad_len = ALIGN(total, sha_block_size) - total;
-	trailing_buf_len =  sha_block_size - sha_pad_len;
-	nbytes = total - trailing_buf_len;
-	num_sg = qcrypto_count_sg(req->src, req->nbytes);
-
-	len = sha_ctx->trailing_buf_len;
-	i = 0;
-
-	while (len < nbytes) {
-		if ((len + req->src[i].length) > nbytes)
-			break;
-		len += req->src[i].length;
-		i++;
-	}
-
-	end_src = i;
-	if (len < nbytes) {
-		uint32_t remnant = (nbytes - len);
-		memcpy(k_src, (sg_virt(&req->src[i]) + remnant),
-				(req->src[i].length - remnant));
-		k_src += (req->src[i].length - remnant);
-		saved_length = req->src[i].length;
-		index = i;
-		req->src[i].length = remnant;
-		i++;
-	}
-
-	while (i < num_sg) {
-		memcpy(k_src, sg_virt(&req->src[i]), req->src[i].length);
-		k_src += req->src[i].length;
-		i++;
-	}
-
-	if (sha_ctx->trailing_buf_len) {
-		num_sg = end_src + 2;
-		sha_ctx->sg = kzalloc(num_sg * (sizeof(struct scatterlist)),
-								GFP_KERNEL);
-		if (sha_ctx->sg == NULL) {
-			pr_err("qcrypto Can't Allocate mem: sha_ctx->sg, error %ld\n",
-				PTR_ERR(sha_ctx->sg));
-			return -ENOMEM;
-		}
-
-		sg_set_buf(&sha_ctx->sg[0], sha_ctx->tmp_tbuf,
-						sha_ctx->trailing_buf_len);
-		for (i = 1; i < num_sg; i++)
-			sg_set_buf(&sha_ctx->sg[i], sg_virt(&req->src[i-1]),
-							req->src[i-1].length);
-
-		req->src = sha_ctx->sg;
-		sg_mark_end(&sha_ctx->sg[num_sg - 1]);
-	} else
-		sg_mark_end(&req->src[end_src]);
-
-	req->nbytes = nbytes;
-	if (saved_length > 0)
-		rctx->src[index].length = saved_length;
-	sha_ctx->trailing_buf_len = trailing_buf_len;
-
-	ret =  _qcrypto_queue_req(cp, &req->base);
-
-	return ret;
-};
-
-static int _sha1_update(struct ahash_request  *req)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha1_state *sha_state_ctx = &rctx->sha1_state_ctx;
-
-	sha_state_ctx->count += req->nbytes;
-	return _sha_update(req, SHA1_BLOCK_SIZE);
-}
-
-static int _sha256_update(struct ahash_request  *req)
-{
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct sha256_state *sha_state_ctx = &rctx->sha256_state_ctx;
-
-	sha_state_ctx->count += req->nbytes;
-	return _sha_update(req, SHA256_BLOCK_SIZE);
-}
-
-static int _sha_final(struct ahash_request *req, uint32_t sha_block_size)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	int ret = 0;
-
-	sha_ctx->last_blk = 1;
-
-	
-	rctx->src = req->src;
-	rctx->nbytes = req->nbytes;
-
-	sg_set_buf(&sha_ctx->tmp_sg, sha_ctx->trailing_buf,
-					sha_ctx->trailing_buf_len);
-	sg_mark_end(&sha_ctx->tmp_sg);
-
-	req->src = &sha_ctx->tmp_sg;
-	req->nbytes = sha_ctx->trailing_buf_len;
-
-	ret =  _qcrypto_queue_req(cp, &req->base);
-
-	return ret;
-};
-
-static int _sha1_final(struct ahash_request  *req)
-{
-	return _sha_final(req, SHA1_BLOCK_SIZE);
-}
-
-static int _sha256_final(struct ahash_request  *req)
-{
-	return _sha_final(req, SHA256_BLOCK_SIZE);
-}
-
-static int _sha_digest(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct crypto_priv *cp = sha_ctx->cp;
-	int ret = 0;
-
-	
-	rctx->src = req->src;
-	rctx->nbytes = req->nbytes;
-
-	sha_ctx->last_blk = 1;
-	ret =  _qcrypto_queue_req(cp, &req->base);
-
-	return ret;
-}
-
-static int _sha1_digest(struct ahash_request *req)
-{
-	_sha1_init(req);
-	return _sha_digest(req);
-}
-
-static int _sha256_digest(struct ahash_request *req)
-{
-	_sha256_init(req);
-	return _sha_digest(req);
-}
-
-static void _crypto_sha_hmac_ahash_req_complete(
-	struct crypto_async_request *req, int err)
-{
-	struct completion *ahash_req_complete = req->data;
-
-	if (err == -EINPROGRESS)
-		return;
-	complete(ahash_req_complete);
-}
-
-static int _sha_hmac_setkey(struct crypto_ahash *tfm, const u8 *key,
-		unsigned int len)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(&tfm->base);
-	int ret = 0;
-
-	sha_ctx->in_buf = kzalloc(len, GFP_KERNEL);
-	if (sha_ctx->in_buf == NULL) {
-		pr_err("qcrypto Can't Allocate mem: sha_ctx->in_buf, error %ld\n",
-		PTR_ERR(sha_ctx->in_buf));
-		return -ENOMEM;
-	}
-	memcpy(sha_ctx->in_buf, key, len);
-	sg_set_buf(&sha_ctx->tmp_sg, sha_ctx->in_buf, len);
-	sg_mark_end(&sha_ctx->tmp_sg);
-
-	ahash_request_set_crypt(sha_ctx->ahash_req, &sha_ctx->tmp_sg,
-				&sha_ctx->authkey[0], len);
-
-	ret = _sha_digest(sha_ctx->ahash_req);
-	if (ret == -EINPROGRESS || ret == -EBUSY) {
-		ret =
-			wait_for_completion_interruptible(
-						&sha_ctx->ahash_req_complete);
-		INIT_COMPLETION(sha_ctx->ahash_req_complete);
-	}
-
-	sha_ctx->authkey_in_len = len;
-	kfree(sha_ctx->in_buf);
-	sha_ctx->in_buf = NULL;
-
-	return ret;
-}
-
-static int _sha1_hmac_setkey(struct crypto_ahash *tfm, const u8 *key,
-							unsigned int len)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(&tfm->base);
-
-	if (len <= SHA1_BLOCK_SIZE)
-		memcpy(&sha_ctx->authkey[0], key, len);
-	else {
-		_sha_init(sha_ctx);
-		sha_ctx->alg = QCE_HASH_SHA1;
-		memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
-						SHA1_DIGEST_SIZE);
-		sha_ctx->diglen = SHA1_DIGEST_SIZE;
-		_sha_hmac_setkey(tfm, key, len);
-	}
-	return 0;
-}
-
-static int _sha256_hmac_setkey(struct crypto_ahash *tfm, const u8 *key,
-							unsigned int len)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(&tfm->base);
-
-	if (len <= SHA256_BLOCK_SIZE)
-		memcpy(&sha_ctx->authkey[0], key, len);
-	else {
-		_sha_init(sha_ctx);
-		sha_ctx->alg = QCE_HASH_SHA256;
-		memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
-						SHA256_DIGEST_SIZE);
-		sha_ctx->diglen = SHA256_DIGEST_SIZE;
-		_sha_hmac_setkey(tfm, key, len);
-	}
-
-	return 0;
-}
-
-static int _sha_hmac_init_ihash(struct ahash_request *req,
-						uint32_t sha_block_size)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	int i;
-
-	for (i = 0; i < sha_block_size; i++)
-		sha_ctx->trailing_buf[i] = sha_ctx->authkey[i] ^ 0x36;
-	sha_ctx->trailing_buf_len = sha_block_size;
-
-	return 0;
-}
-
-static int _sha1_hmac_init(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-	int ret = 0;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-	pstat->sha1_hmac_digest++;
-
-	_sha_init(sha_ctx);
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
-						SHA1_DIGEST_SIZE);
-	sha_ctx->diglen = SHA1_DIGEST_SIZE;
-	_update_sha1_ctx(req);
-
-	if (cp->ce_support.sha_hmac)
-			sha_ctx->alg = QCE_HASH_SHA1_HMAC;
-	else {
-		sha_ctx->alg = QCE_HASH_SHA1;
-		ret = _sha_hmac_init_ihash(req, SHA1_BLOCK_SIZE);
-	}
-
-	return ret;
-}
-
-static int _sha256_hmac_init(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-	int ret = 0;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-	pstat->sha256_hmac_digest++;
-
-	_sha_init(sha_ctx);
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
-						SHA256_DIGEST_SIZE);
-	sha_ctx->diglen = SHA256_DIGEST_SIZE;
-	_update_sha256_ctx(req);
-
-	if (cp->ce_support.sha_hmac)
-		sha_ctx->alg = QCE_HASH_SHA256_HMAC;
-	else {
-		sha_ctx->alg = QCE_HASH_SHA256;
-		ret = _sha_hmac_init_ihash(req, SHA256_BLOCK_SIZE);
-	}
-
-	return ret;
-}
-
-static int _sha1_hmac_update(struct ahash_request *req)
-{
-	return _sha1_update(req);
-}
-
-static int _sha256_hmac_update(struct ahash_request *req)
-{
-	return _sha256_update(req);
-}
-
-static int _sha_hmac_outer_hash(struct ahash_request *req,
-		uint32_t sha_digest_size, uint32_t sha_block_size)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct qcrypto_sha_req_ctx *rctx = ahash_request_ctx(req);
-	struct crypto_priv *cp = sha_ctx->cp;
-	int i;
-
-	for (i = 0; i < sha_block_size; i++)
-		sha_ctx->tmp_tbuf[i] = sha_ctx->authkey[i] ^ 0x5c;
-
-	
-	rctx->src = req->src;
-	rctx->nbytes = req->nbytes;
-
-	memcpy(&sha_ctx->tmp_tbuf[sha_block_size], &sha_ctx->digest[0],
-						 sha_digest_size);
-
-	sg_set_buf(&sha_ctx->tmp_sg, sha_ctx->tmp_tbuf, sha_block_size +
-							sha_digest_size);
-	sg_mark_end(&sha_ctx->tmp_sg);
-	req->src = &sha_ctx->tmp_sg;
-	req->nbytes = sha_block_size + sha_digest_size;
-
-	_sha_init(sha_ctx);
-	if (sha_ctx->alg == QCE_HASH_SHA1) {
-		memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
-							SHA1_DIGEST_SIZE);
-		sha_ctx->diglen = SHA1_DIGEST_SIZE;
-	} else {
-		memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
-							SHA256_DIGEST_SIZE);
-		sha_ctx->diglen = SHA256_DIGEST_SIZE;
-	}
-
-	sha_ctx->last_blk = 1;
-	return  _qcrypto_queue_req(cp, &req->base);
-}
-
-static int _sha_hmac_inner_hash(struct ahash_request *req,
-			uint32_t sha_digest_size, uint32_t sha_block_size)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct ahash_request *areq = sha_ctx->ahash_req;
-	struct crypto_priv *cp = sha_ctx->cp;
-	int ret = 0;
-
-	sha_ctx->last_blk = 1;
-
-	sg_set_buf(&sha_ctx->tmp_sg, sha_ctx->trailing_buf,
-					sha_ctx->trailing_buf_len);
-	sg_mark_end(&sha_ctx->tmp_sg);
-
-	ahash_request_set_crypt(areq, &sha_ctx->tmp_sg, &sha_ctx->digest[0],
-						sha_ctx->trailing_buf_len);
-	sha_ctx->last_blk = 1;
-	ret =  _qcrypto_queue_req(cp, &areq->base);
-
-	if (ret == -EINPROGRESS || ret == -EBUSY) {
-		ret =
-		wait_for_completion_interruptible(&sha_ctx->ahash_req_complete);
-		INIT_COMPLETION(sha_ctx->ahash_req_complete);
-	}
-
-	return ret;
-}
-
-static int _sha1_hmac_final(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	int ret = 0;
-
-	if (cp->ce_support.sha_hmac)
-		return _sha_final(req, SHA1_BLOCK_SIZE);
-	else {
-		ret = _sha_hmac_inner_hash(req, SHA1_DIGEST_SIZE,
-							SHA1_BLOCK_SIZE);
-		if (ret)
-			return ret;
-		return _sha_hmac_outer_hash(req, SHA1_DIGEST_SIZE,
-							SHA1_BLOCK_SIZE);
-	}
-}
-
-static int _sha256_hmac_final(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	int ret = 0;
-
-	if (cp->ce_support.sha_hmac)
-		return _sha_final(req, SHA256_BLOCK_SIZE);
-	else {
-		ret = _sha_hmac_inner_hash(req, SHA256_DIGEST_SIZE,
-							SHA256_BLOCK_SIZE);
-		if (ret)
-			return ret;
-		return _sha_hmac_outer_hash(req, SHA256_DIGEST_SIZE,
-							SHA256_BLOCK_SIZE);
-	}
-	return 0;
-}
-
-
-static int _sha1_hmac_digest(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-	pstat->sha1_hmac_digest++;
-
-	_sha_init(sha_ctx);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
-							SHA1_DIGEST_SIZE);
-	sha_ctx->diglen = SHA1_DIGEST_SIZE;
-	sha_ctx->alg = QCE_HASH_SHA1_HMAC;
-
-	return _sha_digest(req);
-}
-
-static int _sha256_hmac_digest(struct ahash_request *req)
-{
-	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
-	struct crypto_priv *cp = sha_ctx->cp;
-	struct crypto_stat *pstat;
-
-	pstat = &_qcrypto_stat[cp->pdev->id];
-	pstat->sha256_hmac_digest++;
-
-	_sha_init(sha_ctx);
-	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
-						SHA256_DIGEST_SIZE);
-	sha_ctx->diglen = SHA256_DIGEST_SIZE;
-	sha_ctx->alg = QCE_HASH_SHA256_HMAC;
-
-	return _sha_digest(req);
-}
-
-static struct ahash_alg _qcrypto_ahash_algos[] = {
-	{
-		.init		=	_sha1_init,
-		.update		=	_sha1_update,
-		.final		=	_sha1_final,
-		.export		=	_sha1_export,
-		.import		=	_sha1_import,
-		.digest		=	_sha1_digest,
-		.halg		= {
-			.digestsize	= SHA1_DIGEST_SIZE,
-			.statesize	= sizeof(struct sha1_state),
-			.base	= {
-				.cra_name	 = "sha1",
-				.cra_driver_name = "qcrypto-sha1",
-				.cra_priority	 = 300,
-				.cra_flags	 = CRYPTO_ALG_TYPE_AHASH |
-							 CRYPTO_ALG_ASYNC,
-				.cra_blocksize	 = SHA1_BLOCK_SIZE,
-				.cra_ctxsize	 =
-						sizeof(struct qcrypto_sha_ctx),
-				.cra_alignmask	 = 0,
-				.cra_type	 = &crypto_ahash_type,
-				.cra_module	 = THIS_MODULE,
-				.cra_init	 = _qcrypto_ahash_cra_init,
-				.cra_exit	 = _qcrypto_ahash_cra_exit,
-			},
-		},
-	},
-	{
-		.init		=	_sha256_init,
-		.update		=	_sha256_update,
-		.final		=	_sha256_final,
-		.export		=	_sha256_export,
-		.import		=	_sha256_import,
-		.digest		=	_sha256_digest,
-		.halg		= {
-			.digestsize	= SHA256_DIGEST_SIZE,
-			.statesize	= sizeof(struct sha256_state),
-			.base		= {
-				.cra_name	 = "sha256",
-				.cra_driver_name = "qcrypto-sha256",
-				.cra_priority	 = 300,
-				.cra_flags	 = CRYPTO_ALG_TYPE_AHASH |
-							CRYPTO_ALG_ASYNC,
-				.cra_blocksize	 = SHA256_BLOCK_SIZE,
-				.cra_ctxsize	 =
-						sizeof(struct qcrypto_sha_ctx),
-				.cra_alignmask	 = 0,
-				.cra_type	 = &crypto_ahash_type,
-				.cra_module	 = THIS_MODULE,
-				.cra_init	 = _qcrypto_ahash_cra_init,
-				.cra_exit	 = _qcrypto_ahash_cra_exit,
-			},
-		},
-	},
-};
-
-static struct ahash_alg _qcrypto_sha_hmac_algos[] = {
-	{
-		.init		=	_sha1_hmac_init,
-		.update		=	_sha1_hmac_update,
-		.final		=	_sha1_hmac_final,
-		.export		=	_sha1_export,
-		.import		=	_sha1_import,
-		.digest		=	_sha1_hmac_digest,
-		.setkey		=	_sha1_hmac_setkey,
-		.halg		= {
-			.digestsize	= SHA1_DIGEST_SIZE,
-			.statesize	= sizeof(struct sha1_state),
-			.base	= {
-				.cra_name	 = "hmac(sha1)",
-				.cra_driver_name = "qcrypto-hmac-sha1",
-				.cra_priority	 = 300,
-				.cra_flags	 = CRYPTO_ALG_TYPE_AHASH |
-							 CRYPTO_ALG_ASYNC,
-				.cra_blocksize	 = SHA1_BLOCK_SIZE,
-				.cra_ctxsize	 =
-						sizeof(struct qcrypto_sha_ctx),
-				.cra_alignmask	 = 0,
-				.cra_type	 = &crypto_ahash_type,
-				.cra_module	 = THIS_MODULE,
-				.cra_init	 = _qcrypto_ahash_hmac_cra_init,
-				.cra_exit	 = _qcrypto_ahash_cra_exit,
-			},
-		},
-	},
-	{
-		.init		=	_sha256_hmac_init,
-		.update		=	_sha256_hmac_update,
-		.final		=	_sha256_hmac_final,
-		.export		=	_sha256_export,
-		.import		=	_sha256_import,
-		.digest		=	_sha256_hmac_digest,
-		.setkey		=	_sha256_hmac_setkey,
-		.halg		= {
-			.digestsize	= SHA256_DIGEST_SIZE,
-			.statesize	= sizeof(struct sha256_state),
-			.base		= {
-				.cra_name	 = "hmac(sha256)",
-				.cra_driver_name = "qcrypto-hmac-sha256",
-				.cra_priority	 = 300,
-				.cra_flags	 = CRYPTO_ALG_TYPE_AHASH |
-							CRYPTO_ALG_ASYNC,
-				.cra_blocksize	 = SHA256_BLOCK_SIZE,
-				.cra_ctxsize	 =
-						sizeof(struct qcrypto_sha_ctx),
-				.cra_alignmask	 = 0,
-				.cra_type	 = &crypto_ahash_type,
-				.cra_module	 = THIS_MODULE,
-				.cra_init	 = _qcrypto_ahash_hmac_cra_init,
-				.cra_exit	 = _qcrypto_ahash_cra_exit,
-			},
-		},
-	},
-};
-
-static struct crypto_alg _qcrypto_ablk_cipher_algos[] = {
-	{
-		.cra_name		= "ecb(aes)",
-		.cra_driver_name	= "qcrypto-ecb-aes",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= AES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.min_keysize	= AES_MIN_KEY_SIZE,
-				.max_keysize	= AES_MAX_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_aes,
-				.encrypt	= _qcrypto_enc_aes_ecb,
-				.decrypt	= _qcrypto_dec_aes_ecb,
-			},
-		},
-	},
-	{
-		.cra_name	= "cbc(aes)",
-		.cra_driver_name = "qcrypto-cbc-aes",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= AES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.ivsize		= AES_BLOCK_SIZE,
-				.min_keysize	= AES_MIN_KEY_SIZE,
-				.max_keysize	= AES_MAX_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_aes,
-				.encrypt	= _qcrypto_enc_aes_cbc,
-				.decrypt	= _qcrypto_dec_aes_cbc,
-			},
-		},
-	},
-	{
-		.cra_name	= "ctr(aes)",
-		.cra_driver_name = "qcrypto-ctr-aes",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= AES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.ivsize		= AES_BLOCK_SIZE,
-				.min_keysize	= AES_MIN_KEY_SIZE,
-				.max_keysize	= AES_MAX_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_aes,
-				.encrypt	= _qcrypto_enc_aes_ctr,
-				.decrypt	= _qcrypto_dec_aes_ctr,
-			},
-		},
-	},
-	{
-		.cra_name		= "ecb(des)",
-		.cra_driver_name	= "qcrypto-ecb-des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= DES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.min_keysize	= DES_KEY_SIZE,
-				.max_keysize	= DES_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_des,
-				.encrypt	= _qcrypto_enc_des_ecb,
-				.decrypt	= _qcrypto_dec_des_ecb,
-			},
-		},
-	},
-	{
-		.cra_name	= "cbc(des)",
-		.cra_driver_name = "qcrypto-cbc-des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= DES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.ivsize		= DES_BLOCK_SIZE,
-				.min_keysize	= DES_KEY_SIZE,
-				.max_keysize	= DES_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_des,
-				.encrypt	= _qcrypto_enc_des_cbc,
-				.decrypt	= _qcrypto_dec_des_cbc,
-			},
-		},
-	},
-	{
-		.cra_name		= "ecb(des3_ede)",
-		.cra_driver_name	= "qcrypto-ecb-3des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.min_keysize	= DES3_EDE_KEY_SIZE,
-				.max_keysize	= DES3_EDE_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_3des,
-				.encrypt	= _qcrypto_enc_3des_ecb,
-				.decrypt	= _qcrypto_dec_3des_ecb,
-			},
-		},
-	},
-	{
-		.cra_name	= "cbc(des3_ede)",
-		.cra_driver_name = "qcrypto-cbc-3des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize	= DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_ablkcipher_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_ablkcipher_init,
-		.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-		.cra_u		= {
-			.ablkcipher = {
-				.ivsize		= DES3_EDE_BLOCK_SIZE,
-				.min_keysize	= DES3_EDE_KEY_SIZE,
-				.max_keysize	= DES3_EDE_KEY_SIZE,
-				.setkey		= _qcrypto_setkey_3des,
-				.encrypt	= _qcrypto_enc_3des_cbc,
-				.decrypt	= _qcrypto_dec_3des_cbc,
-			},
-		},
-	},
-};
-
-static struct crypto_alg _qcrypto_ablk_cipher_xts_algo = {
-	.cra_name	= "xts(aes)",
-	.cra_driver_name = "qcrypto-xts-aes",
-	.cra_priority	= 300,
-	.cra_flags	= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-	.cra_blocksize	= AES_BLOCK_SIZE,
-	.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-	.cra_alignmask	= 0,
-	.cra_type	= &crypto_ablkcipher_type,
-	.cra_module	= THIS_MODULE,
-	.cra_init	= _qcrypto_cra_ablkcipher_init,
-	.cra_exit	= _qcrypto_cra_ablkcipher_exit,
-	.cra_u		= {
-		.ablkcipher = {
-			.ivsize		= AES_BLOCK_SIZE,
-			.min_keysize	= AES_MIN_KEY_SIZE,
-			.max_keysize	= AES_MAX_KEY_SIZE,
-			.setkey		= _qcrypto_setkey_aes,
-			.encrypt	= _qcrypto_enc_aes_xts,
-			.decrypt	= _qcrypto_dec_aes_xts,
-		},
-	},
-};
-
-static struct crypto_alg _qcrypto_aead_sha1_hmac_algos[] = {
-	{
-		.cra_name	= "authenc(hmac(sha1),cbc(aes))",
-		.cra_driver_name = "qcrypto-aead-hmac-sha1-cbc-aes",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-		.cra_blocksize  = AES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_aead_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_aead_init,
-		.cra_exit	= _qcrypto_cra_aead_exit,
-		.cra_u		= {
-			.aead = {
-				.ivsize         = AES_BLOCK_SIZE,
-				.maxauthsize    = SHA1_DIGEST_SIZE,
-				.setkey = _qcrypto_aead_setkey,
-				.setauthsize = _qcrypto_aead_setauthsize,
-				.encrypt = _qcrypto_aead_encrypt_aes_cbc,
-				.decrypt = _qcrypto_aead_decrypt_aes_cbc,
-				.givencrypt = _qcrypto_aead_givencrypt_aes_cbc,
-				.geniv = "<built-in>",
-			}
-		}
-	},
-
-#ifdef QCRYPTO_AEAD_AES_CTR
-	{
-		.cra_name	= "authenc(hmac(sha1),ctr(aes))",
-		.cra_driver_name = "qcrypto-aead-hmac-sha1-ctr-aes",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-		.cra_blocksize  = AES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_aead_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_aead_init,
-		.cra_exit	= _qcrypto_cra_aead_exit,
-		.cra_u		= {
-			.aead = {
-				.ivsize         = AES_BLOCK_SIZE,
-				.maxauthsize    = SHA1_DIGEST_SIZE,
-				.setkey = _qcrypto_aead_setkey,
-				.setauthsize = _qcrypto_aead_setauthsize,
-				.encrypt = _qcrypto_aead_encrypt_aes_ctr,
-				.decrypt = _qcrypto_aead_decrypt_aes_ctr,
-				.givencrypt = _qcrypto_aead_givencrypt_aes_ctr,
-				.geniv = "<built-in>",
-			}
-		}
-	},
-#endif 
-	{
-		.cra_name	= "authenc(hmac(sha1),cbc(des))",
-		.cra_driver_name = "qcrypto-aead-hmac-sha1-cbc-des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-		.cra_blocksize  = DES_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_aead_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_aead_init,
-		.cra_exit	= _qcrypto_cra_aead_exit,
-		.cra_u		= {
-			.aead = {
-				.ivsize         = DES_BLOCK_SIZE,
-				.maxauthsize    = SHA1_DIGEST_SIZE,
-				.setkey = _qcrypto_aead_setkey,
-				.setauthsize = _qcrypto_aead_setauthsize,
-				.encrypt = _qcrypto_aead_encrypt_des_cbc,
-				.decrypt = _qcrypto_aead_decrypt_des_cbc,
-				.givencrypt = _qcrypto_aead_givencrypt_des_cbc,
-				.geniv = "<built-in>",
-			}
-		}
-	},
-	{
-		.cra_name	= "authenc(hmac(sha1),cbc(des3_ede))",
-		.cra_driver_name = "qcrypto-aead-hmac-sha1-cbc-3des",
-		.cra_priority	= 300,
-		.cra_flags	= CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-		.cra_blocksize  = DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-		.cra_alignmask	= 0,
-		.cra_type	= &crypto_aead_type,
-		.cra_module	= THIS_MODULE,
-		.cra_init	= _qcrypto_cra_aead_init,
-		.cra_exit	= _qcrypto_cra_aead_exit,
-		.cra_u		= {
-			.aead = {
-				.ivsize         = DES3_EDE_BLOCK_SIZE,
-				.maxauthsize    = SHA1_DIGEST_SIZE,
-				.setkey = _qcrypto_aead_setkey,
-				.setauthsize = _qcrypto_aead_setauthsize,
-				.encrypt = _qcrypto_aead_encrypt_3des_cbc,
-				.decrypt = _qcrypto_aead_decrypt_3des_cbc,
-				.givencrypt = _qcrypto_aead_givencrypt_3des_cbc,
-				.geniv = "<built-in>",
-			}
-		}
-	},
-};
-
-static struct crypto_alg _qcrypto_aead_ccm_algo = {
-	.cra_name	= "ccm(aes)",
-	.cra_driver_name = "qcrypto-aes-ccm",
-	.cra_priority	= 300,
-	.cra_flags	= CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-	.cra_blocksize  = AES_BLOCK_SIZE,
-	.cra_ctxsize	= sizeof(struct qcrypto_cipher_ctx),
-	.cra_alignmask	= 0,
-	.cra_type	= &crypto_aead_type,
-	.cra_module	= THIS_MODULE,
-	.cra_init	= _qcrypto_cra_aead_init,
-	.cra_exit	= _qcrypto_cra_aead_exit,
-	.cra_u		= {
-		.aead = {
-			.ivsize         = AES_BLOCK_SIZE,
-			.maxauthsize    = SHA1_DIGEST_SIZE,
-			.setkey = _qcrypto_aead_ccm_setkey,
-			.setauthsize = _qcrypto_aead_ccm_setauthsize,
-			.encrypt = _qcrypto_aead_encrypt_aes_ccm,
-			.decrypt = _qcrypto_aead_decrypt_aes_ccm,
-			.geniv = "<built-in>",
-		}
-	}
-};
-
-
-static int  _qcrypto_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	void *handle;
-	struct crypto_priv *cp;
-	int i;
-	struct msm_ce_hw_support *platform_support;
-
-	if (pdev->id >= MAX_CRYPTO_DEVICE) {
-		pr_err("%s: device id %d  exceeds allowed %d\n",
-				__func__, pdev->id, MAX_CRYPTO_DEVICE);
-		return -ENOENT;
-	}
-
-	cp = kzalloc(sizeof(*cp), GFP_KERNEL);
-	if (!cp) {
-		pr_err("qcrypto Memory allocation of q_alg FAIL, error %ld\n",
-				PTR_ERR(cp));
-		return -ENOMEM;
-	}
-
-	
-	handle = qce_open(pdev, &rc);
-	if (handle == NULL) {
-		kfree(cp);
-		platform_set_drvdata(pdev, NULL);
-		return rc;
-	}
-
-	INIT_LIST_HEAD(&cp->alg_list);
-	platform_set_drvdata(pdev, cp);
-	spin_lock_init(&cp->lock);
-	tasklet_init(&cp->done_tasklet, req_done, (unsigned long)cp);
-	crypto_init_queue(&cp->queue, 50);
-	cp->qce = handle;
-	cp->pdev = pdev;
-	qce_hw_support(cp->qce, &cp->ce_support);
-	platform_support = (struct msm_ce_hw_support *)pdev->dev.platform_data;
-	cp->platform_support.ce_shared = platform_support->ce_shared;
-	cp->platform_support.shared_ce_resource =
-				platform_support->shared_ce_resource;
-	cp->platform_support.hw_key_support =
-				platform_support->hw_key_support;
-	cp->platform_support.bus_scale_table =
-				platform_support->bus_scale_table;
-	cp->high_bw_req_count = 0;
-	cp->ce_lock_count = 0;
-	cp->platform_support.sha_hmac = platform_support->sha_hmac;
-
-	if (cp->platform_support.ce_shared)
-		INIT_WORK(&cp->unlock_ce_ws, qcrypto_unlock_ce);
-
-	if (cp->platform_support.bus_scale_table != NULL) {
-		cp->bus_scale_handle =
-			msm_bus_scale_register_client(
-				(struct msm_bus_scale_pdata *)
-					cp->platform_support.bus_scale_table);
-		if (!cp->bus_scale_handle) {
-			printk(KERN_ERR "%s not able to get bus scale\n",
-				__func__);
-			rc =  -ENOMEM;
-			goto err;
-		}
-	}
-
-	
-	for (i = 0; i < ARRAY_SIZE(_qcrypto_ablk_cipher_algos); i++) {
-		struct qcrypto_alg *q_alg;
-
-		q_alg = _qcrypto_cipher_alg_alloc(cp,
-					&_qcrypto_ablk_cipher_algos[i]);
-		if (IS_ERR(q_alg)) {
-			rc = PTR_ERR(q_alg);
-			goto err;
-		}
-		rc = crypto_register_alg(&q_alg->cipher_alg);
-		if (rc) {
-			dev_err(&pdev->dev, "%s alg registration failed\n",
-					q_alg->cipher_alg.cra_driver_name);
-			kfree(q_alg);
-		} else {
-			list_add_tail(&q_alg->entry, &cp->alg_list);
-			dev_info(&pdev->dev, "%s\n",
-					q_alg->cipher_alg.cra_driver_name);
-		}
-	}
-
-	
-	if (cp->ce_support.aes_xts) {
-		struct qcrypto_alg *q_alg;
-
-		q_alg = _qcrypto_cipher_alg_alloc(cp,
-					&_qcrypto_ablk_cipher_xts_algo);
-		if (IS_ERR(q_alg)) {
-			rc = PTR_ERR(q_alg);
-			goto err;
-		}
-		rc = crypto_register_alg(&q_alg->cipher_alg);
-		if (rc) {
-			dev_err(&pdev->dev, "%s alg registration failed\n",
-					q_alg->cipher_alg.cra_driver_name);
-			kfree(q_alg);
-		} else {
-			list_add_tail(&q_alg->entry, &cp->alg_list);
-			dev_info(&pdev->dev, "%s\n",
-					q_alg->cipher_alg.cra_driver_name);
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(_qcrypto_ahash_algos); i++) {
-		struct qcrypto_alg *q_alg = NULL;
-
-		q_alg = _qcrypto_sha_alg_alloc(cp, &_qcrypto_ahash_algos[i]);
-
-		if (IS_ERR(q_alg)) {
-			rc = PTR_ERR(q_alg);
-			goto err;
-		}
-
-		rc = crypto_register_ahash(&q_alg->sha_alg);
-		if (rc) {
-			dev_err(&pdev->dev, "%s alg registration failed\n",
-				q_alg->sha_alg.halg.base.cra_driver_name);
-			kfree(q_alg);
-		} else {
-			list_add_tail(&q_alg->entry, &cp->alg_list);
-			dev_info(&pdev->dev, "%s\n",
-				q_alg->sha_alg.halg.base.cra_driver_name);
-		}
-	}
-
-	
-	if (cp->ce_support.sha1_hmac_20 || cp->ce_support.sha1_hmac) {
-		for (i = 0; i < ARRAY_SIZE(_qcrypto_aead_sha1_hmac_algos);
-									i++) {
-			struct qcrypto_alg *q_alg;
-
-			q_alg = _qcrypto_cipher_alg_alloc(cp,
-					&_qcrypto_aead_sha1_hmac_algos[i]);
-			if (IS_ERR(q_alg)) {
-				rc = PTR_ERR(q_alg);
-				goto err;
-			}
-
-			rc = crypto_register_alg(&q_alg->cipher_alg);
-			if (rc) {
-				dev_err(&pdev->dev,
-					"%s alg registration failed\n",
-					q_alg->cipher_alg.cra_driver_name);
-				kfree(q_alg);
-			} else {
-				list_add_tail(&q_alg->entry, &cp->alg_list);
-				dev_info(&pdev->dev, "%s\n",
-					q_alg->cipher_alg.cra_driver_name);
-			}
-		}
-	}
-
-	if ((cp->ce_support.sha_hmac) || (cp->platform_support.sha_hmac)) {
-		
-		for (i = 0; i < ARRAY_SIZE(_qcrypto_sha_hmac_algos); i++) {
-			struct qcrypto_alg *q_alg = NULL;
-
-			q_alg = _qcrypto_sha_alg_alloc(cp,
-						&_qcrypto_sha_hmac_algos[i]);
-
-			if (IS_ERR(q_alg)) {
-				rc = PTR_ERR(q_alg);
-				goto err;
-			}
-
-			rc = crypto_register_ahash(&q_alg->sha_alg);
-			if (rc) {
-				dev_err(&pdev->dev,
-				"%s alg registration failed\n",
-				q_alg->sha_alg.halg.base.cra_driver_name);
-				kfree(q_alg);
-			} else {
-				list_add_tail(&q_alg->entry, &cp->alg_list);
-				dev_info(&pdev->dev, "%s\n",
-				q_alg->sha_alg.halg.base.cra_driver_name);
-			}
-		}
-	}
-	if (cp->ce_support.aes_ccm) {
-		struct qcrypto_alg *q_alg;
-
-		q_alg = _qcrypto_cipher_alg_alloc(cp, &_qcrypto_aead_ccm_algo);
-		if (IS_ERR(q_alg)) {
-			rc = PTR_ERR(q_alg);
-			goto err;
-		}
-		rc = crypto_register_alg(&q_alg->cipher_alg);
-		if (rc) {
-			dev_err(&pdev->dev, "%s alg registration failed\n",
-					q_alg->cipher_alg.cra_driver_name);
-			kfree(q_alg);
-		} else {
-			list_add_tail(&q_alg->entry, &cp->alg_list);
-			dev_info(&pdev->dev, "%s\n",
-					q_alg->cipher_alg.cra_driver_name);
-		}
-	}
-
-	return 0;
-err:
-	_qcrypto_remove(pdev);
-	return rc;
-};
-
-static struct platform_driver _qualcomm_crypto = {
-	.probe          = _qcrypto_probe,
-	.remove         = _qcrypto_remove,
-	.driver         = {
-		.owner  = THIS_MODULE,
-		.name   = "qcrypto",
-	},
-};
-
-static int _debug_qcrypto[MAX_CRYPTO_DEVICE];
-
-static int _debug_stats_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t _debug_stats_read(struct file *file, char __user *buf,
-			size_t count, loff_t *ppos)
-{
-	int rc = -EINVAL;
-	int qcrypto = *((int *) file->private_data);
-	int len;
-
-	len = _disp_stats(qcrypto);
-
-	rc = simple_read_from_buffer((void __user *) buf, len,
-			ppos, (void *) _debug_read_buf, len);
-
-	return rc;
-}
-
-static ssize_t _debug_stats_write(struct file *file, const char __user *buf,
-			size_t count, loff_t *ppos)
-{
-
-	int qcrypto = *((int *) file->private_data);
-
-	memset((char *)&_qcrypto_stat[qcrypto], 0, sizeof(struct crypto_stat));
-	return count;
-};
-
-static const struct file_operations _debug_stats_ops = {
-	.open =         _debug_stats_open,
-	.read =         _debug_stats_read,
-	.write =        _debug_stats_write,
-};
-
-static int _qcrypto_debug_init(void)
-{
-	int rc;
-	char name[DEBUG_MAX_FNAME];
-	int i;
-	struct dentry *dent;
-
-	_debug_dent = debugfs_create_dir("qcrypto", NULL);
-	if (IS_ERR(_debug_dent)) {
-		pr_err("qcrypto debugfs_create_dir fail, error %ld\n",
-				PTR_ERR(_debug_dent));
-		return PTR_ERR(_debug_dent);
-	}
-
-	for (i = 0; i < MAX_CRYPTO_DEVICE; i++) {
-		snprintf(name, DEBUG_MAX_FNAME-1, "stats-%d", i+1);
-		_debug_qcrypto[i] = i;
-		dent = debugfs_create_file(name, 0644, _debug_dent,
-				&_debug_qcrypto[i], &_debug_stats_ops);
-		if (dent == NULL) {
-			pr_err("qcrypto debugfs_create_file fail, error %ld\n",
-					PTR_ERR(dent));
-			rc = PTR_ERR(dent);
-			goto err;
-		}
-	}
-	return 0;
-err:
-	debugfs_remove_recursive(_debug_dent);
-	return rc;
-}
-
-static int __init _qcrypto_init(void)
-{
-	int rc;
-
-	rc = _qcrypto_debug_init();
-	if (rc)
-		return rc;
-
-	return platform_driver_register(&_qualcomm_crypto);
-}
-
-static void __exit _qcrypto_exit(void)
-{
-	pr_debug("%s Unregister QCRYPTO\n", __func__);
-	debugfs_remove_recursive(_debug_dent);
-	platform_driver_unregister(&_qualcomm_crypto);
-}
-
-module_init(_qcrypto_init);
-module_exit(_qcrypto_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Mona Hossain <mhossain@codeaurora.org>");
-MODULE_DESCRIPTION("Qualcomm Crypto driver");
-MODULE_VERSION("1.21");
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcryptohw_40.h monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcryptohw_40.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/crypto/msm/qcryptohw_40.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/crypto/msm/qcryptohw_40.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,307 +0,0 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef _DRIVERS_CRYPTO_MSM_QCRYPTOHW_40_H_
-#define _DRIVERS_CRYPTO_MSM_QCRYPTOHW_40_H_
-
-
-#define QCE_AUTH_REG_BYTE_COUNT 4
-#define CRYPTO_VERSION_REG			0x0
-#define CRYPTO_DATA_IN_REG			0x008
-#define CRYPTO_DATA_OUT_REG			0x010
-#define CRYPTO_STATUS_REG			0x100
-#define CRYPTO_ENGINES_AVAIL			0x104
-#define CRYPTO3_VERSION_REG			0x108
-#define CRYPTO_SEG_SIZE_REG			0x200
-#define CRYPTO_GOPROC_REG			0x204
-#define CRYPTO_ENCR_SEG_CFG_REG			0x300
-
-#define CRYPTO_ENCR_SEG_SIZE_REG		0x304
-#define CRYPTO_ENCR_SEG_START_REG		0x308
-
-#define CRYPTO_ENCR_KEY0_REG			0x310
-#define CRYPTO_ENCR_KEY1_REG			0x314
-#define CRYPTO_ENCR_KEY2_REG			0x318
-#define CRYPTO_ENCR_KEY3_REG			0x31C
-#define CRYPTO_ENCR_KEY4_REG			0x320
-#define CRYPTO_ENCR_KEY5_REG			0x324
-#define CRYPTO_ENCR_KEY6_REG			0x328
-#define CRYPTO_ENCR_KEY7_REG			0x32C
-
-#define CRYPTO_ENCR_XTS_KEY0_REG		0x330
-#define CRYPTO_ENCR_XTS_KEY1_REG		0x334
-#define CRYPTO_ENCR_XTS_KEY2_REG		0x338
-#define CRYPTO_ENCR_XTS_KEY3_REG		0x33C
-#define CRYPTO_ENCR_XTS_KEY4_REG		0x340
-#define CRYPTO_ENCR_XTS_KEY5_REG		0x344
-#define CRYPTO_ENCR_XTS_KEY6_REG		0x348
-#define CRYPTO_ENCR_XTS_KEY7_REG		0x34C
-
-#define CRYPTO_CNTR0_IV0_REG			0x350
-#define CRYPTO_CNTR1_IV1_REG			0x354
-#define CRYPTO_CNTR2_IV2_REG			0x358
-#define CRYPTO_CNTR3_IV3_REG			0x35C
-
-#define CRYPTO_CNTR_MASK_REG			0x360
-
-#define CRYPTO_ENCR_XTS_DU_SIZE_REG		0x364
-
-#define CRYPTO_AUTH_SEG_CFG_REG			0x400
-#define CRYPTO_AUTH_SEG_SIZE_REG		0x404
-#define CRYPTO_AUTH_SEG_START_REG		0x408
-
-#define CRYPTO_AUTH_KEY0_REG			0x410
-#define CRYPTO_AUTH_KEY1_REG			0x414
-#define CRYPTO_AUTH_KEY2_REG			0x418
-#define CRYPTO_AUTH_KEY3_REG			0x41C
-#define CRYPTO_AUTH_KEY4_REG			0x420
-#define CRYPTO_AUTH_KEY5_REG			0x424
-#define CRYPTO_AUTH_KEY6_REG			0x428
-#define CRYPTO_AUTH_KEY7_REG			0x42C
-#define CRYPTO_AUTH_KEY8_REG			0x430
-#define CRYPTO_AUTH_KEY9_REG			0x434
-#define CRYPTO_AUTH_KEY10_REG			0x438
-#define CRYPTO_AUTH_KEY11_REG			0x43C
-#define CRYPTO_AUTH_KEY12_REG			0x440
-#define CRYPTO_AUTH_KEY13_REG			0x444
-#define CRYPTO_AUTH_KEY14_REG			0x448
-#define CRYPTO_AUTH_KEY15_REG			0x44C
-
-#define CRYPTO_AUTH_IV0_REG			0x450
-#define CRYPTO_AUTH_IV1_REG			0x454
-#define CRYPTO_AUTH_IV2_REG			0x458
-#define CRYPTO_AUTH_IV3_REG			0x45C
-#define CRYPTO_AUTH_IV4_REG			0x460
-#define CRYPTO_AUTH_IV5_REG			0x464
-#define CRYPTO_AUTH_IV6_REG			0x468
-#define CRYPTO_AUTH_IV7_REG			0x46C
-#define CRYPTO_AUTH_IV8_REG			0x470
-#define CRYPTO_AUTH_IV9_REG			0x474
-#define CRYPTO_AUTH_IV10_REG			0x478
-#define CRYPTO_AUTH_IV11_REG			0x47C
-#define CRYPTO_AUTH_IV12_REG			0x480
-#define CRYPTO_AUTH_IV13_REG			0x484
-#define CRYPTO_AUTH_IV14_REG			0x488
-#define CRYPTO_AUTH_IV15_REG			0x48C
-
-#define CRYPTO_AUTH_INFO_NONCE0_REG		0x490
-#define CRYPTO_AUTH_INFO_NONCE1_REG		0x494
-#define CRYPTO_AUTH_INFO_NONCE2_REG		0x498
-#define CRYPTO_AUTH_INFO_NONCE3_REG		0x49C
-
-#define CRYPTO_AUTH_BYTECNT0_REG		0x4A0
-#define CRYPTO_AUTH_BYTECNT1_REG		0x4A4
-#define CRYPTO_AUTH_BYTECNT2_REG		0x4A8
-#define CRYPTO_AUTH_BYTECNT3_REG		0x4AC
-
-#define CRYPTO_AUTH_EXP_MAC0_REG		0x4B0
-#define CRYPTO_AUTH_EXP_MAC1_REG		0x4B4
-#define CRYPTO_AUTH_EXP_MAC2_REG		0x4B8
-#define CRYPTO_AUTH_EXP_MAC3_REG		0x4BC
-#define CRYPTO_AUTH_EXP_MAC4_REG		0x4C0
-#define CRYPTO_AUTH_EXP_MAC5_REG		0x4C4
-#define CRYPTO_AUTH_EXP_MAC6_REG		0x4C8
-#define CRYPTO_AUTH_EXP_MAC7_REG		0x4CC
-
-#define CRYPTO_CONFIG_REG			0x500
-#define CRYPTO_SACR_REG				0x504
-#define CRYPTO_DEBUG_REG			0x508
-
-#define CRYPTO_DATA_SHADOW0			0x8000
-#define CRYPTO_DATA_SHADOW8191			0x8FFC
-
-
-
-#define CRYPTO_CORE_MAJOR_REV			4 
-#define CRYPTO_CORE_MAJOR_REV_MASK		(0xF << CRYPTO_CORE_MAJOR_REV)
-#define CRYPTO_CORE_MINOR_REV			0 
-#define CRYPTO_CORE_MINOR_REV_MASK		(0xF << CRYPTO_CORE_MINOR_REV)
-#define CRYPTO_CORE_REV_MASK			0xFF
-
-#define CRYPTO_MAC_FAILED			25
-#define CRYPTO_DOUT_SIZE_AVAIL			22 
-#define CRYPTO_DOUT_SIZE_AVAIL_MASK		(0x7 << CRYPTO_DOUT_SIZE_AVAIL)
-#define CRYPTO_DIN_SIZE_AVAIL			19 
-#define CRYPTO_DIN_SIZE_AVAIL_MASK		(0x7 << CRYPTO_DIN_SIZE_AVAIL)
-#define CRYPTO_ACCESS_VIOL			18
-#define CRYPTO_SEG_CHNG_ERR			17
-#define CRYPTO_CFH_CHNG_ERR			16
-#define CRYPTO_DOUT_ERR				15
-#define CRYPTO_DIN_ERR				14
-#define CRYPTO_LOCKED				13
-#define CRYPTO_CRYPTO_STATE			10 
-#define CRYPTO_CRYPTO_STATE_MASK		(0x7 << CRYPTO_CRYPTO_STATE)
-#define CRYPTO_ENCR_BUSY			9
-#define CRYPTO_AUTH_BUSY			8
-#define CRYPTO_DOUT_INTR			7
-#define CRYPTO_DIN_INTR				6
-#define CRYPTO_OP_DONE_INTR			5
-#define CRYPTO_ERR_INTR				4
-#define CRYPTO_DOUT_RDY				3
-#define CRYPTO_DIN_RDY				2
-#define CRYPTO_OPERATION_DONE			1
-#define CRYPTO_SW_ERR				0
-
-#define CRYPTO_REQ_SIZE				30 
-#define CRYPTO_REQ_SIZE_MASK			(0x3 << CRYPTO_REQ_SIZE)
-#define CRYPTO_REQ_SIZE_ENUM_16_BYTES	0
-#define CRYPTO_REQ_SIZE_ENUM_32_BYTES	1
-#define CRYPTO_REQ_SIZE_ENUM_64_BYTES	2
-
-#define CRYPTO_MAX_QUEUED_REQ			27 
-#define CRYPTO_MAX_QUEUED_REQ_MASK		(0x7 << CRYPTO_MAX_QUEUED_REQ)
-#define CRYPTO_ENUM1_QUEUED_REQS		0
-#define CRYPTO_ENUM2_QUEUED_REQS		1
-#define CRYPTO_ENUM3_QUEUED_REQS		2
-#define CRYPTO_ENUM4_QUEUED_REQS		3
-
-#define CRYPTO_FIFO_THRESHOLD			24 
-#define CRYPTO_FIFO_THRESHOLD_MASK		(0x7 << CRYPTO_FIFO_THRESHOLD)
-#define CRYPTO_FIFO_ENUM_16_BYTES		0
-#define CRYPTO_FIFO_ENUM_32_BYTES		1
-#define CRYPTO_FIFO_ENUM_48_BYTES		2
-#define CRYPTO_FIFO_ENUM_64_BYTES		3
-
-#define CRYPTO_IRQ_ENABLES			20	
-#define CRYPTO_IRQ_ENABLES_MASK			(0xF << CRYPTO_IRQ_ENABLES)
-
-#define CRYPTO_ACR_EN				18
-#define CRYPTO_BAM_MODE				17
-#define CRYPTO_LITTLE_ENDIAN_MODE		16
-#define CRYPTO_HIGH_SPD_OUT_EN_N		14
-#define CRYPTO_HIGH_SPD_IN_EN_N			13
-#define CRYPTO_DBG_EN				12
-
-#define CRYPTO_DBG_SEL				7 
-#define CRYPTO_DBG_SEL_MASK			(0x1F << CRYPTO_DBG_SEL)
-
-#define CRYPTO_MASK_DOUT_INTR			6
-#define CRYPTO_MASK_DIN_INTR			5
-#define CRYPTO_MASK_OP_DONE_INTR		4
-#define CRYPTO_MASK_ERR_INTR			3
-#define CRYPTO_AUTO_SHUTDOWN_EN			2
-#define CRYPTO_CLK_EN_N				1
-
-#define CRYPTO_COMP_EXP_MAC			20
-#define CRYPTO_COMP_EXP_MAC_DISABLED		0
-#define CRYPTO_COMP_EXP_MAC_ENABLED		1
-
-#define CRYPTO_F9_DIRECTION			19
-#define CRYPTO_F9_DIRECTION_UPLINK		0
-#define CRYPTO_F9_DIRECTION_DOWNLINK		1
-
-#define CRYPTO_AUTH_NONCE_NUM_WORDS		16
-#define CRYPTO_AUTH_NONCE_NUM_WORDS_MASK \
-					(0x7 << CRYPTO_AUTH_NONCE_NUM_WORDS)
-
-#define CRYPTO_USE_HW_KEY_AUTH			15
-
-#define CRYPTO_LAST				14
-
-#define CRYPTO_AUTH_POS				12 
-#define CRYPTO_AUTH_POS_MASK			(0x3 << CRYPTO_AUTH_POS)
-#define CRYPTO_AUTH_POS_BEFORE			0
-#define CRYPTO_AUTH_POS_AFTER			1
-
-#define CRYPTO_AUTH_SIZE			9 
-#define CRYPTO_AUTH_SIZE_MASK			(0x7 << CRYPTO_AUTH_SIZE)
-#define CRYPTO_AUTH_SIZE_SHA1			0
-#define CRYPTO_AUTH_SIZE_SHA256			1
-#define CRYPTO_AUTH_SIZE_ENUM_4_BYTES		0
-#define CRYPTO_AUTH_SIZE_ENUM_6_BYTES		1
-#define CRYPTO_AUTH_SIZE_ENUM_8_BYTES		2
-#define CRYPTO_AUTH_SIZE_ENUM_10_BYTES		3
-#define CRYPTO_AUTH_SIZE_ENUM_12_BYTES		4
-#define CRYPTO_AUTH_SIZE_ENUM_14_BYTES		5
-#define CRYPTO_AUTH_SIZE_ENUM_16_BYTES		6
-
-#define CRYPTO_AUTH_MODE			6 
-#define CRYPTO_AUTH_MODE_MASK			(0x7 << CRYPTO_AUTH_MODE)
-#define CRYPTO_AUTH_MODE_HASH			0
-#define CRYPTO_AUTH_MODE_HMAC			1
-#define CRYPTO_AUTH_MODE_CCM			0
-#define CRYPTO_AUTH_MODE_CMAC			1
-
-#define CRYPTO_AUTH_KEY_SIZE			3
-#define CRYPTO_AUTH_KEY_SIZE_MASK		(0x7 << CRYPTO_AUTH_KEY_SIZE)
-#define CRYPTO_AUTH_KEY_SZ_AES128		0
-#define CRYPTO_AUTH_KEY_SZ_AES256		2
-
-#define CRYPTO_AUTH_ALG				0 
-#define CRYPTO_AUTH_ALG_MASK			7
-#define CRYPTO_AUTH_ALG_NONE			0
-#define CRYPTO_AUTH_ALG_SHA			1
-#define CRYPTO_AUTH_ALG_AES			2
-#define CRYPTO_AUTH_ALG_KASUMI			3
-#define CRYPTO_AUTH_ALG_SNOW3G			4
-
-#define CRYPTO_ENCR_XTS_DU_SIZE			0 
-#define CRYPTO_ENCR_XTS_DU_SIZE_MASK		0xfffff
-
-#define CRYPTO_F8_KEYSTREAM_ENABLE		15
-#define CRYPTO_F8_KEYSTREAM_DISABLED		0
-#define CRYPTO_F8_KEYSTREAM_ENABLED		1
-
-#define CRYPTO_F8_DIRECTION			14
-#define CRYPTO_F8_DIRECTION_UPLINK		0
-#define CRYPTO_F8_DIRECTION_DOWNLINK		1
-
-#define CRYPTO_USE_HW_KEY_ENCR			13
-#define CRYPTO_USE_HW_KEY_REG			0
-#define CRYPTO_USE_HW_KEY			1
-
-#define CRYPTO_CNTR_ALG				11 
-#define CRYPTO_CNTR_ALG_MASK			(3 << CRYPTO_CNTR_ALG)
-#define CRYPTO_CNTR_ALG_NIST			0
-
-#define CRYPTO_ENCODE				10
-
-#define CRYPTO_ENCR_MODE			6 
-#define CRYPTO_ENCR_MODE_MASK			(0xF << CRYPTO_ENCR_MODE)
-#define CRYPTO_ENCR_MODE_ECB			0
-#define CRYPTO_ENCR_MODE_CBC			1
-#define CRYPTO_ENCR_MODE_CTR			2
-#define CRYPTO_ENCR_MODE_XTS			3
-#define CRYPTO_ENCR_MODE_CCM			4
-
-#define CRYPTO_ENCR_KEY_SZ			3 
-#define CRYPTO_ENCR_KEY_SZ_MASK			(7 << CRYPTO_ENCR_KEY_SZ)
-#define CRYPTO_ENCR_KEY_SZ_DES			0
-#define CRYPTO_ENCR_KEY_SZ_3DES			1
-#define CRYPTO_ENCR_KEY_SZ_AES128		0
-#define CRYPTO_ENCR_KEY_SZ_AES256		2
-#define CRYPTO_ENCR_KEY_SZ_UEA1			0
-#define CRYPTO_ENCR_KEY_SZ_UEA2			1
-
-#define CRYPTO_ENCR_ALG				0 
-#define CRYPTO_ENCR_ALG_MASK			(7 << CRYPTO_ENCR_ALG)
-#define CRYPTO_ENCR_ALG_NONE			0
-#define CRYPTO_ENCR_ALG_DES			1
-#define CRYPTO_ENCR_ALG_AES			2
-#define CRYPTO_ENCR_ALG_KASUMI			3
-#define CRYPTO_ENCR_ALG_SNOW_3G			5
-
-#define CRYPTO_GO				0
-#define CRYPTO_CLR_CNTXT			1
-
-#define CRYPTO_ENCR_AES_SEL			0
-#define CRYPTO_DES_SEL				3
-#define CRYPTO_ENCR_SNOW3G_SEL			4
-#define CRYPTO_ENCR_KASUMI_SEL			5
-#define CRYPTO_SHA_SEL				6
-#define CRYPTO_SHA512_SEL			7
-#define CRYPTO_AUTH_AES_SEL			8
-#define CRYPTO_AUTH_SNOW3G_SEL			9
-#define CRYPTO_AUTH_KASUMI_SEL			10
-#define CRYPTO_BAM_SEL				11
-
-#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpio/gpio-msm-common.c monarudo-jb-3.4.10-e22f38b/drivers/gpio/gpio-msm-common.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpio/gpio-msm-common.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpio/gpio-msm-common.c	2013-08-01 23:38:02.000000000 -0600
@@ -43,6 +43,11 @@
 #define GPIO_PM_USR_INTz       (104)
 #endif
 
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+extern uint16_t get_power_key_gpio(void);
+static char log_buf[DIV_ROUND_UP(NR_MSM_GPIOS, 32)*9+1];
+#endif
+
 #ifdef CONFIG_GPIO_MSM_V3
 enum msm_tlmm_register {
 	SDC4_HDRV_PULL_CTL = 0x0, 
@@ -357,6 +362,21 @@
 	if (msm_gpio_irq_extn.irq_set_wake)
 		msm_gpio_irq_extn.irq_set_wake(d, on);
 
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+	if (gpio==get_power_key_gpio()) {
+		static int counter = 0;
+		if (counter!=0) {
+			pr_info("[KEY_ERR]%s: Power Key set wake: %d, counter=%d\n", __func__, on, counter);
+			dump_stack();
+		}
+		bitmap_scnprintf(log_buf, sizeof(log_buf), msm_gpio.wake_irqs,
+			NR_MSM_GPIOS);
+		log_buf[sizeof(log_buf) - 1] = '\0';
+		pr_info("%s: wake_irqs: %s", __func__, log_buf);
+		counter++;
+	}
+#endif
+
 	return 0;
 }
 
@@ -424,6 +444,12 @@
 	unsigned long irq_flags;
 	unsigned long i;
 
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+	bitmap_scnprintf(log_buf, sizeof(log_buf), msm_gpio.wake_irqs,
+		NR_MSM_GPIOS);
+	log_buf[sizeof(log_buf) - 1] = '\0';
+	pr_info("%s: wake_irqs: %s", __func__, log_buf);
+#endif
 	spin_lock_irqsave(&tlmm_lock, irq_flags);
 	for_each_set_bit(i, msm_gpio.enabled_irqs, NR_MSM_GPIOS)
 		__msm_gpio_set_intr_cfg_enable(i, 0);
@@ -468,6 +494,12 @@
 
 	msm_gpio_show_resume_irq();
 
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+	bitmap_scnprintf(log_buf, sizeof(log_buf), msm_gpio.wake_irqs,
+		NR_MSM_GPIOS);
+	log_buf[sizeof(log_buf) - 1] = '\0';
+	pr_info("%s: wake_irqs: %s", __func__, log_buf);
+#endif
 	spin_lock_irqsave(&tlmm_lock, irq_flags);
 	for_each_set_bit(i, msm_gpio.wake_irqs, NR_MSM_GPIOS)
 		__msm_gpio_set_intr_cfg_enable(i, 0);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/ion/ion_iommu_heap.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/ion/ion_iommu_heap.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/ion/ion_iommu_heap.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/ion/ion_iommu_heap.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,13 +12,15 @@
  */
 #include <linux/err.h>
 #include <linux/io.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/iommu.h>
 #include <linux/pfn.h>
+#include <linux/dma-mapping.h>
 #include "ion_priv.h"
 
 #include <asm/mach/map.h>
@@ -33,38 +35,120 @@
 
 struct ion_iommu_priv_data {
 	struct page **pages;
+	unsigned int pages_uses_vmalloc;
 	int nrpages;
 	unsigned long size;
 };
 
+#define MAX_VMAP_RETRIES 10
+
+static const unsigned int orders[] = {8, 4, 0};
+static const int num_orders = ARRAY_SIZE(orders);
+
+struct page_info {
+	struct page *page;
+	unsigned int order;
+	struct list_head list;
+};
+
 atomic_t v = ATOMIC_INIT(0);
 
+static unsigned int order_to_size(int order)
+{
+	return PAGE_SIZE << order;
+}
+
+static struct page_info *alloc_largest_available(unsigned long size,
+						unsigned int max_order)
+{
+	struct page *page;
+	struct page_info *info;
+	int i;
+
+	for (i = 0; i < num_orders; i++) {
+		gfp_t gfp;
+		if (size < order_to_size(orders[i]))
+			continue;
+		if (max_order < orders[i])
+			continue;
+
+		gfp = __GFP_HIGHMEM;
+
+		if (orders[i]) {
+			gfp |= __GFP_COMP | __GFP_NORETRY |
+			       __GFP_NO_KSWAPD | __GFP_NOWARN;
+		} else {
+			gfp |= GFP_KERNEL;
+		}
+		page = alloc_pages(gfp, orders[i]);
+		if (!page)
+			continue;
+
+		info = kmalloc(sizeof(struct page_info), GFP_KERNEL);
+		info->page = page;
+		info->order = orders[i];
+		return info;
+	}
+	return NULL;
+}
+
 static int ion_iommu_heap_allocate(struct ion_heap *heap,
 				      struct ion_buffer *buffer,
 				      unsigned long size, unsigned long align,
 				      unsigned long flags)
 {
-	int ret = 0, i;
+	int ret, i;
+	struct list_head pages_list;
+	struct page_info *info, *tmp_info;
 	struct ion_iommu_priv_data *data = NULL;
-	pgprot_t page_prot = pgprot_writecombine(PAGE_KERNEL);
-	void *ptr = NULL;
 
 	if (msm_use_iommu()) {
 		struct scatterlist *sg;
 		struct sg_table *table;
-		unsigned int i;
+		int j;
+		void *ptr = NULL;
+		unsigned int npages_to_vmap, total_pages, num_large_pages = 0;
+		unsigned long size_remaining = PAGE_ALIGN(size);
+		unsigned int max_order = orders[0];
+		unsigned int page_tbl_size;
 
 		data = kmalloc(sizeof(*data), GFP_KERNEL);
 		if (!data)
 			return -ENOMEM;
 
+		INIT_LIST_HEAD(&pages_list);
+		while (size_remaining > 0) {
+			info = alloc_largest_available(size_remaining,
+						max_order);
+			if (!info) {
+				ret = -ENOMEM;
+				goto err_free_data;
+			}
+			list_add_tail(&info->list, &pages_list);
+			size_remaining -= order_to_size(info->order);
+			max_order = info->order;
+			num_large_pages++;
+		}
+
 		data->size = PFN_ALIGN(size);
 		data->nrpages = data->size >> PAGE_SHIFT;
-		data->pages = kzalloc(sizeof(struct page *)*data->nrpages,
-				GFP_KERNEL);
+		data->pages_uses_vmalloc = 0;
+		page_tbl_size = sizeof(struct page *) * data->nrpages;
+
+		if (page_tbl_size > SZ_8K) {
+			data->pages = kmalloc(page_tbl_size,
+					      __GFP_COMP | __GFP_NORETRY |
+					      __GFP_NO_KSWAPD | __GFP_NOWARN);
+			if (!data->pages) {
+				data->pages = vmalloc(page_tbl_size);
+				data->pages_uses_vmalloc = 1;
+			}
+		} else {
+			data->pages = kmalloc(page_tbl_size, GFP_KERNEL);
+		}
 		if (!data->pages) {
 			ret = -ENOMEM;
-			goto err1;
+			goto err_free_data;
 		}
 
 		table = buffer->sg_table =
@@ -74,25 +158,49 @@
 			ret = -ENOMEM;
 			goto err1;
 		}
-		ret = sg_alloc_table(table, data->nrpages, GFP_KERNEL);
+		ret = sg_alloc_table(table, num_large_pages, GFP_KERNEL);
 		if (ret)
 			goto err2;
 
-		for_each_sg(table->sgl, sg, table->nents, i) {
-			data->pages[i] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
-			if (!data->pages[i])
-				goto err3;
-
-			sg_set_page(sg, data->pages[i], PAGE_SIZE, 0);
+		i = 0;
+		sg = table->sgl;
+		list_for_each_entry_safe(info, tmp_info, &pages_list, list) {
+			struct page *page = info->page;
+			sg_set_page(sg, page, order_to_size(info->order), 0);
+			sg_dma_address(sg) = sg_phys(sg);
+			sg = sg_next(sg);
+			for (j = 0; j < (1 << info->order); ++j)
+				data->pages[i++] = nth_page(page, j);
+			list_del(&info->list);
+			kfree(info);
 		}
 
-		ptr = vmap(data->pages, data->nrpages, VM_IOREMAP, page_prot);
-		if (ptr != NULL) {
-			memset(ptr, 0, data->size);
-			dmac_flush_range(ptr, ptr + data->size);
+		npages_to_vmap = ((VMALLOC_END - VMALLOC_START)/8)
+			>> PAGE_SHIFT;
+		total_pages = data->nrpages;
+		for (i = 0; i < total_pages; i += npages_to_vmap) {
+			npages_to_vmap = min(npages_to_vmap, total_pages - i);
+			for (j = 0; j < MAX_VMAP_RETRIES && npages_to_vmap;
+			     ++j) {
+				ptr = vmap(&data->pages[i], npages_to_vmap,
+					VM_IOREMAP, pgprot_kernel);
+				if (ptr)
+					break;
+				else
+					npages_to_vmap >>= 1;
+			}
+			if (!ptr) {
+				pr_err("Couldn't vmap the pages for zeroing\n");
+				ret = -ENOMEM;
+				goto err3;
+			}
+			memset(ptr, 0, npages_to_vmap * PAGE_SIZE);
 			vunmap(ptr);
-		} else
-			pr_err("%s: vmap() failed\n", __func__);
+		}
+
+		if (!ION_IS_CACHED(flags))
+			dma_sync_sg_for_device(NULL, table->sgl, table->nents,
+						DMA_BIDIRECTIONAL);
 
 		buffer->priv_virt = data;
 		
@@ -110,33 +218,48 @@
 err2:
 	kfree(buffer->sg_table);
 	buffer->sg_table = 0;
-
-	for (i = 0; i < data->nrpages; i++) {
-		if (data->pages[i])
-			__free_page(data->pages[i]);
-	}
-	kfree(data->pages);
 err1:
+	if (data->pages_uses_vmalloc)
+		vfree(data->pages);
+	else
+		kfree(data->pages);
+err_free_data:
 	kfree(data);
+
+	list_for_each_entry_safe(info, tmp_info, &pages_list, list) {
+		if (info->page)
+			__free_pages(info->page, info->order);
+		list_del(&info->list);
+		kfree(info);
+	}
 	return ret;
 }
 
 static void ion_iommu_heap_free(struct ion_buffer *buffer)
 {
-	struct ion_iommu_priv_data *data = buffer->priv_virt;
 	int i;
+	struct scatterlist *sg;
+	struct sg_table *table = buffer->sg_table;
+	struct ion_iommu_priv_data *data = buffer->priv_virt;
 
+	if (!table)
+		return;
 	if (!data)
 		return;
 
-	for (i = 0; i < data->nrpages; i++)
-		__free_page(data->pages[i]);
+	for_each_sg(table->sgl, sg, table->nents, i)
+		__free_pages(sg_page(sg), get_order(sg_dma_len(sg)));
 
+	sg_free_table(table);
+	kfree(table);
+	table = 0;
 	
 	atomic_sub(data->size, &v);
 	
-
-	kfree(data->pages);
+	if (data->pages_uses_vmalloc)
+		vfree(data->pages);
+	else
+		kfree(data->pages);
 	kfree(data);
 }
 
@@ -188,7 +311,7 @@
 		return NULL;
 
 	if (!ION_IS_CACHED(buffer->flags))
-		page_prot = pgprot_noncached(page_prot);
+		page_prot = pgprot_writecombine(page_prot);
 
 	buffer->vaddr = vmap(data->pages, data->nrpages, VM_IOREMAP, page_prot);
 
@@ -208,21 +331,34 @@
 int ion_iommu_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
 			       struct vm_area_struct *vma)
 {
-	struct ion_iommu_priv_data *data = buffer->priv_virt;
+	struct sg_table *table = buffer->sg_table;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff * PAGE_SIZE;
+	struct scatterlist *sg;
 	int i;
-	unsigned long curr_addr;
-	if (!data)
-		return -EINVAL;
 
 	if (!ION_IS_CACHED(buffer->flags))
 		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
-	curr_addr = vma->vm_start;
-	for (i = 0; i < data->nrpages && curr_addr < vma->vm_end; i++) {
-		if (vm_insert_page(vma, curr_addr, data->pages[i])) {
-			return -EINVAL;
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		struct page *page = sg_page(sg);
+		unsigned long remainder = vma->vm_end - addr;
+		unsigned long len = sg_dma_len(sg);
+
+		if (offset >= sg_dma_len(sg)) {
+			offset -= sg_dma_len(sg);
+			continue;
+		} else if (offset) {
+			page += offset / PAGE_SIZE;
+			len = sg_dma_len(sg) - offset;
+			offset = 0;
 		}
-		curr_addr += PAGE_SIZE;
+		len = min(len, remainder);
+		remap_pfn_range(vma, addr, page_to_pfn(page), len,
+				vma->vm_page_prot);
+		addr += len;
+		if (addr >= vma->vm_end)
+			return 0;
 	}
 	return 0;
 }
@@ -246,6 +382,9 @@
 	data->mapped_size = iova_length;
 	extra = iova_length - buffer->size;
 
+	if (buffer->sg_table->sgl->length > align)
+		align = buffer->sg_table->sgl->length;
+
 	ret = msm_allocate_iova_address(domain_num, partition_num,
 						data->mapped_size, align,
 						&data->iova_addr);
@@ -324,15 +463,30 @@
 
 	switch (cmd) {
 	case ION_IOC_CLEAN_CACHES:
-		dmac_clean_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+		else
+			dmac_clean_range(vaddr, vaddr + length);
 		outer_cache_op = outer_clean_range;
 		break;
 	case ION_IOC_INV_CACHES:
-		dmac_inv_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		else
+			dmac_inv_range(vaddr, vaddr + length);
 		outer_cache_op = outer_inv_range;
 		break;
 	case ION_IOC_CLEAN_INV_CACHES:
-		dmac_flush_range(vaddr, vaddr + length);
+		if (!vaddr) {
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		} else {
+			dmac_flush_range(vaddr, vaddr + length);
+		}
 		outer_cache_op = outer_flush_range;
 		break;
 	default:
@@ -363,10 +517,6 @@
 static void ion_iommu_heap_unmap_dma(struct ion_heap *heap,
 				 struct ion_buffer *buffer)
 {
-	if (buffer->sg_table)
-		sg_free_table(buffer->sg_table);
-	kfree(buffer->sg_table);
-	buffer->sg_table = 0;
 }
 
 static struct ion_heap_ops iommu_heap_ops = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/gpu/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -3,8 +3,7 @@
 choice
       	prompt "Select MSM 3D Graphic driver branch"
 	depends on FB_MSM
-	default MSM_KGSL_MAINLINE if SYNC
-	default MSM_KGSL_JB_REL_RB31
+	default MSM_KGSL_JB_MR1
 
 config MSM_KGSL_MAINLINE
         bool "MSM 3D Graphics driver (branch jb_2.5)"
@@ -14,6 +13,14 @@
           use hardware accelerated OpenGL ES 2.0 and 1.1 on these
           chips.
 
+config MSM_KGSL_JB_MR1
+        bool "MSM 3D Graphics driver (branch jb_mr)"
+        depends on FB_MSM
+        help
+          3D graphics driver for Adreno205. Required to
+          use hardware accelerated OpenGL ES 2.0 and 1.1 on these
+          chips.
+
 config MSM_KGSL_JB_REL_RB31
         bool "MSM 3D Graphics driver (branch jb_rel_rb3.1)"
         depends on FB_MSM
@@ -21,12 +28,17 @@
           3D graphics driver for Adreno205. Required to
           use hardware accelerated OpenGL ES 2.0 and 1.1 on these
           chips.
+
 endchoice
 
 if MSM_KGSL_MAINLINE
 source "drivers/gpu/msm/Kconfig"
 endif
 
+if MSM_KGSL_JB_MR1
+source "drivers/gpu/msm_mr1/Kconfig"
+endif
+
 if MSM_KGSL_JB_REL_RB31
 source "drivers/gpu/msm_rb31/Kconfig"
 endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/Makefile monarudo-jb-3.4.10-e22f38b/drivers/gpu/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -4,6 +4,12 @@
     obj-y += msm/
 endif
 
+ifeq ($(CONFIG_MSM_KGSL_JB_MR1),y)
+    obj-y += msm_mr1/
+endif
+
 ifeq ($(CONFIG_MSM_KGSL_JB_REL_RB31),y)
     obj-y += msm_rb31/
 endif
+
+
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/a3xx_reg.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/a3xx_reg.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/a3xx_reg.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/a3xx_reg.h	2013-08-01 23:38:02.000000000 -0600
@@ -63,15 +63,103 @@
 #define A3XX_RBBM_INT_0_MASK 0x063
 #define A3XX_RBBM_INT_0_STATUS 0x064
 #define A3XX_RBBM_PERFCTR_CTL 0x80
+#define A3XX_RBBM_PERFCTR_LOAD_CMD0 0x81
+#define A3XX_RBBM_PERFCTR_LOAD_CMD1 0x82
+#define A3XX_RBBM_PERFCTR_LOAD_VALUE_LO 0x84
+#define A3XX_RBBM_PERFCTR_LOAD_VALUE_HI 0x85
+#define A3XX_RBBM_PERFCOUNTER0_SELECT 0x86
+#define A3XX_RBBM_PERFCOUNTER1_SELECT 0x87
 #define A3XX_RBBM_GPU_BUSY_MASKED 0x88
+#define A3XX_RBBM_PERFCTR_CP_0_LO 0x90
+#define A3XX_RBBM_PERFCTR_CP_0_HI 0x91
+#define A3XX_RBBM_PERFCTR_RBBM_0_LO 0x92
+#define A3XX_RBBM_PERFCTR_RBBM_0_HI 0x93
+#define A3XX_RBBM_PERFCTR_RBBM_1_LO 0x94
+#define A3XX_RBBM_PERFCTR_RBBM_1_HI 0x95
+#define A3XX_RBBM_PERFCTR_PC_0_LO 0x96
+#define A3XX_RBBM_PERFCTR_PC_0_HI 0x97
+#define A3XX_RBBM_PERFCTR_PC_1_LO 0x98
+#define A3XX_RBBM_PERFCTR_PC_1_HI 0x99
+#define A3XX_RBBM_PERFCTR_PC_2_LO 0x9A
+#define A3XX_RBBM_PERFCTR_PC_2_HI 0x9B
+#define A3XX_RBBM_PERFCTR_PC_3_LO 0x9C
+#define A3XX_RBBM_PERFCTR_PC_3_HI 0x9D
+#define A3XX_RBBM_PERFCTR_VFD_0_LO 0x9E
+#define A3XX_RBBM_PERFCTR_VFD_0_HI 0x9F
+#define A3XX_RBBM_PERFCTR_VFD_1_LO 0xA0
+#define A3XX_RBBM_PERFCTR_VFD_1_HI 0xA1
+#define A3XX_RBBM_PERFCTR_HLSQ_0_LO 0xA2
+#define A3XX_RBBM_PERFCTR_HLSQ_0_HI 0xA3
+#define A3XX_RBBM_PERFCTR_HLSQ_1_LO 0xA4
+#define A3XX_RBBM_PERFCTR_HLSQ_1_HI 0xA5
+#define A3XX_RBBM_PERFCTR_HLSQ_2_LO 0xA6
+#define A3XX_RBBM_PERFCTR_HLSQ_2_HI 0xA7
+#define A3XX_RBBM_PERFCTR_HLSQ_3_LO 0xA8
+#define A3XX_RBBM_PERFCTR_HLSQ_3_HI 0xA9
+#define A3XX_RBBM_PERFCTR_HLSQ_4_LO 0xAA
+#define A3XX_RBBM_PERFCTR_HLSQ_4_HI 0xAB
+#define A3XX_RBBM_PERFCTR_HLSQ_5_LO 0xAC
+#define A3XX_RBBM_PERFCTR_HLSQ_5_HI 0xAD
+#define A3XX_RBBM_PERFCTR_VPC_0_LO 0xAE
+#define A3XX_RBBM_PERFCTR_VPC_0_HI 0xAF
+#define A3XX_RBBM_PERFCTR_VPC_1_LO 0xB0
+#define A3XX_RBBM_PERFCTR_VPC_1_HI 0xB1
+#define A3XX_RBBM_PERFCTR_TSE_0_LO 0xB2
+#define A3XX_RBBM_PERFCTR_TSE_0_HI 0xB3
+#define A3XX_RBBM_PERFCTR_TSE_1_LO 0xB4
+#define A3XX_RBBM_PERFCTR_TSE_1_HI 0xB5
+#define A3XX_RBBM_PERFCTR_RAS_0_LO 0xB6
+#define A3XX_RBBM_PERFCTR_RAS_0_HI 0xB7
+#define A3XX_RBBM_PERFCTR_RAS_1_LO 0xB8
+#define A3XX_RBBM_PERFCTR_RAS_1_HI 0xB9
+#define A3XX_RBBM_PERFCTR_UCHE_0_LO 0xBA
+#define A3XX_RBBM_PERFCTR_UCHE_0_HI 0xBB
+#define A3XX_RBBM_PERFCTR_UCHE_1_LO 0xBC
+#define A3XX_RBBM_PERFCTR_UCHE_1_HI 0xBD
+#define A3XX_RBBM_PERFCTR_UCHE_2_LO 0xBE
+#define A3XX_RBBM_PERFCTR_UCHE_2_HI 0xBF
+#define A3XX_RBBM_PERFCTR_UCHE_3_LO 0xC0
+#define A3XX_RBBM_PERFCTR_UCHE_3_HI 0xC1
+#define A3XX_RBBM_PERFCTR_UCHE_4_LO 0xC2
+#define A3XX_RBBM_PERFCTR_UCHE_4_HI 0xC3
+#define A3XX_RBBM_PERFCTR_UCHE_5_LO 0xC4
+#define A3XX_RBBM_PERFCTR_UCHE_5_HI 0xC5
+#define A3XX_RBBM_PERFCTR_TP_0_LO 0xC6
+#define A3XX_RBBM_PERFCTR_TP_0_HI 0xC7
+#define A3XX_RBBM_PERFCTR_TP_1_LO 0xC8
+#define A3XX_RBBM_PERFCTR_TP_1_HI 0xC9
+#define A3XX_RBBM_PERFCTR_TP_2_LO 0xCA
+#define A3XX_RBBM_PERFCTR_TP_2_HI 0xCB
+#define A3XX_RBBM_PERFCTR_TP_3_LO 0xCC
+#define A3XX_RBBM_PERFCTR_TP_3_HI 0xCD
+#define A3XX_RBBM_PERFCTR_TP_4_LO 0xCE
+#define A3XX_RBBM_PERFCTR_TP_4_HI 0xCF
+#define A3XX_RBBM_PERFCTR_TP_5_LO 0xD0
+#define A3XX_RBBM_PERFCTR_TP_5_HI 0xD1
+#define A3XX_RBBM_PERFCTR_SP_0_LO 0xD2
+#define A3XX_RBBM_PERFCTR_SP_0_HI 0xD3
+#define A3XX_RBBM_PERFCTR_SP_1_LO 0xD4
+#define A3XX_RBBM_PERFCTR_SP_1_HI 0xD5
+#define A3XX_RBBM_PERFCTR_SP_2_LO 0xD6
+#define A3XX_RBBM_PERFCTR_SP_2_HI 0xD7
+#define A3XX_RBBM_PERFCTR_SP_3_LO 0xD8
+#define A3XX_RBBM_PERFCTR_SP_3_HI 0xD9
+#define A3XX_RBBM_PERFCTR_SP_4_LO 0xDA
+#define A3XX_RBBM_PERFCTR_SP_4_HI 0xDB
 #define A3XX_RBBM_PERFCTR_SP_5_LO 0xDC
 #define A3XX_RBBM_PERFCTR_SP_5_HI 0xDD
 #define A3XX_RBBM_PERFCTR_SP_6_LO 0xDE
 #define A3XX_RBBM_PERFCTR_SP_6_HI 0xDF
 #define A3XX_RBBM_PERFCTR_SP_7_LO 0xE0
 #define A3XX_RBBM_PERFCTR_SP_7_HI 0xE1
+#define A3XX_RBBM_PERFCTR_RB_0_LO 0xE2
+#define A3XX_RBBM_PERFCTR_RB_0_HI 0xE3
+#define A3XX_RBBM_PERFCTR_RB_1_LO 0xE4
+#define A3XX_RBBM_PERFCTR_RB_1_HI 0xE5
+
 #define A3XX_RBBM_RBBM_CTL 0x100
-#define A3XX_RBBM_RBBM_CTL 0x100
+#define A3XX_RBBM_PERFCTR_PWR_0_LO 0x0EA
+#define A3XX_RBBM_PERFCTR_PWR_0_HI 0x0EB
 #define A3XX_RBBM_PERFCTR_PWR_1_LO 0x0EC
 #define A3XX_RBBM_PERFCTR_PWR_1_HI 0x0ED
 #define A3XX_RBBM_DEBUG_BUS_CTL             0x111
@@ -86,6 +174,7 @@
 #define A3XX_CP_MERCIU_DATA2 0x1D3
 #define A3XX_CP_MEQ_ADDR 0x1DA
 #define A3XX_CP_MEQ_DATA 0x1DB
+#define A3XX_CP_PERFCOUNTER_SELECT 0x445
 #define A3XX_CP_HW_FAULT  0x45C
 #define A3XX_CP_AHB_FAULT 0x54D
 #define A3XX_CP_PROTECT_CTRL 0x45E
@@ -134,6 +223,14 @@
 #define A3XX_VSC_PIPE_CONFIG_7 0xC1B
 #define A3XX_VSC_PIPE_DATA_ADDRESS_7 0xC1C
 #define A3XX_VSC_PIPE_DATA_LENGTH_7 0xC1D
+#define A3XX_PC_PERFCOUNTER0_SELECT 0xC48
+#define A3XX_PC_PERFCOUNTER1_SELECT 0xC49
+#define A3XX_PC_PERFCOUNTER2_SELECT 0xC4A
+#define A3XX_PC_PERFCOUNTER3_SELECT 0xC4B
+#define A3XX_GRAS_PERFCOUNTER0_SELECT 0xC88
+#define A3XX_GRAS_PERFCOUNTER1_SELECT 0xC89
+#define A3XX_GRAS_PERFCOUNTER2_SELECT 0xC8A
+#define A3XX_GRAS_PERFCOUNTER3_SELECT 0xC8B
 #define A3XX_GRAS_CL_USER_PLANE_X0 0xCA0
 #define A3XX_GRAS_CL_USER_PLANE_Y0 0xCA1
 #define A3XX_GRAS_CL_USER_PLANE_Z0 0xCA2
@@ -159,14 +256,42 @@
 #define A3XX_GRAS_CL_USER_PLANE_Z5 0xCB6
 #define A3XX_GRAS_CL_USER_PLANE_W5 0xCB7
 #define A3XX_RB_GMEM_BASE_ADDR 0xCC0
+#define A3XX_RB_PERFCOUNTER0_SELECT   0xCC6
+#define A3XX_RB_PERFCOUNTER1_SELECT   0xCC7
+#define A3XX_HLSQ_PERFCOUNTER0_SELECT 0xE00
+#define A3XX_HLSQ_PERFCOUNTER1_SELECT 0xE01
+#define A3XX_HLSQ_PERFCOUNTER2_SELECT 0xE02
+#define A3XX_HLSQ_PERFCOUNTER3_SELECT 0xE03
+#define A3XX_HLSQ_PERFCOUNTER4_SELECT 0xE04
+#define A3XX_HLSQ_PERFCOUNTER5_SELECT 0xE05
 #define A3XX_VFD_PERFCOUNTER0_SELECT 0xE44
+#define A3XX_VFD_PERFCOUNTER1_SELECT 0xE45
 #define A3XX_VPC_VPC_DEBUG_RAM_SEL 0xE61
 #define A3XX_VPC_VPC_DEBUG_RAM_READ 0xE62
+#define A3XX_VPC_PERFCOUNTER0_SELECT 0xE64
+#define A3XX_VPC_PERFCOUNTER1_SELECT 0xE65
 #define A3XX_UCHE_CACHE_MODE_CONTROL_REG 0xE82
+#define A3XX_UCHE_PERFCOUNTER0_SELECT 0xE84
+#define A3XX_UCHE_PERFCOUNTER1_SELECT 0xE85
+#define A3XX_UCHE_PERFCOUNTER2_SELECT 0xE86
+#define A3XX_UCHE_PERFCOUNTER3_SELECT 0xE87
+#define A3XX_UCHE_PERFCOUNTER4_SELECT 0xE88
+#define A3XX_UCHE_PERFCOUNTER5_SELECT 0xE89
 #define A3XX_UCHE_CACHE_INVALIDATE0_REG 0xEA0
+#define A3XX_SP_PERFCOUNTER0_SELECT 0xEC4
+#define A3XX_SP_PERFCOUNTER1_SELECT 0xEC5
+#define A3XX_SP_PERFCOUNTER2_SELECT 0xEC6
+#define A3XX_SP_PERFCOUNTER3_SELECT 0xEC7
+#define A3XX_SP_PERFCOUNTER4_SELECT 0xEC8
 #define A3XX_SP_PERFCOUNTER5_SELECT 0xEC9
 #define A3XX_SP_PERFCOUNTER6_SELECT 0xECA
 #define A3XX_SP_PERFCOUNTER7_SELECT 0xECB
+#define A3XX_TP_PERFCOUNTER0_SELECT 0xF04
+#define A3XX_TP_PERFCOUNTER1_SELECT 0xF05
+#define A3XX_TP_PERFCOUNTER2_SELECT 0xF06
+#define A3XX_TP_PERFCOUNTER3_SELECT 0xF07
+#define A3XX_TP_PERFCOUNTER4_SELECT 0xF08
+#define A3XX_TP_PERFCOUNTER5_SELECT 0xF09
 #define A3XX_GRAS_CL_CLIP_CNTL 0x2040
 #define A3XX_GRAS_CL_GB_CLIP_ADJ 0x2044
 #define A3XX_GRAS_CL_VPORT_XOFFSET 0x2048
@@ -228,12 +353,14 @@
 #define A3XX_SP_VS_OUT_REG_7 0x22CE
 #define A3XX_SP_VS_VPC_DST_REG_0 0x22D0
 #define A3XX_SP_VS_OBJ_OFFSET_REG 0x22D4
+#define A3XX_SP_VS_OBJ_START_REG 0x22D5
 #define A3XX_SP_VS_PVT_MEM_ADDR_REG 0x22D7
 #define A3XX_SP_VS_PVT_MEM_SIZE_REG 0x22D8
 #define A3XX_SP_VS_LENGTH_REG 0x22DF
 #define A3XX_SP_FS_CTRL_REG0 0x22E0
 #define A3XX_SP_FS_CTRL_REG1 0x22E1
 #define A3XX_SP_FS_OBJ_OFFSET_REG 0x22E2
+#define A3XX_SP_FS_OBJ_START_REG 0x22E3
 #define A3XX_SP_FS_PVT_MEM_ADDR_REG 0x22E5
 #define A3XX_SP_FS_PVT_MEM_SIZE_REG 0x22E6
 #define A3XX_SP_FS_FLAT_SHAD_MODE_REG_0 0x22E8
@@ -265,9 +392,24 @@
 #define A3XX_VBIF_OUT_AXI_AMEMTYPE_CONF0 0x3058
 #define A3XX_VBIF_OUT_AXI_AOOO_EN 0x305E
 #define A3XX_VBIF_OUT_AXI_AOOO 0x305F
-
-#define RBBM_RBBM_CTL_RESET_PWR_CTR1  (1 << 1)
-#define RBBM_RBBM_CTL_ENABLE_PWR_CTR1  (1 << 17)
+#define A3XX_VBIF_PERF_CNT_EN 0x3070
+#define A3XX_VBIF_PERF_CNT_CLR 0x3071
+#define A3XX_VBIF_PERF_CNT_SEL 0x3072
+#define A3XX_VBIF_PERF_CNT0_LO 0x3073
+#define A3XX_VBIF_PERF_CNT0_HI 0x3074
+#define A3XX_VBIF_PERF_CNT1_LO 0x3075
+#define A3XX_VBIF_PERF_CNT1_HI 0x3076
+#define A3XX_VBIF_PERF_PWR_CNT0_LO 0x3077
+#define A3XX_VBIF_PERF_PWR_CNT0_HI 0x3078
+#define A3XX_VBIF_PERF_PWR_CNT1_LO 0x3079
+#define A3XX_VBIF_PERF_PWR_CNT1_HI 0x307a
+#define A3XX_VBIF_PERF_PWR_CNT2_LO 0x307b
+#define A3XX_VBIF_PERF_PWR_CNT2_HI 0x307c
+
+#define RBBM_RBBM_CTL_RESET_PWR_CTR0  BIT(0)
+#define RBBM_RBBM_CTL_RESET_PWR_CTR1  BIT(1)
+#define RBBM_RBBM_CTL_ENABLE_PWR_CTR0  BIT(16)
+#define RBBM_RBBM_CTL_ENABLE_PWR_CTR1  BIT(17)
 
 
 #define SP_MULTI 0
@@ -524,11 +666,30 @@
 #define RBBM_BLOCK_ID_MARB_2           0x2a
 #define RBBM_BLOCK_ID_MARB_3           0x2b
 
-#define A3XX_RBBM_CLOCK_CTL_DEFAULT 0xBFFFFFFF
+#define A305_RBBM_CLOCK_CTL_DEFAULT   0xAAAAAAAA
+#define A320_RBBM_CLOCK_CTL_DEFAULT   0xBFFFFFFF
+#define A330_RBBM_CLOCK_CTL_DEFAULT   0xAAAAAAAE
+#define A330v2_RBBM_CLOCK_CTL_DEFAULT 0xAAAAAAAA
+
+#define A330_RBBM_GPR0_CTL_DEFAULT  0x0AE2B8AE
+#define A330v2_RBBM_GPR0_CTL_DEFAULT  0x0AA2A8AA
 
 #define SP_FS_FULL_ALU_INSTRUCTIONS    0x0E
 #define SP_ALU_ACTIVE_CYCLES           0x1D
 #define SP0_ICL1_MISSES                0x1A
 #define SP_FS_CFLOW_INSTRUCTIONS       0x0C
 
+#define VBIF_PERF_CNT_0 BIT(0)
+#define VBIF_PERF_CNT_1 BIT(1)
+#define VBIF_PERF_PWR_CNT_0 BIT(2)
+#define VBIF_PERF_PWR_CNT_1 BIT(3)
+#define VBIF_PERF_PWR_CNT_2 BIT(4)
+
+#define VBIF_PERF_CNT_0_SEL 0
+#define VBIF_PERF_CNT_0_SEL_MASK 0x7f
+#define VBIF_PERF_CNT_1_SEL 8
+#define VBIF_PERF_CNT_1_SEL_MASK 0x7f00
+
+#define VBIF_DDR_TOTAL_CYCLES 110
+
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a2xx.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a2xx.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a2xx.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a2xx.c	2013-08-01 23:38:02.000000000 -0600
@@ -1306,18 +1306,26 @@
 			"Current active context has caused gpu hang\n");
 
 	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
-
+		kgsl_cffdump_syncmem(NULL, &context->gpustate,
+			context->reg_save[1],
+			context->reg_save[2] << 2, true);
 		
 		adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE,
 			context->reg_save, 3);
 
 		if (context->flags & CTXT_FLAGS_SHADER_SAVE) {
+			kgsl_cffdump_syncmem(NULL, &context->gpustate,
+				context->shader_save[1],
+				context->shader_save[2] << 2, true);
 			
 			adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_PMODE,
 				context->shader_save, 3);
 
+			kgsl_cffdump_syncmem(NULL, &context->gpustate,
+				context->shader_fixup[1],
+				context->shader_fixup[2] << 2, true);
 			adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->shader_fixup, 3);
@@ -1328,10 +1336,17 @@
 
 	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
 	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
+		kgsl_cffdump_syncmem(NULL, &context->gpustate,
+			context->context_gmem_shadow.gmem_save[1],
+			context->context_gmem_shadow.gmem_save[2] << 2, true);
 		adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_PMODE,
 			context->context_gmem_shadow.gmem_save, 3);
 
+		kgsl_cffdump_syncmem(NULL, &context->gpustate,
+			context->chicken_restore[1],
+			context->chicken_restore[2] << 2, true);
+
 		
 		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 			adreno_ringbuffer_issuecmds(device, context,
@@ -1370,18 +1385,21 @@
 					cmds, 5);
 	kgsl_mmu_setstate(&device->mmu, context->pagetable, context->id);
 
-#ifndef CONFIG_MSM_KGSL_CFF_DUMP_NO_CONTEXT_MEM_DUMP
-	kgsl_cffdump_syncmem(NULL, &context->gpustate,
-		context->gpustate.gpuaddr, LCC_SHADOW_SIZE +
-		REG_SHADOW_SIZE + CMD_BUFFER_SIZE + TEX_SHADOW_SIZE, false);
-#endif
-
 	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
+		kgsl_cffdump_syncmem(NULL, &context->gpustate,
+			context->context_gmem_shadow.gmem_restore[1],
+			context->context_gmem_shadow.gmem_restore[2] << 2,
+			true);
+
 		adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_PMODE,
 			context->context_gmem_shadow.gmem_restore, 3);
 
 		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
+			kgsl_cffdump_syncmem(NULL, &context->gpustate,
+				context->chicken_restore[1],
+				context->chicken_restore[2] << 2, true);
+
 			
 			adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
@@ -1392,6 +1410,9 @@
 	}
 
 	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
+		kgsl_cffdump_syncmem(NULL, &context->gpustate,
+			context->reg_restore[1],
+			context->reg_restore[2] << 2, true);
 
 		
 		adreno_ringbuffer_issuecmds(device, context,
@@ -1399,6 +1420,10 @@
 
 		
 		if (context->flags & CTXT_FLAGS_SHADER_RESTORE) {
+			kgsl_cffdump_syncmem(NULL, &context->gpustate,
+				context->shader_restore[1],
+				context->shader_restore[2] << 2, true);
+
 			adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->shader_restore, 3);
@@ -1491,9 +1516,6 @@
 		KGSL_CMD_WARN(rb->device, "ringbuffer ib1/rb interrupt\n");
 		queue_work(device->work_queue, &device->ts_expired_ws);
 		wake_up_interruptible_all(&device->wait_queue);
-		atomic_notifier_call_chain(&(device->ts_notifier_list),
-					   device->id,
-					   NULL);
 	}
 }
 
@@ -1587,19 +1609,17 @@
 		 MASTER_INT_SIGNAL__RBBM_INT_STAT)) ? 1 : 0;
 }
 
-static void a2xx_rb_init(struct adreno_device *adreno_dev,
+static int a2xx_rb_init(struct adreno_device *adreno_dev,
 			struct adreno_ringbuffer *rb)
 {
 	unsigned int *cmds, cmds_gpu;
 
 	
 	cmds = adreno_ringbuffer_allocspace(rb, NULL, 19);
-	cmds_gpu = rb->buffer_desc.gpuaddr + sizeof(uint)*(rb->wptr-19);
+	if (cmds == NULL)
+		return -ENOMEM;
 
-	if(cmds == NULL || cmds_gpu == 0){
-		KGSL_PWR_ERR(rb->device,"cmds or cmds_gpu is NULL");
-		return;
-	}
+	cmds_gpu = rb->buffer_desc.gpuaddr + sizeof(uint)*(rb->wptr-19);
 
 	GSL_RB_WRITE(cmds, cmds_gpu, cp_type3_packet(CP_ME_INIT, 18));
 	
@@ -1646,6 +1666,8 @@
 	GSL_RB_WRITE(cmds, cmds_gpu, 0x00000000);
 
 	adreno_ringbuffer_submit(rb);
+
+	return 0;
 }
 
 static unsigned int a2xx_busy_cycles(struct adreno_device *adreno_dev)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a2xx_snapshot.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a2xx_snapshot.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a2xx_snapshot.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a2xx_snapshot.c	2013-08-01 23:38:02.000000000 -0600
@@ -218,6 +218,30 @@
 	return DEBUG_SECTION_SZ(MIUDEBUG_COUNT);
 }
 
+static int a2xx_snapshot_istore(struct kgsl_device *device, void *snapshot,
+	int remain, void *priv)
+{
+	struct kgsl_snapshot_istore *header = snapshot;
+	unsigned int *data = snapshot + sizeof(*header);
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	int count, i;
+
+	count = adreno_dev->istore_size * adreno_dev->instruction_size;
+
+	if (remain < (count * 4) + sizeof(*header)) {
+		KGSL_DRV_ERR(device,
+			"snapshot: Not enough memory for the istore section");
+		return 0;
+	}
+
+	header->count = adreno_dev->istore_size;
+
+	for (i = 0; i < count; i++)
+		kgsl_regread(device, ADRENO_ISTORE_START + i, &data[i]);
+
+	return (count * 4) + sizeof(*header);
+}
+
 
 void *a2xx_snapshot(struct adreno_device *adreno_dev, void *snapshot,
 	int *remain, int hang)
@@ -321,6 +345,14 @@
 		}
 	}
 
+
+	if (adreno_is_a2xx(adreno_dev) && hang) {
+		snapshot = kgsl_snapshot_add_section(device,
+			KGSL_SNAPSHOT_SECTION_ISTORE, snapshot, remain,
+			a2xx_snapshot_istore, NULL);
+	}
+
+
 	
 	adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, pmoverride);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a3xx.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a3xx.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a3xx.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a3xx.c	2013-08-01 23:38:02.000000000 -0600
@@ -360,6 +360,21 @@
 	tmp_ctx.cmd = cmd;
 }
 
+unsigned int adreno_a3xx_rbbm_clock_ctl_default(struct adreno_device
+							*adreno_dev)
+{
+	if (adreno_is_a305(adreno_dev))
+		return A305_RBBM_CLOCK_CTL_DEFAULT;
+	else if (adreno_is_a320(adreno_dev))
+		return A320_RBBM_CLOCK_CTL_DEFAULT;
+	else if (adreno_is_a330v2(adreno_dev))
+		return A330v2_RBBM_CLOCK_CTL_DEFAULT;
+	else if (adreno_is_a330(adreno_dev))
+		return A330_RBBM_CLOCK_CTL_DEFAULT;
+
+	BUG_ON(1);
+}
+
 static unsigned int *build_gmem2sys_cmds(struct adreno_device *adreno_dev,
 					 struct adreno_context *drawctxt,
 					 struct gmem_shadow_t *shadow)
@@ -368,7 +383,7 @@
 	unsigned int *start = cmds;
 
 	*cmds++ = cp_type0_packet(A3XX_RBBM_CLOCK_CTL, 1);
-	*cmds++ = A3XX_RBBM_CLOCK_CTL_DEFAULT;
+	*cmds++ = adreno_a3xx_rbbm_clock_ctl_default(adreno_dev);
 
 	*cmds++ = cp_type3_packet(CP_SET_CONSTANT, 3);
 	*cmds++ = CP_REG(A3XX_RB_MODE_CONTROL);
@@ -1107,7 +1122,7 @@
 	unsigned int *start = cmds;
 
 	*cmds++ = cp_type0_packet(A3XX_RBBM_CLOCK_CTL, 1);
-	*cmds++ = A3XX_RBBM_CLOCK_CTL_DEFAULT;
+	*cmds++ = adreno_a3xx_rbbm_clock_ctl_default(adreno_dev);
 
 	*cmds++ = cp_type3_packet(CP_SET_CONSTANT, 5);
 	*cmds++ = CP_REG(A3XX_HLSQ_CONTROL_0_REG);
@@ -2175,6 +2190,11 @@
 	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
 	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
 
+		kgsl_cffdump_syncmem(NULL,
+			&context->gpustate,
+			context->context_gmem_shadow.gmem_save[1],
+			context->context_gmem_shadow.gmem_save[2] << 2, true);
+
 		adreno_ringbuffer_issuecmds(device, context,
 					KGSL_CMD_FLAGS_PMODE,
 					    context->context_gmem_shadow.
@@ -2210,6 +2230,12 @@
 
 
 	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
+		kgsl_cffdump_syncmem(NULL,
+			&context->gpustate,
+			context->context_gmem_shadow.gmem_restore[1],
+			context->context_gmem_shadow.gmem_restore[2] << 2,
+			true);
+
 		adreno_ringbuffer_issuecmds(device, context,
 					KGSL_CMD_FLAGS_PMODE,
 					    context->context_gmem_shadow.
@@ -2242,11 +2268,14 @@
 	}
 }
 
-static void a3xx_rb_init(struct adreno_device *adreno_dev,
+static int a3xx_rb_init(struct adreno_device *adreno_dev,
 			 struct adreno_ringbuffer *rb)
 {
 	unsigned int *cmds, cmds_gpu;
 	cmds = adreno_ringbuffer_allocspace(rb, NULL, 18);
+	if (cmds == NULL)
+		return -ENOMEM;
+
 	cmds_gpu = rb->buffer_desc.gpuaddr + sizeof(uint) * (rb->wptr - 18);
 
 	GSL_RB_WRITE(cmds, cmds_gpu, cp_type3_packet(CP_ME_INIT, 17));
@@ -2270,6 +2299,8 @@
 	GSL_RB_WRITE(cmds, cmds_gpu, 0x00000000);
 
 	adreno_ringbuffer_submit(rb);
+
+	return 0;
 }
 
 static void a3xx_err_callback(struct adreno_device *adreno_dev, int bit)
@@ -2348,9 +2379,256 @@
 
 	
 	queue_work(device->work_queue, &device->ts_expired_ws);
+}
+
+
+struct a3xx_perfcounter_register {
+	unsigned int load_bit;
+	unsigned int select;
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_cp[] = {
+	{ 0, A3XX_CP_PERFCOUNTER_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_rbbm[] = {
+	{ 1, A3XX_RBBM_PERFCOUNTER0_SELECT },
+	{ 2, A3XX_RBBM_PERFCOUNTER1_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_pc[] = {
+	{ 3, A3XX_PC_PERFCOUNTER0_SELECT },
+	{ 4, A3XX_PC_PERFCOUNTER1_SELECT },
+	{ 5, A3XX_PC_PERFCOUNTER2_SELECT },
+	{ 6, A3XX_PC_PERFCOUNTER3_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_vfd[] = {
+	{ 7, A3XX_VFD_PERFCOUNTER0_SELECT },
+	{ 8, A3XX_VFD_PERFCOUNTER1_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_hlsq[] = {
+	{ 9, A3XX_HLSQ_PERFCOUNTER0_SELECT },
+	{ 10, A3XX_HLSQ_PERFCOUNTER1_SELECT },
+	{ 11, A3XX_HLSQ_PERFCOUNTER2_SELECT },
+	{ 12, A3XX_HLSQ_PERFCOUNTER3_SELECT },
+	{ 13, A3XX_HLSQ_PERFCOUNTER4_SELECT },
+	{ 14, A3XX_HLSQ_PERFCOUNTER5_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_vpc[] = {
+	{ 15, A3XX_VPC_PERFCOUNTER0_SELECT },
+	{ 16, A3XX_VPC_PERFCOUNTER1_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_tse[] = {
+	{ 17, A3XX_GRAS_PERFCOUNTER0_SELECT },
+	{ 18, A3XX_GRAS_PERFCOUNTER1_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_ras[] = {
+	{ 19, A3XX_GRAS_PERFCOUNTER2_SELECT },
+	{ 20, A3XX_GRAS_PERFCOUNTER3_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_uche[] = {
+	{ 21, A3XX_UCHE_PERFCOUNTER0_SELECT },
+	{ 22, A3XX_UCHE_PERFCOUNTER1_SELECT },
+	{ 23, A3XX_UCHE_PERFCOUNTER2_SELECT },
+	{ 24, A3XX_UCHE_PERFCOUNTER3_SELECT },
+	{ 25, A3XX_UCHE_PERFCOUNTER4_SELECT },
+	{ 26, A3XX_UCHE_PERFCOUNTER5_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_tp[] = {
+	{ 27, A3XX_TP_PERFCOUNTER0_SELECT },
+	{ 28, A3XX_TP_PERFCOUNTER1_SELECT },
+	{ 29, A3XX_TP_PERFCOUNTER2_SELECT },
+	{ 30, A3XX_TP_PERFCOUNTER3_SELECT },
+	{ 31, A3XX_TP_PERFCOUNTER4_SELECT },
+	{ 32, A3XX_TP_PERFCOUNTER5_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_sp[] = {
+	{ 33, A3XX_SP_PERFCOUNTER0_SELECT },
+	{ 34, A3XX_SP_PERFCOUNTER1_SELECT },
+	{ 35, A3XX_SP_PERFCOUNTER2_SELECT },
+	{ 36, A3XX_SP_PERFCOUNTER3_SELECT },
+	{ 37, A3XX_SP_PERFCOUNTER4_SELECT },
+	{ 38, A3XX_SP_PERFCOUNTER5_SELECT },
+	{ 39, A3XX_SP_PERFCOUNTER6_SELECT },
+	{ 40, A3XX_SP_PERFCOUNTER7_SELECT },
+};
+
+static struct a3xx_perfcounter_register a3xx_perfcounter_reg_rb[] = {
+	{ 41, A3XX_RB_PERFCOUNTER0_SELECT },
+	{ 42, A3XX_RB_PERFCOUNTER1_SELECT },
+};
+
+#define REGCOUNTER_GROUP(_x) { (_x), ARRAY_SIZE((_x)) }
+
+static struct {
+	struct a3xx_perfcounter_register *regs;
+	int count;
+} a3xx_perfcounter_reglist[] = {
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_cp),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_rbbm),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_pc),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_vfd),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_hlsq),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_vpc),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_tse),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_ras),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_uche),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_tp),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_sp),
+	REGCOUNTER_GROUP(a3xx_perfcounter_reg_rb),
+};
+
+static void a3xx_perfcounter_enable_pwr(struct kgsl_device *device,
+	unsigned int countable)
+{
+	unsigned int in, out;
+
+	adreno_regread(device, A3XX_RBBM_RBBM_CTL, &in);
+
+	if (countable == 0)
+		out = in | RBBM_RBBM_CTL_RESET_PWR_CTR0;
+	else
+		out = in | RBBM_RBBM_CTL_RESET_PWR_CTR1;
+
+	adreno_regwrite(device, A3XX_RBBM_RBBM_CTL, out);
+
+	if (countable == 0)
+		out = in | RBBM_RBBM_CTL_ENABLE_PWR_CTR0;
+	else
+		out = in | RBBM_RBBM_CTL_ENABLE_PWR_CTR1;
+
+	adreno_regwrite(device, A3XX_RBBM_RBBM_CTL, out);
+
+	return;
+}
+
+static void a3xx_perfcounter_enable_vbif(struct kgsl_device *device,
+					 unsigned int counter,
+					 unsigned int countable)
+{
+	unsigned int in, out, bit, sel;
+
+	if (counter > 1 || countable > 0x7f)
+		return;
+
+	adreno_regread(device, A3XX_VBIF_PERF_CNT_EN, &in);
+	adreno_regread(device, A3XX_VBIF_PERF_CNT_SEL, &sel);
+
+	if (counter == 0) {
+		bit = VBIF_PERF_CNT_0;
+		sel = (sel & ~VBIF_PERF_CNT_0_SEL_MASK) | countable;
+	} else {
+		bit = VBIF_PERF_CNT_1;
+		sel = (sel & ~VBIF_PERF_CNT_1_SEL_MASK)
+			| (countable << VBIF_PERF_CNT_1_SEL);
+	}
+
+	out = in | bit;
+
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_SEL, sel);
+
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_CLR, bit);
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_CLR, 0);
+
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_EN, out);
+}
+
+static void a3xx_perfcounter_enable_vbif_pwr(struct kgsl_device *device,
+					     unsigned int countable)
+{
+	unsigned int in, out, bit;
+
+	adreno_regread(device, A3XX_VBIF_PERF_CNT_EN, &in);
+	if (countable == 0)
+		bit = VBIF_PERF_PWR_CNT_0;
+	else if (countable == 1)
+		bit = VBIF_PERF_PWR_CNT_1;
+	else
+		bit = VBIF_PERF_PWR_CNT_2;
+
+	out = in | bit;
+
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_CLR, bit);
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_CLR, 0);
+
+	adreno_regwrite(device, A3XX_VBIF_PERF_CNT_EN, out);
+}
+
+
+static void a3xx_perfcounter_enable(struct adreno_device *adreno_dev,
+	unsigned int group, unsigned int counter, unsigned int countable)
+{
+	struct kgsl_device *device = &adreno_dev->dev;
+	unsigned int val = 0;
+	struct a3xx_perfcounter_register *reg;
+
+	if (group >= ARRAY_SIZE(a3xx_perfcounter_reglist))
+		return;
+
+	if (counter >= a3xx_perfcounter_reglist[group].count)
+		return;
+
+	
+	if (group == KGSL_PERFCOUNTER_GROUP_PWR)
+		return a3xx_perfcounter_enable_pwr(device, countable);
+	else if (group == KGSL_PERFCOUNTER_GROUP_VBIF)
+		return a3xx_perfcounter_enable_vbif(device, counter, countable);
+	else if (group == KGSL_PERFCOUNTER_GROUP_VBIF_PWR)
+		return a3xx_perfcounter_enable_vbif_pwr(device, countable);
+
+	reg = &(a3xx_perfcounter_reglist[group].regs[counter]);
+
+	
+	adreno_regwrite(device, reg->select, countable);
+
+	if (reg->load_bit < 32) {
+		val = 1 << reg->load_bit;
+		adreno_regwrite(device, A3XX_RBBM_PERFCTR_LOAD_CMD0, val);
+	} else {
+		val  = 1 << (reg->load_bit - 32);
+		adreno_regwrite(device, A3XX_RBBM_PERFCTR_LOAD_CMD1, val);
+	}
+}
+
+static uint64_t a3xx_perfcounter_read(struct adreno_device *adreno_dev,
+	unsigned int group, unsigned int counter,
+	unsigned int offset)
+{
+	struct kgsl_device *device = &adreno_dev->dev;
+	struct a3xx_perfcounter_register *reg = NULL;
+	unsigned int lo = 0, hi = 0;
+	unsigned int val;
+
+	if (group >= ARRAY_SIZE(a3xx_perfcounter_reglist))
+		return 0;
+
+	if (counter >= a3xx_perfcounter_reglist[group].count)
+		return 0;
+
+	reg = &(a3xx_perfcounter_reglist[group].regs[counter]);
+
+	
+	adreno_regread(device, A3XX_RBBM_PERFCTR_CTL, &val);
+	val &= ~reg->load_bit;
+	adreno_regwrite(device, A3XX_RBBM_PERFCTR_CTL, val);
+
+	
+	adreno_regread(device, offset, &lo);
+	adreno_regread(device, offset + 1, &hi);
+
+	
+	val |= reg->load_bit;
+	adreno_regwrite(device, A3XX_RBBM_PERFCTR_CTL, val);
 
-	atomic_notifier_call_chain(&device->ts_notifier_list,
-				   device->id, NULL);
+	return (((uint64_t) hi) << 32) | lo;
 }
 
 #define A3XX_IRQ_CALLBACK(_c) { .func = _c }
@@ -2454,26 +2732,22 @@
 static unsigned int a3xx_busy_cycles(struct adreno_device *adreno_dev)
 {
 	struct kgsl_device *device = &adreno_dev->dev;
-	unsigned int reg, val;
-
-	
-	adreno_regread(device, A3XX_RBBM_RBBM_CTL, &reg);
-	reg &= ~RBBM_RBBM_CTL_ENABLE_PWR_CTR1;
-	adreno_regwrite(device, A3XX_RBBM_RBBM_CTL, reg);
+	unsigned int val;
+	unsigned int ret = 0;
 
 	
 	adreno_regread(device, A3XX_RBBM_PERFCTR_PWR_1_LO, &val);
 
 	
-	reg |= RBBM_RBBM_CTL_RESET_PWR_CTR1;
-	adreno_regwrite(device, A3XX_RBBM_RBBM_CTL, reg);
-
-	
-	reg &= ~RBBM_RBBM_CTL_RESET_PWR_CTR1;
-	reg |= RBBM_RBBM_CTL_ENABLE_PWR_CTR1;
-	adreno_regwrite(device, A3XX_RBBM_RBBM_CTL, reg);
+	if (adreno_dev->gpu_cycles != 0) {
+		if (val < adreno_dev->gpu_cycles)
+			ret = (0xFFFFFFFF - adreno_dev->gpu_cycles) + val;
+		else
+			ret = val - adreno_dev->gpu_cycles;
+	}
 
-	return val;
+	adreno_dev->gpu_cycles = val;
+	return ret;
 }
 
 struct a3xx_vbif_data {
@@ -2547,17 +2821,67 @@
 	{0, 0},
 };
 
+static struct a3xx_vbif_data a330v2_vbif[] = {
+	
+	{ A3XX_VBIF_ABIT_SORT, 0x0001003F },
+	{ A3XX_VBIF_ABIT_SORT_CONF, 0x000000A4 },
+	
+	{ A3XX_VBIF_GATE_OFF_WRREQ_EN, 0x00003F },
+	{ A3XX_VBIF_DDR_OUT_MAX_BURST, 0x0000303 },
+	
+	{ A3XX_VBIF_ROUND_ROBIN_QOS_ARB, 0x0003 },
+	{ A3XX_VBIF_CLKON, 1 },
+	{0, 0},
+};
+
+static struct {
+	int(*devfunc)(struct adreno_device *);
+	struct a3xx_vbif_data *vbif;
+} a3xx_vbif_platforms[] = {
+	{ adreno_is_a305, a305_vbif },
+	{ adreno_is_a320, a320_vbif },
+	
+	{ adreno_is_a330v2, a330v2_vbif },
+	{ adreno_is_a330, a330_vbif },
+};
+
+static void a3xx_perfcounter_init(struct adreno_device *adreno_dev)
+{
+	if (adreno_dev->fast_hang_detect) {
+		adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
+			SP_ALU_ACTIVE_CYCLES, &ft_detect_regs[6],
+			PERFCOUNTER_FLAG_KERNEL);
+		ft_detect_regs[7] = ft_detect_regs[6] + 1;
+		adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
+			SP0_ICL1_MISSES, &ft_detect_regs[8],
+			PERFCOUNTER_FLAG_KERNEL);
+		ft_detect_regs[9] = ft_detect_regs[8] + 1;
+		adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
+			SP_FS_CFLOW_INSTRUCTIONS, &ft_detect_regs[10],
+			PERFCOUNTER_FLAG_KERNEL);
+		ft_detect_regs[11] = ft_detect_regs[10] + 1;
+	}
+
+	adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
+		SP_FS_FULL_ALU_INSTRUCTIONS, NULL, PERFCOUNTER_FLAG_KERNEL);
+
+	
+	adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_PWR, 1,
+			NULL, PERFCOUNTER_FLAG_KERNEL);
+}
+
 static void a3xx_start(struct adreno_device *adreno_dev)
 {
 	struct kgsl_device *device = &adreno_dev->dev;
 	struct a3xx_vbif_data *vbif = NULL;
+	int i;
 
-	if (adreno_is_a305(adreno_dev))
-		vbif = a305_vbif;
-	else if (adreno_is_a320(adreno_dev))
-		vbif = a320_vbif;
-	else if (adreno_is_a330(adreno_dev))
-		vbif = a330_vbif;
+	for (i = 0; i < ARRAY_SIZE(a3xx_vbif_platforms); i++) {
+		if (a3xx_vbif_platforms[i].devfunc(adreno_dev)) {
+			vbif = a3xx_vbif_platforms[i].vbif;
+			break;
+		}
+	}
 
 	BUG_ON(vbif == NULL);
 
@@ -2591,7 +2915,14 @@
 
 	
 	adreno_regwrite(device, A3XX_RBBM_CLOCK_CTL,
-			A3XX_RBBM_CLOCK_CTL_DEFAULT);
+		adreno_a3xx_rbbm_clock_ctl_default(adreno_dev));
+
+	if (adreno_is_a330v2(adreno_dev))
+		adreno_regwrite(device, A3XX_RBBM_GPR0_CTL,
+			A330v2_RBBM_GPR0_CTL_DEFAULT);
+	else if (adreno_is_a330(adreno_dev))
+		adreno_regwrite(device, A3XX_RBBM_GPR0_CTL,
+			A330_RBBM_GPR0_CTL_DEFAULT);
 
 	
 	if (adreno_is_a330(adreno_dev)) {
@@ -2602,16 +2933,129 @@
 	
 	adreno_regwrite(device, A3XX_RBBM_PERFCTR_CTL, 0x01);
 
-	if (adreno_dev->fast_hang_detect) {
-		adreno_regwrite(device, A3XX_SP_PERFCOUNTER5_SELECT,
-			SP_ALU_ACTIVE_CYCLES);
-		adreno_regwrite(device, A3XX_SP_PERFCOUNTER6_SELECT,
-			SP0_ICL1_MISSES);
-		adreno_regwrite(device, A3XX_SP_PERFCOUNTER7_SELECT,
-			SP_FS_CFLOW_INSTRUCTIONS);
-	}
+	
+
+	adreno_dev->gpu_cycles = 0;
 }
 
+
+static struct adreno_perfcount_register a3xx_perfcounters_cp[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_CP_0_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_rbbm[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RBBM_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RBBM_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_pc[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PC_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PC_1_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PC_2_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PC_3_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_vfd[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_VFD_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_VFD_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_hlsq[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_1_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_2_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_3_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_4_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_HLSQ_5_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_vpc[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_VPC_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_VPC_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_tse[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TSE_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TSE_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_ras[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RAS_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RAS_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_uche[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_1_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_2_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_3_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_4_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_UCHE_5_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_tp[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_1_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_2_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_3_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_4_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_TP_5_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_sp[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_1_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_2_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_3_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_4_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_5_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_6_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_SP_7_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_rb[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RB_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_RB_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_pwr[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PWR_0_LO, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_RBBM_PERFCTR_PWR_1_LO, 0 },
+};
+
+static struct adreno_perfcount_register a3xx_perfcounters_vbif[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_VBIF_PERF_CNT0_LO },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_VBIF_PERF_CNT1_LO },
+};
+static struct adreno_perfcount_register a3xx_perfcounters_vbif_pwr[] = {
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_VBIF_PERF_PWR_CNT0_LO },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_VBIF_PERF_PWR_CNT1_LO },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, A3XX_VBIF_PERF_PWR_CNT2_LO },
+};
+
+static struct adreno_perfcount_group a3xx_perfcounter_groups[] = {
+	{ a3xx_perfcounters_cp, ARRAY_SIZE(a3xx_perfcounters_cp) },
+	{ a3xx_perfcounters_rbbm, ARRAY_SIZE(a3xx_perfcounters_rbbm) },
+	{ a3xx_perfcounters_pc, ARRAY_SIZE(a3xx_perfcounters_pc) },
+	{ a3xx_perfcounters_vfd, ARRAY_SIZE(a3xx_perfcounters_vfd) },
+	{ a3xx_perfcounters_hlsq, ARRAY_SIZE(a3xx_perfcounters_hlsq) },
+	{ a3xx_perfcounters_vpc, ARRAY_SIZE(a3xx_perfcounters_vpc) },
+	{ a3xx_perfcounters_tse, ARRAY_SIZE(a3xx_perfcounters_tse) },
+	{ a3xx_perfcounters_ras, ARRAY_SIZE(a3xx_perfcounters_ras) },
+	{ a3xx_perfcounters_uche, ARRAY_SIZE(a3xx_perfcounters_uche) },
+	{ a3xx_perfcounters_tp, ARRAY_SIZE(a3xx_perfcounters_tp) },
+	{ a3xx_perfcounters_sp, ARRAY_SIZE(a3xx_perfcounters_sp) },
+	{ a3xx_perfcounters_rb, ARRAY_SIZE(a3xx_perfcounters_rb) },
+	{ a3xx_perfcounters_pwr, ARRAY_SIZE(a3xx_perfcounters_pwr) },
+	{ a3xx_perfcounters_vbif, ARRAY_SIZE(a3xx_perfcounters_vbif) },
+	{ a3xx_perfcounters_vbif_pwr, ARRAY_SIZE(a3xx_perfcounters_vbif_pwr) },
+};
+
+static struct adreno_perfcounters a3xx_perfcounters = {
+	a3xx_perfcounter_groups,
+	ARRAY_SIZE(a3xx_perfcounter_groups),
+};
+
 void *a3xx_snapshot(struct adreno_device *adreno_dev, void *snapshot,
 	int *remain, int hang);
 
@@ -2619,16 +3063,20 @@
 	.reg_rbbm_status = A3XX_RBBM_STATUS,
 	.reg_cp_pfp_ucode_addr = A3XX_CP_PFP_UCODE_ADDR,
 	.reg_cp_pfp_ucode_data = A3XX_CP_PFP_UCODE_DATA,
+	.perfcounters = &a3xx_perfcounters,
 
 	.ctxt_create = a3xx_drawctxt_create,
 	.ctxt_save = a3xx_drawctxt_save,
 	.ctxt_restore = a3xx_drawctxt_restore,
 	.ctxt_draw_workaround = NULL,
 	.rb_init = a3xx_rb_init,
+	.perfcounter_init = a3xx_perfcounter_init,
 	.irq_control = a3xx_irq_control,
 	.irq_handler = a3xx_irq_handler,
 	.irq_pending = a3xx_irq_pending,
 	.busy_cycles = a3xx_busy_cycles,
 	.start = a3xx_start,
 	.snapshot = a3xx_snapshot,
+	.perfcounter_enable = a3xx_perfcounter_enable,
+	.perfcounter_read = a3xx_perfcounter_read,
 };
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a3xx_snapshot.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a3xx_snapshot.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_a3xx_snapshot.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_a3xx_snapshot.c	2013-08-01 23:38:02.000000000 -0600
@@ -21,6 +21,14 @@
 
 #define SHADER_MEMORY_SIZE 0x4000
 
+static void _rbbm_debug_bus_read(struct kgsl_device *device,
+	unsigned int block_id, unsigned int index, unsigned int *val)
+{
+	unsigned int block = (block_id << 8) | 1 << 16;
+	adreno_regwrite(device, A3XX_RBBM_DEBUG_BUS_CTL, block | index);
+	adreno_regread(device, A3XX_RBBM_DEBUG_BUS_DATA_STATUS, val);
+}
+
 static int a3xx_snapshot_shader_memory(struct kgsl_device *device,
 	void *snapshot, int remain, void *priv)
 {
@@ -229,11 +237,8 @@
 	header->id = id;
 	header->count = DEBUGFS_BLOCK_SIZE;
 
-	for (i = 0; i < DEBUGFS_BLOCK_SIZE; i++) {
-		adreno_regwrite(device, A3XX_RBBM_DEBUG_BUS_CTL, val | i);
-		adreno_regread(device, A3XX_RBBM_DEBUG_BUS_DATA_STATUS,
-			&data[i]);
-	}
+	for (i = 0; i < DEBUGFS_BLOCK_SIZE; i++)
+		_rbbm_debug_bus_read(device, id, i, &data[i]);
 
 	return size;
 }
@@ -295,12 +300,37 @@
 	struct kgsl_snapshot_registers_list *list,
 	struct adreno_device *adreno_dev)
 {
-	
-	if (!adreno_is_a3xx(adreno_dev)) {
-		regs[list->count].regs = (unsigned int *) a3xx_hlsq_registers;
-		regs[list->count].count = a3xx_hlsq_registers_count;
-		list->count++;
+	struct kgsl_device *device = &adreno_dev->dev;
+
+
+	if (adreno_is_a330(adreno_dev)) {
+		unsigned int stall_context_full = 0;
+
+		_rbbm_debug_bus_read(device, RBBM_BLOCK_ID_HLSQ, 49,
+				&stall_context_full);
+		stall_context_full &= 0x08000000;
+
+		if (stall_context_full)
+			return;
+	} else {
+		unsigned int next_pif = 0;
+
+		
+		_rbbm_debug_bus_read(device, RBBM_BLOCK_ID_HLSQ, 4, &next_pif);
+		next_pif &= 0x1f;
+		if (next_pif != 0 && next_pif != 1 && next_pif != 28)
+			return;
+
+		
+		_rbbm_debug_bus_read(device, RBBM_BLOCK_ID_HLSQ, 7, &next_pif);
+		next_pif &= 0x3f;
+		if (next_pif != 0 && next_pif != 1 && next_pif != 10)
+			return;
 	}
+
+	regs[list->count].regs = (unsigned int *) a3xx_hlsq_registers;
+	regs[list->count].count = a3xx_hlsq_registers_count;
+	list->count++;
 }
 
 static void _snapshot_a330_regs(struct kgsl_snapshot_registers *regs,
@@ -391,7 +421,7 @@
 
 	
 	adreno_regwrite(device, A3XX_RBBM_CLOCK_CTL,
-			A3XX_RBBM_CLOCK_CTL_DEFAULT);
+		adreno_a3xx_rbbm_clock_ctl_default(adreno_dev));
 
 	return snapshot;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno.c	2013-08-01 23:38:02.000000000 -0600
@@ -18,13 +18,13 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/msm_kgsl.h>
+#include <linux/delay.h>
 
 #include <mach/socinfo.h>
 #include <mach/msm_bus_board.h>
 #include <mach/msm_bus.h>
 #include <mach/msm_dcvs.h>
 #include <mach/msm_dcvs_scm.h>
-#include <linux/delay.h>
 #include <mach/board.h>
 
 #include "kgsl.h"
@@ -191,11 +191,243 @@
 	{ ADRENO_REV_A320, 3, 2, ANY_ID, ANY_ID,
 		"a300_pm4.fw", "a300_pfp.fw", &adreno_a3xx_gpudev,
 		512, 0, 2, SZ_512K, 0x3FF037, 0x3FF016 },
-	{ ADRENO_REV_A330, 3, 3, 0, 0,
+	{ ADRENO_REV_A330, 3, 3, 0, ANY_ID,
 		"a330_pm4.fw", "a330_pfp.fw", &adreno_a3xx_gpudev,
 		512, 0, 2, SZ_1M, NO_VER, NO_VER },
 };
 
+
+static void adreno_perfcounter_init(struct kgsl_device *device)
+{
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+
+	if (adreno_dev->gpudev->perfcounter_init)
+		adreno_dev->gpudev->perfcounter_init(adreno_dev);
+};
+
+
+static void adreno_perfcounter_start(struct adreno_device *adreno_dev)
+{
+	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
+	struct adreno_perfcount_group *group;
+	unsigned int i, j;
+
+	
+	for (i = 0; i < counters->group_count; i++) {
+		group = &(counters->groups[i]);
+
+		
+		for (j = 0; j < group->reg_count; j++) {
+			if (group->regs[j].countable ==
+					KGSL_PERFCOUNTER_NOT_USED)
+				continue;
+
+			if (adreno_dev->gpudev->perfcounter_enable)
+				adreno_dev->gpudev->perfcounter_enable(
+					adreno_dev, i, j,
+					group->regs[j].countable);
+		}
+	}
+}
+
+
+int adreno_perfcounter_read_group(struct adreno_device *adreno_dev,
+	struct kgsl_perfcounter_read_group *reads, unsigned int count)
+{
+	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
+	struct adreno_perfcount_group *group;
+	struct kgsl_perfcounter_read_group *list = NULL;
+	unsigned int i, j;
+	int ret = 0;
+
+	
+	if (adreno_is_a2xx(adreno_dev))
+		return -EINVAL;
+
+	
+	if (!adreno_dev->gpudev->perfcounter_read)
+		return -EINVAL;
+
+	
+	if (reads == NULL || count == 0 || count > 100)
+		return -EINVAL;
+
+	
+	for (i = 0; i < count; i++) {
+		if (reads[i].groupid >= counters->group_count)
+			return -EINVAL;
+	}
+
+	list = kmalloc(sizeof(struct kgsl_perfcounter_read_group) * count,
+			GFP_KERNEL);
+	if (!list)
+		return -ENOMEM;
+
+	if (copy_from_user(list, reads,
+			sizeof(struct kgsl_perfcounter_read_group) * count)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	
+	for (j = 0; j < count; j++) {
+		list[j].value = 0;
+
+		group = &(counters->groups[list[j].groupid]);
+
+		
+		for (i = 0; i < group->reg_count; i++) {
+			if (group->regs[i].countable == list[j].countable) {
+				list[j].value =
+					adreno_dev->gpudev->perfcounter_read(
+					adreno_dev, list[j].groupid,
+					i, group->regs[i].offset);
+				break;
+			}
+		}
+	}
+
+	
+	if (copy_to_user(reads, list,
+			sizeof(struct kgsl_perfcounter_read_group) *
+			count) != 0)
+		ret = -EFAULT;
+
+done:
+	kfree(list);
+	return ret;
+}
+
+
+int adreno_perfcounter_query_group(struct adreno_device *adreno_dev,
+	unsigned int groupid, unsigned int *countables, unsigned int count,
+	unsigned int *max_counters)
+{
+	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
+	struct adreno_perfcount_group *group;
+	unsigned int i;
+
+	*max_counters = 0;
+
+	
+	if (adreno_is_a2xx(adreno_dev))
+		return -EINVAL;
+
+	if (groupid >= counters->group_count)
+		return -EINVAL;
+
+	group = &(counters->groups[groupid]);
+	*max_counters = group->reg_count;
+
+	if (countables == NULL || count == 0)
+		return 0;
+
+	for (i = 0; i < group->reg_count && i < count; i++) {
+		if (copy_to_user(&countables[i], &(group->regs[i].countable),
+				sizeof(unsigned int)) != 0)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+
+int adreno_perfcounter_get(struct adreno_device *adreno_dev,
+	unsigned int groupid, unsigned int countable, unsigned int *offset,
+	unsigned int flags)
+{
+	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
+	struct adreno_perfcount_group *group;
+	unsigned int i, empty = -1;
+
+	
+	if (offset)
+		*offset = 0;
+
+	
+	if (adreno_is_a2xx(adreno_dev))
+		return -EINVAL;
+
+	if (groupid >= counters->group_count)
+		return -EINVAL;
+
+	group = &(counters->groups[groupid]);
+
+	for (i = 0; i < group->reg_count; i++) {
+		if (group->regs[i].countable == countable) {
+			
+			group->regs[i].refcount++;
+			group->regs[i].flags |= flags;
+			if (offset)
+				*offset = group->regs[i].offset;
+			return 0;
+		} else if (group->regs[i].countable ==
+			KGSL_PERFCOUNTER_NOT_USED) {
+			
+			empty = i;
+		}
+	}
+
+	
+	if (empty == -1)
+		return -EBUSY;
+
+	
+	group->regs[empty].countable = countable;
+	group->regs[empty].refcount = 1;
+
+	
+	adreno_dev->gpudev->perfcounter_enable(adreno_dev, groupid, empty,
+		countable);
+
+	group->regs[empty].flags = flags;
+
+	if (offset)
+		*offset = group->regs[empty].offset;
+
+	return 0;
+}
+
+
+int adreno_perfcounter_put(struct adreno_device *adreno_dev,
+	unsigned int groupid, unsigned int countable)
+{
+	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
+	struct adreno_perfcount_group *group;
+
+	unsigned int i;
+
+	
+	if (adreno_is_a2xx(adreno_dev))
+		return -EINVAL;
+
+	if (groupid >= counters->group_count)
+		return -EINVAL;
+
+	group = &(counters->groups[groupid]);
+
+	for (i = 0; i < group->reg_count; i++) {
+		if (group->regs[i].countable == countable) {
+			if (group->regs[i].refcount > 0) {
+				group->regs[i].refcount--;
+
+				if (group->regs[i].flags &&
+					group->regs[i].refcount == 0)
+					group->regs[i].refcount++;
+
+				
+				if (group->regs[i].refcount == 0)
+					group->regs[i].countable =
+						KGSL_PERFCOUNTER_NOT_USED;
+			}
+
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
 static irqreturn_t adreno_irq_handler(struct kgsl_device *device)
 {
 	irqreturn_t result;
@@ -240,26 +472,24 @@
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 
-	result = kgsl_mmu_map_global(pagetable, &rb->buffer_desc,
-				     GSL_PT_PAGE_RV);
+	result = kgsl_mmu_map_global(pagetable, &rb->buffer_desc);
 	if (result)
 		goto error;
 
-	result = kgsl_mmu_map_global(pagetable, &rb->memptrs_desc,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	result = kgsl_mmu_map_global(pagetable, &rb->memptrs_desc);
 	if (result)
 		goto unmap_buffer_desc;
 
-	result = kgsl_mmu_map_global(pagetable, &device->memstore,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	result = kgsl_mmu_map_global(pagetable, &device->memstore);
 	if (result)
 		goto unmap_memptrs_desc;
 
-	result = kgsl_mmu_map_global(pagetable, &device->mmu.setstate_memory,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	result = kgsl_mmu_map_global(pagetable, &device->mmu.setstate_memory);
 	if (result)
 		goto unmap_memstore_desc;
 
+	device->mh.mpu_range = device->mmu.setstate_memory.gpuaddr +
+				device->mmu.setstate_memory.size;
 	return result;
 
 unmap_memstore_desc:
@@ -288,18 +518,21 @@
 	struct kgsl_context *context;
 	struct adreno_context *adreno_ctx = NULL;
 
-	if (!adreno_dev->drawctxt_active)
+	 if (!adreno_dev->drawctxt_active || device->ftbl->isidle(device) ||
+		 !device->active_cnt)
 		return kgsl_mmu_device_setstate(&device->mmu, flags);
+
 	num_iommu_units = kgsl_mmu_get_num_iommu_units(&device->mmu);
 
-	context = idr_find(&device->context_idr, context_id);
+	context = kgsl_context_get(device, context_id);
+
 	if (context == NULL)
 		return;
 	adreno_ctx = context->devctxt;
 
 	if (kgsl_mmu_enable_clk(&device->mmu,
 				KGSL_IOMMU_CONTEXT_USER))
-		return;
+		goto done;
 
 	cmds += __adreno_add_idle_indirect_cmds(cmds,
 		device->mmu.setstate_memory.gpuaddr +
@@ -393,13 +626,15 @@
 			KGSL_CMD_FLAGS_PMODE,
 			&link[0], sizedwords);
 		kgsl_mmu_disable_clk_on_ts(&device->mmu,
-		adreno_dev->ringbuffer.timestamp[KGSL_MEMSTORE_GLOBAL], true);
+				adreno_dev->ringbuffer.global_ts, true);
 	}
 
 	if (sizedwords > (sizeof(link)/sizeof(unsigned int))) {
 		KGSL_DRV_ERR(device, "Temp command buffer overflow\n");
 		BUG();
 	}
+done:
+	kgsl_context_put(context);
 }
 
 static void adreno_gpummu_setstate(struct kgsl_device *device,
@@ -417,7 +652,7 @@
 	if (adreno_is_a20x(adreno_dev))
 		flags |= KGSL_MMUFLAGS_TLBFLUSH;
 	if (!kgsl_cff_dump_enable && adreno_dev->drawctxt_active) {
-		context = idr_find(&device->context_idr, context_id);
+		context = kgsl_context_get(device, context_id);
 		if (context == NULL)
 			return;
 		adreno_ctx = context->devctxt;
@@ -485,6 +720,8 @@
 		adreno_ringbuffer_issuecmds(device, adreno_ctx,
 					KGSL_CMD_FLAGS_PMODE,
 					&link[0], sizedwords);
+
+		kgsl_context_put(context);
 	} else {
 		kgsl_mmu_device_setstate(&device->mmu, flags);
 	}
@@ -958,10 +1195,10 @@
 	return 0;
 }
 
-static int adreno_start(struct kgsl_device *device, unsigned int init_ram)
+static int adreno_init(struct kgsl_device *device)
 {
-	int status = -EINVAL;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 
 	if (KGSL_STATE_DUMP_AND_FT != device->state)
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
@@ -987,17 +1224,42 @@
 	if (adreno_dev->gpurev == ADRENO_REV_UNKNOWN) {
 		KGSL_DRV_ERR(device, "Unknown chip ID %x\n",
 			adreno_dev->chip_id);
-		goto error_clk_off;
+		BUG_ON(1);
 	}
 
 
-
 	if ((adreno_dev->pm4_fw_version >=
 		adreno_gpulist[adreno_dev->gpulist_index].sync_lock_pm4_ver) &&
 		(adreno_dev->pfp_fw_version >=
 		adreno_gpulist[adreno_dev->gpulist_index].sync_lock_pfp_ver))
 		device->mmu.flags |= KGSL_MMU_FLAGS_IOMMU_SYNC;
 
+	rb->global_ts = 0;
+
+	ft_detect_regs[0] = adreno_dev->gpudev->reg_rbbm_status;
+
+	adreno_perfcounter_init(device);
+
+	
+	kgsl_pwrctrl_disable(device);
+
+	return 0;
+}
+
+static int adreno_start(struct kgsl_device *device)
+{
+	int status = -EINVAL;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	unsigned int state = device->state;
+
+	kgsl_cffdump_open(device);
+
+	if (KGSL_STATE_DUMP_AND_FT != device->state)
+		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
+
+	
+	kgsl_pwrctrl_enable(device);
+
 	
 	if (adreno_is_a2xx(adreno_dev)) {
 		if (adreno_is_a20x(adreno_dev)) {
@@ -1036,20 +1298,32 @@
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
 
-	status = adreno_ringbuffer_start(&adreno_dev->ringbuffer, init_ram);
-	if (status == 0) {
-		if (KGSL_STATE_DUMP_AND_FT != device->state)
-			mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
-		return 0;
-	}
+	status = adreno_ringbuffer_start(&adreno_dev->ringbuffer);
+	if (status)
+		goto error_irq_off;
 
+
+	if (KGSL_STATE_DUMP_AND_FT != device->state)
+		mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
+
+	adreno_perfcounter_start(adreno_dev);
+
+	device->reset_counter++;
+
+	return 0;
+
+error_irq_off:
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
 
 error_mmu_off:
 	kgsl_mmu_stop(&device->mmu);
 
 error_clk_off:
-	kgsl_pwrctrl_disable(device);
+	if (KGSL_STATE_DUMP_AND_FT != device->state) {
+		kgsl_pwrctrl_disable(device);
+		
+		kgsl_pwrctrl_set_state(device, state);
+	}
 
 	return status;
 }
@@ -1073,6 +1347,8 @@
 	
 	kgsl_pwrctrl_disable(device);
 
+	kgsl_cffdump_close(device->id);
+
 	return 0;
 }
 
@@ -1081,19 +1357,18 @@
 {
 	struct kgsl_context *context;
 	int next = 0;
+
+	rcu_read_lock();
 	while ((context = idr_get_next(&device->context_idr, &next))) {
 		struct adreno_context *adreno_context = context->devctxt;
-		if(!adreno_context)
-			KGSL_FT_ERR(device, "adreno_context %d null\n", next);
 		if (ft_status) {
 			context->reset_status =
 					KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT;
-			if(adreno_context)
-				adreno_context->flags |= CTXT_FLAGS_GPU_HANG;
+			adreno_context->flags |= CTXT_FLAGS_GPU_HANG;
 		} else if (KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT !=
 			context->reset_status) {
-			if (adreno_context && (adreno_context->flags & (CTXT_FLAGS_GPU_HANG |
-				CTXT_FLAGS_GPU_HANG_FT)))
+			if (adreno_context->flags & (CTXT_FLAGS_GPU_HANG |
+				CTXT_FLAGS_GPU_HANG_FT))
 				context->reset_status =
 				KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT;
 			else
@@ -1102,30 +1377,31 @@
 		}
 		next = next + 1;
 	}
+	rcu_read_unlock();
 }
 
 static void adreno_set_max_ts_for_bad_ctxs(struct kgsl_device *device)
 {
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 	struct kgsl_context *context;
 	struct adreno_context *temp_adreno_context;
 	int next = 0;
 
+	rcu_read_lock();
 	while ((context = idr_get_next(&device->context_idr, &next))) {
 		temp_adreno_context = context->devctxt;
 		if (temp_adreno_context->flags & CTXT_FLAGS_GPU_HANG) {
 			kgsl_sharedmem_writel(&device->memstore,
 				KGSL_MEMSTORE_OFFSET(context->id,
 				soptimestamp),
-				rb->timestamp[context->id]);
+				temp_adreno_context->timestamp);
 			kgsl_sharedmem_writel(&device->memstore,
 				KGSL_MEMSTORE_OFFSET(context->id,
 				eoptimestamp),
-				rb->timestamp[context->id]);
+				temp_adreno_context->timestamp);
 		}
 		next = next + 1;
 	}
+	rcu_read_unlock();
 }
 
 static void adreno_destroy_ft_data(struct adreno_ft_data *ft_data)
@@ -1152,6 +1428,8 @@
 			start_ptr = adreno_ringbuffer_dec_wrapped(start_ptr,
 									size);
 		kgsl_sharedmem_readl(&rb->buffer_desc, &val1, start_ptr);
+		
+		rmb();
 		if (KGSL_CMD_IDENTIFIER == val1) {
 			if ((start_ptr / sizeof(unsigned int)) != rb->wptr)
 				start_ptr = adreno_ringbuffer_dec_wrapped(
@@ -1185,6 +1463,8 @@
 					temp_rb_rptr, size);
 		kgsl_sharedmem_readl(&rb->buffer_desc, &val[i],
 					temp_rb_rptr);
+		
+		rmb();
 
 		if (check && ((inc && val[i] == global_eop) ||
 			(!inc && (val[i] ==
@@ -1243,6 +1523,8 @@
 
 	while (temp_rb_rptr / sizeof(unsigned int) != rb->wptr) {
 		kgsl_sharedmem_readl(&rb->buffer_desc, &val[i], temp_rb_rptr);
+		
+		rmb();
 
 		if (check && val[i] == ib1) {
 			
@@ -1279,7 +1561,7 @@
 	return status;
 }
 
-static int adreno_setup_ft_data(struct kgsl_device *device,
+static void adreno_setup_ft_data(struct kgsl_device *device,
 					struct adreno_ft_data *ft_data)
 {
 	int ret = 0;
@@ -1304,50 +1586,54 @@
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 			eoptimestamp));
 
+	
+	rmb();
+
 	ft_data->rb_buffer = vmalloc(rb->buffer_desc.size);
 	if (!ft_data->rb_buffer) {
 		KGSL_MEM_ERR(device, "vmalloc(%d) failed\n",
 				rb->buffer_desc.size);
-		return -ENOMEM;
+		return;
 	}
 
 	ft_data->bad_rb_buffer = vmalloc(rb->buffer_desc.size);
 	if (!ft_data->bad_rb_buffer) {
 		KGSL_MEM_ERR(device, "vmalloc(%d) failed\n",
 				rb->buffer_desc.size);
-		ret = -ENOMEM;
-		goto done;
+		return;
 	}
 
 	ft_data->good_rb_buffer = vmalloc(rb->buffer_desc.size);
 	if (!ft_data->good_rb_buffer) {
 		KGSL_MEM_ERR(device, "vmalloc(%d) failed\n",
 				rb->buffer_desc.size);
-		ret = -ENOMEM;
-		goto done;
+		return;
 	}
 
-	ft_data->status =  0;
+	ft_data->status = 0;
 
 	
 	context = idr_find(&device->context_idr, ft_data->context_id);
 	
 
 	if (!context) {
-		goto done;
+		return;
 	}
-	ret = _find_cmd_seq_after_eop_ts(rb, &rb_rptr,
-					ft_data->global_eop + 1, false);
-	if (ret)
-		goto done;
 
-	ft_data->start_of_replay_cmds = rb_rptr;
+	ft_data->ft_policy = adreno_dev->ft_policy;
 
 	if (!adreno_dev->ft_policy)
 		adreno_dev->ft_policy = KGSL_FT_DEFAULT_POLICY;
 
-	ft_data->ft_policy = adreno_dev->ft_policy;
+	ret = _find_cmd_seq_after_eop_ts(rb, &rb_rptr,
+					ft_data->global_eop + 1, false);
+	if (ret) {
+		ft_data->ft_policy |= KGSL_FT_TEMP_DISABLE;
+		return;
+	} else
+		ft_data->ft_policy &= ~KGSL_FT_TEMP_DISABLE;
 
+	ft_data->start_of_replay_cmds = rb_rptr;
 
 	adreno_context = context->devctxt;
 	if (adreno_context->flags & CTXT_FLAGS_PREAMBLE) {
@@ -1357,21 +1643,12 @@
 			if (ret) {
 				KGSL_FT_ERR(device,
 				"Start not found for replay IB sequence\n");
-				ret = 0;
-				goto done;
+				return;
 			}
 			ft_data->start_of_replay_cmds = rb_rptr;
 			ft_data->replay_for_snapshot = rb_rptr;
 		}
 	}
-
-done:
-	if (ret) {
-		vfree(ft_data->rb_buffer);
-		vfree(ft_data->bad_rb_buffer);
-		vfree(ft_data->good_rb_buffer);
-	}
-	return ret;
 }
 
 static int
@@ -1385,6 +1662,8 @@
 			&curr_global_ts,
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 			eoptimestamp));
+	
+	rmb();
 
 	
 	adreno_dev->long_ib = 0;
@@ -1402,32 +1681,30 @@
 
 static int
 _adreno_ft_restart_device(struct kgsl_device *device,
-		   struct kgsl_context *context,
-		   struct adreno_ft_data *ft_data)
+		   struct kgsl_context *context)
 {
 
-	struct adreno_context *adreno_context = NULL;
+	struct adreno_context *adreno_context = context->devctxt;
 
 	
 	if (adreno_stop(device)) {
 		KGSL_FT_ERR(device, "Device stop failed\n");
 		return 1;
 	}
+	
+	if (adreno_init(device)) {
+		KGSL_FT_ERR(device, "Device start failed\n");
+		return 1;
+	}
 
-	if (adreno_start(device, true)) {
+	if (adreno_start(device)) {
 		KGSL_FT_ERR(device, "Device start failed\n");
 		return 1;
 	}
 
-	if (context) {
-		adreno_context = context->devctxt;
+	if (context)
 		kgsl_mmu_setstate(&device->mmu, adreno_context->pagetable,
 			KGSL_MEMSTORE_GLOBAL);
-	} else {
-		KGSL_FT_CRIT(device, "Last context unknown id:%d\n",
-			ft_data->context_id);
-		return 1;
-	}
 
 	if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype()) {
 		if (kgsl_mmu_enable_clk(&device->mmu,
@@ -1472,11 +1749,24 @@
 			unsigned int *buff, unsigned int size)
 {
 	unsigned int ret = 0;
+	unsigned int retry_num = 0;
 
 	_adreno_debug_ft_info(device, ft_data);
 
-	if (_adreno_ft_restart_device(device, context, ft_data))
-		return 1;
+	do {
+		ret = _adreno_ft_restart_device(device, context);
+		if (ret == 0)
+			break;
+		msleep(20);
+		KGSL_FT_ERR(device, "Retry device restart %d\n", retry_num);
+		retry_num++;
+	} while (retry_num < 4);
+
+	if (ret) {
+		KGSL_FT_ERR(device, "Device restart failed\n");
+		BUG_ON(1);
+		goto done;
+	}
 
 	if (size) {
 
@@ -1486,10 +1776,10 @@
 		ret = adreno_idle(device);
 	}
 
+done:
 	return ret;
 }
 
-
 static int
 _adreno_ft(struct kgsl_device *device,
 			struct adreno_ft_data *ft_data)
@@ -1500,22 +1790,27 @@
 	struct kgsl_context *context;
 	struct adreno_context *adreno_context = NULL;
 	struct adreno_context *last_active_ctx = adreno_dev->drawctxt_active;
+	unsigned int long_ib = 0;
+
+	context = kgsl_context_get(device, ft_data->context_id);
 
-	context = idr_find(&device->context_idr, ft_data->context_id);
 	if (context == NULL) {
-		KGSL_FT_CRIT(device, "Last context unknown id:%d\n",
+		KGSL_FT_ERR(device, "Last context unknown id:%d\n",
 			ft_data->context_id);
-		return -EINVAL;
-	} else if (context->devctxt == NULL) {
-		KGSL_FT_CRIT(device, "Last no adreno context, kgsl context id:%d\n",
-			context->id);
-		return -EINVAL;
+		goto play_good_cmds;
 	} else {
 		adreno_context = context->devctxt;
 		adreno_context->flags |= CTXT_FLAGS_GPU_HANG;
 		context->wait_on_invalid_ts = false;
 
+		if (!(adreno_context->flags & CTXT_FLAGS_PER_CONTEXT_TS)) {
+			ft_data->status = 1;
+			KGSL_FT_ERR(device, "Fault tolerance not supported\n");
+			goto play_good_cmds;
+		}
+
 		if (adreno_context->flags & CTXT_FLAGS_NO_FAULT_TOLERANCE) {
+			ft_data->status = 1;
 			KGSL_FT_ERR(device,
 			"No FT set for this context play good cmds\n");
 			goto play_good_cmds;
@@ -1523,45 +1818,53 @@
 
 	}
 
-	adreno_ringbuffer_extract(rb, ft_data);
-
 	if (adreno_dev->long_ib) {
-		if (_adreno_check_long_ib(device)) {
-			ft_data->status = 1;
-			_adreno_debug_ft_info(device, ft_data);
-			goto play_good_cmds;
-		} else {
+		long_ib = _adreno_check_long_ib(device);
+		if (!long_ib) {
 			adreno_context->flags &= ~CTXT_FLAGS_GPU_HANG;
 			return 0;
 		}
 	}
 
+	adreno_ringbuffer_extract(rb, ft_data);
+
 	
-	if (device->mmu.fault) {
-		KGSL_FT_ERR(device, "MMU fault skipping bad cmds\n");
-		device->mmu.fault = 0;
+	if (long_ib) {
+		ft_data->status = 1;
+		_adreno_debug_ft_info(device, ft_data);
 		goto play_good_cmds;
 	}
 
-	if (ft_data->ft_policy & KGSL_FT_DISABLE) {
+	if ((ft_data->ft_policy & KGSL_FT_DISABLE) ||
+		(ft_data->ft_policy & KGSL_FT_TEMP_DISABLE)) {
 		KGSL_FT_ERR(device, "NO FT policy play only good cmds\n");
+		ft_data->status = 1;
 		goto play_good_cmds;
 	}
 
-	if (ft_data->ft_policy & KGSL_FT_REPLAY) {
+	
+	if (adreno_context->pagefault) {
+		if ((ft_data->context_id == adreno_context->id) &&
+			(ft_data->global_eop == adreno_context->pagefault_ts)) {
+			ft_data->ft_policy &= ~KGSL_FT_REPLAY;
+			KGSL_FT_ERR(device, "MMU fault skipping replay\n");
+		}
 
+		adreno_context->pagefault = 0;
+	}
+
+	if (ft_data->ft_policy & KGSL_FT_REPLAY) {
 		ret = _adreno_ft_resubmit_rb(device, rb, context, ft_data,
 				ft_data->bad_rb_buffer, ft_data->bad_rb_size);
 
 		if (ret) {
-			KGSL_FT_ERR(device, "Replay unsuccessful\n");
+			KGSL_FT_ERR(device, "Replay status: 1\n");
 			ft_data->status = 1;
 		} else
 			goto play_good_cmds;
 	}
 
 	if (ft_data->ft_policy & KGSL_FT_SKIPIB) {
-
 		for (i = 0; i < ft_data->bad_rb_size; i++) {
 			if ((ft_data->bad_rb_buffer[i] ==
 					CP_HDR_INDIRECT_BUFFER_PFD) &&
@@ -1586,7 +1889,7 @@
 				ft_data->bad_rb_buffer, ft_data->bad_rb_size);
 
 		if (ret) {
-			KGSL_FT_ERR(device, "NOP faulty IB unsuccessful\n");
+			KGSL_FT_ERR(device, "NOP faulty IB status: 1\n");
 			ft_data->status = 1;
 		} else {
 			ft_data->status = 0;
@@ -1595,7 +1898,6 @@
 	}
 
 	if (ft_data->ft_policy & KGSL_FT_SKIPFRAME) {
-
 		for (i = 0; i < ft_data->bad_rb_size; i++) {
 			if (ft_data->bad_rb_buffer[i] ==
 					KGSL_END_OF_FRAME_IDENTIFIER) {
@@ -1615,7 +1917,7 @@
 				ft_data->bad_rb_buffer, ft_data->bad_rb_size);
 
 		if (ret) {
-			KGSL_FT_ERR(device, "Skip EOF unsuccessful\n");
+			KGSL_FT_ERR(device, "Skip EOF status: 1\n");
 			ft_data->status = 1;
 		} else {
 			ft_data->status = 0;
@@ -1648,17 +1950,21 @@
 		KGSL_FT_INFO(device, "Playing good commands successful\n");
 
 	if (ft_data->last_valid_ctx_id) {
-		struct kgsl_context *last_ctx =
-				idr_find(&device->context_idr,
-				ft_data->last_valid_ctx_id);
+		struct kgsl_context *last_ctx = kgsl_context_get(device,
+			ft_data->last_valid_ctx_id);
+
 		if (last_ctx)
 			adreno_dev->drawctxt_active = last_ctx->devctxt;
+
+		kgsl_context_put(last_ctx);
 	}
 
 done:
 	
 	if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype())
 		kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
+
+	kgsl_context_put(context);
 	return ret;
 }
 
@@ -1669,15 +1975,14 @@
 	int ret = 0;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
-	unsigned int timestamp;
 
 	KGSL_FT_INFO(device,
 	"Start Parameters: IB1: 0x%X, "
 	"Bad context_id: %u, global_eop: 0x%x\n",
 	ft_data->ib1, ft_data->context_id, ft_data->global_eop);
 
-	timestamp = rb->timestamp[KGSL_MEMSTORE_GLOBAL];
-	KGSL_FT_INFO(device, "Last issued global timestamp: %x\n", timestamp);
+	KGSL_FT_INFO(device, "Last issued global timestamp: %x\n",
+			rb->global_ts);
 
 	while (true) {
 
@@ -1685,9 +1990,7 @@
 
 		if (-EAGAIN == ret) {
 			adreno_destroy_ft_data(ft_data);
-			ret = adreno_setup_ft_data(device, ft_data);
-			if (ret)
-				goto done;
+			adreno_setup_ft_data(device, ft_data);
 			KGSL_FT_INFO(device,
 			"Retry. Parameters: "
 			"IB1: 0x%X, Bad context_id: %u, global_eop: 0x%x\n",
@@ -1707,18 +2010,16 @@
 			adreno_dev->drawctxt_active->pagetable;
 	else
 		device->mmu.hwpagetable = device->mmu.defaultpagetable;
-	rb->timestamp[KGSL_MEMSTORE_GLOBAL] = timestamp;
 	kgsl_sharedmem_writel(&device->memstore,
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
-			eoptimestamp),
-			rb->timestamp[KGSL_MEMSTORE_GLOBAL]);
+			eoptimestamp), rb->global_ts);
 
 	
 	if (adreno_dev->drawctxt_active != NULL) {
+		adreno_drawctxt_switch(adreno_dev, NULL, 0);
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	device->current_process_priv = NULL;
+		device->current_process_priv = NULL;
 #endif
-		adreno_drawctxt_switch(adreno_dev, NULL, 0);
 	}
 done:
 	adreno_set_max_ts_for_bad_ctxs(device);
@@ -1752,12 +2053,12 @@
 
 	for (i = 0; i < ARRAY_SIZE(kgsl_blocking_process_tbl); i++) {
 		if (!((strncmp(suspect_task_comm,
-				kgsl_blocking_process_tbl[i].name, TASK_COMM_LEN)) &&
-				(strncmp(suspect_task_parent_comm,
-				kgsl_blocking_process_tbl[i].name, TASK_COMM_LEN)))) {
-			cankill=0;
-			break;
-		}
+			kgsl_blocking_process_tbl[i].name, TASK_COMM_LEN)) &&
+					(strncmp(suspect_task_parent_comm,
+					kgsl_blocking_process_tbl[i].name, TASK_COMM_LEN)))) {
+				cankill=0;
+				break;
+			}
 	}
 
 	if (cankill) {
@@ -1768,6 +2069,10 @@
 		do_send_sig_info(SIGKILL,
 		SEND_SIG_FORCED, suspect_task, true);
 		ret = 0;
+	} else {
+		KGSL_DRV_ERR(device, "We can't kill suspect process "
+			"causing gpu hung due to stability, tgid=%d, name=%s, pname=%s\n",
+			suspect_tgid, suspect_task_comm, suspect_task_parent_comm);
 	}
 #endif
 	return ret;
@@ -1786,6 +2091,7 @@
 	unsigned int context_id;
 	pid_t gpu_hung_pid;
 
+
 	if (device->state == KGSL_STATE_HUNG)
 		goto done;
 	if (device->state == KGSL_STATE_DUMP_AND_FT) {
@@ -1805,10 +2111,7 @@
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 			current_context));
 		context = idr_find(&device->context_idr, context_id);
-		if ( !context || !(context->dev_priv) || !(context->dev_priv->process_priv) ) {
-			result = -ENODATA;
-			goto done;
-		}
+
 		gpu_hung_pid = context->dev_priv->process_priv->pid;
 
 		
@@ -1816,7 +2119,7 @@
 		kgsl_pwrctrl_pwrlevel_change(device, pwr->max_pwrlevel);
 
 		
-		result = adreno_setup_ft_data(device, &ft_data);
+		adreno_setup_ft_data(device, &ft_data);
 
 		if (!adreno_dev->long_ib) {
 			kgsl_postmortem_dump(device, 0);
@@ -1824,10 +2127,8 @@
 			kgsl_device_snapshot(device, 1);
 		}
 
-		if (!result) {
-			result = adreno_ft(device, &ft_data);
-			adreno_destroy_ft_data(&ft_data);
-		}
+		result = adreno_ft(device, &ft_data);
+		adreno_destroy_ft_data(&ft_data);
 
 		
 		kgsl_pwrctrl_pwrlevel_change(device, curr_pwrlevel);
@@ -1839,7 +2140,6 @@
 			mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
 		}
 		complete_all(&device->ft_gate);
-
 		
 		if (!device->snapshot_no_panic) {
 			if (result) {
@@ -1988,39 +2288,6 @@
 			status = 0;
 		}
 		break;
-	case KGSL_PROP_FAULT_TOLERANCE: {
-			struct kgsl_ft_config ftd;
-
-			if (adreno_dev->ft_user_control == 0)
-				break;
-
-			if (sizebytes != sizeof(ftd))
-				break;
-
-			if (copy_from_user(&ftd, (void __user *) value,
-							   sizeof(ftd))) {
-				status = -EFAULT;
-				break;
-			}
-
-			if (ftd.ft_policy)
-				adreno_dev->ft_policy = ftd.ft_policy;
-			else
-				adreno_dev->ft_policy = KGSL_FT_DEFAULT_POLICY;
-
-			if (ftd.ft_pf_policy)
-				adreno_dev->ft_pf_policy = ftd.ft_policy;
-			else
-				adreno_dev->ft_pf_policy =
-					KGSL_FT_PAGEFAULT_DEFAULT_POLICY;
-
-			if (ftd.ft_pm_dump)
-				device->pm_dump_enable = 1;
-			else
-				device->pm_dump_enable = 0;
-
-		}
-		break;
 	default:
 		break;
 	}
@@ -2036,9 +2303,6 @@
 	unsigned long wait;
 	unsigned long timeout = jiffies + msecs_to_jiffies(ADRENO_IDLE_TIMEOUT);
 
-	if (!(rb->flags & KGSL_FLAGS_STARTED))
-		return 0;
-
 
 	wait = jiffies + msecs_to_jiffies(100);
 
@@ -2147,7 +2411,7 @@
 	if (device->state == KGSL_STATE_ACTIVE) {
 		
 		GSL_RB_GET_READPTR(rb, &rb->rptr);
-		if (!device->active_cnt && (rb->rptr == rb->wptr)) {
+		if (rb->rptr == rb->wptr) {
 
 			if (!adreno_dev->gpudev->irq_pending(adreno_dev)) {
 				
@@ -2181,7 +2445,9 @@
 	struct kgsl_context *context;
 	struct adreno_context *adreno_context = NULL;
 	int next = 0;
+	struct kgsl_memdesc *desc = NULL;
 
+	rcu_read_lock();
 	while (1) {
 		context = idr_get_next(&device->context_idr, &next);
 		if (context == NULL)
@@ -2191,20 +2457,19 @@
 
 		if (kgsl_mmu_pt_equal(&device->mmu, adreno_context->pagetable,
 					pt_base)) {
-			struct kgsl_memdesc *desc;
-
 			desc = &adreno_context->gpustate;
 			if (kgsl_gpuaddr_in_memdesc(desc, gpuaddr, size))
-				return desc;
+				break;
 
 			desc = &adreno_context->context_gmem_shadow.gmemshadow;
 			if (kgsl_gpuaddr_in_memdesc(desc, gpuaddr, size))
-				return desc;
+				break;
 		}
 		next = next + 1;
+		desc = NULL;
 	}
-
-	return NULL;
+	rcu_read_unlock();
+	return desc;
 }
 
 struct kgsl_memdesc *adreno_find_region(struct kgsl_device *device,
@@ -2271,6 +2536,8 @@
 	if (!in_interrupt())
 		kgsl_pre_hwaccess(device);
 
+	kgsl_trace_regwrite(device, offsetwords, value);
+
 	kgsl_cffdump_regwrite(device->id, offsetwords << 2, value);
 	reg = (unsigned int *)(device->reg_virt + (offsetwords << 2));
 
@@ -2341,7 +2608,7 @@
 
 		if (context && device->state != KGSL_STATE_SLUMBER)
 			adreno_ringbuffer_issuecmds(device, context->devctxt,
-					KGSL_CMD_FLAGS_NONE, NULL, 0);
+					KGSL_CMD_FLAGS_GET_INT, NULL, 0);
 	}
 
 	return 0;
@@ -2392,8 +2659,6 @@
 	static struct adreno_context *curr_context;
 	static struct kgsl_context *context;
 
-	memset(curr_reg_val, 0, sizeof(int)*ft_detect_regs_count);
-
 	if (!adreno_dev->fast_hang_detect)
 		fast_hang_detected = 0;
 
@@ -2552,7 +2817,7 @@
 	if (kgsl_check_timestamp(device, context, timestamp))
 		return 0;
 
-	ts_issued = adreno_dev->ringbuffer.timestamp[context_id];
+	ts_issued = adreno_context_timestamp(context, &adreno_dev->ringbuffer);
 
 	adreno_regread(device, REG_CP_RB_RPTR, &rptr);
 	mb();
@@ -2583,7 +2848,7 @@
 	if (context_id == KGSL_CONTEXT_INVALID)
 		return -EINVAL;
 
-	ts_issued = adreno_dev->ringbuffer.timestamp[context_id];
+	ts_issued = adreno_context_timestamp(context, &adreno_dev->ringbuffer);
 
 	if (timestamp_cmp(timestamp, ts_issued) <= 0)
 		return 0;
@@ -2614,8 +2879,6 @@
 	int ts_compare = 1;
 	int io, ret = -ETIMEDOUT;
 
-	
-
 	if (context_id == KGSL_CONTEXT_INVALID) {
 		KGSL_DRV_WARN(device, "context was detached");
 		return -EINVAL;
@@ -2676,6 +2939,7 @@
 		time_elapsed += wait;
 
 
+
 		if (ts_compare && (adreno_ctx &&
 			(adreno_ctx->flags & CTXT_FLAGS_USER_GENERATED_TS))) {
 			if (time_elapsed > KGSL_SYNCOBJ_SERVER_TIMEOUT) {
@@ -2687,6 +2951,7 @@
 				
 				ts_compare = 0;
 
+
 				context->wait_on_invalid_ts = false;
 			}
 		}
@@ -2715,13 +2980,14 @@
 	switch (type) {
 	case KGSL_TIMESTAMP_QUEUED: {
 		struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-		struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 
-		timestamp = rb->timestamp[context_id];
+		timestamp = adreno_context_timestamp(context,
+				&adreno_dev->ringbuffer);
 		break;
 	}
 	case KGSL_TIMESTAMP_CONSUMED:
-		adreno_regread(device, REG_CP_TIMESTAMP, &timestamp);
+		kgsl_sharedmem_readl(&device->memstore, &timestamp,
+			KGSL_MEMSTORE_OFFSET(context_id, soptimestamp));
 		break;
 	case KGSL_TIMESTAMP_RETIRED:
 		kgsl_sharedmem_readl(&device->memstore, &timestamp,
@@ -2737,27 +3003,58 @@
 static long adreno_ioctl(struct kgsl_device_private *dev_priv,
 			      unsigned int cmd, void *data)
 {
+	struct kgsl_device *device = dev_priv->device;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int result = 0;
-	struct kgsl_drawctxt_set_bin_base_offset *binbase;
-	struct kgsl_context *context;
 
 	switch (cmd) {
-	case IOCTL_KGSL_DRAWCTXT_SET_BIN_BASE_OFFSET:
+	case IOCTL_KGSL_DRAWCTXT_SET_BIN_BASE_OFFSET: {
+		struct kgsl_drawctxt_set_bin_base_offset *binbase = data;
+		struct kgsl_context *context;
+
 		binbase = data;
 
-		context = kgsl_find_context(dev_priv, binbase->drawctxt_id);
+		context = kgsl_context_get_owner(dev_priv,
+			binbase->drawctxt_id);
 		if (context) {
 			adreno_drawctxt_set_bin_base_offset(
-				dev_priv->device, context, binbase->offset);
+				device, context, binbase->offset);
 		} else {
 			result = -EINVAL;
-			KGSL_DRV_ERR(dev_priv->device,
+			KGSL_DRV_ERR(device,
 				"invalid drawctxt drawctxt_id %d "
 				"device_id=%d\n",
-				binbase->drawctxt_id, dev_priv->device->id);
+				binbase->drawctxt_id, device->id);
 		}
-		break;
 
+		kgsl_context_put(context);
+		break;
+	}
+	case IOCTL_KGSL_PERFCOUNTER_GET: {
+		struct kgsl_perfcounter_get *get = data;
+		result = adreno_perfcounter_get(adreno_dev, get->groupid,
+			get->countable, &get->offset, PERFCOUNTER_FLAG_NONE);
+		break;
+	}
+	case IOCTL_KGSL_PERFCOUNTER_PUT: {
+		struct kgsl_perfcounter_put *put = data;
+		result = adreno_perfcounter_put(adreno_dev, put->groupid,
+			put->countable);
+		break;
+	}
+	case IOCTL_KGSL_PERFCOUNTER_QUERY: {
+		struct kgsl_perfcounter_query *query = data;
+		result = adreno_perfcounter_query_group(adreno_dev,
+			query->groupid, query->countables,
+			query->count, &query->max_counters);
+		break;
+	}
+	case IOCTL_KGSL_PERFCOUNTER_READ: {
+		struct kgsl_perfcounter_read *read = data;
+		result = adreno_perfcounter_read_group(adreno_dev,
+			read->reads, read->count);
+		break;
+	}
 	default:
 		KGSL_DRV_INFO(dev_priv->device,
 			"invalid ioctl code %08x\n", cmd);
@@ -2779,12 +3076,10 @@
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-	unsigned int cycles;
-
-	
-	
+	unsigned int cycles = 0;
 
-	cycles = adreno_dev->gpudev->busy_cycles(adreno_dev);
+	if (device->state == KGSL_STATE_ACTIVE)
+		cycles = adreno_dev->gpudev->busy_cycles(adreno_dev);
 
 	if (pwr->time != 0) {
 		s64 tmp = ktime_to_us(ktime_get());
@@ -2804,8 +3099,10 @@
 
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
 		if(device->current_process_priv != NULL) {
-			device->current_process_priv->gputime.total = device->current_process_priv->gputime.total + stats->total_time;
-			device->current_process_priv->gputime.busy = device->current_process_priv->gputime.busy + stats->busy_time;
+			device->current_process_priv->gputime.total
+				= device->current_process_priv->gputime.total + stats->total_time;
+			device->current_process_priv->gputime.busy
+				= device->current_process_priv->gputime.busy + stats->busy_time;
 			device->current_process_priv->gputime_in_state[device->pwrctrl.active_pwrlevel].total
 				= device->current_process_priv->gputime_in_state[device->pwrctrl.active_pwrlevel].total + stats->total_time;
 			device->current_process_priv->gputime_in_state[device->pwrctrl.active_pwrlevel].busy
@@ -2846,6 +3143,7 @@
 	.idle = adreno_idle,
 	.isidle = adreno_isidle,
 	.suspend_context = adreno_suspend_context,
+	.init = adreno_init,
 	.start = adreno_start,
 	.stop = adreno_stop,
 	.getproperty = adreno_getproperty,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_debugfs.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_debugfs.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_debugfs.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_debugfs.c	2013-08-01 23:38:02.000000000 -0600
@@ -81,4 +81,7 @@
 	adreno_dev->ft_pf_policy = KGSL_FT_PAGEFAULT_DEFAULT_POLICY;
 	debugfs_create_u32("ft_pagefault_policy", 0644, device->d_debugfs,
 			   &adreno_dev->ft_pf_policy);
+
+	debugfs_create_u32("active_cnt", 0444, device->d_debugfs,
+			   &device->active_cnt);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_drawctxt.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_drawctxt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_drawctxt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_drawctxt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,6 +12,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/msm_kgsl.h>
 
 #include "kgsl.h"
 #include "kgsl_sharedmem.h"
@@ -117,11 +118,10 @@
 
 int adreno_drawctxt_create(struct kgsl_device *device,
 			struct kgsl_pagetable *pagetable,
-			struct kgsl_context *context, uint32_t flags)
+			struct kgsl_context *context, uint32_t *flags)
 {
 	struct adreno_context *drawctxt;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 	int ret;
 
 	drawctxt = kzalloc(sizeof(struct adreno_context), GFP_KERNEL);
@@ -134,28 +134,37 @@
 	drawctxt->pagetable = pagetable;
 	drawctxt->bin_base_offset = 0;
 	drawctxt->id = context->id;
-	rb->timestamp[context->id] = 0;
+	drawctxt->timestamp = 0;
 
-	if (flags & KGSL_CONTEXT_PREAMBLE)
+	*flags &= (KGSL_CONTEXT_PREAMBLE |
+		KGSL_CONTEXT_NO_GMEM_ALLOC |
+		KGSL_CONTEXT_PER_CONTEXT_TS |
+		KGSL_CONTEXT_USER_GENERATED_TS |
+		KGSL_CONTEXT_TYPE_MASK);
+
+	if (*flags & KGSL_CONTEXT_PREAMBLE)
 		drawctxt->flags |= CTXT_FLAGS_PREAMBLE;
 
-	if (flags & KGSL_CONTEXT_NO_GMEM_ALLOC)
+	if (*flags & KGSL_CONTEXT_NO_GMEM_ALLOC)
 		drawctxt->flags |= CTXT_FLAGS_NOGMEMALLOC;
 
-	if (flags & KGSL_CONTEXT_PER_CONTEXT_TS)
+	if (*flags & KGSL_CONTEXT_PER_CONTEXT_TS)
 		drawctxt->flags |= CTXT_FLAGS_PER_CONTEXT_TS;
 
-	if (flags & KGSL_CONTEXT_USER_GENERATED_TS) {
-		if (!(flags & KGSL_CONTEXT_PER_CONTEXT_TS)) {
+	if (*flags & KGSL_CONTEXT_USER_GENERATED_TS) {
+		if (!(*flags & KGSL_CONTEXT_PER_CONTEXT_TS)) {
 			ret = -EINVAL;
 			goto err;
 		}
 		drawctxt->flags |= CTXT_FLAGS_USER_GENERATED_TS;
 	}
 
-	if (flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+	if (*flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
 		drawctxt->flags |= CTXT_FLAGS_NO_FAULT_TOLERANCE;
 
+	drawctxt->type =
+		(*flags & KGSL_CONTEXT_TYPE_MASK) >> KGSL_CONTEXT_TYPE_SHIFT;
+
 	ret = adreno_dev->gpudev->ctxt_create(adreno_dev, drawctxt);
 	if (ret)
 		goto err;
@@ -198,11 +207,10 @@
 
 		drawctxt->flags |= CTXT_FLAGS_BEING_DESTROYED;
 
+		adreno_drawctxt_switch(adreno_dev, NULL, 0);
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
 		device->current_process_priv = NULL;
 #endif
-
-		adreno_drawctxt_switch(adreno_dev, NULL, 0);
 	}
 
 	if (device->state != KGSL_STATE_HUNG)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_drawctxt.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_drawctxt.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_drawctxt.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_drawctxt.h	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -40,6 +40,13 @@
 #define CTXT_FLAGS_SKIP_EOF             BIT(15)
 #define CTXT_FLAGS_NO_FAULT_TOLERANCE  BIT(16)
 
+#define ADRENO_DRAWCTXT_TYPES \
+	{ KGSL_CONTEXT_TYPE_ANY, "any" }, \
+	{ KGSL_CONTEXT_TYPE_GL, "GL" }, \
+	{ KGSL_CONTEXT_TYPE_CL, "CL" }, \
+	{ KGSL_CONTEXT_TYPE_C2D, "C2D" }, \
+	{ KGSL_CONTEXT_TYPE_RS, "RS" }
+
 struct kgsl_device;
 struct adreno_device;
 struct kgsl_device_private;
@@ -69,7 +76,11 @@
 	char pid_name[TASK_COMM_LEN];
 	unsigned int id;
 	unsigned int ib_gpu_time_used;
+	unsigned int timestamp;
 	uint32_t flags;
+	uint32_t pagefault;
+	unsigned long pagefault_ts;
+	unsigned int type;
 	struct kgsl_pagetable *pagetable;
 	struct kgsl_memdesc gpustate;
 	unsigned int reg_restore[3];
@@ -102,7 +113,7 @@
 int adreno_drawctxt_create(struct kgsl_device *device,
 			struct kgsl_pagetable *pagetable,
 			struct kgsl_context *context,
-			uint32_t flags);
+			uint32_t *flags);
 
 void adreno_drawctxt_destroy(struct kgsl_device *device,
 			  struct kgsl_context *context);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno.h	2013-08-01 23:38:02.000000000 -0600
@@ -33,10 +33,12 @@
 #define KGSL_CMD_FLAGS_NONE             0x00000000
 #define KGSL_CMD_FLAGS_PMODE		0x00000001
 #define KGSL_CMD_FLAGS_INTERNAL_ISSUE	0x00000002
+#define KGSL_CMD_FLAGS_GET_INT		0x00000004
 #define KGSL_CMD_FLAGS_EOF	        0x00000100
 
 #define KGSL_CONTEXT_TO_MEM_IDENTIFIER	0x2EADBEEF
 #define KGSL_CMD_IDENTIFIER		0x2EEDFACE
+#define KGSL_CMD_INTERNAL_IDENTIFIER	0x2EEDD00D
 #define KGSL_START_OF_IB_IDENTIFIER	0x2EADEABE
 #define KGSL_END_OF_IB_IDENTIFIER	0x2ABEDEAD
 #define KGSL_END_OF_FRAME_IDENTIFIER	0x2E0F2E0F
@@ -106,6 +108,28 @@
 	unsigned int gpulist_index;
 	struct ocmem_buf *ocmem_hdl;
 	unsigned int ocmem_base;
+	unsigned int gpu_cycles;
+};
+
+#define PERFCOUNTER_FLAG_NONE 0x0
+#define PERFCOUNTER_FLAG_KERNEL 0x1
+
+
+struct adreno_perfcount_register {
+	unsigned int countable;
+	unsigned int refcount;
+	unsigned int offset;
+	unsigned int flags;
+};
+
+struct adreno_perfcount_group {
+	struct adreno_perfcount_register *regs;
+	unsigned int reg_count;
+};
+
+struct adreno_perfcounters {
+	struct adreno_perfcount_group *groups;
+	unsigned int group_count;
 };
 
 struct adreno_gpudev {
@@ -115,6 +139,8 @@
 	
 	int ctx_switches_since_last_draw;
 
+	struct adreno_perfcounters *perfcounters;
+
 	
 	int (*ctxt_create)(struct adreno_device *, struct adreno_context *);
 	void (*ctxt_save)(struct adreno_device *, struct adreno_context *);
@@ -125,9 +151,15 @@
 	void (*irq_control)(struct adreno_device *, int);
 	unsigned int (*irq_pending)(struct adreno_device *);
 	void * (*snapshot)(struct adreno_device *, void *, int *, int);
-	void (*rb_init)(struct adreno_device *, struct adreno_ringbuffer *);
+	int (*rb_init)(struct adreno_device *, struct adreno_ringbuffer *);
+	void (*perfcounter_init)(struct adreno_device *);
 	void (*start)(struct adreno_device *);
 	unsigned int (*busy_cycles)(struct adreno_device *);
+	void (*perfcounter_enable)(struct adreno_device *, unsigned int group,
+		unsigned int counter, unsigned int countable);
+	uint64_t (*perfcounter_read)(struct adreno_device *adreno_dev,
+		unsigned int group, unsigned int counter,
+		unsigned int offset);
 };
 
 struct adreno_ft_data {
@@ -148,6 +180,20 @@
 	unsigned int replay_for_snapshot;
 };
 
+#define  KGSL_FT_DISABLE                  BIT(0)
+#define  KGSL_FT_REPLAY                   BIT(1)
+#define  KGSL_FT_SKIPIB                   BIT(2)
+#define  KGSL_FT_SKIPFRAME                BIT(3)
+#define  KGSL_FT_TEMP_DISABLE             BIT(4)
+#define  KGSL_FT_DEFAULT_POLICY           (KGSL_FT_REPLAY + KGSL_FT_SKIPIB)
+
+#define KGSL_FT_PAGEFAULT_INT_ENABLE         0x00000001
+#define KGSL_FT_PAGEFAULT_GPUHALT_ENABLE     0x00000002
+#define KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE   0x00000004
+#define KGSL_FT_PAGEFAULT_LOG_ONE_PER_INT    0x00000008
+#define KGSL_FT_PAGEFAULT_DEFAULT_POLICY     (KGSL_FT_PAGEFAULT_INT_ENABLE + \
+					KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
+
 extern struct adreno_gpudev adreno_a2xx_gpudev;
 extern struct adreno_gpudev adreno_a3xx_gpudev;
 
@@ -178,6 +224,8 @@
 				unsigned int value);
 
 int adreno_dump(struct kgsl_device *device, int manual);
+unsigned int adreno_a3xx_rbbm_clock_ctl_default(struct adreno_device
+							*adreno_dev);
 
 struct kgsl_memdesc *adreno_find_region(struct kgsl_device *device,
 						unsigned int pt_base,
@@ -201,6 +249,13 @@
 unsigned int adreno_ft_detect(struct kgsl_device *device,
 						unsigned int *prev_reg_val);
 
+int adreno_perfcounter_get(struct adreno_device *adreno_dev,
+	unsigned int groupid, unsigned int countable, unsigned int *offset,
+	unsigned int flags);
+
+int adreno_perfcounter_put(struct adreno_device *adreno_dev,
+	unsigned int groupid, unsigned int countable);
+
 static inline int adreno_is_a200(struct adreno_device *adreno_dev)
 {
 	return (adreno_dev->gpurev == ADRENO_REV_A200);
@@ -262,12 +317,32 @@
 	return (adreno_dev->gpurev == ADRENO_REV_A330);
 }
 
+static inline int adreno_is_a330v2(struct adreno_device *adreno_dev)
+{
+	return ((adreno_dev->gpurev == ADRENO_REV_A330) &&
+		(ADRENO_CHIPID_PATCH(adreno_dev->chip_id) > 0));
+}
+
 static inline int adreno_rb_ctxtswitch(unsigned int *cmd)
 {
 	return (cmd[0] == cp_nop_packet(1) &&
 		cmd[1] == KGSL_CONTEXT_TO_MEM_IDENTIFIER);
 }
 
+static inline int adreno_context_timestamp(struct kgsl_context *k_ctxt,
+		struct adreno_ringbuffer *rb)
+{
+	struct adreno_context *a_ctxt = NULL;
+
+	if (k_ctxt)
+		a_ctxt = k_ctxt->devctxt;
+
+	if (a_ctxt && a_ctxt->flags & CTXT_FLAGS_PER_CONTEXT_TS)
+		return a_ctxt->timestamp;
+
+	return rb->global_ts;
+}
+
 static inline int adreno_encode_istore_size(struct adreno_device *adreno_dev)
 {
 	unsigned int size;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_postmortem.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_postmortem.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_postmortem.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_postmortem.c	2013-08-01 23:38:02.000000000 -0600
@@ -728,7 +728,7 @@
 	if (!device->pm_dump_enable) {
 
 		KGSL_LOG_DUMP(device,
-			"RBBM STATUS %08X | IB1:%08X/%08X | IB2: %08X/%08X"
+			"STATUS %08X | IB1:%08X/%08X | IB2: %08X/%08X"
 			" | RPTR: %04X | WPTR: %04X\n",
 			rbbm_status,  cp_ib1_base, cp_ib1_bufsz, cp_ib2_base,
 			cp_ib2_bufsz, cp_rb_rptr, cp_rb_wptr);
@@ -740,7 +740,9 @@
 			(unsigned int *) &context_id,
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 				current_context));
-	context = idr_find(&device->context_idr, context_id);
+
+	context = kgsl_context_get(device, context_id);
+
 	if (context) {
 		ts_processed = kgsl_readtimestamp(device, context,
 						  KGSL_TIMESTAMP_RETIRED);
@@ -749,6 +751,8 @@
 	} else
 		KGSL_LOG_DUMP(device, "BAD CTXT: %d\n", context_id);
 
+	kgsl_context_put(context);
+
 	num_item = adreno_ringbuffer_count(&adreno_dev->ringbuffer,
 						cp_rb_rptr);
 	if (num_item <= 0)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_ringbuffer.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_ringbuffer.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_ringbuffer.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_ringbuffer.c	2013-08-01 23:38:02.000000000 -0600
@@ -303,7 +303,7 @@
 	return 0;
 }
 
-int adreno_ringbuffer_start(struct adreno_ringbuffer *rb, unsigned int init_ram)
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb)
 {
 	int status;
 	
@@ -315,9 +315,6 @@
 	if (rb->flags & KGSL_FLAGS_STARTED)
 		return 0;
 
-	if (init_ram)
-		rb->timestamp[KGSL_MEMSTORE_GLOBAL] = 0;
-
 	kgsl_sharedmem_set(&rb->memptrs_desc, 0, 0,
 			   sizeof(struct kgsl_rbmemptrs));
 
@@ -418,7 +415,9 @@
 	adreno_regwrite(device, REG_CP_ME_CNTL, 0);
 
 	
-	adreno_dev->gpudev->rb_init(adreno_dev, rb);
+	status = adreno_dev->gpudev->rb_init(adreno_dev, rb);
+	if (status)
+		return status;
 
 	
 	status = adreno_idle(device);
@@ -451,6 +450,7 @@
 	rb->device = device;
 	rb->sizedwords = KGSL_RB_SIZE >> 2;
 
+	rb->buffer_desc.flags = KGSL_MEMFLAGS_GPUREADONLY;
 	
 	status = kgsl_allocate_contiguous(&rb->buffer_desc,
 		(rb->sizedwords << 2));
@@ -491,60 +491,57 @@
 	memset(rb, 0, sizeof(struct adreno_ringbuffer));
 }
 
-static uint32_t
+static int
 adreno_ringbuffer_addcmds(struct adreno_ringbuffer *rb,
 				struct adreno_context *context,
 				unsigned int flags, unsigned int *cmds,
-				int sizedwords, uint32_t timestamp)
+				int sizedwords)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
 	unsigned int *ringcmds;
 	unsigned int total_sizedwords = sizedwords;
 	unsigned int i;
 	unsigned int rcmd_gpu;
-	unsigned int context_id = KGSL_MEMSTORE_GLOBAL;
+	unsigned int context_id;
 	unsigned int gpuaddr = rb->device->memstore.gpuaddr;
+	unsigned int timestamp;
 
-	if (context && context->flags & CTXT_FLAGS_PER_CONTEXT_TS)
+	if ((context && (context->flags & CTXT_FLAGS_PER_CONTEXT_TS)) &&
+		!(flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE))
 		context_id = context->id;
-
-	if ((context && context->flags & CTXT_FLAGS_USER_GENERATED_TS) &&
-			(!(flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE))) {
-		if (timestamp_cmp(rb->timestamp[context_id],
-						timestamp) >= 0) {
-			KGSL_DRV_ERR(rb->device,
-				"Invalid user generated ts <%d:0x%x>, "
-				"less than last issued ts <%d:0x%x>\n",
-				context_id, timestamp, context_id,
-				rb->timestamp[context_id]);
-			return -ERANGE;
-		}
-	}
+	else
+		context_id = KGSL_MEMSTORE_GLOBAL;
 
 	total_sizedwords += flags & KGSL_CMD_FLAGS_PMODE ? 4 : 0;
 	
 	total_sizedwords += 2;
+	
+	total_sizedwords += (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE) ? 2 : 0;
 
 	
 	total_sizedwords += context ? 13 : 0;
 
+	if ((context) && (context->flags & CTXT_FLAGS_PER_CONTEXT_TS) &&
+		(flags & (KGSL_CMD_FLAGS_INTERNAL_ISSUE |
+		KGSL_CMD_FLAGS_GET_INT)))
+			total_sizedwords += 2;
+
 	if (adreno_is_a3xx(adreno_dev))
 		total_sizedwords += 7;
 
+	if (adreno_is_a2xx(adreno_dev))
+		total_sizedwords += 2; 
+
 	total_sizedwords += 2; 
-	if (context && context->flags & CTXT_FLAGS_PER_CONTEXT_TS &&
-			!(flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE)) {
-		total_sizedwords += 3; 
-		total_sizedwords += 4; 
+	total_sizedwords += 3; 
+	total_sizedwords += 4; 
+
+	if (KGSL_MEMSTORE_GLOBAL != context_id)
 		total_sizedwords += 3; 
-	} else {
-		total_sizedwords += 4; 
-	}
 
 	ringcmds = adreno_ringbuffer_allocspace(rb, context, total_sizedwords);
-	if (!ringcmds) {
-		return rb->timestamp[context_id];
-	}
+	if (!ringcmds)
+		return -ENOSPC;
 
 	rcmd_gpu = rb->buffer_desc.gpuaddr
 		+ sizeof(uint)*(rb->wptr-total_sizedwords);
@@ -552,6 +549,29 @@
 	GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_nop_packet(1));
 	GSL_RB_WRITE(ringcmds, rcmd_gpu, KGSL_CMD_IDENTIFIER);
 
+	if (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE) {
+		GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_nop_packet(1));
+		GSL_RB_WRITE(ringcmds, rcmd_gpu, KGSL_CMD_INTERNAL_IDENTIFIER);
+	}
+
+	
+	rb->global_ts++;
+
+	if (KGSL_MEMSTORE_GLOBAL != context_id)
+		timestamp = context->timestamp;
+	else
+		timestamp = rb->global_ts;
+
+	
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_type0_packet(REG_CP_TIMESTAMP, 1));
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, rb->global_ts);
+
+	
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_type3_packet(CP_MEM_WRITE, 2));
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
+		KGSL_MEMSTORE_OFFSET(context_id, soptimestamp)));
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, timestamp);
+
 	if (flags & KGSL_CMD_FLAGS_PMODE) {
 		
 		GSL_RB_WRITE(ringcmds, rcmd_gpu,
@@ -571,24 +591,11 @@
 		GSL_RB_WRITE(ringcmds, rcmd_gpu, 1);
 	}
 
-	
-	rb->timestamp[KGSL_MEMSTORE_GLOBAL]++;
-
-	
-	if (context && !(flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE)) {
-		if (context_id == KGSL_MEMSTORE_GLOBAL)
-			rb->timestamp[context->id] =
-				rb->timestamp[KGSL_MEMSTORE_GLOBAL];
-		else if (context->flags & CTXT_FLAGS_USER_GENERATED_TS)
-			rb->timestamp[context_id] = timestamp;
-		else
-			rb->timestamp[context_id]++;
+	if (adreno_is_a2xx(adreno_dev)) {
+		GSL_RB_WRITE(ringcmds, rcmd_gpu,
+			cp_type3_packet(CP_WAIT_FOR_IDLE, 1));
+		GSL_RB_WRITE(ringcmds, rcmd_gpu, 0x00);
 	}
-	timestamp = rb->timestamp[context_id];
-
-	
-	GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_type0_packet(REG_CP_TIMESTAMP, 1));
-	GSL_RB_WRITE(ringcmds, rcmd_gpu, rb->timestamp[KGSL_MEMSTORE_GLOBAL]);
 
 	if (adreno_is_a3xx(adreno_dev)) {
 
@@ -600,39 +607,19 @@
 		GSL_RB_WRITE(ringcmds, rcmd_gpu, 0x00);
 	}
 
-	if (context && context->flags & CTXT_FLAGS_PER_CONTEXT_TS
-			&& !(flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE)) {
-		
-		GSL_RB_WRITE(ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_MEM_WRITE, 2));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
-			KGSL_MEMSTORE_OFFSET(context_id, soptimestamp)));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, timestamp);
-
-		
-		GSL_RB_WRITE(ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_EVENT_WRITE, 3));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, CACHE_FLUSH_TS);
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
-			KGSL_MEMSTORE_OFFSET(context_id, eoptimestamp)));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, timestamp);
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, cp_type3_packet(CP_EVENT_WRITE, 3));
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, CACHE_FLUSH_TS);
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
+		KGSL_MEMSTORE_OFFSET(context_id, eoptimestamp)));
+	GSL_RB_WRITE(ringcmds, rcmd_gpu, timestamp);
 
+	if (KGSL_MEMSTORE_GLOBAL != context_id) {
 		GSL_RB_WRITE(ringcmds, rcmd_gpu,
 			cp_type3_packet(CP_MEM_WRITE, 2));
 		GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
-			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
-				eoptimestamp)));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu,
-			rb->timestamp[KGSL_MEMSTORE_GLOBAL]);
-	} else {
-		GSL_RB_WRITE(ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_EVENT_WRITE, 3));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, CACHE_FLUSH_TS);
-		GSL_RB_WRITE(ringcmds, rcmd_gpu, (gpuaddr +
-			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
-						eoptimestamp)));
-		GSL_RB_WRITE(ringcmds, rcmd_gpu,
-				rb->timestamp[KGSL_MEMSTORE_GLOBAL]);
+		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
+			eoptimestamp)));
+		GSL_RB_WRITE(ringcmds, rcmd_gpu, rb->global_ts);
 	}
 	if (context) {
 		
@@ -670,6 +657,15 @@
 		GSL_RB_WRITE(ringcmds, rcmd_gpu, CP_INT_CNTL__RB_INT_MASK);
 	}
 
+	if ((context) && (context->flags & CTXT_FLAGS_PER_CONTEXT_TS) &&
+		(flags & (KGSL_CMD_FLAGS_INTERNAL_ISSUE |
+		KGSL_CMD_FLAGS_GET_INT))) {
+			GSL_RB_WRITE(ringcmds, rcmd_gpu,
+				cp_type3_packet(CP_INTERRUPT, 1));
+			GSL_RB_WRITE(ringcmds, rcmd_gpu,
+				CP_INT_CNTL__RB_INT_MASK);
+	}
+
 	if (adreno_is_a3xx(adreno_dev)) {
 		
 		GSL_RB_WRITE(ringcmds, rcmd_gpu,
@@ -686,7 +682,7 @@
 
 	adreno_ringbuffer_submit(rb);
 
-	return timestamp;
+	return 0;
 }
 
 unsigned int
@@ -706,7 +702,7 @@
 	flags |= KGSL_CMD_FLAGS_INTERNAL_ISSUE;
 
 	return adreno_ringbuffer_addcmds(rb, drawctxt, flags, cmds,
-							sizedwords, 0);
+							sizedwords);
 }
 
 static bool _parse_ibs(struct kgsl_device_private *dev_priv, uint gpuaddr,
@@ -905,25 +901,31 @@
 {
 	struct kgsl_device *device = dev_priv->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int *link;
+	unsigned int *link = 0;
 	unsigned int *cmds;
 	unsigned int i;
-	struct adreno_context *drawctxt;
+	struct adreno_context *drawctxt = NULL;
 	unsigned int start_index = 0;
+	int ret = 0;
 
-	if (device->state & KGSL_STATE_HUNG)
-		return -EBUSY;
-	if (!(adreno_dev->ringbuffer.flags & KGSL_FLAGS_STARTED) ||
-	      context == NULL || ibdesc == 0 || numibs == 0)
-		return -EINVAL;
+	if (device->state & KGSL_STATE_HUNG) {
+		ret = -EBUSY;
+		goto done;
+	}
 
+	if (!(adreno_dev->ringbuffer.flags & KGSL_FLAGS_STARTED) ||
+	      context == NULL || ibdesc == 0 || numibs == 0) {
+		ret = -EINVAL;
+		goto done;
+	}
 	drawctxt = context->devctxt;
 
 	if (drawctxt->flags & CTXT_FLAGS_GPU_HANG) {
 		KGSL_CTXT_ERR(device, "proc %s failed fault tolerance"
 			" will not accept commands for context %d\n",
 			drawctxt->pid_name, drawctxt->id);
-		return -EDEADLK;
+		ret = -EDEADLK;
+		goto done;
 	}
 
 	if (drawctxt->flags & CTXT_FLAGS_SKIP_EOF) {
@@ -939,9 +941,8 @@
 	cmds = link = kzalloc(sizeof(unsigned int) * (numibs * 3 + 4),
 				GFP_KERNEL);
 	if (!link) {
-		KGSL_CORE_ERR("kzalloc(%d) failed\n",
-			sizeof(unsigned int) * (numibs * 3 + 4));
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto done;
 	}
 
 
@@ -963,9 +964,15 @@
 		if (unlikely(adreno_dev->ib_check_level >= 1 &&
 		    !_parse_ibs(dev_priv, ibdesc[i].gpuaddr,
 				ibdesc[i].sizedwords))) {
-			kfree(link);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto done;
+		}
+
+		if (ibdesc[i].sizedwords == 0) {
+			ret = -EINVAL;
+			goto done;
 		}
+
 		*cmds++ = CP_HDR_INDIRECT_BUFFER_PFD;
 		*cmds++ = ibdesc[i].gpuaddr;
 		*cmds++ = ibdesc[i].sizedwords;
@@ -979,21 +986,36 @@
 					device->id));
 
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	if(device->current_process_priv == NULL || device->current_process_priv->pid != dev_priv->process_priv->pid)
+	if(device->current_process_priv == NULL
+			|| device->current_process_priv->pid != dev_priv->process_priv->pid)
 		device->current_process_priv = dev_priv->process_priv;
 #endif
-
 	adreno_drawctxt_switch(adreno_dev, drawctxt, flags);
 
-	*timestamp = adreno_ringbuffer_addcmds(&adreno_dev->ringbuffer,
+	if (drawctxt->flags & CTXT_FLAGS_USER_GENERATED_TS) {
+		if (timestamp_cmp(drawctxt->timestamp, *timestamp) >= 0) {
+			KGSL_DRV_ERR(device,
+				"Invalid user generated ts <%d:0x%x>, "
+				"less than last issued ts <%d:0x%x>\n",
+				drawctxt->id, *timestamp, drawctxt->id,
+				drawctxt->timestamp);
+			return -ERANGE;
+		}
+		drawctxt->timestamp = *timestamp;
+	} else
+		drawctxt->timestamp++;
+
+	ret = adreno_ringbuffer_addcmds(&adreno_dev->ringbuffer,
 					drawctxt,
 					(flags & KGSL_CMD_FLAGS_EOF),
-					&link[0], (cmds - link), *timestamp);
-
-	KGSL_CMD_INFO(device, "ctxt %d g %08x numibs %d ts %d\n",
-		context->id, (unsigned int)ibdesc, numibs, *timestamp);
-
-	kfree(link);
+					&link[0], (cmds - link));
+	if (ret)
+		goto done;
+
+	if (drawctxt->flags & CTXT_FLAGS_PER_CONTEXT_TS)
+		*timestamp = drawctxt->timestamp;
+	else
+		*timestamp = adreno_dev->ringbuffer.global_ts;
 
 #ifdef CONFIG_MSM_KGSL_CFF_DUMP
 	adreno_idle(device);
@@ -1001,9 +1023,15 @@
 
 	if (drawctxt->flags & CTXT_FLAGS_GPU_HANG_FT) {
 		drawctxt->flags &= ~CTXT_FLAGS_GPU_HANG_FT;
-		return -EPROTO;
-	} else
-		return 0;
+		ret = -EPROTO;
+	}
+
+done:
+	kgsl_trace_issueibcmds(device, context->id, ibdesc, numibs,
+		*timestamp, flags, ret, drawctxt->type);
+
+	kfree(link);
+	return ret;
 }
 
 static void _turn_preamble_on_for_ib_seq(struct adreno_ringbuffer *rb,
@@ -1071,11 +1099,13 @@
 	if (0xFFFFFFFF == ft_data->start_of_replay_cmds)
 		return;
 
-	k_ctxt = idr_find(&device->context_idr, ft_data->context_id);
+	k_ctxt = kgsl_context_get(device, ft_data->context_id);
+
 	if (k_ctxt) {
 		a_ctxt = k_ctxt->devctxt;
 		if (a_ctxt->flags & CTXT_FLAGS_PREAMBLE)
 			_turn_preamble_on_for_ib_seq(rb, rb_rptr);
+		kgsl_context_put(k_ctxt);
 	}
 	k_ctxt = NULL;
 
@@ -1099,7 +1129,8 @@
 			kgsl_sharedmem_readl(&rb->buffer_desc, &val2,
 						temp_rb_rptr);
 
-			k_ctxt = idr_find(&rb->device->context_idr, val2);
+			k_ctxt = kgsl_context_get(rb->device, val2);
+
 			if (k_ctxt) {
 				a_ctxt = k_ctxt->devctxt;
 
@@ -1127,6 +1158,7 @@
 				copy_rb_contents = 0;
 			}
 			}
+			kgsl_context_put(k_ctxt);
 		}
 
 		if (copy_rb_contents)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_ringbuffer.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_ringbuffer.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_ringbuffer.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_ringbuffer.h	2013-08-01 23:38:02.000000000 -0600
@@ -51,7 +51,7 @@
 	unsigned int wptr; 
 	unsigned int rptr; 
 
-	unsigned int timestamp[KGSL_MEMSTORE_MAX];
+	unsigned int global_ts;
 };
 
 
@@ -85,8 +85,7 @@
 
 int adreno_ringbuffer_init(struct kgsl_device *device);
 
-int adreno_ringbuffer_start(struct adreno_ringbuffer *rb,
-				unsigned int init_ram);
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb);
 
 void adreno_ringbuffer_stop(struct adreno_ringbuffer *rb);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_snapshot.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_snapshot.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/adreno_snapshot.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/adreno_snapshot.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -114,6 +114,9 @@
 static unsigned int sp_vs_pvt_mem_addr;
 static unsigned int sp_fs_pvt_mem_addr;
 
+static unsigned int sp_vs_obj_start_reg;
+static unsigned int sp_fs_obj_start_reg;
+
 
 static int load_state_unit_sizes[7][2] = {
 	{ 2, 4 },
@@ -292,6 +295,26 @@
 		sp_fs_pvt_mem_addr = 0;
 	}
 
+	if (sp_vs_obj_start_reg) {
+		ret = kgsl_snapshot_get_object(device, ptbase,
+			sp_vs_obj_start_reg & 0xFFFFFFE0, 0,
+			SNAPSHOT_GPU_OBJECT_GENERIC);
+		if (ret < 0)
+			return -EINVAL;
+		snapshot_frozen_objsize += ret;
+		sp_vs_obj_start_reg = 0;
+	}
+
+	if (sp_fs_obj_start_reg) {
+		ret = kgsl_snapshot_get_object(device, ptbase,
+			sp_fs_obj_start_reg & 0xFFFFFFE0, 0,
+			SNAPSHOT_GPU_OBJECT_GENERIC);
+		if (ret < 0)
+			return -EINVAL;
+		snapshot_frozen_objsize += ret;
+		sp_fs_obj_start_reg = 0;
+	}
+
 	
 
 	
@@ -354,7 +377,7 @@
 	int offset = type0_pkt_offset(*ptr);
 	int i;
 
-	for (i = 0; i < size; i++, offset++) {
+	for (i = 0; i < size - 1; i++, offset++) {
 
 		
 
@@ -395,11 +418,20 @@
 			case A3XX_SP_FS_PVT_MEM_ADDR_REG:
 				sp_fs_pvt_mem_addr = ptr[i + 1];
 				break;
+			case A3XX_SP_VS_OBJ_START_REG:
+				sp_vs_obj_start_reg = ptr[i + 1];
+				break;
+			case A3XX_SP_FS_OBJ_START_REG:
+				sp_fs_obj_start_reg = ptr[i + 1];
+				break;
 			}
 		}
 	}
 }
 
+static inline int parse_ib(struct kgsl_device *device, unsigned int ptbase,
+		unsigned int gpuaddr, unsigned int dwords);
+
 
 static int ib_add_gpu_object(struct kgsl_device *device, unsigned int ptbase,
 		unsigned int gpuaddr, unsigned int dwords)
@@ -433,23 +465,12 @@
 			if (adreno_cmd_is_ib(src[i])) {
 				unsigned int gpuaddr = src[i + 1];
 				unsigned int size = src[i + 2];
-				unsigned int ibbase;
-
-				
-				kgsl_regread(device, REG_CP_IB2_BASE, &ibbase);
 
+				ret = parse_ib(device, ptbase, gpuaddr, size);
 
-				if (ibbase == gpuaddr)
-					push_object(device,
-						SNAPSHOT_OBJ_TYPE_IB, ptbase,
-						gpuaddr, size);
-				else {
-					ret = ib_add_gpu_object(device,
-						ptbase, gpuaddr, size);
-
-					if (ret < 0)
-						goto done;
-				}
+				
+				if (ret < 0)
+					goto done;
 			} else {
 				ret = ib_parse_type3(device, &src[i], ptbase);
 
@@ -474,28 +495,23 @@
 	return ret;
 }
 
-static int snapshot_istore(struct kgsl_device *device, void *snapshot,
-	int remain, void *priv)
+static inline int parse_ib(struct kgsl_device *device, unsigned int ptbase,
+		unsigned int gpuaddr, unsigned int dwords)
 {
-	struct kgsl_snapshot_istore *header = snapshot;
-	unsigned int *data = snapshot + sizeof(*header);
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	int count, i;
-
-	count = adreno_dev->istore_size * adreno_dev->instruction_size;
+	unsigned int ib1base, ib2base;
+	int ret = 0;
 
-	if (remain < (count * 4) + sizeof(*header)) {
-		KGSL_DRV_ERR(device,
-			"snapshot: Not enough memory for the istore section");
-		return 0;
-	}
 
-	header->count = adreno_dev->istore_size;
+	kgsl_regread(device, REG_CP_IB1_BASE, &ib1base);
+	kgsl_regread(device, REG_CP_IB2_BASE, &ib2base);
 
-	for (i = 0; i < count; i++)
-		kgsl_regread(device, ADRENO_ISTORE_START + i, &data[i]);
+	if (gpuaddr == ib1base || gpuaddr == ib2base)
+		push_object(device, SNAPSHOT_OBJ_TYPE_IB, ptbase,
+			gpuaddr, dwords);
+	else
+		ret = ib_add_gpu_object(device, ptbase, gpuaddr, dwords);
 
-	return (count * 4) + sizeof(*header);
+	return ret;
 }
 
 static int snapshot_rb(struct kgsl_device *device, void *snapshot,
@@ -597,21 +613,20 @@
 
 			struct kgsl_memdesc *memdesc =
 				adreno_find_ctxtmem(device, ptbase, ibaddr,
-					ibsize);
+					ibsize << 2);
 
 			
 			if (NULL == memdesc)
 				if (kgsl_gpuaddr_in_memdesc(
 						&device->mmu.setstate_memory,
-						ibaddr, ibsize))
+						ibaddr, ibsize << 2))
 					memdesc = &device->mmu.setstate_memory;
 
-			if (ibaddr == ibbase || memdesc != NULL)
+			if (memdesc != NULL)
 				push_object(device, SNAPSHOT_OBJ_TYPE_IB,
 					ptbase, ibaddr, ibsize);
 			else
-				ib_add_gpu_object(device, ptbase, ibaddr,
-					ibsize);
+				parse_ib(device, ptbase, ibaddr, ibsize);
 		}
 
 		index = index + 1;
@@ -655,15 +670,14 @@
 				continue;
 
 			if (adreno_cmd_is_ib(*src))
-				push_object(device, SNAPSHOT_OBJ_TYPE_IB,
-					obj->ptbase, src[1], src[2]);
-			else {
+				ret = parse_ib(device, obj->ptbase, src[1],
+					src[2]);
+			else
 				ret = ib_parse_type3(device, src, obj->ptbase);
 
-				
-				if (ret < 0)
-					break;
-			}
+			
+			if (ret < 0)
+				break;
 		}
 	}
 
@@ -742,13 +756,6 @@
 	for (i = 0; i < objbufptr; i++)
 		snapshot = dump_object(device, i, snapshot, remain);
 
-
-	if (hang) {
-		snapshot = kgsl_snapshot_add_section(device,
-			KGSL_SNAPSHOT_SECTION_ISTORE, snapshot, remain,
-			snapshot_istore, NULL);
-	}
-
 	
 	if (adreno_dev->gpudev->snapshot)
 		snapshot = adreno_dev->gpudev->snapshot(adreno_dev, snapshot,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -97,17 +97,6 @@
 	default n
 	depends on MSM_KGSL
 
-config MSM_KGSL_DEFAULT_GPUMMU
-	bool "Prefer gpummu than iommu"
-	default n
-
-config MSM_KGSL_PAGE_TABLE_SIZE_FOR_IOMMU
-	hex "Size of pagetables for iommu"
-	default 0x1FE00000
-	---help---
-	Sets the pagetable size used by the IOMMU.  The max value
-	is 0x1FE00000 or (512M - 1536K - little interval).
-
 config MSM_KGSL_KILL_HANG_PROCESS
 	bool "Enable killing recoverable gpu hang process routine"
 	default y
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl.c	2013-08-01 23:38:02.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/msm_ion.h>
 #include <linux/io.h>
 #include <mach/socinfo.h>
+#include <linux/mman.h>
 
 #include "kgsl.h"
 #include "kgsl_debugfs.h"
@@ -52,50 +53,7 @@
 
 static struct ion_client *kgsl_ion_client;
 
-
-struct kgsl_mem_entry *kgsl_get_mem_entry(struct kgsl_device *device,
-	unsigned int ptbase, unsigned int gpuaddr, unsigned int size)
-{
-	struct kgsl_process_private *priv;
-	struct kgsl_mem_entry *entry;
-
-	mutex_lock(&kgsl_driver.process_mutex);
-
-	list_for_each_entry(priv, &kgsl_driver.process_list, list) {
-		if (!kgsl_mmu_pt_equal(&device->mmu, priv->pagetable, ptbase))
-			continue;
-		spin_lock(&priv->mem_lock);
-		entry = kgsl_sharedmem_find_region(priv, gpuaddr, size);
-
-		if (entry) {
-			spin_unlock(&priv->mem_lock);
-			mutex_unlock(&kgsl_driver.process_mutex);
-			return entry;
-		}
-		spin_unlock(&priv->mem_lock);
-	}
-	mutex_unlock(&kgsl_driver.process_mutex);
-
-	return NULL;
-}
-EXPORT_SYMBOL(kgsl_get_mem_entry);
-
-static inline struct kgsl_mem_entry *
-kgsl_mem_entry_create(void)
-{
-	struct kgsl_mem_entry *entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-
-	if (!entry)
-		KGSL_CORE_ERR("kzalloc(%d) failed\n", sizeof(*entry));
-	else {
-		kref_init(&entry->refcount);
-		entry->memdesc.handle = NULL;
-	}
-
-	return entry;
-}
-
-unsigned int kgsl_get_alloc_size(int detailed)
+unsigned int kgsl_get_alloc_size(int detailed) 
 {
 	unsigned int ret = 0;
 	struct kgsl_process_private *private;
@@ -135,6 +93,119 @@
 	return ret;
 }
 
+static void kgsl_mem_entry_detach_process(struct kgsl_mem_entry *entry);
+void kgsl_trace_issueibcmds(struct kgsl_device *device, int id,
+		struct kgsl_ibdesc *ibdesc, int numibs,
+		unsigned int timestamp, unsigned int flags,
+		int result, unsigned int type)
+{
+	trace_kgsl_issueibcmds(device, id, ibdesc, numibs,
+		timestamp, flags, result, type);
+}
+EXPORT_SYMBOL(kgsl_trace_issueibcmds);
+
+/**
+ * kgsl_trace_regwrite - call regwrite ftrace function by proxy
+ * device: KGSL device
+ * offset: dword offset of the register being written
+ * value: Value of the register being written
+ *
+ * Wrap the regwrite ftrace hook into a function that can be called from the
+ * GPU specific modules.
+ */
+void kgsl_trace_regwrite(struct kgsl_device *device, unsigned int offset,
+		unsigned int value)
+{
+	trace_kgsl_regwrite(device, offset, value);
+}
+EXPORT_SYMBOL(kgsl_trace_regwrite);
+
+int kgsl_memfree_hist_init(void)
+{
+	void *base;
+
+	base = kzalloc(KGSL_MEMFREE_HIST_SIZE, GFP_KERNEL);
+	kgsl_driver.memfree_hist.base_hist_rb = base;
+	if (base == NULL)
+		return -ENOMEM;
+	kgsl_driver.memfree_hist.size = KGSL_MEMFREE_HIST_SIZE;
+	kgsl_driver.memfree_hist.wptr = base;
+	return 0;
+}
+
+void kgsl_memfree_hist_exit(void)
+{
+	kfree(kgsl_driver.memfree_hist.base_hist_rb);
+	kgsl_driver.memfree_hist.base_hist_rb = NULL;
+}
+
+void kgsl_memfree_hist_set_event(unsigned int pid, unsigned int gpuaddr,
+			unsigned int size, int flags)
+{
+	struct kgsl_memfree_hist_elem *p;
+
+	void *base = kgsl_driver.memfree_hist.base_hist_rb;
+	int rbsize = kgsl_driver.memfree_hist.size;
+
+	if (base == NULL)
+		return;
+
+	mutex_lock(&kgsl_driver.memfree_hist_mutex);
+	p = kgsl_driver.memfree_hist.wptr;
+	p->pid = pid;
+	p->gpuaddr = gpuaddr;
+	p->size = size;
+	p->flags = flags;
+
+	kgsl_driver.memfree_hist.wptr++;
+	if ((void *)kgsl_driver.memfree_hist.wptr >= base+rbsize) {
+		kgsl_driver.memfree_hist.wptr =
+			(struct kgsl_memfree_hist_elem *)base;
+	}
+	mutex_unlock(&kgsl_driver.memfree_hist_mutex);
+}
+
+
+
+struct kgsl_mem_entry * __must_check
+kgsl_get_mem_entry(struct kgsl_device *device, unsigned int ptbase,
+		   unsigned int gpuaddr, unsigned int size)
+{
+	struct kgsl_process_private *priv;
+	struct kgsl_mem_entry *entry;
+
+	mutex_lock(&kgsl_driver.process_mutex);
+
+	list_for_each_entry(priv, &kgsl_driver.process_list, list) {
+		if (!kgsl_mmu_pt_equal(&device->mmu, priv->pagetable, ptbase))
+			continue;
+		entry = kgsl_sharedmem_find_region(priv, gpuaddr, size);
+
+		if (entry) {
+			mutex_unlock(&kgsl_driver.process_mutex);
+			return entry;
+		}
+	}
+	mutex_unlock(&kgsl_driver.process_mutex);
+
+	return NULL;
+}
+EXPORT_SYMBOL(kgsl_get_mem_entry);
+
+static inline struct kgsl_mem_entry *
+kgsl_mem_entry_create(void)
+{
+	struct kgsl_mem_entry *entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+
+	if (!entry)
+		KGSL_CORE_ERR("kzalloc(%d) failed\n", sizeof(*entry));
+	else {
+		kref_init(&entry->refcount);
+		entry->memdesc.handle = NULL;
+	}
+	return entry;
+}
+
 void
 kgsl_mem_entry_destroy(struct kref *kref)
 {
@@ -142,6 +213,9 @@
 						    struct kgsl_mem_entry,
 						    refcount);
 
+	
+	kgsl_mem_entry_detach_process(entry);
+
 	if (entry->memtype != KGSL_MEM_ENTRY_KERNEL)
 		kgsl_driver.stats.mapped -= entry->memdesc.size;
 
@@ -167,47 +241,27 @@
 }
 EXPORT_SYMBOL(kgsl_mem_entry_destroy);
 
-
-
-void
-kgsl_dump_contextpid(struct idr *context_idr)
-{
-	int i = 0;
-	struct kgsl_context *context;
-	struct task_struct *task;
-	struct task_struct *parent_task;
-	char task_name[TASK_COMM_LEN+1] = {0};
-	char task_parent_name[TASK_COMM_LEN+1] = {0};
-
-	printk(" == [KGSL] context maximal count is %d, dump context id, pid, name, group leader name==\n",KGSL_MEMSTORE_MAX);
-	for (i = 0; i <KGSL_MEMSTORE_MAX; i++) {
-
-		context = idr_find(context_idr, i);
-
-		if (context  && context->dev_priv &&  context->dev_priv->process_priv) {
-			task = find_task_by_pid_ns(context->dev_priv->process_priv->pid, &init_pid_ns);
-			if (task) {
-				parent_task = task->group_leader;
-				get_task_comm(task_name, task);
-
-				if (parent_task)
-					get_task_comm(task_parent_name, parent_task);
-				else
-					task_parent_name[0] = '\0';
-			}
-			printk("context id=%d\t\t pid=%d\t\t %s\t\t %s\n", context->id,context->dev_priv->process_priv->pid, task_name, task_parent_name);
-		}
-	}
-}
-
-static
-void kgsl_mem_entry_attach_process(struct kgsl_mem_entry *entry,
-				   struct kgsl_process_private *process)
+static int
+kgsl_mem_entry_track_gpuaddr(struct kgsl_process_private *process,
+				struct kgsl_mem_entry *entry)
 {
+	int ret = 0;
 	struct rb_node **node;
 	struct rb_node *parent = NULL;
 
-	spin_lock(&process->mem_lock);
+	if (kgsl_memdesc_use_cpu_map(&entry->memdesc)) {
+		if (!entry->memdesc.gpuaddr)
+			goto done;
+	} else if (entry->memdesc.gpuaddr) {
+		WARN(1, "gpuaddr assigned w/o holding memory lock\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	if (!kgsl_memdesc_use_cpu_map(&entry->memdesc)) {
+		ret = kgsl_mmu_get_gpuaddr(process->pagetable, &entry->memdesc);
+		if (ret)
+			goto done;
+	}
 
 	node = &process->mem_rb.rb_node;
 
@@ -226,10 +280,60 @@
 	rb_link_node(&entry->node, parent, node);
 	rb_insert_color(&entry->node, &process->mem_rb);
 
-	spin_unlock(&process->mem_lock);
+done:
+	return ret;
+}
+
+static void
+kgsl_mem_entry_untrack_gpuaddr(struct kgsl_process_private *process,
+				struct kgsl_mem_entry *entry)
+{
+	if (entry->memdesc.gpuaddr) {
+		kgsl_mmu_put_gpuaddr(process->pagetable, &entry->memdesc);
+		rb_erase(&entry->node, &entry->priv->mem_rb);
+	}
+}
+
+static int
+kgsl_mem_entry_attach_process(struct kgsl_mem_entry *entry,
+				   struct kgsl_process_private *process)
+{
+	int ret;
+
+	while (1) {
+		if (idr_pre_get(&process->mem_idr, GFP_KERNEL) == 0) {
+			ret = -ENOMEM;
+			goto err;
+		}
 
+		spin_lock(&process->mem_lock);
+		ret = idr_get_new_above(&process->mem_idr, entry, 1,
+					&entry->id);
+		spin_unlock(&process->mem_lock);
+
+		if (ret == 0)
+			break;
+		else if (ret != -EAGAIN)
+			goto err;
+	}
 	entry->priv = process;
 	entry->memdesc.private = process;
+
+	spin_lock(&process->mem_lock);
+	ret = kgsl_mem_entry_track_gpuaddr(process, entry);
+	if (ret)
+		idr_remove(&process->mem_idr, entry->id);
+	spin_unlock(&process->mem_lock);
+	if (ret)
+		goto err;
+	
+	if (entry->memdesc.gpuaddr) {
+		ret = kgsl_mmu_map(process->pagetable, &entry->memdesc);
+		if (ret)
+			kgsl_mem_entry_detach_process(entry);
+	}
+err:
+	return ret;
 }
 
 
@@ -238,12 +342,20 @@
 	if (entry == NULL)
 		return;
 
-	entry->priv->stats[entry->memtype].cur -= entry->memdesc.size;
-	entry->priv = NULL;
+	
+	kgsl_mmu_unmap(entry->priv->pagetable, &entry->memdesc);
 
-	kgsl_mmu_unmap(entry->memdesc.pagetable, &entry->memdesc);
+	spin_lock(&entry->priv->mem_lock);
 
-	kgsl_mem_entry_put(entry);
+	kgsl_mem_entry_untrack_gpuaddr(entry->priv, entry);
+	if (entry->id != 0)
+		idr_remove(&entry->priv->mem_idr, entry->id);
+	entry->id = 0;
+
+	entry->priv->stats[entry->memtype].cur -= entry->memdesc.size;
+	spin_unlock(&entry->priv->mem_lock);
+
+	entry->priv = NULL;
 }
 
 
@@ -255,14 +367,19 @@
 
 	context = kzalloc(sizeof(*context), GFP_KERNEL);
 
-	if (context == NULL)
-		return NULL;
+	if (context == NULL) {
+		KGSL_DRV_INFO(dev_priv->device, "kzalloc(%d) failed\n",
+				sizeof(*context));
+		return ERR_PTR(-ENOMEM);
+	}
 
 	while (1) {
 		if (idr_pre_get(&dev_priv->device->context_idr,
 				GFP_KERNEL) == 0) {
-			kfree(context);
-			return NULL;
+			KGSL_DRV_INFO(dev_priv->device,
+					"idr_pre_get: ENOMEM\n");
+			ret = -ENOMEM;
+			goto func_end;
 		}
 
 		ret = idr_get_new_above(&dev_priv->device->context_idr,
@@ -272,27 +389,25 @@
 			break;
 	}
 
-	if (ret) {
-		kfree(context);
-		return NULL;
-	}
+	if (ret)
+		goto func_end;
 
 	
 	if (id >= KGSL_MEMSTORE_MAX) {
 		KGSL_DRV_ERR(dev_priv->device, "cannot have more than %d "
 				"ctxts due to memstore limitation\n",
 				KGSL_MEMSTORE_MAX);
-		kgsl_dump_contextpid(&dev_priv->device->context_idr);
 		idr_remove(&dev_priv->device->context_idr, id);
-		kfree(context);
-		return NULL;
+		ret = -ENOSPC;
+		goto func_end;
 	}
 
 	kref_init(&context->refcount);
 	context->id = id;
 	context->dev_priv = dev_priv;
 
-	if (kgsl_sync_timeline_create(context)) {
+	ret = kgsl_sync_timeline_create(context);
+	if (ret) {
 		idr_remove(&dev_priv->device->context_idr, id);
 		goto func_end;
 	}
@@ -306,7 +421,7 @@
 func_end:
 	if (ret) {
 		kfree(context);
-		return NULL;
+		return ERR_PTR(ret);
 	}
 
 	return context;
@@ -327,7 +442,7 @@
 		device->ftbl->drawctxt_destroy(device, context);
 	
 	BUG_ON(context->devctxt);
-	kgsl_cancel_events_ctxt(device, context);
+	kgsl_context_cancel_events(device, context);
 	idr_remove(&device->context_idr, id);
 	context->id = KGSL_CONTEXT_INVALID;
 	kgsl_context_put(context);
@@ -342,27 +457,6 @@
 	kfree(context);
 }
 
-static void kgsl_check_idle_locked(struct kgsl_device *device)
-{
-	if (device->pwrctrl.nap_allowed == true &&
-	    device->state == KGSL_STATE_ACTIVE &&
-		device->requested_state == KGSL_STATE_NONE) {
-		kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
-		kgsl_pwrscale_idle(device);
-		if (kgsl_pwrctrl_sleep(device) != 0)
-			mod_timer(&device->idle_timer,
-				  jiffies +
-				  device->pwrctrl.interval_timeout);
-	}
-}
-
-static void kgsl_check_idle(struct kgsl_device *device)
-{
-	mutex_lock(&device->mutex);
-	kgsl_check_idle_locked(device);
-	mutex_unlock(&device->mutex);
-}
-
 struct kgsl_device *kgsl_get_device(int dev_idx)
 {
 	int i;
@@ -396,24 +490,6 @@
 	return ret;
 }
 
-int kgsl_register_ts_notifier(struct kgsl_device *device,
-			      struct notifier_block *nb)
-{
-	BUG_ON(device == NULL);
-	return atomic_notifier_chain_register(&device->ts_notifier_list,
-					      nb);
-}
-EXPORT_SYMBOL(kgsl_register_ts_notifier);
-
-int kgsl_unregister_ts_notifier(struct kgsl_device *device,
-				struct notifier_block *nb)
-{
-	BUG_ON(device == NULL);
-	return atomic_notifier_chain_unregister(&device->ts_notifier_list,
-						nb);
-}
-EXPORT_SYMBOL(kgsl_unregister_ts_notifier);
-
 int kgsl_check_timestamp(struct kgsl_device *device,
 	struct kgsl_context *context, unsigned int timestamp)
 {
@@ -443,11 +519,9 @@
 	policy_saved = device->pwrscale.policy;
 	device->pwrscale.policy = NULL;
 	kgsl_pwrctrl_request_state(device, KGSL_STATE_SUSPEND);
-	if (device->active_cnt != 0) {
-		mutex_unlock(&device->mutex);
-		wait_for_completion(&device->suspend_gate);
-		mutex_lock(&device->mutex);
-	}
+
+	kgsl_active_count_wait(device);
+
 	
 	del_timer_sync(&device->idle_timer);
 	switch (device->state) {
@@ -459,6 +533,8 @@
 		case KGSL_STATE_NAP:
 		case KGSL_STATE_SLEEP:
 			
+			kgsl_pwrctrl_enable(device);
+			
 			INIT_COMPLETION(device->hwaccess_gate);
 			device->ftbl->suspend_context(device);
 			device->ftbl->stop(device);
@@ -545,9 +621,14 @@
 					struct kgsl_device, display_off);
 	KGSL_PWR_WARN(device, "early suspend start\n");
 	mutex_lock(&device->mutex);
-	device->pwrctrl.restore_slumber = true;
-	kgsl_pwrctrl_request_state(device, KGSL_STATE_SLUMBER);
-	kgsl_pwrctrl_sleep(device);
+
+	
+	if (device->active_cnt == 0) {
+		device->pwrctrl.restore_slumber = true;
+		kgsl_pwrctrl_request_state(device, KGSL_STATE_SLUMBER);
+		kgsl_pwrctrl_sleep(device);
+	}
+
 	mutex_unlock(&device->mutex);
 	KGSL_PWR_WARN(device, "early suspend end\n");
 }
@@ -577,26 +658,84 @@
 	device->pwrctrl.restore_slumber = false;
 	if (device->pwrscale.policy == NULL)
 		kgsl_pwrctrl_pwrlevel_change(device, KGSL_PWRLEVEL_TURBO);
-	kgsl_pwrctrl_wake(device);
+	if (kgsl_pwrctrl_wake(device) != 0) {
+		mutex_unlock(&device->mutex);
+		return;
+	}
+
+	if (device->active_cnt == 0) {
+		kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
+		kgsl_pwrctrl_sleep(device);
+	}
+
 	mutex_unlock(&device->mutex);
-	kgsl_check_idle(device);
 	KGSL_PWR_WARN(device, "late resume end\n");
 }
 EXPORT_SYMBOL(kgsl_late_resume_driver);
 
+static void kgsl_destroy_process_private(struct kref *kref)
+{
+
+	struct kgsl_mem_entry *entry = NULL;
+	int next = 0;
+
+
+	struct kgsl_process_private *private = container_of(kref,
+			struct kgsl_process_private, refcount);
+
+	if (!private) {
+		KGSL_CORE_ERR("Cannot destroy null process private\n");
+		mutex_unlock(&kgsl_driver.process_mutex);
+		return;
+	}
+	spin_lock(&kgsl_driver.process_dump_lock);
+	list_del(&private->list);
+	spin_unlock(&kgsl_driver.process_dump_lock);
+	mutex_unlock(&kgsl_driver.process_mutex);
+
+	if (private->kobj.parent)
+		kgsl_process_uninit_sysfs(private);
+	if (private->debug_root)
+		debugfs_remove_recursive(private->debug_root);
+
+	while (1) {
+		rcu_read_lock();
+		entry = idr_get_next(&private->mem_idr, &next);
+		rcu_read_unlock();
+		if (entry == NULL)
+			break;
+		kgsl_mem_entry_put(entry);
+		next = 0;
+	}
+	kgsl_mmu_putpagetable(private->pagetable);
+	idr_destroy(&private->mem_idr);
+
+	kfree(private);
+	return;
+}
+
+static void
+kgsl_put_process_private(struct kgsl_device *device,
+			 struct kgsl_process_private *private)
+{
+	mutex_lock(&kgsl_driver.process_mutex);
+
+	if (!kref_put(&private->refcount, kgsl_destroy_process_private))
+		mutex_unlock(&kgsl_driver.process_mutex);
+	return;
+}
+
 static struct kgsl_process_private *
-kgsl_get_process_private(struct kgsl_device_private *cur_dev_priv)
+kgsl_find_process_private(struct kgsl_device_private *cur_dev_priv)
 {
 	struct kgsl_process_private *private;
-#ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	int i;
-#endif
 
+	
 	mutex_lock(&kgsl_driver.process_mutex);
 	list_for_each_entry(private, &kgsl_driver.process_list, list) {
 		if (private->pid == task_tgid_nr(current)) {
-			private->refcnt++;
-			goto out;
+			kref_get(&private->refcount);
+			goto done;
 		}
 	}
 
@@ -605,80 +744,70 @@
 	if (private == NULL) {
 		KGSL_DRV_ERR(cur_dev_priv->device, "kzalloc(%d) failed\n",
 			sizeof(struct kgsl_process_private));
-		goto out;
+		goto done;
 	}
 
-#ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	private->gputime.total = 0;
-	private->gputime.busy = 0;
-	for(i=0;i<KGSL_MAX_PWRLEVELS;i++) {
-		private->gputime_in_state[i].total = 0;
-		private->gputime_in_state[i].busy = 0;
-	}
-#endif
+	kref_init(&private->refcount);
 
-	spin_lock_init(&private->mem_lock);
-	private->refcnt = 1;
 	private->pid = task_tgid_nr(current);
-	private->mem_rb = RB_ROOT;
-
-	if (kgsl_mmu_enabled())
-	{
-		unsigned long pt_name;
-
-		pt_name = task_tgid_nr(current);
-		private->pagetable = kgsl_mmu_getpagetable(pt_name);
-		if (private->pagetable == NULL) {
-			kfree(private);
-			private = NULL;
-			goto out;
-		}
-	}
-
+	spin_lock_init(&private->mem_lock);
+	mutex_init(&private->process_private_mutex);
+	
 	spin_lock(&kgsl_driver.process_dump_lock);
 	list_add(&private->list, &kgsl_driver.process_list);
 	spin_unlock(&kgsl_driver.process_dump_lock);
-
-	kgsl_process_init_sysfs(private);
-	kgsl_process_init_debugfs(private);
-
-out:
+done:
 	mutex_unlock(&kgsl_driver.process_mutex);
 	return private;
 }
 
-static void
-kgsl_put_process_private(struct kgsl_device *device,
-			 struct kgsl_process_private *private)
+static struct kgsl_process_private *
+kgsl_get_process_private(struct kgsl_device_private *cur_dev_priv)
 {
-	struct kgsl_mem_entry *entry = NULL;
-	struct rb_node *node;
-
-	if (!private)
-		return;
+	struct kgsl_process_private *private;
+#ifdef CONFIG_MSM_KGSL_GPU_USAGE
+	int i;
+#endif
 
-	mutex_lock(&kgsl_driver.process_mutex);
-	spin_lock(&kgsl_driver.process_dump_lock);
-	if (--private->refcnt)
-		goto unlock;
+	private = kgsl_find_process_private(cur_dev_priv);
 
-	kgsl_process_uninit_sysfs(private);
-	debugfs_remove_recursive(private->debug_root);
+	mutex_lock(&private->process_private_mutex);
 
-	list_del(&private->list);
+	if (!private->mem_rb.rb_node) {
+		private->mem_rb = RB_ROOT;
+		idr_init(&private->mem_idr);
+	}
 
-	for (node = rb_first(&private->mem_rb); node; ) {
-		entry = rb_entry(node, struct kgsl_mem_entry, node);
-		node = rb_next(&entry->node);
+	if ((!private->pagetable) && kgsl_mmu_enabled()) {
+		unsigned long pt_name;
 
-		rb_erase(&entry->node, &private->mem_rb);
-		kgsl_mem_entry_detach_process(entry);
+		pt_name = task_tgid_nr(current);
+		private->pagetable = kgsl_mmu_getpagetable(pt_name);
+		if (private->pagetable == NULL) {
+			mutex_unlock(&private->process_private_mutex);
+			kgsl_put_process_private(cur_dev_priv->device,
+						private);
+			return NULL;
+		}
 	}
-	kgsl_mmu_putpagetable(private->pagetable);
-	kfree(private);
-unlock:
-	spin_unlock(&kgsl_driver.process_dump_lock);
-	mutex_unlock(&kgsl_driver.process_mutex);
+
+	if (!private->kobj.parent)
+		kgsl_process_init_sysfs(private);
+	if (!private->debug_root)
+		kgsl_process_init_debugfs(private);
+
+#ifdef CONFIG_MSM_KGSL_GPU_USAGE
+    private->gputime.total = 0;
+    private->gputime.busy = 0;
+    for(i=0;i<KGSL_MAX_PWRLEVELS;i++) {
+        private->gputime_in_state[i].total = 0;
+        private->gputime_in_state[i].busy = 0;
+    }
+#endif
+
+	mutex_unlock(&private->process_private_mutex);
+
+	return private;
 }
 
 static int kgsl_release(struct inode *inodep, struct file *filep)
@@ -693,7 +822,7 @@
 	filep->private_data = NULL;
 
 	mutex_lock(&device->mutex);
-	kgsl_check_suspended(device);
+	kgsl_active_count_get(device);
 
 	while (1) {
 		context = idr_get_next(&device->context_idr, &next);
@@ -709,10 +838,13 @@
 
 	device->open_count--;
 	if (device->open_count == 0) {
+		BUG_ON(device->active_cnt > 1);
 		result = device->ftbl->stop(device);
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
+		device->active_cnt--;
+	} else {
+		kgsl_active_count_put(device);
 	}
-
 	mutex_unlock(&device->mutex);
 	kfree(dev_priv);
 
@@ -757,40 +889,53 @@
 	dev_priv->device = device;
 	filep->private_data = dev_priv;
 
-	
-	dev_priv->process_priv = kgsl_get_process_private(dev_priv);
-	if (dev_priv->process_priv ==  NULL) {
-		result = -ENOMEM;
-		goto err_freedevpriv;
-	}
-
 	mutex_lock(&device->mutex);
-	kgsl_check_suspended(device);
 
 	if (device->open_count == 0) {
+		device->active_cnt++;
 		kgsl_sharedmem_set(&device->memstore, 0, 0,
 				device->memstore.size);
 
-		result = device->ftbl->start(device, true);
+		result = device->ftbl->init(device);
+		if (result)
+			goto err_freedevpriv;
+
+		result = device->ftbl->start(device);
+		if (result)
+			goto err_freedevpriv;
 
-		if (result) {
-			mutex_unlock(&device->mutex);
-			goto err_putprocess;
-		}
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_ACTIVE);
+		kgsl_active_count_put(device);
 	}
 	device->open_count++;
 	mutex_unlock(&device->mutex);
 
+	dev_priv->process_priv = kgsl_get_process_private(dev_priv);
+	if (dev_priv->process_priv ==  NULL) {
+		result = -ENOMEM;
+		goto err_stop;
+	}
+
 	KGSL_DRV_INFO(device, "Initialized %s: mmu=%s pagetable_count=%d\n",
 		device->name, kgsl_mmu_enabled() ? "on" : "off",
 		kgsl_pagetable_count);
 
 	return result;
 
-err_putprocess:
-	kgsl_put_process_private(device, dev_priv->process_priv);
+err_stop:
+	mutex_lock(&device->mutex);
+	device->open_count--;
+	if (device->open_count == 0) {
+		
+		kgsl_pwrctrl_enable(device);
+		result = device->ftbl->stop(device);
+		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
+	}
 err_freedevpriv:
+	
+	if (device->open_count == 0)
+		device->active_cnt--;
+	mutex_unlock(&device->mutex);
 	filep->private_data = NULL;
 	kfree(dev_priv);
 err_pmruntime:
@@ -798,44 +943,117 @@
 	return result;
 }
 
-struct kgsl_mem_entry *
+struct kgsl_mem_entry * __must_check
 kgsl_sharedmem_find_region(struct kgsl_process_private *private,
 	unsigned int gpuaddr, size_t size)
 {
-	struct rb_node *node = private->mem_rb.rb_node;
+	struct rb_node *node;
 
 	if (!kgsl_mmu_gpuaddr_in_range(gpuaddr))
 		return NULL;
 
+	spin_lock(&private->mem_lock);
+	node = private->mem_rb.rb_node;
 	while (node != NULL) {
 		struct kgsl_mem_entry *entry;
 
 		entry = rb_entry(node, struct kgsl_mem_entry, node);
 
-
-		if (kgsl_gpuaddr_in_memdesc(&entry->memdesc, gpuaddr, size))
+		if (kgsl_gpuaddr_in_memdesc(&entry->memdesc, gpuaddr, size)) {
+			kgsl_mem_entry_get(entry);
+			spin_unlock(&private->mem_lock);
 			return entry;
-
+		}
 		if (gpuaddr < entry->memdesc.gpuaddr)
 			node = node->rb_left;
 		else if (gpuaddr >=
 			(entry->memdesc.gpuaddr + entry->memdesc.size))
 			node = node->rb_right;
 		else {
+			spin_unlock(&private->mem_lock);
 			return NULL;
 		}
 	}
 
+	spin_unlock(&private->mem_lock);
+
 	return NULL;
 }
 EXPORT_SYMBOL(kgsl_sharedmem_find_region);
 
-static inline struct kgsl_mem_entry *
+static inline struct kgsl_mem_entry * __must_check
 kgsl_sharedmem_find(struct kgsl_process_private *private, unsigned int gpuaddr)
 {
 	return kgsl_sharedmem_find_region(private, gpuaddr, 1);
 }
 
+static int
+kgsl_sharedmem_region_empty(struct kgsl_process_private *private,
+	unsigned int gpuaddr, size_t size)
+{
+	int result = 1;
+	unsigned int gpuaddr_end = gpuaddr + size;
+
+	struct rb_node *node;
+
+	if (!kgsl_mmu_gpuaddr_in_range(gpuaddr))
+		return 0;
+
+	
+	if (gpuaddr_end < gpuaddr)
+		return 0;
+
+	node = private->mem_rb.rb_node;
+	while (node != NULL) {
+		struct kgsl_mem_entry *entry;
+		unsigned int memdesc_start, memdesc_end;
+
+		entry = rb_entry(node, struct kgsl_mem_entry, node);
+
+		memdesc_start = entry->memdesc.gpuaddr;
+		memdesc_end = memdesc_start
+				+ kgsl_memdesc_mmapsize(&entry->memdesc);
+
+		if (gpuaddr_end <= memdesc_start)
+			node = node->rb_left;
+		else if (memdesc_end <= gpuaddr)
+			node = node->rb_right;
+		else {
+			result = 0;
+			break;
+		}
+	}
+	return result;
+}
+
+static inline struct kgsl_mem_entry * __must_check
+kgsl_sharedmem_find_id(struct kgsl_process_private *process, unsigned int id)
+{
+	struct kgsl_mem_entry *entry;
+
+	rcu_read_lock();
+	entry = idr_find(&process->mem_idr, id);
+	if (entry)
+		kgsl_mem_entry_get(entry);
+	rcu_read_unlock();
+
+	return entry;
+}
+
+static inline bool kgsl_mem_entry_set_pend(struct kgsl_mem_entry *entry)
+{
+	bool ret = false;
+	spin_lock(&entry->priv->mem_lock);
+	if (entry && entry->pending_free) {
+		ret = false;
+	} else if (entry) {
+		entry->pending_free = 1;
+		ret = true;
+	}
+	spin_unlock(&entry->priv->mem_lock);
+	return ret;
+}
+
 static long kgsl_ioctl_device_getproperty(struct kgsl_device_private *dev_priv,
 					  unsigned int cmd, void *data)
 {
@@ -877,18 +1095,20 @@
 			result = -EFAULT;
 			break;
 		}
-		context = kgsl_find_context(dev_priv, id);
+		context = kgsl_context_get_owner(dev_priv, id);
 		if (!context) {
 			result = -EINVAL;
 			break;
 		}
 		if (copy_to_user(param->value, &(context->reset_status),
-			sizeof(unsigned int))) {
+			sizeof(unsigned int)))
 			result = -EFAULT;
-			break;
+		else {
+			
+			context->reset_status = KGSL_CTX_STAT_NO_ERROR;
 		}
-		
-		context->reset_status = KGSL_CTX_STAT_NO_ERROR;
+
+		kgsl_context_put(context);
 		break;
 	}
 	default:
@@ -925,10 +1145,6 @@
 	struct kgsl_device *device = dev_priv->device;
 	unsigned int context_id = context ? context->id : KGSL_MEMSTORE_GLOBAL;
 
-	
-
-	device->active_cnt++;
-
 	trace_kgsl_waittimestamp_entry(device, context_id,
 				       kgsl_readtimestamp(device, context,
 							KGSL_TIMESTAMP_RETIRED),
@@ -942,9 +1158,6 @@
 							KGSL_TIMESTAMP_RETIRED),
 				      result);
 
-	
-	kgsl_active_count_put(dev_priv->device);
-
 	return result;
 }
 
@@ -964,17 +1177,14 @@
 {
 	struct kgsl_device_waittimestamp_ctxtid *param = data;
 	struct kgsl_context *context;
-	int result;
+	long result = -EINVAL;
 
-	context = kgsl_find_context(dev_priv, param->context_id);
-	if (context == NULL) {
-		KGSL_DRV_ERR(dev_priv->device, "invalid context_id %d\n",
-			param->context_id);
-		return -EINVAL;
-	}
-	kgsl_context_get(context);
-	result = _device_waittimestamp(dev_priv, context,
+	context = kgsl_context_get_owner(dev_priv, param->context_id);
+
+	if (context)
+		result = _device_waittimestamp(dev_priv, context,
 			param->timestamp, param->timeout);
+
 	kgsl_context_put(context);
 	return result;
 }
@@ -987,12 +1197,9 @@
 	struct kgsl_ibdesc *ibdesc;
 	struct kgsl_context *context;
 
-	context = kgsl_find_context(dev_priv, param->drawctxt_id);
+	context = kgsl_context_get_owner(dev_priv, param->drawctxt_id);
 	if (context == NULL) {
 		result = -EINVAL;
-		KGSL_DRV_ERR(dev_priv->device,
-			"invalid context_id %d\n",
-			param->drawctxt_id);
 		goto done;
 	}
 
@@ -1057,12 +1264,10 @@
 					     &param->timestamp,
 					     param->flags);
 
-	trace_kgsl_issueibcmds(dev_priv->device, param, ibdesc, result);
-
 free_ibdesc:
 	kfree(ibdesc);
 done:
-
+	kgsl_context_put(context);
 	return result;
 }
 
@@ -1095,27 +1300,26 @@
 {
 	struct kgsl_cmdstream_readtimestamp_ctxtid *param = data;
 	struct kgsl_context *context;
+	long result = -EINVAL;
 
-	context = kgsl_find_context(dev_priv, param->context_id);
-	if (context == NULL) {
-		KGSL_DRV_ERR(dev_priv->device, "invalid context_id %d\n",
-			param->context_id);
-		return -EINVAL;
-	}
+	context = kgsl_context_get_owner(dev_priv, param->context_id);
 
-	return _cmdstream_readtimestamp(dev_priv, context,
+	if (context)
+		result = _cmdstream_readtimestamp(dev_priv, context,
 			param->type, &param->timestamp);
+
+	kgsl_context_put(context);
+	return result;
 }
 
 static void kgsl_freemem_event_cb(struct kgsl_device *device,
-	void *priv, u32 id, u32 timestamp)
+	void *priv, u32 id, u32 timestamp, u32 type)
 {
 	struct kgsl_mem_entry *entry = priv;
-	spin_lock(&entry->priv->mem_lock);
-	rb_erase(&entry->node, &entry->priv->mem_rb);
-	spin_unlock(&entry->priv->mem_lock);
+
+	
 	trace_kgsl_mem_timestamp_free(device, entry, id, timestamp, 0);
-	kgsl_mem_entry_detach_process(entry);
+	kgsl_mem_entry_put(entry);
 }
 
 static long _cmdstream_freememontimestamp(struct kgsl_device_private *dev_priv,
@@ -1127,15 +1331,18 @@
 	struct kgsl_device *device = dev_priv->device;
 	unsigned int context_id = context ? context->id : KGSL_MEMSTORE_GLOBAL;
 
-	spin_lock(&dev_priv->process_priv->mem_lock);
 	entry = kgsl_sharedmem_find(dev_priv->process_priv, gpuaddr);
-	spin_unlock(&dev_priv->process_priv->mem_lock);
 
 	if (!entry) {
 		KGSL_DRV_ERR(dev_priv->device,
 				"invalid gpuaddr %08x\n", gpuaddr);
-		result = -EINVAL;
-		goto done;
+		return -EINVAL;
+	}
+	if (!kgsl_mem_entry_set_pend(entry)) {
+		KGSL_DRV_ERR(dev_priv->device,
+		"Cannot set pending bit for gpuaddr %08x\n", gpuaddr);
+		kgsl_mem_entry_put(entry);
+		return -EBUSY;
 	}
 	trace_kgsl_mem_timestamp_queue(device, entry, context_id,
 				       kgsl_readtimestamp(device, context,
@@ -1143,7 +1350,7 @@
 				       timestamp);
 	result = kgsl_add_event(dev_priv->device, context_id, timestamp,
 				kgsl_freemem_event_cb, entry, dev_priv);
-done:
+	kgsl_mem_entry_put(entry);
 	return result;
 }
 
@@ -1164,16 +1371,14 @@
 {
 	struct kgsl_cmdstream_freememontimestamp_ctxtid *param = data;
 	struct kgsl_context *context;
+	long result = -EINVAL;
 
-	context = kgsl_find_context(dev_priv, param->context_id);
-	if (context == NULL) {
-		KGSL_DRV_ERR(dev_priv->device,
-			"invalid drawctxt context_id %d\n", param->context_id);
-		return -EINVAL;
-	}
-
-	return _cmdstream_freememontimestamp(dev_priv, param->gpuaddr,
+	context = kgsl_context_get_owner(dev_priv, param->context_id);
+	if (context)
+		result = _cmdstream_freememontimestamp(dev_priv, param->gpuaddr,
 			context, param->timestamp, param->type);
+	kgsl_context_put(context);
+	return result;
 }
 
 static long kgsl_ioctl_drawctxt_create(struct kgsl_device_private *dev_priv,
@@ -1185,22 +1390,22 @@
 
 	context = kgsl_create_context(dev_priv);
 
-	if (context == NULL) {
-		result = -ENOMEM;
+	if (IS_ERR(context)) {
+		result = PTR_ERR(context);
 		goto done;
 	}
 
 	if (dev_priv->device->ftbl->drawctxt_create) {
 		result = dev_priv->device->ftbl->drawctxt_create(
 			dev_priv->device, dev_priv->process_priv->pagetable,
-			context, param->flags);
+			context, &param->flags);
 		if (result)
 			goto done;
 	}
 	trace_kgsl_context_create(dev_priv->device, context, param->flags);
 	param->drawctxt_id = context->id;
 done:
-	if (result && context)
+	if (result && !IS_ERR(context))
 		kgsl_context_detach(context);
 
 	return result;
@@ -1209,46 +1414,75 @@
 static long kgsl_ioctl_drawctxt_destroy(struct kgsl_device_private *dev_priv,
 					unsigned int cmd, void *data)
 {
-	int result = 0;
 	struct kgsl_drawctxt_destroy *param = data;
 	struct kgsl_context *context;
+	long result = -EINVAL;
 
-	context = kgsl_find_context(dev_priv, param->drawctxt_id);
+	context = kgsl_context_get_owner(dev_priv, param->drawctxt_id);
 
-	if (context == NULL) {
-		result = -EINVAL;
-		goto done;
+	if (context) {
+		kgsl_context_detach(context);
+		result = 0;
 	}
 
-	kgsl_context_detach(context);
-done:
+	kgsl_context_put(context);
 	return result;
 }
 
 static long kgsl_ioctl_sharedmem_free(struct kgsl_device_private *dev_priv,
 					unsigned int cmd, void *data)
 {
-	int result = 0;
 	struct kgsl_sharedmem_free *param = data;
 	struct kgsl_process_private *private = dev_priv->process_priv;
 	struct kgsl_mem_entry *entry = NULL;
 
-	spin_lock(&private->mem_lock);
 	entry = kgsl_sharedmem_find(private, param->gpuaddr);
-	if (entry)
-		rb_erase(&entry->node, &private->mem_rb);
+	if (!entry) {
+		KGSL_MEM_INFO(dev_priv->device, "invalid gpuaddr %08x\n",
+				param->gpuaddr);
+		return -EINVAL;
+	}
+	if (!kgsl_mem_entry_set_pend(entry)) {
+		kgsl_mem_entry_put(entry);
+		return -EINVAL;
+	}
 
-	spin_unlock(&private->mem_lock);
+	trace_kgsl_mem_free(entry);
 
-	if (entry) {
-		trace_kgsl_mem_free(entry);
-		kgsl_mem_entry_detach_process(entry);
-	} else {
-		KGSL_CORE_ERR("invalid gpuaddr %08x\n", param->gpuaddr);
-		result = -EINVAL;
+	kgsl_memfree_hist_set_event(entry->priv->pid,
+				    entry->memdesc.gpuaddr,
+				    entry->memdesc.size,
+				    entry->memdesc.flags);
+
+	kgsl_mem_entry_put(entry);
+	kgsl_mem_entry_put(entry);
+	return 0;
+}
+
+static long kgsl_ioctl_gpumem_free_id(struct kgsl_device_private *dev_priv,
+					unsigned int cmd, void *data)
+{
+	struct kgsl_gpumem_free_id *param = data;
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_mem_entry *entry = NULL;
+
+	entry = kgsl_sharedmem_find_id(private, param->id);
+
+	if (!entry) {
+		KGSL_MEM_INFO(dev_priv->device, "invalid id %d\n", param->id);
+		return -EINVAL;
 	}
 
-	return result;
+	if (!kgsl_mem_entry_set_pend(entry)) {
+		kgsl_mem_entry_put(entry);
+		return -EINVAL;
+	}
+
+	trace_kgsl_mem_free(entry);
+
+	kgsl_mem_entry_put(entry);
+	kgsl_mem_entry_put(entry);
+	return 0;
 }
 
 static struct vm_area_struct *kgsl_get_vma_from_start_addr(unsigned int addr)
@@ -1358,6 +1592,8 @@
 	entry->memdesc.size = size;
 	entry->memdesc.physaddr = phys + offset;
 	entry->memdesc.hostptr = (void *) (virt + offset);
+	
+	entry->memdesc.flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	ret = memdesc_sg_phys(&entry->memdesc, phys + offset, size);
 	if (ret)
@@ -1372,11 +1608,10 @@
 }
 
 static int memdesc_sg_virt(struct kgsl_memdesc *memdesc,
-	void *addr, int size)
+	unsigned long paddr, int size)
 {
 	int i;
 	int sglen = PAGE_ALIGN(size) / PAGE_SIZE;
-	unsigned long paddr = (unsigned long) addr;
 
 	memdesc->sg = kgsl_sg_alloc(sglen);
 
@@ -1427,34 +1662,33 @@
 	return -EINVAL;
 }
 
-static int kgsl_setup_hostptr(struct kgsl_mem_entry *entry,
+static int kgsl_setup_useraddr(struct kgsl_mem_entry *entry,
 			      struct kgsl_pagetable *pagetable,
-			      void *hostptr, unsigned int offset,
+			      unsigned long useraddr, unsigned int offset,
 			      size_t size)
 {
 	struct vm_area_struct *vma;
 	unsigned int len;
 
 	down_read(&current->mm->mmap_sem);
-	vma = find_vma(current->mm, (unsigned int) hostptr);
+	vma = find_vma(current->mm, useraddr);
 	up_read(&current->mm->mmap_sem);
 
 	if (!vma) {
-		KGSL_CORE_ERR("find_vma(%p) failed\n", hostptr);
+		KGSL_CORE_ERR("find_vma(%lx) failed\n", useraddr);
 		return -EINVAL;
 	}
 
 	
-	len = vma->vm_end - (unsigned long) hostptr;
+	len = vma->vm_end - useraddr;
 
 	if (offset >= len)
 		return -EINVAL;
 
-	if (!KGSL_IS_PAGE_ALIGNED((unsigned long) hostptr) ||
+	if (!KGSL_IS_PAGE_ALIGNED(useraddr) ||
 	    !KGSL_IS_PAGE_ALIGNED(len)) {
-		KGSL_CORE_ERR("user address len(%u)"
-			      "and start(%p) must be page"
-			      "aligned\n", len, hostptr);
+		KGSL_CORE_ERR("bad alignment: start(%lx) len(%u)\n",
+			      useraddr, len);
 		return -EINVAL;
 	}
 
@@ -1475,28 +1709,29 @@
 
 	entry->memdesc.pagetable = pagetable;
 	entry->memdesc.size = size;
-	entry->memdesc.hostptr = hostptr + (offset & PAGE_MASK);
+	entry->memdesc.useraddr = useraddr + (offset & PAGE_MASK);
+	if (kgsl_memdesc_use_cpu_map(&entry->memdesc))
+		entry->memdesc.gpuaddr = entry->memdesc.useraddr;
 
-	return memdesc_sg_virt(&entry->memdesc,
-		hostptr + (offset & PAGE_MASK), size);
+	return memdesc_sg_virt(&entry->memdesc, entry->memdesc.useraddr,
+				size);
 }
 
 #ifdef CONFIG_ASHMEM
 static int kgsl_setup_ashmem(struct kgsl_mem_entry *entry,
 			     struct kgsl_pagetable *pagetable,
-			     int fd, void *hostptr, size_t size)
+			     int fd, unsigned long useraddr, size_t size)
 {
 	int ret;
 	struct vm_area_struct *vma;
 	struct file *filep, *vmfile;
 	unsigned long len;
-	unsigned int hostaddr = (unsigned int) hostptr;
 
-	vma = kgsl_get_vma_from_start_addr(hostaddr);
+	vma = kgsl_get_vma_from_start_addr(useraddr);
 	if (vma == NULL)
 		return -EINVAL;
 
-	if (vma->vm_pgoff || vma->vm_start != hostaddr) {
+	if (vma->vm_pgoff || vma->vm_start != useraddr) {
 		KGSL_CORE_ERR("Invalid vma region\n");
 		return -EINVAL;
 	}
@@ -1507,8 +1742,8 @@
 		size = len;
 
 	if (size != len) {
-		KGSL_CORE_ERR("Invalid size %d for vma region %p\n",
-			      size, hostptr);
+		KGSL_CORE_ERR("Invalid size %d for vma region %lx\n",
+			      size, useraddr);
 		return -EINVAL;
 	}
 
@@ -1528,9 +1763,11 @@
 	entry->priv_data = filep;
 	entry->memdesc.pagetable = pagetable;
 	entry->memdesc.size = ALIGN(size, PAGE_SIZE);
-	entry->memdesc.hostptr = hostptr;
+	entry->memdesc.useraddr = useraddr;
+	if (kgsl_memdesc_use_cpu_map(&entry->memdesc))
+		entry->memdesc.gpuaddr = entry->memdesc.useraddr;
 
-	ret = memdesc_sg_virt(&entry->memdesc, hostptr, size);
+	ret = memdesc_sg_virt(&entry->memdesc, useraddr, size);
 	if (ret)
 		goto err;
 
@@ -1543,7 +1780,7 @@
 #else
 static int kgsl_setup_ashmem(struct kgsl_mem_entry *entry,
 			     struct kgsl_pagetable *pagetable,
-			     int fd, void *hostptr, size_t size)
+			     int fd, unsigned long useraddr, size_t size)
 {
 	return -EINVAL;
 }
@@ -1569,6 +1806,8 @@
 	entry->priv_data = handle;
 	entry->memdesc.pagetable = pagetable;
 	entry->memdesc.size = 0;
+	
+	entry->memdesc.flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	sg_table = ion_sg_table(kgsl_ion_client, handle);
 
@@ -1592,6 +1831,13 @@
 	return -ENOMEM;
 }
 
+static inline int
+can_use_cpu_map(void)
+{
+	return (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU
+		&& kgsl_mmu_is_perprocess());
+}
+
 static long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 				     unsigned int cmd, void *data)
 {
@@ -1611,7 +1857,17 @@
 	else
 		memtype = param->memtype;
 
+	param->flags &= KGSL_MEMFLAGS_GPUREADONLY
+			| KGSL_MEMTYPE_MASK
+			| KGSL_MEMALIGN_MASK
+			| KGSL_MEMFLAGS_USE_CPU_MAP;
+
 	entry->memdesc.flags = param->flags;
+	if (!can_use_cpu_map())
+		entry->memdesc.flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
+
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
+		entry->memdesc.priv |= KGSL_MEMDESC_GUARD_PAGE;
 
 	switch (memtype) {
 	case KGSL_USER_MEM_TYPE_PMEM:
@@ -1637,8 +1893,8 @@
 		if (param->hostptr == 0)
 			break;
 
-		result = kgsl_setup_hostptr(entry, private->pagetable,
-					    (void *) param->hostptr,
+		result = kgsl_setup_useraddr(entry, private->pagetable,
+					    param->hostptr,
 					    param->offset, param->len);
 		entry->memtype = KGSL_MEM_ENTRY_USER;
 		break;
@@ -1655,7 +1911,7 @@
 			break;
 
 		result = kgsl_setup_ashmem(entry, private->pagetable,
-					   param->fd, (void *) param->hostptr,
+					   param->fd, param->hostptr,
 					   param->len);
 
 		entry->memtype = KGSL_MEM_ENTRY_ASHMEM;
@@ -1677,12 +1933,12 @@
 	else if (entry->memdesc.size >= SZ_64K)
 		kgsl_memdesc_set_align(&entry->memdesc, ilog2(SZ_64));
 
-	result = kgsl_mmu_map(private->pagetable,
-			      &entry->memdesc,
-			      GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	
+	param->flags = entry->memdesc.flags;
 
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result)
-		goto error_put_file_ptr;
+		goto error_attach;
 
 	
 	param->gpuaddr = entry->memdesc.gpuaddr + (param->offset & ~PAGE_MASK);
@@ -1692,13 +1948,11 @@
 
 	kgsl_process_add_stats(private, entry->memtype, param->len);
 
-	kgsl_mem_entry_attach_process(entry, private);
 	trace_kgsl_mem_map(entry, param->fd);
 
-	kgsl_check_idle(dev_priv->device);
 	return result;
 
-error_put_file_ptr:
+error_attach:
 	switch (entry->memtype) {
 	case KGSL_MEM_ENTRY_PMEM:
 	case KGSL_MEM_ENTRY_ASHMEM:
@@ -1713,35 +1967,127 @@
 	}
 error:
 	kfree(entry);
-	kgsl_check_idle(dev_priv->device);
 	return result;
 }
 
+static int _kgsl_gpumem_sync_cache(struct kgsl_mem_entry *entry, int op)
+{
+	int ret = 0;
+	int cacheop;
+	int mode;
+
+
+	if ((op & KGSL_GPUMEM_CACHE_FLUSH) == KGSL_GPUMEM_CACHE_FLUSH)
+		cacheop = KGSL_CACHE_OP_FLUSH;
+	else if (op & KGSL_GPUMEM_CACHE_CLEAN)
+		cacheop = KGSL_CACHE_OP_CLEAN;
+	else if (op & KGSL_GPUMEM_CACHE_INV)
+		cacheop = KGSL_CACHE_OP_INV;
+	else {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	mode = kgsl_memdesc_get_cachemode(&entry->memdesc);
+	if (mode != KGSL_CACHEMODE_UNCACHED
+		&& mode != KGSL_CACHEMODE_WRITECOMBINE)
+		kgsl_cache_range_op(&entry->memdesc, cacheop);
+
+done:
+	return ret;
+}
+
+
+static long
+kgsl_ioctl_gpumem_sync_cache(struct kgsl_device_private *dev_priv,
+	unsigned int cmd, void *data)
+{
+	struct kgsl_gpumem_sync_cache *param = data;
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_mem_entry *entry = NULL;
+	long ret;
+
+	if (param->id != 0) {
+		entry = kgsl_sharedmem_find_id(private, param->id);
+		if (entry == NULL) {
+			KGSL_MEM_INFO(dev_priv->device, "can't find id %d\n",
+					param->id);
+			return -EINVAL;
+		}
+	} else if (param->gpuaddr != 0) {
+		entry = kgsl_sharedmem_find(private, param->gpuaddr);
+		if (entry == NULL) {
+			KGSL_MEM_INFO(dev_priv->device,
+					"can't find gpuaddr %x\n",
+					param->gpuaddr);
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	ret = _kgsl_gpumem_sync_cache(entry, param->op);
+	kgsl_mem_entry_put(entry);
+	return ret;
+}
+
+
 static long
 kgsl_ioctl_sharedmem_flush_cache(struct kgsl_device_private *dev_priv,
 				 unsigned int cmd, void *data)
 {
-	int result = 0;
-	struct kgsl_mem_entry *entry;
 	struct kgsl_sharedmem_free *param = data;
 	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_mem_entry *entry = NULL;
+	long ret;
 
-	spin_lock(&private->mem_lock);
 	entry = kgsl_sharedmem_find(private, param->gpuaddr);
-	if (!entry) {
-		KGSL_CORE_ERR("invalid gpuaddr %08x\n", param->gpuaddr);
-		result = -EINVAL;
-		goto done;
-	}
-	if (!entry->memdesc.hostptr) {
-		KGSL_CORE_ERR("invalid hostptr with gpuaddr %08x\n",
-			param->gpuaddr);
-			goto done;
+	if (entry == NULL) {
+		KGSL_MEM_INFO(dev_priv->device,
+				"can't find gpuaddr %x\n",
+				param->gpuaddr);
+		return -EINVAL;
 	}
 
-	kgsl_cache_range_op(&entry->memdesc, KGSL_CACHE_OP_CLEAN);
-done:
-	spin_unlock(&private->mem_lock);
+	ret = _kgsl_gpumem_sync_cache(entry, KGSL_GPUMEM_CACHE_FLUSH);
+	kgsl_mem_entry_put(entry);
+	return ret;
+}
+
+int
+_gpumem_alloc(struct kgsl_device_private *dev_priv,
+		struct kgsl_mem_entry **ret_entry,
+		unsigned int size, unsigned int flags)
+{
+	int result;
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_mem_entry *entry;
+
+	flags &= KGSL_MEMFLAGS_GPUREADONLY
+		| KGSL_CACHEMODE_MASK
+		| KGSL_MEMTYPE_MASK
+		| KGSL_MEMALIGN_MASK
+		| KGSL_MEMFLAGS_USE_CPU_MAP;
+
+	entry = kgsl_mem_entry_create();
+	if (entry == NULL)
+		return -ENOMEM;
+
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
+		entry->memdesc.priv |= KGSL_MEMDESC_GUARD_PAGE;
+
+	result = kgsl_allocate_user(&entry->memdesc, private, private->pagetable, size,
+				    flags);
+	if (result != 0)
+		goto err;
+
+	entry->memtype = KGSL_MEM_ENTRY_KERNEL;
+
+	*ret_entry = entry;
+	return result;
+err:
+	kfree(entry);
+	*ret_entry = NULL;
 	return result;
 }
 
@@ -1751,29 +2097,105 @@
 {
 	struct kgsl_process_private *private = dev_priv->process_priv;
 	struct kgsl_gpumem_alloc *param = data;
-	struct kgsl_mem_entry *entry;
+	struct kgsl_mem_entry *entry = NULL;
 	int result;
 
-	entry = kgsl_mem_entry_create();
-	if (entry == NULL)
-		return -ENOMEM;
+	param->flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
+	result = _gpumem_alloc(dev_priv, &entry, param->size, param->flags);
+	if (result)
+		return result;
+
+	result = kgsl_mem_entry_attach_process(entry, private);
+	if (result != 0)
+		goto err;
+
+	kgsl_process_add_stats(private, entry->memtype, param->size);
+	trace_kgsl_mem_alloc(entry);
+
+	param->gpuaddr = entry->memdesc.gpuaddr;
+	param->size = entry->memdesc.size;
+	param->flags = entry->memdesc.flags;
+	return result;
+err:
+	kgsl_sharedmem_free(&entry->memdesc);
+	kfree(entry);
+	return result;
+}
+
+static long
+kgsl_ioctl_gpumem_alloc_id(struct kgsl_device_private *dev_priv,
+			unsigned int cmd, void *data)
+{
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_gpumem_alloc_id *param = data;
+	struct kgsl_mem_entry *entry = NULL;
+	int result;
+
+	if (!can_use_cpu_map())
+		param->flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
+
+	result = _gpumem_alloc(dev_priv, &entry, param->size, param->flags);
+	if (result != 0)
+		goto err;
+
+	result = kgsl_mem_entry_attach_process(entry, private);
+	if (result != 0)
+		goto err;
+
+	kgsl_process_add_stats(private, entry->memtype, param->size);
+	trace_kgsl_mem_alloc(entry);
+
+	param->id = entry->id;
+	param->flags = entry->memdesc.flags;
+	param->size = entry->memdesc.size;
+	param->mmapsize = kgsl_memdesc_mmapsize(&entry->memdesc);
+	param->gpuaddr = entry->memdesc.gpuaddr;
+	return result;
+err:
+	if (entry)
+		kgsl_sharedmem_free(&entry->memdesc);
+	kfree(entry);
+	return result;
+}
 
-	result = kgsl_allocate_user(&entry->memdesc, private, private->pagetable,
-		param->size, param->flags);
+static long
+kgsl_ioctl_gpumem_get_info(struct kgsl_device_private *dev_priv,
+			unsigned int cmd, void *data)
+{
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_gpumem_get_info *param = data;
+	struct kgsl_mem_entry *entry = NULL;
+	int result = 0;
 
-	if (result == 0) {
-		entry->memtype = KGSL_MEM_ENTRY_KERNEL;
-		kgsl_mem_entry_attach_process(entry, private);
-		param->gpuaddr = entry->memdesc.gpuaddr;
-
-		kgsl_process_add_stats(private, entry->memtype, param->size);
-		trace_kgsl_mem_alloc(entry);
-	} else
-		kfree(entry);
+	if (param->id != 0) {
+		entry = kgsl_sharedmem_find_id(private, param->id);
+		if (entry == NULL) {
+			KGSL_MEM_INFO(dev_priv->device, "can't find id %d\n",
+					param->id);
+			return -EINVAL;
+		}
+	} else if (param->gpuaddr != 0) {
+		entry = kgsl_sharedmem_find(private, param->gpuaddr);
+		if (entry == NULL) {
+			KGSL_MEM_INFO(dev_priv->device,
+					"can't find gpuaddr %lx\n",
+					param->gpuaddr);
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+	param->gpuaddr = entry->memdesc.gpuaddr;
+	param->id = entry->id;
+	param->flags = entry->memdesc.flags;
+	param->size = entry->memdesc.size;
+	param->mmapsize = kgsl_memdesc_mmapsize(&entry->memdesc);
+	param->useraddr = entry->memdesc.useraddr;
 
-	kgsl_check_idle(dev_priv->device);
+	kgsl_mem_entry_put(entry);
 	return result;
 }
+
 static long kgsl_ioctl_cff_syncmem(struct kgsl_device_private *dev_priv,
 					unsigned int cmd, void *data)
 {
@@ -1782,14 +2204,14 @@
 	struct kgsl_process_private *private = dev_priv->process_priv;
 	struct kgsl_mem_entry *entry = NULL;
 
-	spin_lock(&private->mem_lock);
 	entry = kgsl_sharedmem_find_region(private, param->gpuaddr, param->len);
-	if (entry)
-		kgsl_cffdump_syncmem(dev_priv, &entry->memdesc, param->gpuaddr,
-				     param->len, true);
-	else
-		result = -EINVAL;
-	spin_unlock(&private->mem_lock);
+	if (!entry)
+		return -EINVAL;
+
+	kgsl_cffdump_syncmem(dev_priv, &entry->memdesc, param->gpuaddr,
+			     param->len, true);
+
+	kgsl_mem_entry_put(entry);
 	return result;
 }
 
@@ -1813,11 +2235,12 @@
 
 
 static void kgsl_genlock_event_cb(struct kgsl_device *device,
-	void *priv, u32 context_id, u32 timestamp)
+	void *priv, u32 context_id, u32 timestamp, u32 type)
 {
 	struct kgsl_genlock_event_priv *ev = priv;
 	int ret;
 
+	
 	ret = genlock_lock(ev->handle, GENLOCK_UNLOCK, 0, 0);
 	if (ret)
 		KGSL_CORE_ERR("Error while unlocking genlock: %d\n", ret);
@@ -1957,10 +2380,18 @@
 			kgsl_ioctl_cff_user_event, 0),
 	KGSL_IOCTL_FUNC(IOCTL_KGSL_TIMESTAMP_EVENT,
 			kgsl_ioctl_timestamp_event,
-			KGSL_IOCTL_LOCK),
+			KGSL_IOCTL_LOCK | KGSL_IOCTL_WAKE),
 	KGSL_IOCTL_FUNC(IOCTL_KGSL_SETPROPERTY,
 			kgsl_ioctl_device_setproperty,
-			KGSL_IOCTL_LOCK | KGSL_IOCTL_WAKE)
+			KGSL_IOCTL_LOCK | KGSL_IOCTL_WAKE),
+	KGSL_IOCTL_FUNC(IOCTL_KGSL_GPUMEM_ALLOC_ID,
+			kgsl_ioctl_gpumem_alloc_id, 0),
+	KGSL_IOCTL_FUNC(IOCTL_KGSL_GPUMEM_FREE_ID,
+			kgsl_ioctl_gpumem_free_id, 0),
+	KGSL_IOCTL_FUNC(IOCTL_KGSL_GPUMEM_GET_INFO,
+			kgsl_ioctl_gpumem_get_info, 0),
+	KGSL_IOCTL_FUNC(IOCTL_KGSL_GPUMEM_SYNC_CACHE,
+			kgsl_ioctl_gpumem_sync_cache, 0),
 };
 
 static long kgsl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
@@ -2035,14 +2466,19 @@
 
 	if (lock) {
 		mutex_lock(&dev_priv->device->mutex);
-		if (use_hw)
-			kgsl_check_suspended(dev_priv->device);
+		if (use_hw) {
+			ret = kgsl_active_count_get(dev_priv->device);
+			if (ret < 0)
+				goto unlock;
+		}
 	}
 
 	ret = func(dev_priv, cmd, uptr);
 
+unlock:
 	if (lock) {
-		kgsl_check_idle_locked(dev_priv->device);
+		if (use_hw)
+			kgsl_active_count_put(dev_priv->device);
 		mutex_unlock(&dev_priv->device->mutex);
 	}
 
@@ -2110,6 +2546,8 @@
 kgsl_gpumem_vm_close(struct vm_area_struct *vma)
 {
 	struct kgsl_mem_entry *entry  = vma->vm_private_data;
+
+	entry->memdesc.useraddr = 0;
 	kgsl_mem_entry_put(entry);
 }
 
@@ -2119,8 +2557,162 @@
 	.close = kgsl_gpumem_vm_close,
 };
 
+static int
+get_mmap_entry(struct kgsl_process_private *private,
+		struct kgsl_mem_entry **out_entry, unsigned long pgoff,
+		unsigned long len)
+{
+	int ret = 0;
+	struct kgsl_mem_entry *entry;
+
+	entry = kgsl_sharedmem_find_id(private, pgoff);
+	if (entry == NULL) {
+		entry = kgsl_sharedmem_find(private, pgoff << PAGE_SHIFT);
+	}
+
+	if (!entry)
+		return -EINVAL;
+
+	if (!entry->memdesc.ops ||
+		!entry->memdesc.ops->vmflags ||
+		!entry->memdesc.ops->vmfault) {
+		ret = -EINVAL;
+		goto err_put;
+	}
+
+	if (entry->memdesc.useraddr != 0) {
+		ret = -EBUSY;
+		goto err_put;
+	}
+
+	if (len != kgsl_memdesc_mmapsize(&entry->memdesc)) {
+		ret = -ERANGE;
+		goto err_put;
+	}
+
+	*out_entry = entry;
+	return 0;
+err_put:
+	kgsl_mem_entry_put(entry);
+	return ret;
+}
+
+static inline bool
+mmap_range_valid(unsigned long addr, unsigned long len)
+{
+	return (addr + len) > addr && (addr + len) < TASK_SIZE;
+}
+
+static unsigned long
+kgsl_get_unmapped_area(struct file *file, unsigned long addr,
+			unsigned long len, unsigned long pgoff,
+			unsigned long flags)
+{
+	unsigned long ret = 0, orig_len = len;
+	unsigned long vma_offset = pgoff << PAGE_SHIFT;
+	struct kgsl_device_private *dev_priv = file->private_data;
+	struct kgsl_process_private *private = dev_priv->process_priv;
+	struct kgsl_device *device = dev_priv->device;
+	struct kgsl_mem_entry *entry = NULL;
+	unsigned int align;
+	unsigned int retry = 0;
+
+	if (vma_offset == device->memstore.gpuaddr)
+		return get_unmapped_area(NULL, addr, len, pgoff, flags);
+
+	ret = get_mmap_entry(private, &entry, pgoff, len);
+	if (ret)
+		return ret;
+
+	if (!kgsl_memdesc_use_cpu_map(&entry->memdesc) || (flags & MAP_FIXED)) {
+		ret = get_unmapped_area(NULL, addr, len, pgoff, flags);
+		goto put;
+	}
+	if (entry->memdesc.gpuaddr != 0) {
+		KGSL_MEM_INFO(device,
+				"pgoff %lx already mapped to gpuaddr %x\n",
+				pgoff, entry->memdesc.gpuaddr);
+		ret = -EBUSY;
+		goto put;
+	}
+	orig_len = kgsl_memdesc_mmapsize(&entry->memdesc);
+
+	align = kgsl_memdesc_get_align(&entry->memdesc);
+	if (align >= ilog2(SZ_1M))
+		align = ilog2(SZ_1M);
+	else if (align >= ilog2(SZ_64K))
+		align = ilog2(SZ_64K);
+	else if (align <= PAGE_SHIFT)
+		align = 0;
+
+	if (align)
+		len += 1 << align;
+
+	if (!mmap_range_valid(addr, len))
+		addr = 0;
+	do {
+		ret = get_unmapped_area(NULL, addr, len, pgoff, flags);
+		if (IS_ERR_VALUE(ret)) {
+			if (!retry && (ret == (unsigned long)-ENOMEM)
+				&& (align > PAGE_SHIFT)) {
+				align = 0;
+				addr = 0;
+				len = orig_len;
+				retry = 1;
+				continue;
+			}
+			break;
+		}
+		if (align)
+			ret = ALIGN(ret, (1 << align));
+
+		
+		spin_lock(&private->mem_lock);
+		if (kgsl_sharedmem_region_empty(private, ret, len)) {
+			int ret_val;
+			entry->memdesc.gpuaddr = ret;
+			
+			ret_val = kgsl_mem_entry_track_gpuaddr(private, entry);
+			BUG_ON(ret_val);
+			spin_unlock(&private->mem_lock);
+			
+			ret_val = kgsl_mmu_map(private->pagetable,
+						&entry->memdesc);
+			if (ret_val) {
+				spin_lock(&private->mem_lock);
+				kgsl_mem_entry_untrack_gpuaddr(private, entry);
+				spin_unlock(&private->mem_lock);
+				ret = ret_val;
+			}
+			break;
+		}
+		spin_unlock(&private->mem_lock);
+
+		trace_kgsl_mem_unmapped_area_collision(entry, addr, orig_len,
+							ret);
+
+		addr = (addr == 0) ? ret + orig_len : addr + orig_len;
+
+		if (!retry && !mmap_range_valid(addr, len)) {
+			addr = 0;
+			retry = 1;
+		} else {
+			ret = -EBUSY;
+		}
+	} while (mmap_range_valid(addr, len));
+
+	if (IS_ERR_VALUE(ret))
+		KGSL_MEM_ERR(device,
+				"pid %d pgoff %lx len %ld failed error %ld\n",
+				private->pid, pgoff, len, ret);
+put:
+	kgsl_mem_entry_put(entry);
+	return ret;
+}
+
 static int kgsl_mmap(struct file *file, struct vm_area_struct *vma)
 {
+	unsigned int ret, cache;
 	unsigned long vma_offset = vma->vm_pgoff << PAGE_SHIFT;
 	struct kgsl_device_private *dev_priv = file->private_data;
 	struct kgsl_process_private *private = dev_priv->process_priv;
@@ -2132,31 +2724,61 @@
 	if (vma_offset == device->memstore.gpuaddr)
 		return kgsl_mmap_memstore(device, vma);
 
-	
-
-	spin_lock(&private->mem_lock);
-	entry = kgsl_sharedmem_find(private, vma_offset);
+	ret = get_mmap_entry(private, &entry, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start);
+	if (ret)
+		return ret;
 
-	if (entry)
-		kgsl_mem_entry_get(entry);
+	vma->vm_flags |= entry->memdesc.ops->vmflags(&entry->memdesc);
 
-	spin_unlock(&private->mem_lock);
+	vma->vm_private_data = entry;
 
-	if (entry == NULL)
-		return -EINVAL;
+	
 
-	if (!entry->memdesc.ops ||
-		!entry->memdesc.ops->vmflags ||
-		!entry->memdesc.ops->vmfault)
-		return -EINVAL;
+	cache = kgsl_memdesc_get_cachemode(&entry->memdesc);
 
-	vma->vm_flags |= entry->memdesc.ops->vmflags(&entry->memdesc);
+	switch (cache) {
+	case KGSL_CACHEMODE_UNCACHED:
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+		break;
+	case KGSL_CACHEMODE_WRITETHROUGH:
+		vma->vm_page_prot = pgprot_writethroughcache(vma->vm_page_prot);
+		break;
+	case KGSL_CACHEMODE_WRITEBACK:
+		vma->vm_page_prot = pgprot_writebackcache(vma->vm_page_prot);
+		break;
+	case KGSL_CACHEMODE_WRITECOMBINE:
+	default:
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+		break;
+	}
 
-	vma->vm_private_data = entry;
-	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 	vma->vm_ops = &kgsl_gpumem_vm_ops;
+
+	if (cache == KGSL_CACHEMODE_WRITEBACK
+		|| cache == KGSL_CACHEMODE_WRITETHROUGH) {
+		struct scatterlist *s;
+		int i;
+		int sglen = entry->memdesc.sglen;
+		unsigned long addr = vma->vm_start;
+
+		for_each_sg(entry->memdesc.sg, s, sglen, i) {
+			int j;
+			for (j = 0; j < (sg_dma_len(s) >> PAGE_SHIFT); j++) {
+				struct page *page = sg_page(s);
+				page = nth_page(page, j);
+				vm_insert_page(vma, addr, page);
+				addr += PAGE_SIZE;
+			}
+		}
+	}
+
 	vma->vm_file = file;
 
+	entry->memdesc.useraddr = vma->vm_start;
+
+	trace_kgsl_mem_mmap(entry);
+
 	if (entry->memdesc.handle != NULL) {
 		remap_pfn_range(vma, vma->vm_start, __phys_to_pfn(entry->memdesc.sg[0].dma_address),
 		entry->memdesc.size, vma->vm_page_prot);
@@ -2178,6 +2800,7 @@
 	.release = kgsl_release,
 	.open = kgsl_open,
 	.mmap = kgsl_mmap,
+	.get_unmapped_area = kgsl_get_unmapped_area,
 	.unlocked_ioctl = kgsl_ioctl,
 };
 
@@ -2186,6 +2809,8 @@
 	.ptlock = __SPIN_LOCK_UNLOCKED(kgsl_driver.ptlock),
 	.process_dump_lock = __SPIN_LOCK_UNLOCKED(kgsl_driver.process_dump_lock),
 	.devlock = __MUTEX_INITIALIZER(kgsl_driver.devlock),
+	.memfree_hist_mutex =
+		__MUTEX_INITIALIZER(kgsl_driver.memfree_hist_mutex),
 };
 EXPORT_SYMBOL(kgsl_driver);
 
@@ -2260,18 +2885,6 @@
 	if (status)
 		return status;
 
-#ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	device->current_process_priv = NULL;
-#endif
-
-	
-	device->gputime.total = 0;
-	device->gputime.busy = 0;
-	for(i=0;i<KGSL_MAX_PWRLEVELS;i++) {
-		device->gputime_in_state[i].total = 0;
-		device->gputime_in_state[i].busy = 0;
-	}
-
 	
 	kgsl_device_debugfs_init(device);
 
@@ -2343,7 +2956,6 @@
 	if (result)
 		goto error_pwrctrl_close;
 
-	kgsl_cffdump_open(device->id);
 
 	setup_timer(&device->idle_timer, kgsl_timer, (unsigned long) device);
 	status = kgsl_create_device_workqueue(device);
@@ -2374,6 +2986,18 @@
 	
 	kgsl_pwrctrl_init_sysfs(device);
 
+#ifdef CONFIG_MSM_KGSL_GPU_USAGE
+	device->current_process_priv = NULL;
+#endif
+
+	
+	device->gputime.total = 0;
+	device->gputime.busy = 0;
+	for(i=0;i<KGSL_MAX_PWRLEVELS;i++) {
+		device->gputime_in_state[i].total = 0;
+		device->gputime_in_state[i].busy = 0;
+	}
+
 	return 0;
 
 error_close_mmu:
@@ -2401,11 +3025,7 @@
 	
 
 	if (manual) {
-		if (device->active_cnt != 0) {
-			mutex_unlock(&device->mutex);
-			wait_for_completion(&device->suspend_gate);
-			mutex_lock(&device->mutex);
-		}
+		kgsl_active_count_wait(device);
 
 		if (device->state == KGSL_STATE_ACTIVE)
 			kgsl_idle(device);
@@ -2461,7 +3081,6 @@
 {
 	kgsl_device_snapshot_close(device);
 
-	kgsl_cffdump_close(device->id);
 	kgsl_pwrctrl_uninit_sysfs(device);
 
 	pm_qos_remove_request(&device->pm_qos_req_dma);
@@ -2511,6 +3130,7 @@
 		kgsl_driver.class = NULL;
 	}
 
+	kgsl_memfree_hist_exit();
 	unregister_chrdev_region(kgsl_driver.major, KGSL_DEVICE_MAX);
 }
 
@@ -2581,6 +3201,9 @@
 			goto err;
 	}
 
+	if (kgsl_memfree_hist_init())
+		KGSL_CORE_ERR("failed to init memfree_hist");
+
 	return 0;
 
 err:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_cffdump.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_cffdump.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_cffdump.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_cffdump.h	2013-08-01 23:38:02.000000000 -0600
@@ -22,10 +22,10 @@
 
 void kgsl_cffdump_init(void);
 void kgsl_cffdump_destroy(void);
-void kgsl_cffdump_open(enum kgsl_deviceid device_id);
+void kgsl_cffdump_open(struct kgsl_device *device);
 void kgsl_cffdump_close(enum kgsl_deviceid device_id);
 void kgsl_cffdump_syncmem(struct kgsl_device_private *dev_priv,
-	const struct kgsl_memdesc *memdesc, uint physaddr, uint sizebytes,
+	struct kgsl_memdesc *memdesc, uint physaddr, uint sizebytes,
 	bool clean_cache);
 void kgsl_cffdump_setmem(uint addr, uint value, uint sizebytes);
 void kgsl_cffdump_regwrite(enum kgsl_deviceid device_id, uint addr,
@@ -49,7 +49,7 @@
 
 #define kgsl_cffdump_init()					(void)0
 #define kgsl_cffdump_destroy()					(void)0
-#define kgsl_cffdump_open(device_id)				(void)0
+#define kgsl_cffdump_open(device)				(void)0
 #define kgsl_cffdump_close(device_id)				(void)0
 #define kgsl_cffdump_syncmem(dev_priv, memdesc, addr, sizebytes, clean_cache) \
 	(void) 0
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_debugfs.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_debugfs.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_debugfs.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_debugfs.c	2013-08-01 23:38:02.000000000 -0600
@@ -25,23 +25,6 @@
 static struct dentry *pm_d_debugfs;
 struct dentry *proc_d_debugfs;
 
-#ifdef CONFIG_MSM_KGSL_GPU_USAGE
-
-static int ctx_dump_set(void* data, u64 val)
-{
-	struct kgsl_device *device = data;
-
-	mutex_lock(&device->mutex);
-	kgsl_dump_contextpid(&device->context_idr);
-	mutex_unlock(&device->mutex);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(ctx_dump_fops,
-			NULL,
-			ctx_dump_set, "%llu\n");
-#endif
-
 static int pm_dump_set(void *data, u64 val)
 {
 	struct kgsl_device *device = data;
@@ -141,6 +124,47 @@
 KGSL_DEBUGFS_LOG(pwr_log);
 KGSL_DEBUGFS_LOG(ft_log);
 
+static int memfree_hist_print(struct seq_file *s, void *unused)
+{
+	void *base = kgsl_driver.memfree_hist.base_hist_rb;
+
+	struct kgsl_memfree_hist_elem *wptr = kgsl_driver.memfree_hist.wptr;
+	struct kgsl_memfree_hist_elem *p;
+	char str[16];
+
+	seq_printf(s, "%8s %8s %8s %11s\n",
+			"pid", "gpuaddr", "size", "flags");
+
+	mutex_lock(&kgsl_driver.memfree_hist_mutex);
+	p = wptr;
+	for (;;) {
+		kgsl_get_memory_usage(str, sizeof(str), p->flags);
+		if (p->size)
+			seq_printf(s, "%8d %08x %8d %11s\n",
+				p->pid, p->gpuaddr, p->size, str);
+		p++;
+		if ((void *)p >= base + kgsl_driver.memfree_hist.size)
+			p = (struct kgsl_memfree_hist_elem *) base;
+
+		if (p == kgsl_driver.memfree_hist.wptr)
+			break;
+	}
+	mutex_unlock(&kgsl_driver.memfree_hist_mutex);
+	return 0;
+}
+
+static int memfree_hist_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, memfree_hist_print, inode->i_private);
+}
+
+static const struct file_operations memfree_hist_fops = {
+	.open = memfree_hist_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
 void kgsl_device_debugfs_init(struct kgsl_device *device)
 {
 	if (kgsl_debugfs_dir && !IS_ERR(kgsl_debugfs_dir))
@@ -167,12 +191,9 @@
 				&mem_log_fops);
 	debugfs_create_file("log_level_pwr", 0644, device->d_debugfs, device,
 				&pwr_log_fops);
-	debugfs_create_file("log_level_ft", 0644, device->d_debugfs, device,
-				&ft_log_fops);
-#ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	debugfs_create_file("contexpid_dump",  0644, device->d_debugfs, device,
-				&ctx_dump_fops);
-#endif
+	debugfs_create_file("memfree_history", 0444, device->d_debugfs, device,
+				&memfree_hist_fops);
+
 	
 
 	pm_d_debugfs = debugfs_create_dir("postmortem", device->d_debugfs);
@@ -217,35 +238,70 @@
 	return '-';
 }
 
+static char get_cacheflag(const struct kgsl_memdesc *m)
+{
+	static const char table[] = {
+		[KGSL_CACHEMODE_WRITECOMBINE] = '-',
+		[KGSL_CACHEMODE_UNCACHED] = 'u',
+		[KGSL_CACHEMODE_WRITEBACK] = 'b',
+		[KGSL_CACHEMODE_WRITETHROUGH] = 't',
+	};
+	return table[kgsl_memdesc_get_cachemode(m)];
+}
+
+static void print_mem_entry(struct seq_file *s, struct kgsl_mem_entry *entry)
+{
+	char flags[6];
+	char usage[16];
+	struct kgsl_memdesc *m = &entry->memdesc;
+
+	flags[0] = kgsl_memdesc_is_global(m) ?  'g' : '-';
+	flags[1] = m->flags & KGSL_MEMFLAGS_GPUREADONLY ? 'r' : '-';
+	flags[2] = get_alignflag(m);
+	flags[3] = get_cacheflag(m);
+	flags[4] = kgsl_memdesc_use_cpu_map(m) ? 'p' : '-';
+	flags[5] = '\0';
+
+	kgsl_get_memory_usage(usage, sizeof(usage), m->flags);
+
+	seq_printf(s, "%08x %8d %5d %5s %10s %16s %5d\n",
+			m->gpuaddr, m->size, entry->id, flags,
+			memtype_str(entry->memtype), usage, m->sglen);
+}
+
 static int process_mem_print(struct seq_file *s, void *unused)
 {
 	struct kgsl_mem_entry *entry;
 	struct rb_node *node;
 	struct kgsl_process_private *private = s->private;
-	char flags[4];
-	char usage[16];
+	int next = 0;
 
+	seq_printf(s, "%8s %8s %5s %5s %10s %16s %5s\n",
+		   "gpuaddr", "size", "id", "flags", "type", "usage", "sglen");
+
+	
 	spin_lock(&private->mem_lock);
-	seq_printf(s, "%8s %8s %5s %10s %16s %5s\n",
-		   "gpuaddr", "size", "flags", "type", "usage", "sglen");
-	for (node = rb_first(&private->mem_rb); node; node = rb_next(node)) {
-		struct kgsl_memdesc *m;
 
+	for (node = rb_first(&private->mem_rb); node; node = rb_next(node)) {
 		entry = rb_entry(node, struct kgsl_mem_entry, node);
-		m = &entry->memdesc;
-
-		flags[0] = m->priv & KGSL_MEMDESC_GLOBAL ?  'g' : '-';
-		flags[1] = m->flags & KGSL_MEMFLAGS_GPUREADONLY ? 'r' : '-';
-		flags[2] = get_alignflag(m);
-		flags[3] = '\0';
-
-		kgsl_get_memory_usage(usage, sizeof(usage), m->flags);
-
-		seq_printf(s, "%08x %8d %5s %10s %16s %5d\n",
-			   m->gpuaddr, m->size, flags,
-			   memtype_str(entry->memtype), usage, m->sglen);
+		print_mem_entry(s, entry);
 	}
+
 	spin_unlock(&private->mem_lock);
+
+	
+	while (1) {
+		rcu_read_lock();
+		entry = idr_get_next(&private->mem_idr, &next);
+		rcu_read_unlock();
+
+		if (entry == NULL)
+			break;
+		if (entry->memdesc.gpuaddr == 0)
+			print_mem_entry(s, entry);
+		next++;
+	}
+
 	return 0;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_device.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_device.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_device.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_device.h	2013-08-01 23:38:02.000000000 -0600
@@ -47,6 +47,10 @@
 
 #define KGSL_IS_PAGE_ALIGNED(addr) (!((addr) & (~PAGE_MASK)))
 
+
+#define KGSL_EVENT_TIMESTAMP_RETIRED 0
+#define KGSL_EVENT_CANCELLED 1
+
 struct kgsl_device;
 struct platform_device;
 struct kgsl_device_private;
@@ -62,7 +66,8 @@
 	int (*idle) (struct kgsl_device *device);
 	unsigned int (*isidle) (struct kgsl_device *device);
 	int (*suspend_context) (struct kgsl_device *device);
-	int (*start) (struct kgsl_device *device, unsigned int init_ram);
+	int (*init) (struct kgsl_device *device);
+	int (*start) (struct kgsl_device *device);
 	int (*stop) (struct kgsl_device *device);
 	int (*getproperty) (struct kgsl_device *device,
 		enum kgsl_property_type type, void *value,
@@ -91,7 +96,7 @@
 			uint32_t flags);
 	int (*drawctxt_create) (struct kgsl_device *device,
 		struct kgsl_pagetable *pagetable, struct kgsl_context *context,
-		uint32_t flags);
+		uint32_t *flags);
 	void (*drawctxt_destroy) (struct kgsl_device *device,
 		struct kgsl_context *context);
 	long (*ioctl) (struct kgsl_device_private *dev_priv,
@@ -112,10 +117,12 @@
 	int              mpu_range;
 };
 
+typedef void (*kgsl_event_func)(struct kgsl_device *, void *, u32, u32, u32);
+
 struct kgsl_event {
 	struct kgsl_context *context;
 	uint32_t timestamp;
-	void (*func)(struct kgsl_device *, void *, u32, u32);
+	kgsl_event_func func;
 	void *priv;
 	struct list_head list;
 	void *owner;
@@ -149,7 +156,6 @@
 	struct kgsl_pwrctrl pwrctrl;
 	int open_count;
 
-	struct atomic_notifier_head ts_notifier_list;
 	struct mutex mutex;
 	uint32_t state;
 	uint32_t requested_state;
@@ -171,7 +177,6 @@
 	u32 snapshot_timestamp;	
 	int snapshot_frozen;	
 	struct kobject snapshot_kobj;
-	int snapshot_no_panic;  
 
 	struct list_head snapshot_obj_list;
 
@@ -195,6 +200,9 @@
 	int pm_regs_enabled;
 	int pm_ib_enabled;
 
+	int reset_counter; 
+	int snapshot_no_panic;
+
 	
 	struct kgsl_gpubusy gputime;
 	struct kgsl_gpubusy gputime_in_state[KGSL_MAX_PWRLEVELS];
@@ -210,7 +218,6 @@
 	.hwaccess_gate = COMPLETION_INITIALIZER((_dev).hwaccess_gate),\
 	.suspend_gate = COMPLETION_INITIALIZER((_dev).suspend_gate),\
 	.ft_gate = COMPLETION_INITIALIZER((_dev).ft_gate),\
-	.ts_notifier_list = ATOMIC_NOTIFIER_INIT((_dev).ts_notifier_list),\
 	.idle_check_ws = __WORK_INITIALIZER((_dev).idle_check_ws,\
 			kgsl_idle_check),\
 	.ts_expired_ws  = __WORK_INITIALIZER((_dev).ts_expired_ws,\
@@ -241,7 +248,14 @@
 	unsigned int refcnt;
 	pid_t pid;
 	spinlock_t mem_lock;
+
+	
+	struct kref refcount;
+	
+	struct mutex process_private_mutex;
+
 	struct rb_root mem_rb;
+	struct idr mem_idr;
 	struct kgsl_pagetable *pagetable;
 	struct list_head list;
 	struct kobject kobj;
@@ -258,8 +272,6 @@
 #endif
 };
 
-
-
 struct kgsl_device_private {
 	struct kgsl_device *device;
 	struct kgsl_process_private *process_priv;
@@ -271,7 +283,9 @@
 };
 
 struct kgsl_device *kgsl_get_device(int dev_idx);
-void kgsl_dump_contextpid(struct idr *context_idr);
+
+int kgsl_add_event(struct kgsl_device *device, u32 id, u32 ts,
+	kgsl_event_func func, void *priv, void *owner);
 
 static inline void kgsl_process_add_stats(struct kgsl_process_private *priv,
 	unsigned int type, size_t size)
@@ -366,25 +380,11 @@
 	return 0;
 }
 
-static inline struct kgsl_context *
-kgsl_find_context(struct kgsl_device_private *dev_priv, uint32_t id)
-{
-	struct kgsl_context *ctxt =
-		idr_find(&dev_priv->device->context_idr, id);
 
 
-	return  (ctxt && ctxt->dev_priv == dev_priv) ? ctxt : NULL;
-}
-
 int kgsl_check_timestamp(struct kgsl_device *device,
 		struct kgsl_context *context, unsigned int timestamp);
 
-int kgsl_register_ts_notifier(struct kgsl_device *device,
-			      struct notifier_block *nb);
-
-int kgsl_unregister_ts_notifier(struct kgsl_device *device,
-				struct notifier_block *nb);
-
 int kgsl_device_platform_probe(struct kgsl_device *device);
 
 void kgsl_device_platform_remove(struct kgsl_device *device);
@@ -404,30 +404,61 @@
 	return pdev->dev.platform_data;
 }
 
+void kgsl_context_destroy(struct kref *kref);
+
 static inline void
-kgsl_context_get(struct kgsl_context *context)
+kgsl_context_put(struct kgsl_context *context)
 {
-	kref_get(&context->refcount);
+	if (context)
+		kref_put(&context->refcount, kgsl_context_destroy);
 }
 
-void kgsl_context_destroy(struct kref *kref);
+static inline void _kgsl_context_get(struct kgsl_context *context)
+{
+	if (context)
+		kref_get(&context->refcount);
+}
 
-static inline void
-kgsl_context_put(struct kgsl_context *context)
+static inline struct kgsl_context *kgsl_context_get(struct kgsl_device *device,
+		uint32_t id)
 {
-	kref_put(&context->refcount, kgsl_context_destroy);
+	struct kgsl_context *context = NULL;
+
+	rcu_read_lock();
+	context = idr_find(&device->context_idr, id);
+
+	_kgsl_context_get(context);
+
+	rcu_read_unlock();
+	return context;
 }
 
-static inline void
-kgsl_active_count_put(struct kgsl_device *device)
+static inline struct kgsl_context *kgsl_context_get_owner(
+		struct kgsl_device_private *dev_priv, uint32_t id)
 {
-	if (device->active_cnt == 1)
-		INIT_COMPLETION(device->suspend_gate);
+	struct kgsl_context *context;
 
-	device->active_cnt--;
+	context = kgsl_context_get(dev_priv->device, id);
 
-	if (device->active_cnt == 0)
-		complete(&device->suspend_gate);
+	
+	if (context && context->dev_priv != dev_priv) {
+		kgsl_context_put(context);
+		return NULL;
+	}
+
+	return context;
+}
+
+static inline void kgsl_context_cancel_events(struct kgsl_device *device,
+	struct kgsl_context *context)
+{
+	kgsl_signal_events(device, context, KGSL_EVENT_CANCELLED);
+}
+
+static inline void kgsl_cancel_events_timestamp(struct kgsl_device *device,
+	struct kgsl_context *context, unsigned int timestamp)
+{
+	kgsl_signal_event(device, context, timestamp, KGSL_EVENT_CANCELLED);
 }
 
 #endif  
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_events.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_events.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_events.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_events.c	2013-08-01 23:38:02.000000000 -0600
@@ -18,6 +18,12 @@
 
 #include "kgsl_trace.h"
 
+static inline struct list_head *_get_list_head(struct kgsl_device *device,
+		struct kgsl_context *context)
+{
+	return (context) ? &context->events : &device->events;
+}
+
 static void _add_event_to_list(struct list_head *head, struct kgsl_event *event)
 {
 	struct list_head *n;
@@ -36,19 +42,127 @@
 		list_add_tail(&event->list, head);
 }
 
+static inline void _do_signal_event(struct kgsl_device *device,
+		struct kgsl_event *event, unsigned int timestamp,
+		unsigned int type)
+{
+	int id = event->context ? event->context->id : KGSL_MEMSTORE_GLOBAL;
+
+	trace_kgsl_fire_event(id, timestamp, type, jiffies - event->created);
+
+	if (event->func)
+		event->func(device, event->priv, id, timestamp, type);
+
+	list_del(&event->list);
+	kgsl_context_put(event->context);
+	kfree(event);
+
+	kgsl_active_count_put(device);
+}
+
+static void _retire_events(struct kgsl_device *device,
+		struct list_head *head, unsigned int timestamp)
+{
+	struct kgsl_event *event, *tmp;
+
+	list_for_each_entry_safe(event, tmp, head, list) {
+		if (timestamp_cmp(timestamp, event->timestamp) < 0)
+			break;
+
+		_do_signal_event(device, event, event->timestamp,
+			KGSL_EVENT_TIMESTAMP_RETIRED);
+	}
+}
+
+static struct kgsl_event *_find_event(struct kgsl_device *device,
+		struct list_head *head, unsigned int timestamp,
+		kgsl_event_func func, void *priv)
+{
+	struct kgsl_event *event, *tmp;
+
+	list_for_each_entry_safe(event, tmp, head, list) {
+		if (timestamp == event->timestamp && func == event->func &&
+			event->priv == priv)
+			return event;
+	}
+
+	return NULL;
+}
+
+static void _signal_event(struct kgsl_device *device,
+		struct list_head *head, unsigned int timestamp,
+		unsigned int cur, unsigned int type)
+{
+	struct kgsl_event *event, *tmp;
+
+	list_for_each_entry_safe(event, tmp, head, list) {
+		if (timestamp_cmp(timestamp, event->timestamp) == 0)
+			_do_signal_event(device, event, cur, type);
+	}
+}
+
+static void _signal_events(struct kgsl_device *device,
+		struct list_head *head, uint32_t timestamp,
+		unsigned int type)
+{
+	struct kgsl_event *event, *tmp;
+
+	list_for_each_entry_safe(event, tmp, head, list)
+		_do_signal_event(device, event, timestamp, type);
+
+}
+
+void kgsl_signal_event(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp,
+		unsigned int type)
+{
+	struct list_head *head = _get_list_head(device, context);
+	uint32_t cur;
+
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+	cur = kgsl_readtimestamp(device, context, KGSL_TIMESTAMP_RETIRED);
+	_signal_event(device, head, timestamp, cur, type);
+
+	if (context && list_empty(&context->events))
+		list_del_init(&context->events_list);
+}
+EXPORT_SYMBOL(kgsl_signal_event);
+
+void kgsl_signal_events(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int type)
+{
+	struct list_head *head = _get_list_head(device, context);
+	uint32_t cur;
+
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+
+	cur = kgsl_readtimestamp(device, context, KGSL_TIMESTAMP_RETIRED);
+
+	_signal_events(device, head, cur, type);
+
+
+	if (context)
+		list_del_init(&context->events_list);
+}
+EXPORT_SYMBOL(kgsl_signal_events);
+
 int kgsl_add_event(struct kgsl_device *device, u32 id, u32 ts,
-	void (*cb)(struct kgsl_device *, void *, u32, u32), void *priv,
-	void *owner)
+	kgsl_event_func func, void *priv, void *owner)
 {
+	int ret;
 	struct kgsl_event *event;
 	unsigned int cur_ts;
 	struct kgsl_context *context = NULL;
 
-	if (cb == NULL)
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+	if (func == NULL)
 		return -EINVAL;
 
 	if (id != KGSL_MEMSTORE_GLOBAL) {
-		context = idr_find(&device->context_idr, id);
+		context = kgsl_context_get(device, id);
 		if (context == NULL)
 			return -EINVAL;
 	}
@@ -56,29 +170,35 @@
 
 
 	if (timestamp_cmp(cur_ts, ts) >= 0) {
-		trace_kgsl_fire_event(id, ts, 0);
-		cb(device, priv, id, ts);
+		trace_kgsl_fire_event(id, cur_ts, ts, 0);
+
+		func(device, priv, id, ts, KGSL_EVENT_TIMESTAMP_RETIRED);
+		kgsl_context_put(context);
 		return 0;
 	}
 
 	event = kzalloc(sizeof(*event), GFP_KERNEL);
-	if (event == NULL)
+	if (event == NULL) {
+		kgsl_context_put(context);
 		return -ENOMEM;
+	}
+
+	ret = kgsl_active_count_get_light(device);
+	if (ret < 0) {
+		kfree(event);
+		return ret;
+	}
 
 	event->context = context;
 	event->timestamp = ts;
 	event->priv = priv;
-	event->func = cb;
+	event->func = func;
 	event->owner = owner;
 	event->created = jiffies;
 
 	trace_kgsl_register_event(id, ts);
 
 	
-	if (context)
-		kgsl_context_get(context);
-
-	
 
 	if (context) {
 		_add_event_to_list(&context->events, event);
@@ -91,100 +211,46 @@
 	} else
 		_add_event_to_list(&device->events, event);
 
-
-	device->active_cnt++;
-
 	queue_work(device->work_queue, &device->ts_expired_ws);
 	return 0;
 }
 EXPORT_SYMBOL(kgsl_add_event);
 
-void kgsl_cancel_events_ctxt(struct kgsl_device *device,
-	struct kgsl_context *context)
-{
-	struct kgsl_event *event, *event_tmp;
-	unsigned int id, cur;
-
-	cur = kgsl_readtimestamp(device, context, KGSL_TIMESTAMP_RETIRED);
-	id = context->id;
-
-	list_for_each_entry_safe(event, event_tmp, &context->events, list) {
-
-		trace_kgsl_fire_event(id, cur, jiffies - event->created);
-
-		if (event->func)
-			event->func(device, event->priv, id, cur);
-
-		kgsl_context_put(context);
-		list_del(&event->list);
-		kfree(event);
-
-		kgsl_active_count_put(device);
-	}
-
-	
-	list_del_init(&context->events_list);
-}
-
-void kgsl_cancel_events(struct kgsl_device *device,
-	void *owner)
+void kgsl_cancel_events(struct kgsl_device *device, void *owner)
 {
 	struct kgsl_event *event, *event_tmp;
 	unsigned int cur;
 
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
 	cur = kgsl_readtimestamp(device, NULL, KGSL_TIMESTAMP_RETIRED);
 
 	list_for_each_entry_safe(event, event_tmp, &device->events, list) {
 		if (event->owner != owner)
 			continue;
 
-
-		trace_kgsl_fire_event(KGSL_MEMSTORE_GLOBAL, cur,
-			jiffies - event->created);
-
-		if (event->func)
-			event->func(device, event->priv, KGSL_MEMSTORE_GLOBAL,
-				cur);
-
-		if (event->context)
-			kgsl_context_put(event->context);
-
-		list_del(&event->list);
-		kfree(event);
-
-		kgsl_active_count_put(device);
+		_do_signal_event(device, event, cur, KGSL_EVENT_CANCELLED);
 	}
 }
 EXPORT_SYMBOL(kgsl_cancel_events);
 
-static void _process_event_list(struct kgsl_device *device,
-		struct list_head *head, unsigned int timestamp)
+void kgsl_cancel_event(struct kgsl_device *device, struct kgsl_context *context,
+		unsigned int timestamp, kgsl_event_func func,
+		void *priv)
 {
-	struct kgsl_event *event, *tmp;
-	unsigned int id;
-
-	list_for_each_entry_safe(event, tmp, head, list) {
-		if (timestamp_cmp(timestamp, event->timestamp) < 0)
-			break;
-
-		id = event->context ? event->context->id : KGSL_MEMSTORE_GLOBAL;
-
-
-		trace_kgsl_fire_event(id, event->timestamp,
-			jiffies - event->created);
-
-		if (event->func)
-			event->func(device, event->priv, id, event->timestamp);
+	struct kgsl_event *event;
+	struct list_head *head = _get_list_head(device, context);
 
-		if (event->context)
-			kgsl_context_put(event->context);
+	event = _find_event(device, head, timestamp, func, priv);
 
-		list_del(&event->list);
-		kfree(event);
+	if (event) {
+		unsigned int cur = kgsl_readtimestamp(device, context,
+			KGSL_TIMESTAMP_RETIRED);
 
-		kgsl_active_count_put(device);
+		_do_signal_event(device, event, cur, KGSL_EVENT_CANCELLED);
 	}
 }
+EXPORT_SYMBOL(kgsl_cancel_event);
 
 static inline int _mark_next_event(struct kgsl_device *device,
 		struct list_head *head)
@@ -195,7 +261,8 @@
 		event = list_first_entry(head, struct kgsl_event, list);
 
 
-		return device->ftbl->next_event(device, event);
+		if (device->ftbl->next_event)
+			return device->ftbl->next_event(device, event);
 	}
 
 	return 0;
@@ -208,7 +275,7 @@
 		unsigned int timestamp = kgsl_readtimestamp(device, context,
 			KGSL_TIMESTAMP_RETIRED);
 
-		_process_event_list(device, &context->events, timestamp);
+		_retire_events(device, &context->events, timestamp);
 
 
 		if (!_mark_next_event(device, &context->events))
@@ -230,16 +297,18 @@
 
 	
 	timestamp = kgsl_readtimestamp(device, NULL, KGSL_TIMESTAMP_RETIRED);
-	_process_event_list(device, &device->events, timestamp);
+	_retire_events(device, &device->events, timestamp);
 	_mark_next_event(device, &device->events);
 
 	
 	list_for_each_entry_safe(context, tmp, &device->events_pending_list,
 		events_list) {
 
+		_kgsl_context_get(context);
 
 		if (kgsl_process_context_events(device, context) == 0)
 			list_del_init(&context->events_list);
+		kgsl_context_put(context);
 	}
 
 	mutex_unlock(&device->mutex);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_gpummu.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_gpummu.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_gpummu.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_gpummu.c	2013-08-01 23:38:02.000000000 -0600
@@ -542,7 +542,7 @@
 {
 	unsigned int numpages;
 	unsigned int pte, ptefirst, ptelast, superpte;
-	unsigned int range = kgsl_sg_size(memdesc->sg, memdesc->sglen);
+	unsigned int range = memdesc->size;
 	struct kgsl_gpummu_pt *gpummu_pt = mmu_specific_pt;
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl.h	2013-08-01 23:38:02.000000000 -0600
@@ -60,6 +60,23 @@
 #define KGSL_STATS_ADD(_size, _stat, _max) \
 	do { _stat += (_size); if (_stat > _max) _max = _stat; } while (0)
 
+
+#define KGSL_MEMFREE_HIST_SIZE	((int)(PAGE_SIZE * 2))
+
+struct kgsl_memfree_hist_elem {
+	unsigned int pid;
+	unsigned int gpuaddr;
+	unsigned int size;
+	unsigned int flags;
+};
+
+struct kgsl_memfree_hist {
+	void *base_hist_rb;
+	unsigned int size;
+	struct kgsl_memfree_hist_elem *wptr;
+};
+
+
 struct kgsl_device;
 struct kgsl_context;
 
@@ -90,6 +107,9 @@
 
 	void *ptpool;
 
+	struct mutex memfree_hist_mutex;
+	struct kgsl_memfree_hist memfree_hist;
+
 	struct {
 		unsigned int vmalloc;
 		unsigned int vmalloc_max;
@@ -122,10 +142,13 @@
 
 #define KGSL_MEMDESC_GUARD_PAGE BIT(0)
 #define KGSL_MEMDESC_GLOBAL BIT(1)
+#define KGSL_MEMDESC_FROZEN BIT(2)
+#define KGSL_MEMDESC_MAPPED BIT(3)
 
 struct kgsl_memdesc {
 	struct kgsl_pagetable *pagetable;
-	void *hostptr;
+	void *hostptr; 
+	unsigned long useraddr; 
 	unsigned int gpuaddr;
 	unsigned int physaddr;
 	unsigned int size;
@@ -151,29 +174,28 @@
 #define KGSL_MEM_ENTRY_MAX     7
 #else
 enum {
-KGSL_MEM_ENTRY_KERNEL = 0,
-KGSL_MEM_ENTRY_PMEM,
-KGSL_MEM_ENTRY_ASHMEM,
-KGSL_MEM_ENTRY_USER,
-KGSL_MEM_ENTRY_ION,
-KGSL_MEM_ENTRY_PAGE_ALLOC,
-KGSL_MEM_ENTRY_PRE_ALLOC,
-KGSL_MEM_ENTRY_MAX,
+	KGSL_MEM_ENTRY_KERNEL = 0,
+	KGSL_MEM_ENTRY_PMEM,
+	KGSL_MEM_ENTRY_ASHMEM,
+	KGSL_MEM_ENTRY_USER,
+	KGSL_MEM_ENTRY_ION,
+	KGSL_MEM_ENTRY_PAGE_ALLOC,
+	KGSL_MEM_ENTRY_PRE_ALLOC,
+	KGSL_MEM_ENTRY_MAX,
 };
 #endif
 
-
-#define KGSL_MEM_ENTRY_FROZEN (1 << 0)
-
 struct kgsl_mem_entry {
 	struct kref refcount;
 	struct kgsl_memdesc memdesc;
 	int memtype;
-	int flags;
 	void *priv_data;
 	struct rb_node node;
+	unsigned int id;
 	unsigned int context_id;
 	struct kgsl_process_private *priv;
+	
+	int pending_free;
 };
 
 #ifdef CONFIG_MSM_KGSL_MMU_PAGE_FAULT
@@ -194,16 +216,16 @@
 
 void kgsl_get_memory_usage(char *str, size_t len, unsigned int memflags);
 
-int kgsl_add_event(struct kgsl_device *device, u32 id, u32 ts,
-	void (*cb)(struct kgsl_device *, void *, u32, u32), void *priv,
-	void *owner);
+void kgsl_signal_event(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp,
+		unsigned int type);
+
+void kgsl_signal_events(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int type);
 
 void kgsl_cancel_events(struct kgsl_device *device,
 	void *owner);
 
-void kgsl_cancel_events_ctxt(struct kgsl_device *device,
-	struct kgsl_context *context);
-
 extern const struct dev_pm_ops kgsl_pm_ops;
 
 struct early_suspend;
@@ -212,6 +234,14 @@
 void kgsl_early_suspend_driver(struct early_suspend *h);
 void kgsl_late_resume_driver(struct early_suspend *h);
 
+void kgsl_trace_regwrite(struct kgsl_device *device, unsigned int offset,
+		unsigned int value);
+
+void kgsl_trace_issueibcmds(struct kgsl_device *device, int id,
+		struct kgsl_ibdesc *ibdesc, int numibs,
+		unsigned int timestamp, unsigned int flags,
+		int result, unsigned int type);
+
 #ifdef CONFIG_MSM_KGSL_DRM
 extern int kgsl_drm_init(struct platform_device *dev);
 extern void kgsl_drm_exit(void);
@@ -229,6 +259,14 @@
 static inline int kgsl_gpuaddr_in_memdesc(const struct kgsl_memdesc *memdesc,
 				unsigned int gpuaddr, unsigned int size)
 {
+	
+	if (!size)
+		size = 1;
+
+	
+	if ((gpuaddr + size) < gpuaddr)
+		return 0;
+
 	if (gpuaddr >= memdesc->gpuaddr &&
 	    ((gpuaddr + size) <= (memdesc->gpuaddr + memdesc->size))) {
 		return 1;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_iommu.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_iommu.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_iommu.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_iommu.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -11,6 +11,7 @@
  *
  */
 #include <linux/types.h>
+#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/spinlock.h>
 #include <linux/genalloc.h>
@@ -31,6 +32,7 @@
 #include "adreno.h"
 #include "kgsl_trace.h"
 #include "z180.h"
+#include "kgsl_cffdump.h"
 
 
 static struct kgsl_iommu_register_list kgsl_iommuv1_reg[KGSL_IOMMU_REG_MAX] = {
@@ -40,6 +42,10 @@
 	{ 0x20, 0, 0 },				
 	{ 0x800, 0, 0 },			
 	{ 0x820, 0, 0 },			
+	{ 0x03C, 0, 0 },			
+	{ 0x818, 0, 0 },			
+	{ 0x2C, 0, 0 },                         
+	{ 0x2C, 0, 0 },                         
 };
 
 static struct kgsl_iommu_register_list kgsl_iommuv2_reg[KGSL_IOMMU_REG_MAX] = {
@@ -48,11 +54,18 @@
 	{ 0x28, 0x00FFFFFF, 14 },		
 	{ 0x58, 0, 0 },				
 	{ 0x618, 0, 0 },			
-	{ 0x008, 0, 0 }				
+	{ 0x008, 0, 0 },			
+	{ 0, 0, 0 },				
+	{ 0, 0, 0 },				
+	{ 0x68, 0, 0 },				
+	{ 0x6C, 0, 0 }				
 };
 
 struct remote_iommu_petersons_spinlock kgsl_iommu_sync_lock_vars;
 
+
+static struct page *kgsl_guard_page;
+
 static int get_iommu_unit(struct device *dev, struct kgsl_mmu **mmu_out,
 			struct kgsl_iommu_unit **iommu_unit_out)
 {
@@ -100,6 +113,145 @@
 	return NULL;
 }
 
+
+
+struct _mem_entry {
+	unsigned int gpuaddr;
+	unsigned int size;
+	unsigned int flags;
+	unsigned int priv;
+	pid_t pid;
+};
+
+
+static void _prev_entry(struct kgsl_process_private *priv,
+	unsigned int faultaddr, struct _mem_entry *ret)
+{
+	struct rb_node *node;
+	struct kgsl_mem_entry *entry;
+
+	for (node = rb_first(&priv->mem_rb); node; ) {
+		entry = rb_entry(node, struct kgsl_mem_entry, node);
+
+		if (entry->memdesc.gpuaddr > faultaddr)
+			break;
+
+
+		if (entry->memdesc.gpuaddr > ret->gpuaddr) {
+			ret->gpuaddr = entry->memdesc.gpuaddr;
+			ret->size = entry->memdesc.size;
+			ret->flags = entry->memdesc.flags;
+			ret->priv = entry->memdesc.priv;
+			ret->pid = priv->pid;
+		}
+
+		node = rb_next(&entry->node);
+	}
+}
+
+
+static void _next_entry(struct kgsl_process_private *priv,
+	unsigned int faultaddr, struct _mem_entry *ret)
+{
+	struct rb_node *node;
+	struct kgsl_mem_entry *entry;
+
+	for (node = rb_last(&priv->mem_rb); node; ) {
+		entry = rb_entry(node, struct kgsl_mem_entry, node);
+
+		if (entry->memdesc.gpuaddr < faultaddr)
+			break;
+
+
+		if (entry->memdesc.gpuaddr < ret->gpuaddr) {
+			ret->gpuaddr = entry->memdesc.gpuaddr;
+			ret->size = entry->memdesc.size;
+			ret->flags = entry->memdesc.flags;
+			ret->priv = entry->memdesc.priv;
+			ret->pid = priv->pid;
+		}
+
+		node = rb_prev(&entry->node);
+	}
+}
+
+static void _find_mem_entries(struct kgsl_mmu *mmu, unsigned int faultaddr,
+	unsigned int ptbase, struct _mem_entry *preventry,
+	struct _mem_entry *nextentry)
+{
+	struct kgsl_process_private *private;
+	int id = kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase);
+
+	memset(preventry, 0, sizeof(*preventry));
+	memset(nextentry, 0, sizeof(*nextentry));
+
+	
+	nextentry->gpuaddr = 0xFFFFFFFF;
+
+	mutex_lock(&kgsl_driver.process_mutex);
+
+	list_for_each_entry(private, &kgsl_driver.process_list, list) {
+
+		if (private->pagetable->name != id)
+			continue;
+
+		spin_lock(&private->mem_lock);
+		_prev_entry(private, faultaddr, preventry);
+		_next_entry(private, faultaddr, nextentry);
+		spin_unlock(&private->mem_lock);
+	}
+
+	mutex_unlock(&kgsl_driver.process_mutex);
+}
+
+static void _print_entry(struct kgsl_device *device, struct _mem_entry *entry)
+{
+	char name[32];
+	memset(name, 0, sizeof(name));
+
+	kgsl_get_memory_usage(name, sizeof(name) - 1, entry->flags);
+
+	KGSL_LOG_DUMP(device,
+		"[%8.8X - %8.8X] %s (pid = %d) (%s)\n",
+		entry->gpuaddr,
+		entry->gpuaddr + entry->size,
+		entry->priv & KGSL_MEMDESC_GUARD_PAGE ? "(+guard)" : "",
+		entry->pid, name);
+}
+
+static void _check_if_freed(struct kgsl_iommu_device *iommu_dev,
+	unsigned long addr, unsigned int pid)
+{
+	void *base = kgsl_driver.memfree_hist.base_hist_rb;
+	struct kgsl_memfree_hist_elem *wptr;
+	struct kgsl_memfree_hist_elem *p;
+
+	mutex_lock(&kgsl_driver.memfree_hist_mutex);
+	wptr = kgsl_driver.memfree_hist.wptr;
+	p = wptr;
+	for (;;) {
+		if (p->size && p->pid == pid)
+			if (addr >= p->gpuaddr &&
+				addr < (p->gpuaddr + p->size)) {
+
+				KGSL_LOG_DUMP(iommu_dev->kgsldev,
+					"---- premature free ----\n");
+				KGSL_LOG_DUMP(iommu_dev->kgsldev,
+					"[%8.8X-%8.8X] was already freed by pid %d\n",
+					p->gpuaddr,
+					p->gpuaddr + p->size,
+					p->pid);
+			}
+		p++;
+		if ((void *)p >= base + kgsl_driver.memfree_hist.size)
+			p = (struct kgsl_memfree_hist_elem *) base;
+
+		if (p == kgsl_driver.memfree_hist.wptr)
+			break;
+	}
+	mutex_unlock(&kgsl_driver.memfree_hist_mutex);
+}
+
 static int kgsl_iommu_fault_handler(struct iommu_domain *domain,
 	struct device *dev, unsigned long addr, int flags)
 {
@@ -112,6 +264,14 @@
 	struct kgsl_device *device;
 	struct adreno_device *adreno_dev;
 	unsigned int no_page_fault_log = 0;
+	unsigned int curr_context_id = 0;
+	unsigned int curr_global_ts = 0;
+	static struct adreno_context *curr_context;
+	static struct kgsl_context *context;
+	unsigned int pid;
+	unsigned int fsynr0, fsynr1;
+	int write;
+	struct _mem_entry prev, next;
 
 	ret = get_iommu_unit(dev, &mmu, &iommu_unit);
 	if (ret)
@@ -131,23 +291,67 @@
 
 	fsr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 		iommu_dev->ctx_id, FSR);
+	fsynr0 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
+		iommu_dev->ctx_id, FSYNR0);
+	fsynr1 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
+		iommu_dev->ctx_id, FSYNR1);
+
+	if (!msm_soc_version_supports_iommu_v1())
+		write = ((fsynr1 & (KGSL_IOMMU_FSYNR1_AWRITE_MASK <<
+			KGSL_IOMMU_FSYNR1_AWRITE_SHIFT)) ? 1 : 0);
+	else
+		write = ((fsynr0 & (KGSL_IOMMU_V1_FSYNR0_WNR_MASK <<
+			KGSL_IOMMU_V1_FSYNR0_WNR_SHIFT)) ? 1 : 0);
 
 	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE)
 		no_page_fault_log = kgsl_mmu_log_fault_addr(mmu, ptbase, addr);
 
+	pid = kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase);
 	if (!no_page_fault_log) {
 		KGSL_MEM_CRIT(iommu_dev->kgsldev,
-			"GPU PAGE FAULT: addr = %lX pid = %d\n",
-			addr, kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase));
-		KGSL_MEM_CRIT(iommu_dev->kgsldev, "context = %d FSR = %X\n",
-			iommu_dev->ctx_id, fsr);
+			"GPU PAGE FAULT: addr = %lX pid = %d\n", addr, pid);
+		KGSL_MEM_CRIT(iommu_dev->kgsldev,
+		"context = %d FSR = %X FSYNR0 = %X FSYNR1 = %X(%s fault)\n",
+			iommu_dev->ctx_id, fsr, fsynr0, fsynr1,
+			write ? "write" : "read");
 	}
 
+	_check_if_freed(iommu_dev, addr, pid);
+
+	KGSL_LOG_DUMP(iommu_dev->kgsldev, "---- nearby memory ----\n");
+
+	_find_mem_entries(mmu, addr, ptbase, &prev, &next);
+
+	if (prev.gpuaddr)
+		_print_entry(iommu_dev->kgsldev, &prev);
+	else
+		KGSL_LOG_DUMP(iommu_dev->kgsldev, "*EMPTY*\n");
+
+	KGSL_LOG_DUMP(iommu_dev->kgsldev, " <- fault @ %8.8lX\n", addr);
+
+	if (next.gpuaddr != 0xFFFFFFFF)
+		_print_entry(iommu_dev->kgsldev, &next);
+	else
+		KGSL_LOG_DUMP(iommu_dev->kgsldev, "*EMPTY*\n");
+
 	mmu->fault = 1;
 	iommu_dev->fault = 1;
 
+	kgsl_sharedmem_readl(&device->memstore, &curr_context_id,
+		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL, current_context));
+	context = idr_find(&device->context_idr, curr_context_id);
+	if (context != NULL)
+			curr_context = context->devctxt;
+
+	kgsl_sharedmem_readl(&device->memstore, &curr_global_ts,
+		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL, eoptimestamp));
+
+	curr_context->pagefault = 1;
+	curr_context->pagefault_ts = curr_global_ts;
+
 	trace_kgsl_mmu_pagefault(iommu_dev->kgsldev, addr,
-			kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase), 0);
+			kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase),
+				write ? "write" : "read");
 
 	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
 		ret = -EBUSY;
@@ -177,7 +381,8 @@
 }
 
 static void kgsl_iommu_clk_disable_event(struct kgsl_device *device, void *data,
-					unsigned int id, unsigned int ts)
+					unsigned int id, unsigned int ts,
+					u32 type)
 {
 	struct kgsl_mmu *mmu = data;
 	struct kgsl_iommu *iommu = mmu->priv;
@@ -257,6 +462,19 @@
 					goto done;
 				}
 			}
+#if 0
+			if (iommu_drvdata->aclk) {
+				ret = clk_prepare_enable(iommu_drvdata->aclk);
+				if (ret) {
+					if (iommu_drvdata->clk)
+						clk_disable_unprepare(
+							iommu_drvdata->clk);
+					clk_disable_unprepare(
+							iommu_drvdata->pclk);
+					goto done;
+				}
+			}
+#endif
 			iommu_unit->dev[j].clk_enabled = true;
 		}
 	}
@@ -430,22 +648,27 @@
 
 static int kgsl_iommu_init_sync_lock(struct kgsl_mmu *mmu)
 {
-	struct kgsl_iommu *iommu = mmu->device->mmu.priv;
+	struct kgsl_iommu *iommu = mmu->priv;
 	int status = 0;
 	struct kgsl_pagetable *pagetable = NULL;
 	uint32_t lock_gpu_addr = 0;
 	uint32_t lock_phy_addr = 0;
 	uint32_t page_offset = 0;
 
-	iommu->sync_lock_initialized = 0;
+	if (!msm_soc_version_supports_iommu_v1() ||
+		!kgsl_mmu_is_perprocess())
+		return status;
 
-	if (!(mmu->flags & KGSL_MMU_FLAGS_IOMMU_SYNC)) {
-		KGSL_DRV_ERR(mmu->device,
-		"The GPU microcode does not support IOMMUv1 sync opcodes\n");
-		return -ENXIO;
+	if (KGSL_DEVICE_2D0 == mmu->device->id ||
+		KGSL_DEVICE_2D1 == mmu->device->id) {
+		return status;
 	}
 
 	
+	if (iommu->sync_lock_initialized)
+		return status;
+
+	
 	lock_phy_addr = (msm_iommu_lock_initialize()
 			- MSM_SHARED_RAM_BASE + msm_shared_ram_phys);
 
@@ -470,13 +693,10 @@
 		return status;
 
 	
-	iommu->sync_lock_desc.priv |= KGSL_MEMDESC_GLOBAL;
-
 	pagetable = mmu->priv_bank_table ? mmu->priv_bank_table :
 				mmu->defaultpagetable;
 
-	status = kgsl_mmu_map(pagetable, &iommu->sync_lock_desc,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	status = kgsl_mmu_map_global(pagetable, &iommu->sync_lock_desc);
 
 	if (status) {
 		kgsl_mmu_unmap(pagetable, &iommu->sync_lock_desc);
@@ -704,6 +924,42 @@
 	}
 }
 
+static int kgsl_iommu_setup_regs(struct kgsl_mmu *mmu,
+				    struct kgsl_pagetable *pt)
+{
+	int status;
+	int i = 0;
+	struct kgsl_iommu *iommu = mmu->priv;
+
+	if (!msm_soc_version_supports_iommu_v1())
+		return 0;
+
+	for (i = 0; i < iommu->unit_count; i++) {
+		status = kgsl_mmu_map_global(pt,
+				&(iommu->iommu_units[i].reg_map));
+		if (status)
+			goto err;
+	}
+
+	return 0;
+err:
+	for (i--; i >= 0; i--)
+		kgsl_mmu_unmap(pt,
+				&(iommu->iommu_units[i].reg_map));
+
+	return status;
+}
+
+static void kgsl_iommu_cleanup_regs(struct kgsl_mmu *mmu,
+					struct kgsl_pagetable *pt)
+{
+	struct kgsl_iommu *iommu = mmu->priv;
+	int i;
+	for (i = 0; i < iommu->unit_count; i++)
+		kgsl_mmu_unmap(pt, &(iommu->iommu_units[i].reg_map));
+}
+
+
 static int kgsl_iommu_init(struct kgsl_mmu *mmu)
 {
 	int status = 0;
@@ -739,6 +995,20 @@
 				KGSL_IOMMU_SETSTATE_NOP_OFFSET,
 				cp_nop_packet(1));
 
+	if (cpu_is_msm8960()) {
+		iommu_ops.mmu_setup_pt = kgsl_iommu_setup_regs;
+		iommu_ops.mmu_cleanup_pt = kgsl_iommu_cleanup_regs;
+	}
+
+	if (kgsl_guard_page == NULL) {
+		kgsl_guard_page = alloc_page(GFP_KERNEL | __GFP_ZERO |
+				__GFP_HIGHMEM);
+		if (kgsl_guard_page == NULL) {
+			status = -ENOMEM;
+			goto done;
+		}
+	}
+
 	dev_info(mmu->device->dev, "|%s| MMU type set for device is IOMMU\n",
 			__func__);
 done:
@@ -752,9 +1022,6 @@
 static int kgsl_iommu_setup_defaultpagetable(struct kgsl_mmu *mmu)
 {
 	int status = 0;
-	int i = 0;
-	struct kgsl_iommu *iommu = mmu->priv;
-	struct kgsl_pagetable *pagetable = NULL;
 
 	if (!cpu_is_msm8960() && msm_soc_version_supports_iommu_v1()) {
 		mmu->priv_bank_table =
@@ -763,6 +1030,9 @@
 			status = -ENOMEM;
 			goto err;
 		}
+		status = kgsl_iommu_setup_regs(mmu, mmu->priv_bank_table);
+		if (status)
+			goto err;
 	}
 	mmu->defaultpagetable = kgsl_mmu_getpagetable(KGSL_MMU_GLOBAL_PT);
 	
@@ -770,31 +1040,10 @@
 		status = -ENOMEM;
 		goto err;
 	}
-	pagetable = mmu->priv_bank_table ? mmu->priv_bank_table :
-				mmu->defaultpagetable;
-	
-	if (msm_soc_version_supports_iommu_v1()) {
-		for (i = 0; i < iommu->unit_count; i++) {
-			iommu->iommu_units[i].reg_map.priv |=
-						KGSL_MEMDESC_GLOBAL;
-			status = kgsl_mmu_map(pagetable,
-				&(iommu->iommu_units[i].reg_map),
-				GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
-			if (status) {
-				iommu->iommu_units[i].reg_map.priv &=
-							~KGSL_MEMDESC_GLOBAL;
-				goto err;
-			}
-		}
-	}
 	return status;
 err:
-	for (i--; i >= 0; i--) {
-		kgsl_mmu_unmap(pagetable,
-				&(iommu->iommu_units[i].reg_map));
-		iommu->iommu_units[i].reg_map.priv &= ~KGSL_MEMDESC_GLOBAL;
-	}
 	if (mmu->priv_bank_table) {
+		kgsl_iommu_cleanup_regs(mmu, mmu->priv_bank_table);
 		kgsl_mmu_putpagetable(mmu->priv_bank_table);
 		mmu->priv_bank_table = NULL;
 	}
@@ -805,6 +1054,103 @@
 	return status;
 }
 
+static void kgsl_iommu_lock_rb_in_tlb(struct kgsl_mmu *mmu)
+{
+	struct kgsl_device *device = mmu->device;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	struct adreno_ringbuffer *rb;
+	struct kgsl_iommu *iommu = mmu->priv;
+	unsigned int num_tlb_entries;
+	unsigned int tlblkcr = 0;
+	unsigned int v2pxx = 0;
+	unsigned int vaddr = 0;
+	int i, j, k, l;
+
+	if (!iommu->sync_lock_initialized)
+		return;
+
+	rb = &adreno_dev->ringbuffer;
+	num_tlb_entries = rb->buffer_desc.size / PAGE_SIZE;
+
+	for (i = 0; i < iommu->unit_count; i++) {
+		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			tlblkcr = 0;
+			if (cpu_is_msm8960())
+				tlblkcr |= ((num_tlb_entries &
+					KGSL_IOMMU_TLBLKCR_FLOOR_MASK) <<
+					KGSL_IOMMU_TLBLKCR_FLOOR_SHIFT);
+			else
+				tlblkcr |= (((num_tlb_entries *
+					iommu_unit->dev_count) &
+					KGSL_IOMMU_TLBLKCR_FLOOR_MASK) <<
+					KGSL_IOMMU_TLBLKCR_FLOOR_SHIFT);
+			
+			tlblkcr	|= ((1 & KGSL_IOMMU_TLBLKCR_TLBIALLCFG_MASK)
+				<< KGSL_IOMMU_TLBLKCR_TLBIALLCFG_SHIFT);
+			tlblkcr	|= ((1 & KGSL_IOMMU_TLBLKCR_TLBIASIDCFG_MASK)
+				<< KGSL_IOMMU_TLBLKCR_TLBIASIDCFG_SHIFT);
+			tlblkcr	|= ((1 & KGSL_IOMMU_TLBLKCR_TLBIVAACFG_MASK)
+				<< KGSL_IOMMU_TLBLKCR_TLBIVAACFG_SHIFT);
+			
+			tlblkcr |= ((1 & KGSL_IOMMU_TLBLKCR_LKE_MASK)
+				<< KGSL_IOMMU_TLBLKCR_LKE_SHIFT);
+			KGSL_IOMMU_SET_CTX_REG(iommu, iommu_unit,
+					iommu_unit->dev[j].ctx_id,
+					TLBLKCR, tlblkcr);
+		}
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			
+			if (cpu_is_msm8960() &&  KGSL_IOMMU_CONTEXT_PRIV == j)
+				continue;
+			
+			vaddr = rb->buffer_desc.gpuaddr;
+			for (k = 0; k < num_tlb_entries; k++) {
+				v2pxx = 0;
+				v2pxx |= (((k + j * num_tlb_entries) &
+					KGSL_IOMMU_V2PXX_INDEX_MASK)
+					<< KGSL_IOMMU_V2PXX_INDEX_SHIFT);
+				v2pxx |= vaddr & (KGSL_IOMMU_V2PXX_VA_MASK <<
+						KGSL_IOMMU_V2PXX_VA_SHIFT);
+
+				KGSL_IOMMU_SET_CTX_REG(iommu, iommu_unit,
+						iommu_unit->dev[j].ctx_id,
+						V2PUR, v2pxx);
+				vaddr += PAGE_SIZE;
+				for (l = 0; l < iommu_unit->dev_count; l++) {
+					tlblkcr = KGSL_IOMMU_GET_CTX_REG(iommu,
+						iommu_unit,
+						iommu_unit->dev[l].ctx_id,
+						TLBLKCR);
+					mb();
+					tlblkcr &=
+					~(KGSL_IOMMU_TLBLKCR_VICTIM_MASK
+					<< KGSL_IOMMU_TLBLKCR_VICTIM_SHIFT);
+					tlblkcr |= (((k + 1 +
+					(j * num_tlb_entries)) &
+					KGSL_IOMMU_TLBLKCR_VICTIM_MASK) <<
+					KGSL_IOMMU_TLBLKCR_VICTIM_SHIFT);
+					KGSL_IOMMU_SET_CTX_REG(iommu,
+						iommu_unit,
+						iommu_unit->dev[l].ctx_id,
+						TLBLKCR, tlblkcr);
+				}
+			}
+		}
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			tlblkcr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
+						iommu_unit->dev[j].ctx_id,
+						TLBLKCR);
+			mb();
+			
+			tlblkcr &= ~(KGSL_IOMMU_TLBLKCR_LKE_MASK
+				<< KGSL_IOMMU_TLBLKCR_LKE_SHIFT);
+			KGSL_IOMMU_SET_CTX_REG(iommu, iommu_unit,
+				iommu_unit->dev[j].ctx_id, TLBLKCR, tlblkcr);
+		}
+	}
+}
+
 static int kgsl_iommu_start(struct kgsl_mmu *mmu)
 {
 	struct kgsl_device *device = mmu->device;
@@ -826,14 +1172,14 @@
 				kgsl_iommu_init_sync_lock(mmu);
 	}
 
-	if (cpu_is_msm8960()) {
+	if (cpu_is_msm8960() && KGSL_DEVICE_3D0 == mmu->device->id) {
 		struct kgsl_mh *mh = &(mmu->device->mh);
+		BUG_ON(iommu->iommu_units[0].reg_map.gpuaddr != 0 &&
+			mh->mpu_base > iommu->iommu_units[0].reg_map.gpuaddr);
 		kgsl_regwrite(mmu->device, MH_MMU_CONFIG, 0x00000001);
+
 		kgsl_regwrite(mmu->device, MH_MMU_MPU_END,
-			mh->mpu_base +
-			iommu->iommu_units[0].reg_map.gpuaddr);
-	} else {
-		kgsl_regwrite(mmu->device, MH_MMU_CONFIG, 0x00000000);
+			mh->mpu_base + mh->mpu_range);
 	}
 
 	mmu->hwpagetable = mmu->defaultpagetable;
@@ -853,6 +1199,7 @@
 		KGSL_CORE_ERR("clk enable failed\n");
 		goto done;
 	}
+	msm_iommu_lock();
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
 		for (j = 0; j < iommu_unit->dev_count; j++) {
@@ -863,6 +1210,13 @@
 						TTBR0));
 		}
 	}
+	kgsl_iommu_lock_rb_in_tlb(mmu);
+	msm_iommu_unlock();
+
+	
+	kgsl_cffdump_setmem(mmu->setstate_memory.gpuaddr +
+				KGSL_IOMMU_SETSTATE_NOP_OFFSET,
+				cp_nop_packet(1), sizeof(unsigned int));
 
 	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
 	mmu->flags |= KGSL_FLAGS_STARTED;
@@ -881,7 +1235,7 @@
 		unsigned int *tlb_flags)
 {
 	int ret;
-	unsigned int range = kgsl_sg_size(memdesc->sg, memdesc->sglen);
+	unsigned int range = memdesc->size;
 	struct kgsl_iommu_pt *iommu_pt = mmu_specific_pt;
 
 
@@ -890,16 +1244,17 @@
 	if (range == 0 || gpuaddr == 0)
 		return 0;
 
+	if (kgsl_memdesc_has_guard_page(memdesc))
+		range += PAGE_SIZE;
+
 	ret = iommu_unmap_range(iommu_pt->domain, gpuaddr, range);
 	if (ret)
 		KGSL_CORE_ERR("iommu_unmap_range(%p, %x, %d) failed "
 			"with err: %d\n", iommu_pt->domain, gpuaddr,
 			range, ret);
 
-#ifdef CONFIG_KGSL_PER_PROCESS_PAGE_TABLE
-	if (!ret && msm_soc_version_supports_iommu_v1())
+	if (!ret && kgsl_mmu_is_perprocess())
 		*tlb_flags = UINT_MAX;
-#endif
 	return 0;
 }
 
@@ -912,23 +1267,35 @@
 	int ret;
 	unsigned int iommu_virt_addr;
 	struct kgsl_iommu_pt *iommu_pt = mmu_specific_pt;
-	int size = kgsl_sg_size(memdesc->sg, memdesc->sglen);
+	int size = memdesc->size;
 
 	BUG_ON(NULL == iommu_pt);
 
-
 	iommu_virt_addr = memdesc->gpuaddr;
 
 	ret = iommu_map_range(iommu_pt->domain, iommu_virt_addr, memdesc->sg,
-				size, (IOMMU_READ | IOMMU_WRITE));
+				size, protflags);
 	if (ret) {
-		KGSL_CORE_ERR("iommu_map_range(%p, %x, %p, %d, %d) "
-				"failed with err: %d\n", iommu_pt->domain,
-				iommu_virt_addr, memdesc->sg, size,
-				(IOMMU_READ | IOMMU_WRITE), ret);
+		KGSL_CORE_ERR("iommu_map_range(%p, %x, %p, %d, %x) err: %d\n",
+			iommu_pt->domain, iommu_virt_addr, memdesc->sg, size,
+			protflags, ret);
 		return ret;
 	}
-
+	if (kgsl_memdesc_has_guard_page(memdesc)) {
+		ret = iommu_map(iommu_pt->domain, iommu_virt_addr + size,
+				page_to_phys(kgsl_guard_page), PAGE_SIZE,
+				protflags & ~IOMMU_WRITE);
+		if (ret) {
+			KGSL_CORE_ERR("iommu_map(%p, %x, %x, %x) err: %d\n",
+				iommu_pt->domain, iommu_virt_addr + size,
+				page_to_phys(kgsl_guard_page),
+				protflags & ~IOMMU_WRITE,
+				ret);
+			
+			iommu_unmap_range(iommu_pt->domain, iommu_virt_addr,
+					  size);
+		}
+	}
 	return ret;
 }
 
@@ -936,7 +1303,6 @@
 {
 	struct kgsl_iommu *iommu = mmu->priv;
 	int i, j;
-
 	if (mmu->flags & KGSL_FLAGS_STARTED) {
 		
 		kgsl_detach_pagetable_iommu_domain(mmu);
@@ -951,10 +1317,12 @@
 				for (j = 0; j < iommu_unit->dev_count; j++) {
 					if (iommu_unit->dev[j].fault) {
 						kgsl_iommu_enable_clk(mmu, j);
+						msm_iommu_lock();
 						KGSL_IOMMU_SET_CTX_REG(iommu,
 						iommu_unit,
 						iommu_unit->dev[j].ctx_id,
 						RESUME, 1);
+						msm_iommu_unlock();
 						iommu_unit->dev[j].fault = 0;
 					}
 				}
@@ -972,24 +1340,30 @@
 {
 	struct kgsl_iommu *iommu = mmu->priv;
 	int i;
-	for (i = 0; i < iommu->unit_count; i++) {
-		struct kgsl_pagetable *pagetable = (mmu->priv_bank_table ?
-			mmu->priv_bank_table : mmu->defaultpagetable);
-		if (iommu->iommu_units[i].reg_map.gpuaddr)
-			kgsl_mmu_unmap(pagetable,
-			&(iommu->iommu_units[i].reg_map));
-		if (iommu->iommu_units[i].reg_map.hostptr)
-			iounmap(iommu->iommu_units[i].reg_map.hostptr);
-		kgsl_sg_free(iommu->iommu_units[i].reg_map.sg,
-				iommu->iommu_units[i].reg_map.sglen);
-	}
 
-	if (mmu->priv_bank_table)
+	if (mmu->priv_bank_table != NULL) {
+		kgsl_iommu_cleanup_regs(mmu, mmu->priv_bank_table);
 		kgsl_mmu_putpagetable(mmu->priv_bank_table);
-	if (mmu->defaultpagetable)
+	}
+
+	if (mmu->defaultpagetable != NULL)
 		kgsl_mmu_putpagetable(mmu->defaultpagetable);
+
+	for (i = 0; i < iommu->unit_count; i++) {
+		struct kgsl_memdesc *reg_map = &iommu->iommu_units[i].reg_map;
+
+		if (reg_map->hostptr)
+			iounmap(reg_map->hostptr);
+		kgsl_sg_free(reg_map->sg, reg_map->sglen);
+	}
+
 	kfree(iommu);
 
+	if (kgsl_guard_page != NULL) {
+		__free_page(kgsl_guard_page);
+		kgsl_guard_page = NULL;
+	}
+
 	return 0;
 }
 
@@ -1030,6 +1404,9 @@
 			iommu->iommu_reg_list[KGSL_IOMMU_CTX_TTBR0].reg_shift);
 
 	
+	if (msm_soc_version_supports_iommu_v1())
+		kgsl_idle(mmu->device);
+
 	
 	msm_iommu_lock();
 
@@ -1103,6 +1480,9 @@
 	.mmu_get_pt_base_addr = kgsl_iommu_get_pt_base_addr,
 	.mmu_sync_lock = kgsl_iommu_sync_lock,
 	.mmu_sync_unlock = kgsl_iommu_sync_unlock,
+	
+	.mmu_setup_pt = NULL,
+	.mmu_cleanup_pt = NULL,
 };
 
 struct kgsl_mmu_pt_ops iommu_pt_ops = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_iommu.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_iommu.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_iommu.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_iommu.h	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -19,6 +19,29 @@
 #define KGSL_IOMMU_CTX_OFFSET_V2	0x8000
 #define KGSL_IOMMU_CTX_SHIFT		12
 
+#define KGSL_IOMMU_TLBLKCR_LKE_MASK		0x00000001
+#define KGSL_IOMMU_TLBLKCR_LKE_SHIFT		0
+#define KGSL_IOMMU_TLBLKCR_TLBIALLCFG_MASK	0x00000001
+#define KGSL_IOMMU_TLBLKCR_TLBIALLCFG_SHIFT	1
+#define KGSL_IOMMU_TLBLKCR_TLBIASIDCFG_MASK	0x00000001
+#define KGSL_IOMMU_TLBLKCR_TLBIASIDCFG_SHIFT	2
+#define KGSL_IOMMU_TLBLKCR_TLBIVAACFG_MASK	0x00000001
+#define KGSL_IOMMU_TLBLKCR_TLBIVAACFG_SHIFT	3
+#define KGSL_IOMMU_TLBLKCR_FLOOR_MASK		0x000000FF
+#define KGSL_IOMMU_TLBLKCR_FLOOR_SHIFT		8
+#define KGSL_IOMMU_TLBLKCR_VICTIM_MASK		0x000000FF
+#define KGSL_IOMMU_TLBLKCR_VICTIM_SHIFT		16
+
+#define KGSL_IOMMU_V2PXX_INDEX_MASK		0x000000FF
+#define KGSL_IOMMU_V2PXX_INDEX_SHIFT		0
+#define KGSL_IOMMU_V2PXX_VA_MASK		0x000FFFFF
+#define KGSL_IOMMU_V2PXX_VA_SHIFT		12
+
+#define KGSL_IOMMU_FSYNR1_AWRITE_MASK		0x00000001
+#define KGSL_IOMMU_FSYNR1_AWRITE_SHIFT		8
+#define KGSL_IOMMU_V1_FSYNR0_WNR_MASK		0x00000001
+#define KGSL_IOMMU_V1_FSYNR0_WNR_SHIFT		4
+
 enum kgsl_iommu_reg_map {
 	KGSL_IOMMU_GLOBAL_BASE = 0,
 	KGSL_IOMMU_CTX_TTBR0,
@@ -26,6 +49,10 @@
 	KGSL_IOMMU_CTX_FSR,
 	KGSL_IOMMU_CTX_TLBIALL,
 	KGSL_IOMMU_CTX_RESUME,
+	KGSL_IOMMU_CTX_TLBLKCR,
+	KGSL_IOMMU_CTX_V2PUR,
+	KGSL_IOMMU_CTX_FSYNR0,
+	KGSL_IOMMU_CTX_FSYNR1,
 	KGSL_IOMMU_REG_MAX
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_mmu.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_mmu.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_mmu.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_mmu.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/iommu.h>
+#include <mach/iommu.h>
 #include <mach/socinfo.h>
 
 #include "kgsl.h"
@@ -26,9 +27,6 @@
 #include "kgsl_sharedmem.h"
 #include "adreno.h"
 
-#define KGSL_MMU_ALIGN_SHIFT    13
-#define KGSL_MMU_ALIGN_MASK     (~((1 << KGSL_MMU_ALIGN_SHIFT) - 1))
-
 static enum kgsl_mmutype kgsl_mmu_type;
 
 static void pagetable_remove_sysfs_objects(struct kgsl_pagetable *pagetable);
@@ -36,17 +34,18 @@
 static int kgsl_cleanup_pt(struct kgsl_pagetable *pt)
 {
 	int i;
-	
-	if ((KGSL_MMU_TYPE_NONE != kgsl_mmu_type) &&
-		(KGSL_MMU_TYPE_IOMMU == kgsl_mmu_type) &&
-		(KGSL_MMU_GLOBAL_PT !=  pt->name) &&
-		(KGSL_MMU_PRIV_BANK_TABLE_NAME !=  pt->name))
-		return 0;
+	struct kgsl_device *device;
+
 	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
-		struct kgsl_device *device = kgsl_driver.devp[i];
+		device = kgsl_driver.devp[i];
 		if (device)
 			device->ftbl->cleanup_pt(device, pt);
 	}
+	
+	device = kgsl_driver.devp[KGSL_DEVICE_3D0];
+	if (device->mmu.mmu_ops->mmu_cleanup_pt != NULL)
+		device->mmu.mmu_ops->mmu_cleanup_pt(&device->mmu, pt);
+
 	return 0;
 }
 
@@ -55,21 +54,23 @@
 {
 	int i = 0;
 	int status = 0;
+	struct kgsl_device *device;
 
-	
-	if ((KGSL_MMU_TYPE_NONE != kgsl_mmu_type) &&
-		(KGSL_MMU_TYPE_IOMMU == kgsl_mmu_type) &&
-		(KGSL_MMU_GLOBAL_PT !=  pt->name) &&
-		(KGSL_MMU_PRIV_BANK_TABLE_NAME !=  pt->name))
-		return 0;
 	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
-		struct kgsl_device *device = kgsl_driver.devp[i];
+		device = kgsl_driver.devp[i];
 		if (device) {
 			status = device->ftbl->setup_pt(device, pt);
 			if (status)
 				goto error_pt;
 		}
 	}
+	
+	device = kgsl_driver.devp[KGSL_DEVICE_3D0];
+	if (device->mmu.mmu_ops->mmu_setup_pt != NULL) {
+		status = device->mmu.mmu_ops->mmu_setup_pt(&device->mmu, pt);
+		if (status)
+			goto error_pt;
+	}
 	return status;
 error_pt:
 	while (i >= 0) {
@@ -309,17 +310,6 @@
 	return ret;
 }
 
-unsigned int kgsl_mmu_get_ptsize(void)
-{
-
-	if (KGSL_MMU_TYPE_GPU == kgsl_mmu_type)
-		return CONFIG_MSM_KGSL_PAGE_TABLE_SIZE;
-	else if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_type)
-		return CONFIG_MSM_KGSL_PAGE_TABLE_SIZE_FOR_IOMMU;
-	else
-		return 0;
-}
-
 int
 kgsl_mmu_get_ptname_from_ptbase(struct kgsl_mmu *mmu, unsigned int pt_base)
 {
@@ -353,11 +343,11 @@
 	spin_lock(&kgsl_driver.ptlock);
 	list_for_each_entry(pt, &kgsl_driver.pagetable_list, list) {
 		if (mmu->mmu_ops->mmu_pt_equal(mmu, pt, pt_base)) {
-			if ((addr & (~(PAGE_SIZE-1))) == pt->fault_addr) {
+			if ((addr & ~(PAGE_SIZE-1)) == pt->fault_addr) {
 				ret = 1;
 				break;
 			} else {
-				pt->fault_addr = (addr & (~(PAGE_SIZE-1)));
+				pt->fault_addr = (addr & ~(PAGE_SIZE-1));
 				ret = 0;
 				break;
 			}
@@ -476,10 +466,10 @@
 	if ((KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype()) &&
 		((KGSL_MMU_GLOBAL_PT == name) ||
 		(KGSL_MMU_PRIV_BANK_TABLE_NAME == name))) {
-		pagetable->kgsl_pool = gen_pool_create(PAGE_SHIFT, -1);
+		pagetable->kgsl_pool = gen_pool_create(ilog2(SZ_8K), -1);
 		if (pagetable->kgsl_pool == NULL) {
 			KGSL_CORE_ERR("gen_pool_create(%d) failed\n",
-					KGSL_MMU_ALIGN_SHIFT);
+					ilog2(SZ_8K));
 			goto err_alloc;
 		}
 		if (gen_pool_add(pagetable->kgsl_pool,
@@ -490,14 +480,14 @@
 		}
 	}
 
-	pagetable->pool = gen_pool_create(KGSL_MMU_ALIGN_SHIFT, -1);
+	pagetable->pool = gen_pool_create(PAGE_SHIFT, -1);
 	if (pagetable->pool == NULL) {
 		KGSL_CORE_ERR("gen_pool_create(%d) failed\n",
-			      KGSL_MMU_ALIGN_SHIFT);
+			      PAGE_SHIFT);
 		goto err_kgsl_pool;
 	}
 
-	if (gen_pool_add(pagetable->pool, KGSL_PAGETABLE_BASE,
+	if (gen_pool_add(pagetable->pool, kgsl_mmu_get_base_addr(),
 				ptsize, -1)) {
 		KGSL_CORE_ERR("gen_pool_add failed\n");
 		goto err_pool;
@@ -545,11 +535,7 @@
 	if (KGSL_MMU_TYPE_NONE == kgsl_mmu_type)
 		return (void *)(-1);
 
-#ifndef CONFIG_KGSL_PER_PROCESS_PAGE_TABLE
-	name = KGSL_MMU_GLOBAL_PT;
-#endif
-	
-	if (!msm_soc_version_supports_iommu_v1())
+	if (!kgsl_mmu_is_perprocess())
 		name = KGSL_MMU_GLOBAL_PT;
 
 	pt = kgsl_get_pagetable(name);
@@ -607,25 +593,17 @@
 				mh->mh_intf_cfg2);
 
 }
-
-static inline struct gen_pool *
-_get_pool(struct kgsl_pagetable *pagetable, unsigned int flags)
-{
-	if (pagetable->kgsl_pool &&
-		(KGSL_MEMDESC_GLOBAL & flags))
-		return pagetable->kgsl_pool;
-	return pagetable->pool;
-}
+EXPORT_SYMBOL(kgsl_mh_start);
 
 int
-kgsl_mmu_map(struct kgsl_pagetable *pagetable,
-				struct kgsl_memdesc *memdesc,
-				unsigned int protflags)
+kgsl_mmu_get_gpuaddr(struct kgsl_pagetable *pagetable,
+			struct kgsl_memdesc *memdesc)
 {
-	int ret;
-	struct gen_pool *pool;
+	struct gen_pool *pool = NULL;
 	int size;
 	int page_align = ilog2(PAGE_SIZE);
+	struct task_struct *task;
+	char task_comm[TASK_COMM_LEN+1] = "\0";
 
 	if (kgsl_mmu_type == KGSL_MMU_TYPE_NONE) {
 		if (memdesc->sglen == 1) {
@@ -645,26 +623,74 @@
 		}
 	}
 
-	size = kgsl_sg_size(memdesc->sg, memdesc->sglen);
-
 	
-	pool = _get_pool(pagetable, memdesc->priv);
+	size = memdesc->size;
+	if (kgsl_memdesc_has_guard_page(memdesc))
+		size += PAGE_SIZE;
+
+	pool = pagetable->pool;
+
+	if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype()) {
+		if (kgsl_memdesc_get_align(memdesc) > 0)
+			page_align = kgsl_memdesc_get_align(memdesc);
+		if (kgsl_memdesc_is_global(memdesc)) {
+			pool = pagetable->kgsl_pool;
+			if (pool == NULL && memdesc->gpuaddr == 0) {
+				KGSL_CORE_ERR(
+				  "No address for global mapping into pt %d\n",
+				  pagetable->name);
+				return -EINVAL;
+			}
+		} else if (kgsl_memdesc_use_cpu_map(memdesc)) {
+			if (memdesc->gpuaddr == 0)
+				return -EINVAL;
+			pool = NULL;
+		}
+	}
+	if (pool) {
+		memdesc->gpuaddr = gen_pool_alloc_aligned(pool, size,
+							  page_align);
+		if (memdesc->gpuaddr == 0) {
+			if (pagetable->name != KGSL_MMU_GLOBAL_PT && pagetable->name != KGSL_MMU_PRIV_BANK_TABLE_NAME) {
+				task = find_task_by_pid_ns(pagetable->name, &init_pid_ns);
+				task = task->group_leader;
+				get_task_comm(task_comm, task);
+			}
 
-	if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype() &&
-	    kgsl_memdesc_get_align(memdesc) > 0)
-		page_align = kgsl_memdesc_get_align(memdesc);
-
-	memdesc->gpuaddr = gen_pool_alloc_aligned(pool, size, page_align);
-	if (memdesc->gpuaddr == 0) {
-		KGSL_CORE_ERR("gen_pool_alloc(%d) failed from pool: %s\n",
-			size,
-			(pool == pagetable->kgsl_pool) ?
-			"kgsl_pool" : "general_pool");
-		KGSL_CORE_ERR(" [%d] allocated=%d, entries=%d\n",
-				pagetable->name, pagetable->stats.mapped,
-				pagetable->stats.entries);
-		return -ENOMEM;
+			KGSL_CORE_ERR("gen_pool_alloc(%d) failed, pool: %s\n",
+					size,
+					(pool == pagetable->kgsl_pool) ?
+					"kgsl_pool" : "general_pool");
+			KGSL_CORE_ERR(" [%d] (%s) allocated=%d, entries=%d\n",
+					pagetable->name,
+					task_comm,
+					pagetable->stats.mapped,
+					pagetable->stats.entries);
+			return -ENOMEM;
+		}
 	}
+	return 0;
+}
+EXPORT_SYMBOL(kgsl_mmu_get_gpuaddr);
+
+int
+kgsl_mmu_map(struct kgsl_pagetable *pagetable,
+				struct kgsl_memdesc *memdesc)
+{
+	int ret = 0;
+	int size;
+	unsigned int protflags = kgsl_memdesc_protflags(memdesc);
+
+	if (!memdesc->gpuaddr)
+		return -EINVAL;
+	
+	if (!kgsl_memdesc_is_global(memdesc) &&
+		(KGSL_MEMDESC_MAPPED & memdesc->priv))
+		return -EINVAL;
+	
+	size = memdesc->size;
+	if (kgsl_memdesc_has_guard_page(memdesc))
+		size += PAGE_SIZE;
 
 	if (KGSL_MMU_TYPE_IOMMU != kgsl_mmu_get_mmutype())
 		spin_lock(&pagetable->lock);
@@ -674,7 +700,7 @@
 		spin_lock(&pagetable->lock);
 
 	if (ret)
-		goto err_free_gpuaddr;
+		goto done;
 
 	
 
@@ -685,35 +711,70 @@
 		       pagetable->stats.max_mapped);
 
 	spin_unlock(&pagetable->lock);
+	memdesc->priv |= KGSL_MEMDESC_MAPPED;
 
 	return 0;
 
-err_free_gpuaddr:
+done:
 	spin_unlock(&pagetable->lock);
-	gen_pool_free(pool, memdesc->gpuaddr, size);
-	memdesc->gpuaddr = 0;
 	return ret;
 }
 EXPORT_SYMBOL(kgsl_mmu_map);
 
 int
-kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
-		struct kgsl_memdesc *memdesc)
+kgsl_mmu_put_gpuaddr(struct kgsl_pagetable *pagetable,
+			struct kgsl_memdesc *memdesc)
 {
 	struct gen_pool *pool;
 	int size;
-	unsigned int start_addr = 0;
-	unsigned int end_addr = 0;
 
 	if (memdesc->size == 0 || memdesc->gpuaddr == 0)
 		return 0;
 
-	if (kgsl_mmu_type == KGSL_MMU_TYPE_NONE) {
+	if (kgsl_mmu_type == KGSL_MMU_TYPE_NONE)
+		goto done;
+
+	
+	size = memdesc->size;
+	if (kgsl_memdesc_has_guard_page(memdesc))
+		size += PAGE_SIZE;
+
+	pool = pagetable->pool;
+
+	if (KGSL_MMU_TYPE_IOMMU == kgsl_mmu_get_mmutype()) {
+		if (kgsl_memdesc_is_global(memdesc))
+			pool = pagetable->kgsl_pool;
+		else if (kgsl_memdesc_use_cpu_map(memdesc))
+			pool = NULL;
+	}
+	if (pool)
+		gen_pool_free(pool, memdesc->gpuaddr, size);
+done:
+	if (!kgsl_memdesc_is_global(memdesc))
 		memdesc->gpuaddr = 0;
+	return 0;
+}
+EXPORT_SYMBOL(kgsl_mmu_put_gpuaddr);
+
+int
+kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
+		struct kgsl_memdesc *memdesc)
+{
+	int size;
+	unsigned int start_addr = 0;
+	unsigned int end_addr = 0;
+
+	if (memdesc->size == 0 || memdesc->gpuaddr == 0 ||
+		!(KGSL_MEMDESC_MAPPED & memdesc->priv))
+		return -EINVAL;
+
+	if (kgsl_mmu_type == KGSL_MMU_TYPE_NONE)
 		return 0;
-	}
 
-	size = kgsl_sg_size(memdesc->sg, memdesc->sglen);
+	
+	size = memdesc->size;
+	if (kgsl_memdesc_has_guard_page(memdesc))
+		size += PAGE_SIZE;
 
 	start_addr = memdesc->gpuaddr;
 	end_addr = (memdesc->gpuaddr + size);
@@ -735,18 +796,14 @@
 	pagetable->stats.mapped -= size;
 
 	spin_unlock(&pagetable->lock);
-
-	pool = _get_pool(pagetable, memdesc->priv);
-	gen_pool_free(pool, memdesc->gpuaddr, size);
-
-	if (!(memdesc->priv & KGSL_MEMDESC_GLOBAL))
-		memdesc->gpuaddr = 0;
+	if (!kgsl_memdesc_is_global(memdesc))
+		memdesc->priv &= ~KGSL_MEMDESC_MAPPED;
 	return 0;
 }
 EXPORT_SYMBOL(kgsl_mmu_unmap);
 
 int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
-			struct kgsl_memdesc *memdesc, unsigned int protflags)
+			struct kgsl_memdesc *memdesc)
 {
 	int result = -EINVAL;
 	unsigned int gpuaddr = 0;
@@ -758,13 +815,15 @@
 	
 	if (!memdesc->size)
 		return 0;
-
 	gpuaddr = memdesc->gpuaddr;
 	memdesc->priv |= KGSL_MEMDESC_GLOBAL;
 
-	result = kgsl_mmu_map(pagetable, memdesc, protflags);
+	result = kgsl_mmu_get_gpuaddr(pagetable, memdesc);
 	if (result)
 		goto error;
+	result = kgsl_mmu_map(pagetable, memdesc);
+	if (result)
+		goto error_put_gpuaddr;
 
 	
 	if (gpuaddr && gpuaddr != memdesc->gpuaddr) {
@@ -776,6 +835,8 @@
 	return result;
 error_unmap:
 	kgsl_mmu_unmap(pagetable, memdesc);
+error_put_gpuaddr:
+	kgsl_mmu_put_gpuaddr(pagetable, memdesc);
 error:
 	return result;
 }
@@ -849,11 +910,9 @@
 	kgsl_mmu_type =
 		cpu_is_apq8064() ? KGSL_MMU_TYPE_NONE : KGSL_MMU_TYPE_GPU;
 
-#ifndef CONFIG_MSM_KGSL_DEFAULT_GPUMMU
 	
 	if (iommu_present(&platform_bus_type))
 		kgsl_mmu_type = KGSL_MMU_TYPE_IOMMU;
-#endif
 
 	if (mmutype && !strncmp(mmutype, "gpummu", 6))
 		kgsl_mmu_type = KGSL_MMU_TYPE_GPU;
@@ -869,8 +928,13 @@
 {
 	if (KGSL_MMU_TYPE_NONE == kgsl_mmu_type)
 		return 1;
-	return ((gpuaddr >= KGSL_PAGETABLE_BASE) &&
-		(gpuaddr < (KGSL_PAGETABLE_BASE + kgsl_mmu_get_ptsize())));
+	if (gpuaddr >= kgsl_mmu_get_base_addr() &&
+		gpuaddr < kgsl_mmu_get_base_addr() + kgsl_mmu_get_ptsize())
+		return 1;
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU
+		&& kgsl_mmu_is_perprocess())
+		return (gpuaddr > 0 && gpuaddr < TASK_SIZE);
+	return 0;
 }
 EXPORT_SYMBOL(kgsl_mmu_gpuaddr_in_range);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_mmu.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_mmu.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_mmu.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_mmu.h	2013-08-01 23:38:02.000000000 -0600
@@ -13,12 +13,12 @@
 #ifndef __KGSL_MMU_H
 #define __KGSL_MMU_H
 
-#define KGSL_IOMMU_GLOBAL_MEM_BASE	0xC0000000
+#include <mach/iommu.h>
+
+#define KGSL_IOMMU_GLOBAL_MEM_BASE	0xf8000000
 #define KGSL_IOMMU_GLOBAL_MEM_SIZE	SZ_4M
-#define KGSL_IOMMU_TTBR1_SPLIT		2
 
-#define KGSL_MMU_ALIGN_SHIFT    13
-#define KGSL_MMU_ALIGN_MASK     (~((1 << KGSL_MMU_ALIGN_SHIFT) - 1))
+#define KGSL_MMU_ALIGN_MASK     (~((1 << PAGE_SHIFT) - 1))
 
 
 #define KGSL_MMU_GLOBAL_PT 0
@@ -142,6 +142,10 @@
 	unsigned int (*mmu_sync_unlock)
 			(struct kgsl_mmu *mmu,
 			unsigned int *cmds);
+	int (*mmu_setup_pt) (struct kgsl_mmu *mmu,
+			struct kgsl_pagetable *pt);
+	void (*mmu_cleanup_pt) (struct kgsl_mmu *mmu,
+			struct kgsl_pagetable *pt);
 };
 
 struct kgsl_mmu_pt_ops {
@@ -187,12 +191,15 @@
 int kgsl_mmu_start(struct kgsl_device *device);
 int kgsl_mmu_close(struct kgsl_device *device);
 int kgsl_mmu_map(struct kgsl_pagetable *pagetable,
-		 struct kgsl_memdesc *memdesc,
-		 unsigned int protflags);
+		 struct kgsl_memdesc *memdesc);
+int kgsl_mmu_get_gpuaddr(struct kgsl_pagetable *pagetable,
+		 struct kgsl_memdesc *memdesc);
 int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
-			struct kgsl_memdesc *memdesc, unsigned int protflags);
+			struct kgsl_memdesc *memdesc);
 int kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
 		    struct kgsl_memdesc *memdesc);
+int kgsl_mmu_put_gpuaddr(struct kgsl_pagetable *pagetable,
+		 struct kgsl_memdesc *memdesc);
 unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr);
 void kgsl_setstate(struct kgsl_mmu *mmu, unsigned int context_id,
 			uint32_t flags);
@@ -207,7 +214,6 @@
 int kgsl_mmu_enabled(void);
 void kgsl_mmu_set_mmutype(char *mmutype);
 enum kgsl_mmutype kgsl_mmu_get_mmutype(void);
-unsigned int kgsl_mmu_get_ptsize(void);
 int kgsl_mmu_gpuaddr_in_range(unsigned int gpuaddr);
 
 
@@ -334,4 +340,43 @@
 		return 0;
 }
 
+#ifdef CONFIG_KGSL_PER_PROCESS_PAGE_TABLE
+static inline int kgsl_mmu_is_perprocess(void)
+{
+
+	
+	return (kgsl_mmu_get_mmutype() != KGSL_MMU_TYPE_IOMMU)
+		|| msm_soc_version_supports_iommu_v1();
+}
+#else
+static inline int kgsl_mmu_is_perprocess(void)
+{
+	return 0;
+}
+#endif
+
+static inline unsigned int kgsl_mmu_get_base_addr(void)
+{
+	if (KGSL_MMU_TYPE_GPU == kgsl_mmu_get_mmutype()
+		|| !kgsl_mmu_is_perprocess())
+		return KGSL_PAGETABLE_BASE;
+	return PAGE_OFFSET;
+}
+
+static inline unsigned int kgsl_mmu_get_ptsize(void)
+{
+	enum kgsl_mmutype mmu_type = kgsl_mmu_get_mmutype();
+
+	if (KGSL_MMU_TYPE_GPU == mmu_type)
+		return CONFIG_MSM_KGSL_PAGE_TABLE_SIZE;
+	else if (KGSL_MMU_TYPE_IOMMU == mmu_type) {
+		if (kgsl_mmu_is_perprocess())
+			return KGSL_IOMMU_GLOBAL_MEM_BASE
+				- kgsl_mmu_get_base_addr() - SZ_1M;
+		else
+			return SZ_2G;
+	}
+	return 0;
+}
+
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrctrl.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrctrl.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrctrl.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrctrl.c	2013-08-01 23:38:02.000000000 -0600
@@ -23,6 +23,7 @@
 #include "kgsl_pwrscale.h"
 #include "kgsl_device.h"
 #include "kgsl_trace.h"
+#include "kgsl_sharedmem.h"
 
 #define KGSL_PWRFLAGS_POWER_ON 0
 #define KGSL_PWRFLAGS_CLK_ON   1
@@ -89,7 +90,7 @@
 	gpufreq_stat.last_time = cur_time;
 
 	spin_unlock(&gpufreq_stats_lock);
-return 0;
+	return 0;
 }
 
 static void update_clk_statistics(struct kgsl_device *device,
@@ -550,12 +551,7 @@
 {
 	int ret;
 	struct kgsl_device *device = kgsl_device_from_dev(dev);
-	struct kgsl_clk_stats *clkstats;
-
-	if(device == NULL)
-		return 0;
-	clkstats = &device->pwrctrl.clk_stats;
-
+	struct kgsl_clk_stats *clkstats = &device->pwrctrl.clk_stats;
 	ret = snprintf(buf, PAGE_SIZE, "%7d %7d\n",
 			clkstats->on_time_old, clkstats->elapsed_old);
 	if (!test_bit(KGSL_PWRFLAGS_AXI_ON, &device->pwrctrl.power_flags)) {
@@ -566,8 +562,8 @@
 }
 
 static int kgsl_pwrctrl_gpubusy_time_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+				struct device_attribute *attr,
+				char *buf)
 {
 	int ret;
 	struct kgsl_device *device = kgsl_device_from_dev(dev);
@@ -586,45 +582,38 @@
 }
 
 static int kgsl_pwrctrl_gpubusy_time_in_state_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+				struct device_attribute *attr,
+				char *buf)
 {
 	int i;
 	char* tmp = buf;
 	struct kgsl_device *device = kgsl_device_from_dev(dev);
-	struct platform_device *pdev;
-	struct kgsl_device_platform_data *pdata;
+	struct platform_device *pdev = container_of(device->parentdev, struct platform_device, dev);
+	struct kgsl_device_platform_data *pdata = pdev->dev.platform_data;
 	s64 system_time, busy_time;
 
-	if(device == NULL)
-		return 0;
-	pdev = container_of(device->parentdev, struct platform_device, dev);
-	pdata = pdev->dev.platform_data;
-
 	for(i=0;i<pdata->num_levels;i++) {
 		system_time = device->gputime_in_state[i].total;
 		do_div(system_time, 1000);
 		busy_time = device->gputime_in_state[i].busy;
 		do_div(busy_time, 1000);
-		tmp = (char*)( (int)tmp + snprintf(tmp, PAGE_SIZE - (int)(tmp-buf), "%d %lld %lld\n", pdata->pwrlevel[i].gpu_freq, system_time, busy_time));
+		tmp = (char*)( (int)tmp + snprintf(tmp, PAGE_SIZE - (int)(tmp-buf), "%d %lld %lld\n",
+					pdata->pwrlevel[i].gpu_freq, system_time, busy_time));
 	}
 	return (ssize_t)(tmp - buf);
 }
 
+
 static int kgsl_pwrctrl_gputop_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
 	int ret;
 	struct kgsl_device *device = kgsl_device_from_dev(dev);
-	struct kgsl_clk_stats *clkstats;
+	struct kgsl_clk_stats *clkstats = &device->pwrctrl.clk_stats;
 	int i = 0;
 	char *ptr = buf;
 
-	if(device == NULL)
-		return 0;
-	clkstats = &device->pwrctrl.clk_stats;
-
 	ret = snprintf(buf, PAGE_SIZE, "%7d %7d ", clkstats->on_time_old,
 					clkstats->elapsed_old);
 	for (i = 0, ptr += ret; i < device->pwrctrl.num_pwrlevels;
@@ -660,6 +649,14 @@
 	return num_chars;
 }
 
+static int kgsl_pwrctrl_reset_count_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct kgsl_device *device = kgsl_device_from_dev(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", device->reset_counter);
+}
+
 static int kgsl_pwrctrl_gputime_in_state_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -674,10 +671,12 @@
 	if (test_bit(KGSL_PWRFLAGS_CLK_ON, &device->pwrctrl.power_flags) || (device->state == KGSL_STATE_NAP))
 		gpufreq_stats_update(0, device->pwrctrl.active_pwrlevel, device->pwrctrl.active_pwrlevel);
 
+	spin_lock(&gpufreq_stats_lock);
 	for (i = 0; i < device->pwrctrl.num_pwrlevels; i++) {
 		len += sprintf(buf + len, "%u %llu\n", device->pwrctrl.pwrlevels[i].gpu_freq,
 			(unsigned long long)jiffies_to_clock_t(gputime_in_state[i]));
 	}
+	spin_unlock(&gpufreq_stats_lock);
 
 	return len;
 }
@@ -707,6 +706,9 @@
 DEVICE_ATTR(num_pwrlevels, 0444,
 	kgsl_pwrctrl_num_pwrlevels_show,
 	NULL);
+DEVICE_ATTR(reset_count, 0444,
+	kgsl_pwrctrl_reset_count_show,
+	NULL);
 DEVICE_ATTR(gpubusy_time, 0644, kgsl_pwrctrl_gpubusy_time_show, NULL);
 DEVICE_ATTR(gpubusy_time_in_state, 0644, kgsl_pwrctrl_gpubusy_time_in_state_show, NULL);
 DEVICE_ATTR(gputime_in_state, 0444, kgsl_pwrctrl_gputime_in_state_show, NULL);
@@ -723,7 +725,7 @@
 	&dev_attr_min_pwrlevel,
 	&dev_attr_thermal_pwrlevel,
 	&dev_attr_num_pwrlevels,
-
+	&dev_attr_reset_count,
 	
 	&dev_attr_gpubusy_time,
 	&dev_attr_gpubusy_time_in_state,
@@ -747,12 +749,6 @@
 	unsigned int on_time = 0;
 	int i;
 	int num_pwrlevels = device->pwrctrl.num_pwrlevels - 1;
-
-	if(num_pwrlevels < 0){
-		KGSL_PWR_ERR(device,"device->pwrctrl.num_pwrlevels: %d < 0 index error",num_pwrlevels);
-		return;
-	}
-
 	
 	for (i = 0; i < num_pwrlevels; i++) {
 		clkstats->old_clock_time[i] = clkstats->clock_time[i];
@@ -788,11 +784,8 @@
 			&pwr->power_flags)) {
 			trace_kgsl_clk(device, state);
 			for (i = KGSL_MAX_CLKS - 1; i > 0; i--)
-				if (pwr->grp_clks[i]) {
+				if (pwr->grp_clks[i])
 					clk_disable(pwr->grp_clks[i]);
-					if (i == 0)
-						gpufreq_stats_update(0, pwr->active_pwrlevel, (pwr->num_pwrlevels - 1));
-				}
 			
 			if ((pwr->pwrlevels[0].gpu_freq > 0) &&
 				(requested_state != KGSL_STATE_NAP)) {
@@ -800,8 +793,11 @@
 					pwr->pwrlevels[pwr->num_pwrlevels - 1].
 					gpu_freq);
 				for (i = KGSL_MAX_CLKS - 1; i > 0; i--)
-					if (pwr->grp_clks[i])
+					if (pwr->grp_clks[i]) {
 						clk_unprepare(pwr->grp_clks[i]);
+						if (i == 0)
+							gpufreq_stats_update(0, pwr->active_pwrlevel, (pwr->num_pwrlevels - 1));
+					}
 			}
 			kgsl_pwrctrl_busy_time(device, true);
 		} else if (requested_state == KGSL_STATE_SLEEP) {
@@ -964,7 +960,8 @@
 	if (pdata->set_grp_async != NULL)
 		pdata->set_grp_async();
 
-	if (pdata->num_levels > KGSL_MAX_PWRLEVELS) {
+	if (pdata->num_levels > KGSL_MAX_PWRLEVELS ||
+	    pdata->num_levels < 1) {
 		KGSL_PWR_ERR(device, "invalid power level count: %d\n",
 					 pdata->num_levels);
 		result = -EINVAL;
@@ -1093,10 +1090,15 @@
 		return;
 
 	mutex_lock(&device->mutex);
-	if (device->state & (KGSL_STATE_ACTIVE | KGSL_STATE_NAP)) {
-		kgsl_pwrscale_idle(device);
 
-		if (kgsl_pwrctrl_sleep(device) != 0) {
+	kgsl_pwrscale_idle(device);
+
+	if (device->state == KGSL_STATE_ACTIVE
+		   || device->state ==  KGSL_STATE_NAP) {
+		if (device->active_cnt > 0 || kgsl_pwrctrl_sleep(device) != 0) {
+
+			kgsl_pwrctrl_request_state(device, KGSL_STATE_NONE);
+
 			mod_timer(&device->idle_timer,
 					jiffies +
 					device->pwrctrl.interval_timeout);
@@ -1114,6 +1116,7 @@
 
 	mutex_unlock(&device->mutex);
 }
+EXPORT_SYMBOL(kgsl_idle_check);
 
 void kgsl_timer(unsigned long data)
 {
@@ -1131,54 +1134,26 @@
 	}
 }
 
+
+/**
+ * kgsl_pre_hwaccess - Enforce preconditions for touching registers
+ * @device: The device
+ *
+ * This function ensures that the correct lock is held and that the GPU
+ * clock is on immediately before a register is read or written. Note
+ * that this function does not check active_cnt because the registers
+ * must be accessed during device start and stop, when the active_cnt
+ * may legitimately be 0.
+ */
 void kgsl_pre_hwaccess(struct kgsl_device *device)
 {
+	
 	BUG_ON(!mutex_is_locked(&device->mutex));
-	switch (device->state) {
-	case KGSL_STATE_ACTIVE:
-		return;
-	case KGSL_STATE_NAP:
-	case KGSL_STATE_SLEEP:
-	case KGSL_STATE_SLUMBER:
-		kgsl_pwrctrl_wake(device);
-		break;
-	case KGSL_STATE_SUSPEND:
-		kgsl_check_suspended(device);
-		break;
-	case KGSL_STATE_INIT:
-	case KGSL_STATE_HUNG:
-	case KGSL_STATE_DUMP_AND_FT:
-		if (test_bit(KGSL_PWRFLAGS_CLK_ON,
-					 &device->pwrctrl.power_flags))
-			break;
-		else
-			KGSL_PWR_ERR(device,
-					"hw access while clocks off from state %d\n",
-					device->state);
-		break;
-	default:
-		KGSL_PWR_ERR(device, "hw access while in unknown state %d\n",
-					 device->state);
-		break;
-	}
+	
+	BUG_ON(!test_bit(KGSL_PWRFLAGS_CLK_ON, &device->pwrctrl.power_flags));
 }
 EXPORT_SYMBOL(kgsl_pre_hwaccess);
 
-void kgsl_check_suspended(struct kgsl_device *device)
-{
-	if (device->requested_state == KGSL_STATE_SUSPEND ||
-				device->state == KGSL_STATE_SUSPEND) {
-		mutex_unlock(&device->mutex);
-		wait_for_completion(&device->hwaccess_gate);
-		mutex_lock(&device->mutex);
-	} else if (device->state == KGSL_STATE_DUMP_AND_FT) {
-		mutex_unlock(&device->mutex);
-		wait_for_completion(&device->ft_gate);
-		mutex_lock(&device->mutex);
-	} else if (device->state == KGSL_STATE_SLUMBER)
-		kgsl_pwrctrl_wake(device);
-}
-
 static int
 _nap(struct kgsl_device *device)
 {
@@ -1257,6 +1232,8 @@
 	case KGSL_STATE_NAP:
 	case KGSL_STATE_SLEEP:
 		del_timer_sync(&device->idle_timer);
+		
+		kgsl_pwrctrl_enable(device);
 		device->ftbl->suspend_context(device);
 		device->ftbl->stop(device);
 		_sleep_accounting(device);
@@ -1286,6 +1263,7 @@
 		break;
 	case KGSL_STATE_SLEEP:
 		status = _sleep(device);
+		kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
 		break;
 	case KGSL_STATE_SLUMBER:
 		status = _slumber(device);
@@ -1301,13 +1279,18 @@
 }
 EXPORT_SYMBOL(kgsl_pwrctrl_sleep);
 
-void kgsl_pwrctrl_wake(struct kgsl_device *device)
+int kgsl_pwrctrl_wake(struct kgsl_device *device)
 {
-	int status;
+	int status = 0;
+	unsigned int context_id;
+	unsigned int state = device->state;
+	unsigned int ts_processed = 0xdeaddead;
+	struct kgsl_context *context;
+
 	kgsl_pwrctrl_request_state(device, KGSL_STATE_ACTIVE);
 	switch (device->state) {
 	case KGSL_STATE_SLUMBER:
-		status = device->ftbl->start(device, 0);
+		status = device->ftbl->start(device);
 		if (status) {
 			kgsl_pwrctrl_request_state(device, KGSL_STATE_NONE);
 			KGSL_DRV_ERR(device, "start failed %d\n", status);
@@ -1317,6 +1300,18 @@
 	case KGSL_STATE_SLEEP:
 		kgsl_pwrctrl_axi(device, KGSL_PWRFLAGS_ON);
 		kgsl_pwrscale_wake(device);
+		kgsl_sharedmem_readl(&device->memstore,
+			(unsigned int *) &context_id,
+			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
+				current_context));
+		context = kgsl_context_get(device, context_id);
+		if (context)
+			ts_processed = kgsl_readtimestamp(device, context,
+				KGSL_TIMESTAMP_RETIRED);
+		KGSL_PWR_INFO(device, "Wake from %s state. CTXT: %d RTRD TS: %08X\n",
+			kgsl_pwrstate_to_str(state),
+			context ? context->id : -1, ts_processed);
+		kgsl_context_put(context);
 		
 	case KGSL_STATE_NAP:
 		
@@ -1336,8 +1331,10 @@
 		KGSL_PWR_WARN(device, "unhandled state %s\n",
 				kgsl_pwrstate_to_str(device->state));
 		kgsl_pwrctrl_request_state(device, KGSL_STATE_NONE);
+		status = -EINVAL;
 		break;
 	}
+	return status;
 }
 EXPORT_SYMBOL(kgsl_pwrctrl_wake);
 
@@ -1403,3 +1400,88 @@
 }
 EXPORT_SYMBOL(kgsl_pwrstate_to_str);
 
+
+int kgsl_active_count_get(struct kgsl_device *device)
+{
+	int ret = 0;
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+	if (device->active_cnt == 0) {
+		if (device->requested_state == KGSL_STATE_SUSPEND ||
+				device->state == KGSL_STATE_SUSPEND) {
+			mutex_unlock(&device->mutex);
+			wait_for_completion(&device->hwaccess_gate);
+			mutex_lock(&device->mutex);
+		} else if (device->state == KGSL_STATE_DUMP_AND_FT) {
+			mutex_unlock(&device->mutex);
+			wait_for_completion(&device->ft_gate);
+			mutex_lock(&device->mutex);
+		}
+		ret = kgsl_pwrctrl_wake(device);
+	}
+	if (ret == 0)
+		device->active_cnt++;
+	return ret;
+}
+EXPORT_SYMBOL(kgsl_active_count_get);
+
+int kgsl_active_count_get_light(struct kgsl_device *device)
+{
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+	if (device->state != KGSL_STATE_ACTIVE) {
+		dev_WARN_ONCE(device->dev, 1, "device in unexpected state %s\n",
+				kgsl_pwrstate_to_str(device->state));
+		return -EINVAL;
+	}
+
+	if (device->active_cnt == 0) {
+		dev_WARN_ONCE(device->dev, 1, "active count is 0!\n");
+		return -EINVAL;
+	}
+
+	device->active_cnt++;
+	return 0;
+}
+EXPORT_SYMBOL(kgsl_active_count_get_light);
+
+void kgsl_active_count_put(struct kgsl_device *device)
+{
+	BUG_ON(!mutex_is_locked(&device->mutex));
+	BUG_ON(device->active_cnt == 0);
+
+	kgsl_pwrscale_idle(device);
+	if (device->active_cnt > 1) {
+		device->active_cnt--;
+		return;
+	}
+
+	INIT_COMPLETION(device->suspend_gate);
+
+	if (device->pwrctrl.nap_allowed == true &&
+			(device->state == KGSL_STATE_ACTIVE &&
+			device->requested_state == KGSL_STATE_NONE)) {
+		kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
+		if (kgsl_pwrctrl_sleep(device) != 0)
+			mod_timer(&device->idle_timer,
+					jiffies
+					+ device->pwrctrl.interval_timeout);
+	}
+	device->active_cnt--;
+
+	if (device->active_cnt == 0)
+		complete(&device->suspend_gate);
+}
+EXPORT_SYMBOL(kgsl_active_count_put);
+
+void kgsl_active_count_wait(struct kgsl_device *device)
+{
+	BUG_ON(!mutex_is_locked(&device->mutex));
+
+	if (device->active_cnt != 0) {
+		mutex_unlock(&device->mutex);
+		wait_for_completion(&device->suspend_gate);
+		mutex_lock(&device->mutex);
+	}
+}
+EXPORT_SYMBOL(kgsl_active_count_wait);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrctrl.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrctrl.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrctrl.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrctrl.h	2013-08-01 23:38:02.000000000 -0600
@@ -67,9 +67,8 @@
 void kgsl_timer(unsigned long data);
 void kgsl_idle_check(struct work_struct *work);
 void kgsl_pre_hwaccess(struct kgsl_device *device);
-void kgsl_check_suspended(struct kgsl_device *device);
 int kgsl_pwrctrl_sleep(struct kgsl_device *device);
-void kgsl_pwrctrl_wake(struct kgsl_device *device);
+int kgsl_pwrctrl_wake(struct kgsl_device *device);
 void kgsl_pwrctrl_pwrlevel_change(struct kgsl_device *device,
 	unsigned int level);
 int kgsl_pwrctrl_init_sysfs(struct kgsl_device *device);
@@ -83,4 +82,10 @@
 
 void kgsl_pwrctrl_set_state(struct kgsl_device *device, unsigned int state);
 void kgsl_pwrctrl_request_state(struct kgsl_device *device, unsigned int state);
+
+int kgsl_active_count_get(struct kgsl_device *device);
+int kgsl_active_count_get_light(struct kgsl_device *device);
+void kgsl_active_count_put(struct kgsl_device *device);
+void kgsl_active_count_wait(struct kgsl_device *device);
+
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -234,16 +234,15 @@
 void kgsl_pwrscale_busy(struct kgsl_device *device)
 {
 	if (PWRSCALE_ACTIVE(device) && device->pwrscale.policy->busy)
-		if (device->requested_state != KGSL_STATE_SLUMBER)
-			device->pwrscale.policy->busy(device,
-					&device->pwrscale);
+		device->pwrscale.policy->busy(device,
+				&device->pwrscale);
 }
+EXPORT_SYMBOL(kgsl_pwrscale_busy);
 
 void kgsl_pwrscale_idle(struct kgsl_device *device)
 {
 	if (PWRSCALE_ACTIVE(device) && device->pwrscale.policy->idle)
-		if (device->requested_state != KGSL_STATE_SLUMBER &&
-			device->requested_state != KGSL_STATE_SLEEP)
+		if (device->state == KGSL_STATE_ACTIVE)
 			device->pwrscale.policy->idle(device,
 					&device->pwrscale);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale.h	2013-08-01 23:38:02.000000000 -0600
@@ -36,7 +36,6 @@
 	struct kgsl_pwrscale_policy *policy;
 	struct kobject kobj;
 	void *priv;
-	int gpu_busy;
 	int enabled;
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale_msm.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale_msm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale_msm.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale_msm.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -17,22 +17,26 @@
 #include "kgsl_pwrscale.h"
 #include "kgsl_device.h"
 #include "a2xx_reg.h"
+#include "kgsl_trace.h"
 
 struct msm_priv {
-	struct kgsl_device *device;
-	int enabled;
-	int handle;
-	unsigned int cur_freq;
-	struct msm_dcvs_idle idle_source;
-	struct msm_dcvs_freq freq_sink;
-	struct msm_dcvs_core_info *core_info;
+	struct kgsl_device		*device;
+	int				enabled;
+	unsigned int			cur_freq;
+	unsigned int			req_level;
+	int				floor_level;
+	struct msm_dcvs_core_info	*core_info;
+	int				gpu_busy;
+	int				dcvs_core_id;
 };
 
-static int msm_idle_enable(struct msm_dcvs_idle *self,
-					enum msm_core_control_event event)
+static struct msm_priv *the_msm_priv;
+
+#if 0
+static int msm_idle_enable(int type_core_num,
+		enum msm_core_control_event event)
 {
-	struct msm_priv *priv = container_of(self, struct msm_priv,
-								idle_source);
+	struct msm_priv *priv = the_msm_priv;
 
 	switch (event) {
 	case MSM_DCVS_ENABLE_IDLE_PULSE:
@@ -48,12 +52,10 @@
 	return 0;
 }
 
-static int msm_set_freq(struct msm_dcvs_freq *self,
-						unsigned int freq)
+static int msm_set_freq(int core_num, unsigned int freq)
 {
 	int i, delta = 5000000;
-	struct msm_priv *priv = container_of(self, struct msm_priv,
-								freq_sink);
+	struct msm_priv *priv = the_msm_priv;
 	struct kgsl_device *device = priv->device;
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
 
@@ -66,49 +68,116 @@
 		return 0;
 
 	mutex_lock(&device->mutex);
-	kgsl_pwrctrl_pwrlevel_change(device, i);
-	priv->cur_freq = pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq;
+	priv->req_level = i;
+	if (priv->req_level <= priv->floor_level) {
+		kgsl_pwrctrl_pwrlevel_change(device, priv->req_level);
+		priv->cur_freq = pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq;
+	}
 	mutex_unlock(&device->mutex);
 
 	
 	return priv->cur_freq / 1000;
 }
 
-static unsigned int msm_get_freq(struct msm_dcvs_freq *self)
+static int msm_set_min_freq(int core_num, unsigned int freq)
 {
-	struct msm_priv *priv = container_of(self, struct msm_priv,
-								freq_sink);
+	int i, delta = 5000000;
+	struct msm_priv *priv = the_msm_priv;
+	struct kgsl_device *device = priv->device;
+	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
+
+	
+	freq *= 1000;
+	for (i = 0; i < pwr->num_pwrlevels; i++)
+		if (abs(pwr->pwrlevels[i].gpu_freq - freq) < delta)
+			break;
+	if (i == pwr->num_pwrlevels)
+		return 0;
+
+	mutex_lock(&device->mutex);
+	priv->floor_level = i;
+	if (priv->floor_level <= priv->req_level)
+		kgsl_pwrctrl_pwrlevel_change(device, priv->floor_level);
+	else if (priv->floor_level > priv->req_level)
+		kgsl_pwrctrl_pwrlevel_change(device, priv->req_level);
+
+	priv->cur_freq = pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq;
+	mutex_unlock(&device->mutex);
+
 	
 	return priv->cur_freq / 1000;
 }
 
+static unsigned int msm_get_freq(int core_num)
+{
+	struct msm_priv *priv = the_msm_priv;
+
+	
+	return priv->cur_freq / 1000;
+}
+#endif
 static void msm_busy(struct kgsl_device *device,
 			struct kgsl_pwrscale *pwrscale)
 {
 	struct msm_priv *priv = pwrscale->priv;
-	if (priv->enabled)
-		msm_dcvs_idle(priv->handle, MSM_DCVS_IDLE_EXIT, 0);
+	if (priv->enabled && !priv->gpu_busy) {
+		msm_dcvs_idle(priv->dcvs_core_id, MSM_DCVS_IDLE_EXIT, 0);
+		trace_kgsl_mpdcvs(device, 1);
+		priv->gpu_busy = 1;
+	}
 	return;
 }
 
 static void msm_idle(struct kgsl_device *device,
-			struct kgsl_pwrscale *pwrscale)
+		struct kgsl_pwrscale *pwrscale)
 {
 	struct msm_priv *priv = pwrscale->priv;
-	unsigned int rb_rptr, rb_wptr;
-	kgsl_regread(device, REG_CP_RB_RPTR, &rb_rptr);
-	kgsl_regread(device, REG_CP_RB_WPTR, &rb_wptr);
-
-	if (priv->enabled && (rb_rptr == rb_wptr))
-		msm_dcvs_idle(priv->handle, MSM_DCVS_IDLE_ENTER, 0);
 
+	if (priv->enabled && priv->gpu_busy)
+		if (device->ftbl->isidle(device)) {
+			msm_dcvs_idle(priv->dcvs_core_id,
+					MSM_DCVS_IDLE_ENTER, 0);
+			trace_kgsl_mpdcvs(device, 0);
+			priv->gpu_busy = 0;
+		}
 	return;
 }
 
 static void msm_sleep(struct kgsl_device *device,
 			struct kgsl_pwrscale *pwrscale)
 {
-	
+	struct msm_priv *priv = pwrscale->priv;
+
+	if (priv->enabled && priv->gpu_busy) {
+		msm_dcvs_idle(priv->dcvs_core_id, MSM_DCVS_IDLE_ENTER, 0);
+		trace_kgsl_mpdcvs(device, 0);
+		priv->gpu_busy = 0;
+	}
+
+	return;
+}
+
+static void msm_set_io_fraction(struct kgsl_device *device,
+				unsigned int value)
+{
+	int i;
+	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
+
+	for (i = 0; i < pwr->num_pwrlevels; i++)
+		pwr->pwrlevels[i].io_fraction = value;
+
+}
+
+static void msm_restore_io_fraction(struct kgsl_device *device)
+{
+	int i;
+	struct kgsl_device_platform_data *pdata =
+				kgsl_device_get_drvdata(device);
+	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
+
+	for (i = 0; i < pdata->num_levels; i++)
+		pwr->pwrlevels[i].io_fraction =
+			pdata->pwrlevel[i].io_fraction;
 }
 
 static int msm_init(struct kgsl_device *device,
@@ -116,59 +185,52 @@
 {
 	struct msm_priv *priv;
 	struct msm_dcvs_freq_entry *tbl;
-	int i, ret, low_level;
+	int i, ret = -EINVAL, low_level;
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
 	struct platform_device *pdev =
 		container_of(device->parentdev, struct platform_device, dev);
 	struct kgsl_device_platform_data *pdata = pdev->dev.platform_data;
 
-	priv = pwrscale->priv = kzalloc(sizeof(struct msm_priv),
-		GFP_KERNEL);
-	if (pwrscale->priv == NULL)
-		return -ENOMEM;
-
-	priv->core_info = pdata->core_info;
-	tbl = priv->core_info->freq_tbl;
-	
-	low_level = pwr->num_pwrlevels - KGSL_PWRLEVEL_LAST_OFFSET;
-	for (i = 0; i <= low_level; i++)
-		tbl[i].freq =
-			pwr->pwrlevels[low_level - i].gpu_freq / 1000;
-	ret = msm_dcvs_register_core(device->name, 0, priv->core_info);
-	if (ret) {
-		KGSL_PWR_ERR(device, "msm_dcvs_register_core failed");
-		goto err;
+	if (the_msm_priv) {
+		priv = pwrscale->priv = the_msm_priv;
+	} else {
+		priv = pwrscale->priv = kzalloc(sizeof(struct msm_priv),
+			GFP_KERNEL);
+		if (pwrscale->priv == NULL)
+			return -ENOMEM;
+
+		priv->core_info = pdata->core_info;
+		tbl = priv->core_info->freq_tbl;
+		priv->floor_level = pwr->num_pwrlevels - 1;
+		
+		low_level = pwr->num_pwrlevels - KGSL_PWRLEVEL_LAST_OFFSET;
+		for (i = 0; i <= low_level; i++)
+			tbl[i].freq =
+				pwr->pwrlevels[low_level - i].gpu_freq / 1000;
+		if (priv->dcvs_core_id < 0) {
+			KGSL_PWR_ERR(device, "msm_dcvs_register_core failed");
+			goto err;
+		}
+		the_msm_priv = priv;
 	}
-
 	priv->device = device;
-	priv->idle_source.enable = msm_idle_enable;
-	priv->idle_source.core_name = device->name;
-	priv->handle = msm_dcvs_idle_source_register(&priv->idle_source);
-	if (priv->handle < 0) {
-		ret = priv->handle;
-		KGSL_PWR_ERR(device, "msm_dcvs_idle_source_register failed\n");
-		goto err;
-	}
-
-	priv->freq_sink.core_name = device->name;
-	priv->freq_sink.set_frequency = msm_set_freq;
-	priv->freq_sink.get_frequency = msm_get_freq;
-	ret = msm_dcvs_freq_sink_register(&priv->freq_sink);
 	if (ret >= 0) {
 		if (device->ftbl->isidle(device)) {
-			device->pwrscale.gpu_busy = 0;
-			msm_dcvs_idle(priv->handle, MSM_DCVS_IDLE_ENTER, 0);
+			priv->gpu_busy = 0;
+			msm_dcvs_idle(priv->dcvs_core_id,
+					MSM_DCVS_IDLE_ENTER, 0);
 		} else {
-			device->pwrscale.gpu_busy = 1;
+			priv->gpu_busy = 1;
 		}
+		msm_set_io_fraction(device, 0);
 		return 0;
 	}
 
 	KGSL_PWR_ERR(device, "msm_dcvs_freq_sink_register failed\n");
-	msm_dcvs_idle_source_unregister(&priv->idle_source);
 
 err:
-	kfree(pwrscale->priv);
+	if (!the_msm_priv)
+		kfree(pwrscale->priv);
 	pwrscale->priv = NULL;
 
 	return ret;
@@ -177,14 +239,12 @@
 static void msm_close(struct kgsl_device *device,
 		      struct kgsl_pwrscale *pwrscale)
 {
-	struct msm_priv *priv = pwrscale->priv;
 
 	if (pwrscale->priv == NULL)
 		return;
-	msm_dcvs_idle_source_unregister(&priv->idle_source);
-	msm_dcvs_freq_sink_unregister(&priv->freq_sink);
-	kfree(pwrscale->priv);
+	
 	pwrscale->priv = NULL;
+	msm_restore_io_fraction(device);
 }
 
 struct kgsl_pwrscale_policy kgsl_pwrscale_policy_msm = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale_trustzone.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2013-08-01 23:38:02.000000000 -0600
@@ -35,12 +35,13 @@
 spinlock_t tz_lock;
 
 #define FLOOR			5000
+#define CEILING			50000
 #define SWITCH_OFF		200
 #define SWITCH_OFF_RESET_TH	40
 #define SKIP_COUNTER		500
 #define TZ_RESET_ID		0x3
 #define TZ_UPDATE_ID		0x4
-#define TZ_CMD_ID		0x90
+#define TZ_CMD_ID              0x90
 
 #define PARAM_INDEX_WRITE_DOWNTHRESHOLD 100
 #define PARAM_INDEX_WRITE_UPTHRESHOLD 101
@@ -235,8 +236,8 @@
 }
 
 static ssize_t dcvs_init_idle_vector_show(struct kgsl_device *device,
-			struct kgsl_pwrscale *pwrscale,
-			char *buf)
+				struct kgsl_pwrscale *pwrscale,
+				char *buf)
 {
 	int val, ret;
 
@@ -247,8 +248,8 @@
 }
 
 static ssize_t dcvs_init_idle_vector_store(struct kgsl_device *device,
-			struct kgsl_pwrscale *pwrscale,
-			const char *buf, size_t count)
+				struct kgsl_pwrscale *pwrscale,
+				const char *buf, size_t count)
 {
 	int val, ret;
 
@@ -387,8 +388,8 @@
 }
 
 static ssize_t dcvs_downthreshold_count_store(struct kgsl_device *device,
-struct kgsl_pwrscale *pwrscale,
-const char *buf, size_t count)
+				struct kgsl_pwrscale *pwrscale,
+				const char *buf, size_t count)
 {
 	int val, ret;
 
@@ -413,7 +414,7 @@
 PWRSCALE_POLICY_ATTR(dcvs_upthreshold_percent, 0644, dcvs_upthreshold_percent_show, dcvs_upthreshold_percent_store);
 PWRSCALE_POLICY_ATTR(dcvs_downthreshold_percent, 0644, dcvs_downthreshold_percent_show, dcvs_downthreshold_percent_store);
 PWRSCALE_POLICY_ATTR(dcvs_upthreshold_count, 0644, dcvs_upthreshold_count_show, dcvs_upthreshold_count_store);
-PWRSCALE_POLICY_ATTR(dcvs_downthreshold_count, 0644, dcvs_downthreshold_count_show, dcvs_downthreshold_count_store);
+PWRSCALE_POLICY_ATTR(dcvs_downthreshold_count, 0644, dcvs_downthreshold_count_show, dcvs_downthreshold_count_store); 
 
 static struct attribute *tz_attrs[] = {
 	&policy_attr_governor.attr,
@@ -474,17 +475,19 @@
 		priv->no_switch_cnt = 0;
 	}
 
-	idle = priv->bin.total_time - priv->bin.busy_time;
+	if (priv->bin.busy_time > CEILING) {
+		val = -1;
+	} else {
+		idle = priv->bin.total_time - priv->bin.busy_time;
+		idle = (idle > 0) ? idle : 0;
+		
+		total_time = stats.total_time & 0x0FFFFFFF;
+		total_time |= (pwr->active_pwrlevel) << 28;
+
+		val = __secure_tz_entry(TZ_UPDATE_ID, idle, total_time);
+	}
 	priv->bin.total_time = 0;
 	priv->bin.busy_time = 0;
-	idle = (idle > 0) ? idle : 0;
-
-	
-	total_time = stats.total_time & 0x0FFFFFFF;
-	total_time |= (pwr->active_pwrlevel) << 28;
-
-	val = __secure_tz_entry(TZ_UPDATE_ID, idle, total_time);
-
 	if (val)
 		kgsl_pwrctrl_pwrlevel_change(device,
 					     pwr->active_pwrlevel + val);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sharedmem.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sharedmem.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sharedmem.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sharedmem.c	2013-08-01 23:38:02.000000000 -0600
@@ -43,6 +43,7 @@
 	.show = _show, \
 }
 
+
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
 static ssize_t
 gpubusy_show(struct kgsl_process_private *priv, int type, char *buf)
@@ -52,8 +53,9 @@
 
 	tmp = (char*)((int)tmp + snprintf(tmp, PAGE_SIZE, "%lld %lld", priv->gputime.total, priv->gputime.busy));
 	for(i=0;i<KGSL_MAX_PWRLEVELS;i++)
-		tmp = (char*)( (int)tmp + snprintf(tmp, PAGE_SIZE - (int)(tmp-buf), " %lld %lld", priv->gputime_in_state[i].total, priv->gputime_in_state[i].busy));
-			tmp = (char*)((int)tmp + snprintf(tmp, PAGE_SIZE, "\n"));
+	tmp = (char*)( (int)tmp + snprintf(tmp, PAGE_SIZE - (int)(tmp-buf), " %lld %lld",
+				priv->gputime_in_state[i].total, priv->gputime_in_state[i].busy));
+	tmp = (char*)((int)tmp + snprintf(tmp, PAGE_SIZE, "\n"));
 	return (ssize_t)(tmp - buf);
 }
 
@@ -77,10 +79,6 @@
 }
 
 
-
-static struct page *kgsl_guard_page;
-
-
 static struct kgsl_process_private *
 _get_priv_from_kobj(struct kobject *kobj)
 {
@@ -200,11 +198,9 @@
 		ret = sysfs_create_file(&private->kobj,
 			&mem_stats[i].max_attr.attr);
 	}
-
 #ifdef CONFIG_MSM_KGSL_GPU_USAGE
-	ret = sysfs_create_file(&private->kobj, &gpubusy.attr);
+ret = sysfs_create_file(&private->kobj, &gpubusy.attr);
 #endif
-
 }
 
 static int kgsl_drv_memstat_show(struct device *dev,
@@ -318,8 +314,8 @@
 #endif
 
 static int kgsl_ion_alloc_vmfault(struct kgsl_memdesc *memdesc,
-					struct vm_area_struct *vma,
-					struct vm_fault *vmf)
+				struct vm_area_struct *vma,
+				struct vm_fault *vmf)
 {
 	unsigned long offset, pfn;
 	int ret;
@@ -350,13 +346,12 @@
 
 	if (memdesc->hostptr) {
 		iounmap(memdesc->hostptr);
+		kgsl_driver.stats.pre_alloc_kernel -= memdesc->size;
 		kgsl_driver.stats.vmalloc -= memdesc->size;
 	}
 
 	if (memdesc->private)
 		kgsl_process_sub_stats(memdesc->private, KGSL_MEM_ENTRY_PRE_ALLOC, memdesc->size);
-	else
-		kgsl_driver.stats.pre_alloc_kernel -= memdesc->size;
 }
 
 static int kgsl_ion_alloc_map_kernel(struct kgsl_memdesc *memdesc)
@@ -368,7 +363,8 @@
 			return -ENOMEM;
 		}
 		KGSL_STATS_ADD(memdesc->size, kgsl_driver.stats.vmalloc,
-		kgsl_driver.stats.vmalloc_max);
+			kgsl_driver.stats.vmalloc_max);
+		kgsl_driver.stats.pre_alloc_kernel += memdesc->size;
 	}
 
 	return 0;
@@ -422,15 +418,12 @@
 	struct scatterlist *sg;
 	int sglen = memdesc->sglen;
 
-	
-	if (memdesc->priv & KGSL_MEMDESC_GUARD_PAGE)
-		sglen--;
-
 	kgsl_driver.stats.page_alloc -= memdesc->size;
 
 	if (memdesc->hostptr) {
 		vunmap(memdesc->hostptr);
 		kgsl_driver.stats.vmalloc -= memdesc->size;
+		kgsl_driver.stats.page_alloc_kernel -= memdesc->size;
 	}
 	if (memdesc->sg)
 		for_each_sg(memdesc->sg, sg, sglen, i){
@@ -438,11 +431,8 @@
 				break;
 			__free_pages(sg_page(sg), get_order(sg->length));
 		}
-
 	if (memdesc->private)
 		kgsl_process_sub_stats(memdesc->private, KGSL_MEM_ENTRY_PAGE_ALLOC, memdesc->size);
-	else
-		kgsl_driver.stats.page_alloc_kernel -= memdesc->size;
 }
 
 static int kgsl_contiguous_vmflags(struct kgsl_memdesc *memdesc)
@@ -461,10 +451,6 @@
 		int i, count = 0;
 
 		
-		if (memdesc->priv & KGSL_MEMDESC_GUARD_PAGE)
-			sglen--;
-
-		
 		pages = vmalloc(npages * sizeof(struct page *));
 		if (!pages) {
 			KGSL_CORE_ERR("vmalloc(%d) failed\n",
@@ -485,6 +471,7 @@
 					VM_IOREMAP, page_prot);
 		KGSL_STATS_ADD(memdesc->size, kgsl_driver.stats.vmalloc,
 				kgsl_driver.stats.vmalloc_max);
+		kgsl_driver.stats.page_alloc_kernel += memdesc->size;
 		vfree(pages);
 	}
 	if (!memdesc->hostptr)
@@ -574,21 +561,25 @@
 
 void kgsl_cache_range_op(struct kgsl_memdesc *memdesc, int op)
 {
-	void *addr = memdesc->hostptr;
+
+	void *addr = (memdesc->hostptr) ?
+		memdesc->hostptr : (void *) memdesc->useraddr;
+
 	int size = memdesc->size;
 
-	switch (op) {
-	case KGSL_CACHE_OP_FLUSH:
-		dmac_flush_range(addr, addr + size);
-		break;
-	case KGSL_CACHE_OP_CLEAN:
-		dmac_clean_range(addr, addr + size);
-		break;
-	case KGSL_CACHE_OP_INV:
-		dmac_inv_range(addr, addr + size);
-		break;
+	if (addr !=  NULL) {
+		switch (op) {
+		case KGSL_CACHE_OP_FLUSH:
+			dmac_flush_range(addr, addr + size);
+			break;
+		case KGSL_CACHE_OP_CLEAN:
+			dmac_clean_range(addr, addr + size);
+			break;
+		case KGSL_CACHE_OP_INV:
+			dmac_inv_range(addr, addr + size);
+			break;
+		}
 	}
-
 	outer_cache_range_op_sg(memdesc->sg, memdesc->sglen, op);
 }
 EXPORT_SYMBOL(kgsl_cache_range_op);
@@ -596,7 +587,7 @@
 static int
 _kgsl_sharedmem_page_alloc(struct kgsl_memdesc *memdesc,
 			struct kgsl_pagetable *pagetable,
-			size_t size, unsigned int protflags)
+			size_t size)
 {
 	int pcount = 0, order, ret = 0;
 	int j, len, page_size, sglen_alloc, sglen = 0;
@@ -609,63 +600,56 @@
 
 	page_size = (align >= ilog2(SZ_64K) && size >= SZ_64K)
 			? SZ_64K : PAGE_SIZE;
-
 	
-	kgsl_memdesc_set_align(memdesc, ilog2(page_size));
+	if (page_size != PAGE_SIZE)
+		kgsl_memdesc_set_align(memdesc, ilog2(page_size));
 
 
 	sglen_alloc = PAGE_ALIGN(size) >> PAGE_SHIFT;
 
-
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
-		sglen_alloc++;
-
 	memdesc->size = size;
 	memdesc->pagetable = pagetable;
 	memdesc->ops = &kgsl_page_alloc_ops;
 
-	memdesc->sg = kgsl_sg_alloc(sglen_alloc);
+	memdesc->sglen_alloc = sglen_alloc;
+	memdesc->sg = kgsl_sg_alloc(memdesc->sglen_alloc);
 
 	if (memdesc->sg == NULL) {
-		KGSL_CORE_ERR("vmalloc(%d) failed\n",
-			sglen_alloc * sizeof(struct scatterlist));
 		ret = -ENOMEM;
 		goto done;
 	}
 
 
-	pages = kmalloc(sglen_alloc * sizeof(struct page *), GFP_KERNEL);
+	pages = kmalloc(memdesc->sglen_alloc * sizeof(struct page *),
+		GFP_KERNEL);
 
 	if (pages == NULL) {
-		KGSL_CORE_ERR("kmalloc (%d) failed\n",
-			sglen_alloc * sizeof(struct page *));
 		ret = -ENOMEM;
 		goto done;
 	}
 
 	kmemleak_not_leak(memdesc->sg);
 
-	memdesc->sglen_alloc = sglen_alloc;
-	sg_init_table(memdesc->sg, sglen_alloc);
+	sg_init_table(memdesc->sg, memdesc->sglen_alloc);
 
 	len = size;
 
 	while (len > 0) {
 		struct page *page;
+		unsigned int gfp_mask = __GFP_HIGHMEM;
 		int j;
 
 		
 		if (len < page_size)
 			page_size = PAGE_SIZE;
 
-		if (page_size == PAGE_SIZE)
-			page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
-		else {
-			page = alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | __GFP_COMP |
-				__GFP_NO_COMPACT | __GFP_NOWARN | __GFP_NORETRY | __GFP_NO_KSWAPD,
-				get_order(page_size));
+		if (page_size != PAGE_SIZE)
+			gfp_mask |= __GFP_COMP | __GFP_NORETRY |
+				__GFP_NO_KSWAPD | __GFP_NOWARN;
+		else
+			gfp_mask |= GFP_KERNEL;
 
-		}
+		page = alloc_pages(gfp_mask, get_order(page_size));
 
 		if (page == NULL) {
 			if (page_size != PAGE_SIZE) {
@@ -688,21 +672,6 @@
 		len -= page_size;
 	}
 
-	
-
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU) {
-
-		if (kgsl_guard_page == NULL)
-			kgsl_guard_page = alloc_page(GFP_KERNEL | __GFP_ZERO |
-				__GFP_HIGHMEM);
-
-		if (kgsl_guard_page != NULL) {
-			sg_set_page(&memdesc->sg[sglen++], kgsl_guard_page,
-				PAGE_SIZE, 0);
-			memdesc->priv |= KGSL_MEMDESC_GUARD_PAGE;
-		}
-	}
-
 	memdesc->sglen = sglen;
 
 
@@ -726,11 +695,6 @@
 	outer_cache_range_op_sg(memdesc->sg, memdesc->sglen,
 				KGSL_CACHE_OP_FLUSH);
 
-	ret = kgsl_mmu_map(pagetable, memdesc, protflags);
-
-	if (ret)
-		goto done;
-
 	order = get_order(size);
 
 	if (order < 16)
@@ -757,16 +721,12 @@
 
 	size = ALIGN(size, PAGE_SIZE * 2);
 
-	kgsl_driver.stats.page_alloc_kernel += size;
-	ret =  _kgsl_sharedmem_page_alloc(memdesc, pagetable, size,
-		GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	ret =  _kgsl_sharedmem_page_alloc(memdesc, pagetable, size);
 	if (!ret)
 		ret = kgsl_page_alloc_map_kernel(memdesc);
-	if (ret) {
-		
-		kgsl_driver.stats.page_alloc_kernel += size;
+	if (ret)
 		kgsl_sharedmem_free(memdesc);
-	}
+
 	return ret;
 }
 EXPORT_SYMBOL(kgsl_sharedmem_page_alloc);
@@ -777,19 +737,8 @@
 			    struct kgsl_pagetable *pagetable,
 			    size_t size)
 {
-	unsigned int protflags;
 	int ret = 0;
-
-	if (size == 0)
-		return -EINVAL;
-
-	protflags = GSL_PT_PAGE_RV;
-	if (!(memdesc->flags & KGSL_MEMFLAGS_GPUREADONLY))
-		protflags |= GSL_PT_PAGE_WV;
-
-	ret = _kgsl_sharedmem_page_alloc(memdesc, pagetable, size,
-		protflags);
-
+	ret = _kgsl_sharedmem_page_alloc(memdesc, pagetable, PAGE_ALIGN(size));
 	if (ret == 0 && private)
 		kgsl_process_add_stats(private, KGSL_MEM_ENTRY_PAGE_ALLOC, size);
 
@@ -810,31 +759,31 @@
 
 
 	
-	
+		
 
 	memdesc->size = size;
 	memdesc->pagetable = pagetable;
 	memdesc->ops = &kgsl_ion_alloc_ops;
 
-    if (kgsl_client == NULL) {
-        KGSL_CORE_ERR("kgsl_client is not initialized\n");
-        ret = -ENOMEM;
-        goto done;
-    }
-
-    handle = ion_alloc(kgsl_client, size, SZ_4K, 0x1 << ION_SF_HEAP_ID);
-    if (IS_ERR_OR_NULL(handle)) {
-        ret = -ENOMEM;
-        goto done;
-    }
+	if (kgsl_client == NULL) {
+		KGSL_CORE_ERR("kgsl_client is not initialized\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	handle = ion_alloc(kgsl_client, size, SZ_4K, 0x1 << ION_SF_HEAP_ID);
+	if (IS_ERR_OR_NULL(handle)) {
+		ret = -ENOMEM;
+		goto done;
+	}
 
 	memdesc->handle = handle;
 
-    if (ion_phys(kgsl_client, handle, &pa, &len)) {
-        printk("kgsl: ion_phys() failed\n");
-        ret = -ENOMEM;
-        goto done;
-    }
+	if (ion_phys(kgsl_client, handle, &pa, &len)) {
+		printk("kgsl: ion_phys() failed\n");
+		ret = -ENOMEM;
+		goto done;
+	}
 
 	ret = memdesc_sg_phys(memdesc, pa, memdesc->size);
 	if (ret)
@@ -851,11 +800,8 @@
 		dmac_flush_range(ptr, ptr + memdesc->size);
 		iounmap(ptr);
 	}
-
 	outer_cache_range_op_sg(memdesc->sg, memdesc->sglen, KGSL_CACHE_OP_FLUSH);
 
-	ret = kgsl_mmu_map(pagetable, memdesc, protflags);
-
 	if (ret) {
 		printk("[kgsl] kgsl_mmu_map failed\n");
 		ret = -ENOMEM;
@@ -869,7 +815,6 @@
 
 done:
 	KGSL_STATS_ADD(size, kgsl_driver.stats.pre_alloc, kgsl_driver.stats.pre_alloc_max);
-
 	if (ret)
 		kgsl_sharedmem_free(memdesc);
 
@@ -886,17 +831,14 @@
 	BUG_ON(size == 0);
 	size = PAGE_ALIGN(size);
 
-	kgsl_driver.stats.pre_alloc_kernel += size;
 	ret = _kgsl_sharedmem_ion_alloc(memdesc, pagetable, size,
 		GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
 	if (!ret)
 		ret = kgsl_ion_alloc_map_kernel(memdesc);
 
-	if (ret) {
-		
-		kgsl_driver.stats.pre_alloc_kernel += size;
+	if (ret)
 		kgsl_sharedmem_free(memdesc);
-	}
+
 	return ret;
 }
 EXPORT_SYMBOL(kgsl_sharedmem_ion_alloc);
@@ -935,6 +877,7 @@
 }
 EXPORT_SYMBOL(kgsl_sharedmem_init_ion);
 
+
 int
 kgsl_sharedmem_alloc_coherent(struct kgsl_memdesc *memdesc, size_t size)
 {
@@ -975,8 +918,10 @@
 	if (memdesc == NULL || memdesc->size == 0)
 		return;
 
-	if (memdesc->gpuaddr)
+	if (memdesc->gpuaddr) {
 		kgsl_mmu_unmap(memdesc->pagetable, memdesc);
+		kgsl_mmu_put_gpuaddr(memdesc->pagetable, memdesc);
+	}
 
 	if (memdesc->ops && memdesc->ops->free)
 		memdesc->ops->free(memdesc);
@@ -1008,12 +953,6 @@
 
 	if (result)
 		goto err;
-
-	result = kgsl_mmu_map(pagetable, memdesc,
-		GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
-
-	if (result)
-		goto err;
 
 	KGSL_STATS_ADD(size, kgsl_driver.stats.coherent,
 		kgsl_driver.stats.coherent_max);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sharedmem.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sharedmem.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sharedmem.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sharedmem.h	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -19,6 +19,7 @@
 #include "kgsl_mmu.h"
 #include <linux/slab.h>
 #include <linux/kmemleak.h>
+#include <linux/iommu.h>
 #include <linux/sched.h>
 
 #include "kgsl_log.h"
@@ -88,6 +89,12 @@
 }
 
 static inline int
+kgsl_memdesc_get_cachemode(const struct kgsl_memdesc *memdesc)
+{
+	return (memdesc->flags & KGSL_CACHEMODE_MASK) >> KGSL_CACHEMODE_SHIFT;
+}
+
+static inline int
 kgsl_memdesc_set_align(struct kgsl_memdesc *memdesc, unsigned int align)
 {
 	if (align > 32) {
@@ -153,22 +160,72 @@
 	return 0;
 }
 
+static inline int kgsl_memdesc_is_global(const struct kgsl_memdesc *memdesc)
+{
+	return (memdesc->priv & KGSL_MEMDESC_GLOBAL) != 0;
+}
+
+static inline int
+kgsl_memdesc_has_guard_page(const struct kgsl_memdesc *memdesc)
+{
+	return (memdesc->priv & KGSL_MEMDESC_GUARD_PAGE) != 0;
+}
+
+static inline unsigned int
+kgsl_memdesc_protflags(const struct kgsl_memdesc *memdesc)
+{
+	unsigned int protflags = 0;
+	enum kgsl_mmutype mmutype = kgsl_mmu_get_mmutype();
+
+	if (mmutype == KGSL_MMU_TYPE_GPU) {
+		protflags = GSL_PT_PAGE_RV;
+		if (!(memdesc->flags & KGSL_MEMFLAGS_GPUREADONLY))
+			protflags |= GSL_PT_PAGE_WV;
+	} else if (mmutype == KGSL_MMU_TYPE_IOMMU) {
+		protflags = IOMMU_READ;
+		if (!(memdesc->flags & KGSL_MEMFLAGS_GPUREADONLY))
+			protflags |= IOMMU_WRITE;
+	}
+	return protflags;
+}
+
+static inline int
+kgsl_memdesc_use_cpu_map(const struct kgsl_memdesc *memdesc)
+{
+	return (memdesc->flags & KGSL_MEMFLAGS_USE_CPU_MAP) != 0;
+}
+
+static inline unsigned int
+kgsl_memdesc_mmapsize(const struct kgsl_memdesc *memdesc)
+{
+	unsigned int size = memdesc->size;
+	if (kgsl_memdesc_use_cpu_map(memdesc) &&
+		kgsl_memdesc_has_guard_page(memdesc))
+		size += SZ_4K;
+	return size;
+}
+
 static inline int
 kgsl_allocate(struct kgsl_memdesc *memdesc,
 		struct kgsl_pagetable *pagetable, size_t size)
 {
 	int ret = 1;
 
+	memdesc->priv |= (KGSL_MEMTYPE_KERNEL << KGSL_MEMTYPE_SHIFT);
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
 		return kgsl_sharedmem_ebimem(memdesc, pagetable, size);
 
-	memdesc->flags |= (KGSL_MEMTYPE_KERNEL << KGSL_MEMTYPE_SHIFT);
 	if (size >= SZ_4M)
 		ret = kgsl_sharedmem_ion_alloc(memdesc, pagetable, size);
 
 	if (ret)
 		return kgsl_sharedmem_page_alloc(memdesc, pagetable, size);
 
+	if (ret)
+		return ret;
+	ret = kgsl_mmu_map(pagetable, memdesc);
+	if (ret)
+		kgsl_sharedmem_free(memdesc);
 	return ret;
 }
 
@@ -181,6 +238,9 @@
 	int ret = 1;
 	char task_comm[TASK_COMM_LEN];
 
+	if (size == 0)
+		return -EINVAL;
+
 	memdesc->flags = flags;
 
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
@@ -190,10 +250,10 @@
 			ret = kgsl_sharedmem_ion_alloc_user(memdesc, private, pagetable, size);
 		else if ( size >= SZ_1M && strcmp("om.htc.launcher", get_task_comm(task_comm, current->group_leader)) == 0 )
 			ret = kgsl_sharedmem_ion_alloc_user(memdesc, private, pagetable, size);
+
 		if (ret)
 			ret = kgsl_sharedmem_page_alloc_user(memdesc, private, pagetable, size);
 	}
-
 	return ret;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_snapshot.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_snapshot.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_snapshot.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_snapshot.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -100,7 +100,12 @@
 {
 	struct kgsl_snapshot_linux_context *header = _ctxtptr;
 	struct kgsl_context *context = ptr;
-	struct kgsl_device *device = context->dev_priv->device;
+	struct kgsl_device *device;
+
+	if (context)
+		device = context->dev_priv->device;
+	else
+		device = (struct kgsl_device *)data;
 
 	header->id = id;
 
@@ -127,7 +132,12 @@
 	int size = sizeof(*header);
 
 
+	rcu_read_lock();
 	idr_for_each(&device->context_idr, snapshot_context_count, &ctxtcount);
+	rcu_read_unlock();
+
+	
+	ctxtcount++;
 
 	size += ctxtcount * sizeof(struct kgsl_snapshot_linux_context);
 
@@ -158,7 +168,8 @@
 	header->busclk = kgsl_get_clkrate(pwr->ebi1_clk);
 
 	
-	header->current_context = -1;
+	kgsl_sharedmem_readl(&device->memstore, &header->current_context,
+		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL, current_context));
 
 	
 	header->ptbase = kgsl_mmu_get_current_ptbase(&device->mmu);
@@ -173,11 +184,16 @@
 
 	header->ctxtcount = ctxtcount;
 
-	
 	_ctxtptr = snapshot + sizeof(*header);
-	idr_for_each(&device->context_idr, snapshot_context_info, NULL);
 
 	
+	snapshot_context_info(KGSL_MEMSTORE_GLOBAL, NULL, device);
+
+	
+	rcu_read_lock();
+	idr_for_each(&device->context_idr, snapshot_context_info, NULL);
+	rcu_read_unlock();
+	
 	return size;
 }
 
@@ -257,7 +273,7 @@
 {
 	list_del(&obj->node);
 
-	obj->entry->flags &= ~KGSL_MEM_ENTRY_FROZEN;
+	obj->entry->memdesc.priv &= ~KGSL_MEMDESC_FROZEN;
 	kgsl_mem_entry_put(obj->entry);
 
 	kfree(obj);
@@ -279,6 +295,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(kgsl_snapshot_have_object);
 
 
 int kgsl_snapshot_get_object(struct kgsl_device *device, unsigned int ptbase,
@@ -287,6 +304,10 @@
 	struct kgsl_mem_entry *entry;
 	struct kgsl_snapshot_object *obj;
 	int offset;
+	int ret = -EINVAL;
+
+	if (!gpuaddr)
+		return 0;
 
 	entry = kgsl_get_mem_entry(device, ptbase, gpuaddr, size);
 
@@ -300,7 +321,7 @@
 	if (entry->memtype != KGSL_MEM_ENTRY_KERNEL) {
 		KGSL_DRV_ERR(device,
 			"Only internal GPU buffers can be frozen\n");
-		return -EINVAL;
+		goto err_put;
 	}
 
 
@@ -317,36 +338,33 @@
 	if (size + offset > entry->memdesc.size) {
 		KGSL_DRV_ERR(device, "Invalid size for GPU buffer %8.8X\n",
 				gpuaddr);
-		return -EINVAL;
+		goto err_put;
 	}
 
 	
 	list_for_each_entry(obj, &device->snapshot_obj_list, node) {
 		if (obj->gpuaddr == gpuaddr && obj->ptbase == ptbase) {
 			
-			if (obj->size != size)
+			if (obj->size < size)
 				obj->size = size;
-
-			return 0;
+			ret = 0;
+			goto err_put;
 		}
 	}
 
 	if (kgsl_memdesc_map(&entry->memdesc) == NULL) {
 		KGSL_DRV_ERR(device, "Unable to map GPU buffer %X\n",
 				gpuaddr);
-		return -EINVAL;
+		goto err_put;
 	}
 
 	obj = kzalloc(sizeof(*obj), GFP_KERNEL);
 
 	if (obj == NULL) {
 		KGSL_DRV_ERR(device, "Unable to allocate memory\n");
-		return -EINVAL;
+		goto err_put;
 	}
 
-	
-	kgsl_mem_entry_get(entry);
-
 	obj->type = type;
 	obj->entry = entry;
 	obj->gpuaddr = gpuaddr;
@@ -357,12 +375,15 @@
 	list_add(&obj->node, &device->snapshot_obj_list);
 
 
-	if (entry->flags & KGSL_MEM_ENTRY_FROZEN)
-		return 0;
+	ret = (entry->memdesc.priv & KGSL_MEMDESC_FROZEN) ? 0
+		: entry->memdesc.size;
 
-	entry->flags |= KGSL_MEM_ENTRY_FROZEN;
+	entry->memdesc.priv |= KGSL_MEMDESC_FROZEN;
 
-	return entry->memdesc.size;
+	return ret;
+err_put:
+	kgsl_mem_entry_put(entry);
+	return ret;
 }
 EXPORT_SYMBOL(kgsl_snapshot_get_object);
 
@@ -583,6 +604,24 @@
 	return count;
 }
 
+static ssize_t no_panic_show(struct kgsl_device *device, char *buf)
+{
+    return snprintf(buf, PAGE_SIZE, "%x\n", device->snapshot_no_panic);
+}
+
+static ssize_t no_panic_store(struct kgsl_device *device, const char *buf,
+    size_t count)
+{
+    if (device && count > 0) {
+        mutex_lock(&device->mutex);
+        device->snapshot_no_panic = simple_strtol(buf, NULL, 10);
+        mutex_unlock(&device->mutex);
+    }
+
+    return count;
+}
+
+
 static struct bin_attribute snapshot_attr = {
 	.attr.name = "dump",
 	.attr.mode = 0444,
@@ -599,6 +638,7 @@
 
 SNAPSHOT_ATTR(trigger, 0600, NULL, trigger_store);
 SNAPSHOT_ATTR(timestamp, 0444, timestamp_show, NULL);
+SNAPSHOT_ATTR(no_panic, 0644, no_panic_show, no_panic_store);
 
 static void snapshot_sysfs_release(struct kobject *kobj)
 {
@@ -675,6 +715,10 @@
 		goto done;
 
 	ret  = sysfs_create_file(&device->snapshot_kobj, &attr_timestamp.attr);
+	if (ret)
+		goto done;
+
+	ret  = sysfs_create_file(&device->snapshot_kobj, &attr_no_panic.attr);
 
 done:
 	return ret;
@@ -687,6 +731,7 @@
 	sysfs_remove_bin_file(&device->snapshot_kobj, &snapshot_attr);
 	sysfs_remove_file(&device->snapshot_kobj, &attr_trigger.attr);
 	sysfs_remove_file(&device->snapshot_kobj, &attr_timestamp.attr);
+	sysfs_remove_file(&device->snapshot_kobj, &attr_no_panic.attr);
 
 	kobject_put(&device->snapshot_kobj);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sync.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sync.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_sync.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_sync.c	2013-08-01 23:38:02.000000000 -0600
@@ -63,20 +63,6 @@
 	return timestamp_cmp(ts_a, ts_b);
 }
 
-void kgsl_sync_timeline_value_str(struct sync_timeline *timeline, char *str,
-				   int size)
-{
-	struct kgsl_sync_timeline *ktimeline =
-		 (struct kgsl_sync_timeline *) timeline;
-	snprintf(str, size, "%d", ktimeline->last_timestamp);
-}
-
-void kgsl_sync_pt_value_str(struct sync_pt *pt, char *str, int size)
-{
-	struct kgsl_sync_pt *kpt = (struct kgsl_sync_pt *) pt;
-	snprintf(str, size, "%d", kpt->timestamp);
-}
-
 struct kgsl_fence_event_priv {
 	struct kgsl_context *context;
 	unsigned int timestamp;
@@ -84,10 +70,12 @@
 
 
 static inline void kgsl_fence_event_cb(struct kgsl_device *device,
-	void *priv, u32 context_id, u32 timestamp)
+	void *priv, u32 context_id, u32 timestamp, u32 type)
 {
 	struct kgsl_fence_event_priv *ev = priv;
-	kgsl_sync_timeline_signal(ev->context->timeline, ev->timestamp);
+
+	
+	kgsl_sync_timeline_signal(ev->context->timeline, timestamp);
 	kgsl_context_put(ev->context);
 	kfree(ev);
 }
@@ -107,16 +95,19 @@
 	if (len != sizeof(priv))
 		return -EINVAL;
 
-	context = kgsl_find_context(owner, context_id);
-	if (context == NULL)
-		return -EINVAL;
-
 	event = kzalloc(sizeof(*event), GFP_KERNEL);
 	if (event == NULL)
 		return -ENOMEM;
+
+	context = kgsl_context_get_owner(owner, context_id);
+
+	if (context == NULL) {
+		kfree(event);
+		return -EINVAL;
+	}
+
 	event->context = context;
 	event->timestamp = timestamp;
-	kgsl_context_get(context);
 
 	pt = kgsl_sync_pt_create(context->timeline, timestamp);
 	if (pt == NULL) {
@@ -157,7 +148,6 @@
 fail_event:
 fail_copy_fd:
 	
-	sync_fence_put(fence);
 	put_unused_fd(priv.fence_fd);
 fail_fd:
 	
@@ -170,11 +160,10 @@
 }
 
 static const struct sync_timeline_ops kgsl_sync_timeline_ops = {
+	.driver_name = "kgsl-timeline",
 	.dup = kgsl_sync_pt_dup,
 	.has_signaled = kgsl_sync_pt_has_signaled,
 	.compare = kgsl_sync_pt_compare,
-	.timeline_value_str = kgsl_sync_timeline_value_str,
-	.pt_value_str = kgsl_sync_pt_value_str,
 };
 
 int kgsl_sync_timeline_create(struct kgsl_context *context)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_trace.h monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_trace.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/kgsl_trace.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/kgsl_trace.h	2013-08-01 23:38:02.000000000 -0600
@@ -24,6 +24,8 @@
 #include <linux/tracepoint.h>
 #include "kgsl_device.h"
 
+#include "adreno_drawctxt.h"
+
 struct kgsl_device;
 struct kgsl_ringbuffer_issueibcmds;
 struct kgsl_device_waittimestamp;
@@ -31,11 +33,16 @@
 TRACE_EVENT(kgsl_issueibcmds,
 
 	TP_PROTO(struct kgsl_device *device,
-			struct kgsl_ringbuffer_issueibcmds *cmd,
+			int drawctxt_id,
 			struct kgsl_ibdesc *ibdesc,
-			int result),
+			int numibs,
+			int timestamp,
+			int flags,
+			int result,
+			unsigned int type),
 
-	TP_ARGS(device, cmd, ibdesc, result),
+	TP_ARGS(device, drawctxt_id, ibdesc, numibs, timestamp, flags,
+		result, type),
 
 	TP_STRUCT__entry(
 		__string(device_name, device->name)
@@ -45,21 +52,23 @@
 		__field(unsigned int, timestamp)
 		__field(unsigned int, flags)
 		__field(int, result)
+		__field(unsigned int, drawctxt_type)
 	),
 
 	TP_fast_assign(
 		__assign_str(device_name, device->name);
-		__entry->drawctxt_id = cmd->drawctxt_id;
+		__entry->drawctxt_id = drawctxt_id;
 		__entry->ibdesc_addr = ibdesc[0].gpuaddr;
-		__entry->numibs = cmd->numibs;
-		__entry->timestamp = cmd->timestamp;
-		__entry->flags = cmd->flags;
+		__entry->numibs = numibs;
+		__entry->timestamp = timestamp;
+		__entry->flags = flags;
 		__entry->result = result;
+		__entry->drawctxt_type = type;
 	),
 
 	TP_printk(
 		"d_name=%s ctx=%u ib=0x%u numibs=%u timestamp=0x%x "
-		"flags=0x%x(%s) result=%d",
+		"flags=0x%x(%s) result=%d type=%s",
 		__get_str(device_name),
 		__entry->drawctxt_id,
 		__entry->ibdesc_addr,
@@ -71,7 +80,9 @@
 			{ KGSL_CONTEXT_SUBMIT_IB_LIST, "IB_LIST" },
 			{ KGSL_CONTEXT_CTX_SWITCH, "CTX_SWITCH" })
 			: "None",
-		__entry->result
+		__entry->result,
+		__print_symbolic(__entry->drawctxt_type,
+			ADRENO_DRAWCTXT_TYPES)
 	)
 );
 
@@ -305,6 +316,8 @@
 		__field(unsigned int, size)
 		__field(unsigned int, tgid)
 		__array(char, usage, 16)
+		__field(unsigned int, id)
+		__field(unsigned int, flags)
 	),
 
 	TP_fast_assign(
@@ -313,12 +326,76 @@
 		__entry->tgid = mem_entry->priv->pid;
 		kgsl_get_memory_usage(__entry->usage, sizeof(__entry->usage),
 				     mem_entry->memdesc.flags);
+		__entry->id = mem_entry->id;
+		__entry->flags = mem_entry->memdesc.flags;
 	),
 
 	TP_printk(
-		"gpuaddr=0x%08x size=%d tgid=%d usage=%s",
+		"gpuaddr=0x%08x size=%d tgid=%d usage=%s id=%d flags=0x%08x",
 		__entry->gpuaddr, __entry->size, __entry->tgid,
-		__entry->usage
+		__entry->usage, __entry->id, __entry->flags
+	)
+);
+
+TRACE_EVENT(kgsl_mem_mmap,
+
+	TP_PROTO(struct kgsl_mem_entry *mem_entry),
+
+	TP_ARGS(mem_entry),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, useraddr)
+		__field(unsigned int, gpuaddr)
+		__field(unsigned int, size)
+		__array(char, usage, 16)
+		__field(unsigned int, id)
+		__field(unsigned int, flags)
+	),
+
+	TP_fast_assign(
+		__entry->useraddr = mem_entry->memdesc.useraddr;
+		__entry->gpuaddr = mem_entry->memdesc.gpuaddr;
+		__entry->size = mem_entry->memdesc.size;
+		kgsl_get_memory_usage(__entry->usage, sizeof(__entry->usage),
+				     mem_entry->memdesc.flags);
+		__entry->id = mem_entry->id;
+		__entry->flags = mem_entry->memdesc.flags;
+	),
+
+	TP_printk(
+		"useraddr=%lx gpuaddr=0x%08x size=%d usage=%s id=%d"
+		" flags=0x%08x",
+		__entry->useraddr, __entry->gpuaddr, __entry->size,
+		__entry->usage, __entry->id, __entry->flags
+	)
+);
+
+TRACE_EVENT(kgsl_mem_unmapped_area_collision,
+
+	TP_PROTO(struct kgsl_mem_entry *mem_entry,
+		 unsigned long hint,
+		 unsigned long len,
+		 unsigned long addr),
+
+	TP_ARGS(mem_entry, hint, len, addr),
+
+	TP_STRUCT__entry(
+		__field(unsigned int, id)
+		__field(unsigned long, hint)
+		__field(unsigned long, len)
+		__field(unsigned long, addr)
+	),
+
+	TP_fast_assign(
+		__entry->id = mem_entry->id;
+		__entry->hint  = hint;
+		__entry->len = len;
+		__entry->addr = addr;
+	),
+
+	TP_printk(
+		"id=%d hint=0x%lx len=%ld addr=0x%lx",
+		__entry->id, __entry->hint, __entry->len, __entry->addr
 	)
 );
 
@@ -335,6 +412,7 @@
 		__field(int, type)
 		__field(unsigned int, tgid)
 		__array(char, usage, 16)
+		__field(unsigned int, id)
 	),
 
 	TP_fast_assign(
@@ -345,13 +423,14 @@
 		__entry->tgid = mem_entry->priv->pid;
 		kgsl_get_memory_usage(__entry->usage, sizeof(__entry->usage),
 				     mem_entry->memdesc.flags);
+		__entry->id = mem_entry->id;
 	),
 
 	TP_printk(
-		"gpuaddr=0x%08x size=%d type=%d fd=%d tgid=%d usage %s",
+		"gpuaddr=0x%08x size=%d type=%d fd=%d tgid=%d usage=%s id=%d",
 		__entry->gpuaddr, __entry->size,
 		__entry->type, __entry->fd, __entry->tgid,
-		__entry->usage
+		__entry->usage, __entry->id
 	)
 );
 
@@ -368,6 +447,7 @@
 		__field(int, fd)
 		__field(unsigned int, tgid)
 		__array(char, usage, 16)
+		__field(unsigned int, id)
 	),
 
 	TP_fast_assign(
@@ -377,12 +457,13 @@
 		__entry->tgid = mem_entry->priv->pid;
 		kgsl_get_memory_usage(__entry->usage, sizeof(__entry->usage),
 				     mem_entry->memdesc.flags);
+		__entry->id = mem_entry->id;
 	),
 
 	TP_printk(
-		"gpuaddr=0x%08x size=%d type=%d tgid=%d usage=%s",
+		"gpuaddr=0x%08x size=%d type=%d tgid=%d usage=%s id=%d",
 		__entry->gpuaddr, __entry->size, __entry->type,
-		__entry->tgid, __entry->usage
+		__entry->tgid, __entry->usage, __entry->id
 	)
 );
 
@@ -399,6 +480,7 @@
 		__field(unsigned int, size)
 		__field(int, type)
 		__array(char, usage, 16)
+		__field(unsigned int, id)
 		__field(unsigned int, drawctxt_id)
 		__field(unsigned int, curr_ts)
 		__field(unsigned int, free_ts)
@@ -410,6 +492,7 @@
 		__entry->size = mem_entry->memdesc.size;
 		kgsl_get_memory_usage(__entry->usage, sizeof(__entry->usage),
 				     mem_entry->memdesc.flags);
+		__entry->id = mem_entry->id;
 		__entry->drawctxt_id = id;
 		__entry->type = mem_entry->memtype;
 		__entry->curr_ts = curr_ts;
@@ -417,13 +500,14 @@
 	),
 
 	TP_printk(
-		"d_name=%s gpuaddr=0x%08x size=%d type=%d usage=%s ctx=%u"
+		"d_name=%s gpuaddr=0x%08x size=%d type=%d usage=%s id=%d ctx=%u"
 		" curr_ts=0x%x free_ts=0x%x",
 		__get_str(device_name),
 		__entry->gpuaddr,
 		__entry->size,
 		__entry->type,
 		__entry->usage,
+		__entry->id,
 		__entry->drawctxt_id,
 		__entry->curr_ts,
 		__entry->free_ts
@@ -541,21 +625,48 @@
 
 TRACE_EVENT(kgsl_fire_event,
 		TP_PROTO(unsigned int id, unsigned int ts,
-			unsigned int age),
-		TP_ARGS(id, ts, age),
+			unsigned int type, unsigned int age),
+		TP_ARGS(id, ts, type, age),
 		TP_STRUCT__entry(
 			__field(unsigned int, id)
 			__field(unsigned int, ts)
+			__field(unsigned int, type)
 			__field(unsigned int, age)
 		),
 		TP_fast_assign(
 			__entry->id = id;
 			__entry->ts = ts;
+			__entry->type = type;
 			__entry->age = age;
 		),
 		TP_printk(
-			"ctx=%d ts=%d age=%u",
-			__entry->id, __entry->ts, __entry->age)
+			"ctx=%d ts=%d type=%d age=%u",
+			__entry->id, __entry->ts, __entry->type, __entry->age)
+);
+
+TRACE_EVENT(kgsl_regwrite,
+
+	TP_PROTO(struct kgsl_device *device, unsigned int offset,
+		unsigned int value),
+
+	TP_ARGS(device, offset, value),
+
+	TP_STRUCT__entry(
+		__string(device_name, device->name)
+		__field(unsigned int, offset)
+		__field(unsigned int, value)
+	),
+
+	TP_fast_assign(
+		__assign_str(device_name, device->name);
+		__entry->offset = offset;
+		__entry->value = value;
+	),
+
+	TP_printk(
+		"d_name=%s reg=%x value=%x",
+		__get_str(device_name), __entry->offset, __entry->value
+	)
 );
 
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/z180.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/z180.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/z180.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/z180.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -92,7 +92,8 @@
 #define Z180_CMDWINDOW_TARGET_SHIFT		0
 #define Z180_CMDWINDOW_ADDR_SHIFT		8
 
-static int z180_start(struct kgsl_device *device, unsigned int init_ram);
+static int z180_init(struct kgsl_device *device);
+static int z180_start(struct kgsl_device *device);
 static int z180_stop(struct kgsl_device *device);
 static int z180_wait(struct kgsl_device *device,
 				struct kgsl_context *context,
@@ -205,10 +206,6 @@
 
 			queue_work(device->work_queue, &device->ts_expired_ws);
 			wake_up_interruptible(&device->wait_queue);
-
-			atomic_notifier_call_chain(
-				&(device->ts_notifier_list),
-				device->id, NULL);
 		}
 	}
 
@@ -241,22 +238,21 @@
 	int result = 0;
 	struct z180_device *z180_dev = Z180_DEVICE(device);
 
-	result = kgsl_mmu_map_global(pagetable, &device->mmu.setstate_memory,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	result = kgsl_mmu_map_global(pagetable, &device->mmu.setstate_memory);
 
 	if (result)
 		goto error;
 
-	result = kgsl_mmu_map_global(pagetable, &device->memstore,
-				     GSL_PT_PAGE_RV | GSL_PT_PAGE_WV);
+	result = kgsl_mmu_map_global(pagetable, &device->memstore);
 	if (result)
 		goto error_unmap_dummy;
 
 	result = kgsl_mmu_map_global(pagetable,
-				     &z180_dev->ringbuffer.cmdbufdesc,
-				     GSL_PT_PAGE_RV);
+				     &z180_dev->ringbuffer.cmdbufdesc);
 	if (result)
 		goto error_unmap_memstore;
+	device->mh.mpu_range = z180_dev->ringbuffer.cmdbufdesc.gpuaddr +
+				z180_dev->ringbuffer.cmdbufdesc.size;
 	return result;
 
 error_unmap_dummy:
@@ -312,16 +308,11 @@
 	*p++ = ADDR_VGV3_LAST << 24;
 }
 
-static void z180_cmdstream_start(struct kgsl_device *device, int init_ram)
+static void z180_cmdstream_start(struct kgsl_device *device)
 {
 	struct z180_device *z180_dev = Z180_DEVICE(device);
 	unsigned int cmd = VGV3_NEXTCMD_JUMP << VGV3_NEXTCMD_NEXTCMD_FSHIFT;
 
-	if (init_ram) {
-		z180_dev->timestamp = 0;
-		z180_dev->current_timestamp = 0;
-	}
-
 	addmarker(&z180_dev->ringbuffer, 0);
 
 	z180_cmdwindow_write(device, ADDR_VGV3_MODE, 4);
@@ -471,6 +462,10 @@
 	z180_cmdwindow_write(device, ADDR_VGV3_CONTROL, cmd);
 	z180_cmdwindow_write(device, ADDR_VGV3_CONTROL, 0);
 error:
+
+	kgsl_trace_issueibcmds(device, context->id, ibdesc, numibs,
+		*timestamp, ctrl, result, 0);
+
 	return (int)result;
 }
 
@@ -479,6 +474,7 @@
 	struct z180_device *z180_dev = Z180_DEVICE(device);
 	memset(&z180_dev->ringbuffer, 0, sizeof(struct z180_ringbuffer));
 	z180_dev->ringbuffer.prevctx = Z180_INVALID_CONTEXT;
+	z180_dev->ringbuffer.cmdbufdesc.flags = KGSL_MEMFLAGS_GPUREADONLY;
 	return kgsl_allocate_contiguous(&z180_dev->ringbuffer.cmdbufdesc,
 		Z180_RB_SIZE);
 }
@@ -535,7 +531,17 @@
 	return 0;
 }
 
-static int z180_start(struct kgsl_device *device, unsigned int init_ram)
+static int z180_init(struct kgsl_device *device)
+{
+	struct z180_device *z180_dev = Z180_DEVICE(device);
+
+	z180_dev->timestamp = 0;
+	z180_dev->current_timestamp = 0;
+
+	return 0;
+}
+
+static int z180_start(struct kgsl_device *device)
 {
 	int status = 0;
 
@@ -552,11 +558,14 @@
 	if (status)
 		goto error_clk_off;
 
-	z180_cmdstream_start(device, init_ram);
+	z180_cmdstream_start(device);
 
 	mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
+
+	device->reset_counter++;
+
 	return 0;
 
 error_clk_off:
@@ -880,6 +889,7 @@
 	.idle = z180_idle,
 	.isidle = z180_isidle,
 	.suspend_context = z180_suspend_context,
+	.init = z180_init,
 	.start = z180_start,
 	.stop = z180_stop,
 	.getproperty = z180_getproperty,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/z180_postmortem.c monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/z180_postmortem.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm/z180_postmortem.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm/z180_postmortem.c	2013-08-01 23:38:02.000000000 -0600
@@ -151,6 +151,7 @@
 				KGSL_LOG_DUMP(device,
 				"Could not map IB to kernel memory, Ringbuffer Slot: %d\n",
 				rb_slot_num);
+				kgsl_mem_entry_put(entry);
 				continue;
 			}
 
@@ -173,6 +174,7 @@
 						linebuf);
 			}
 			KGSL_LOG_DUMP(device, "IB Dump Finished\n");
+			kgsl_mem_entry_put(entry);
 		}
 	}
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm_mr1/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm_mr1/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm_mr1/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm_mr1/Kconfig	2013-08-01 23:37:45.000000000 -0600
@@ -0,0 +1,119 @@
+config MSM_KGSL
+	tristate "MSM 3D Graphics driver"
+	default n
+	depends on ARCH_MSM && !ARCH_MSmonarudoX00A && !ARCH_MSmonarudoX25
+	select GENERIC_ALLOCATOR
+	select FW_LOADER
+	---help---
+	  3D graphics driver. Required to use hardware accelerated
+	  OpenGL ES 2.0 and 1.1.
+
+config MSM_KGSL_CFF_DUMP
+	bool "Enable KGSL Common File Format (CFF) Dump Feature [Use with caution]"
+	default n
+	depends on MSM_KGSL
+	select RELAY
+	---help---
+	  This is an analysis and diagnostic feature only, and should only be
+	  turned on during KGSL GPU diagnostics and will slow down the KGSL
+	  performance sigificantly, hence *do not use in production builds*.
+	  When enabled, CFF Dump is on at boot. It can be turned off at runtime
+	  via 'echo 0 > /d/kgsl/cff_dump'.  The log can be captured via
+	  /d/kgsl-cff/cpu[0|1].
+
+config MSM_KGSL_CFF_DUMP_NO_CONTEXT_MEM_DUMP
+	bool "When selected will disable KGSL CFF Dump for context switches"
+	default n
+	depends on MSM_KGSL_CFF_DUMP
+	---help---
+	  Dumping all the memory for every context switch can produce quite
+	  huge log files, to reduce this, turn this feature on.
+
+config MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL
+	bool "Disable human readable CP_STAT fields in post-mortem dump"
+	default n
+	depends on MSM_KGSL
+	---help---
+	  For a more compact kernel log the human readable output of
+	  CP_STAT can be turned off with this option.
+
+config MSM_KGSL_PSTMRTMDMP_NO_IB_DUMP
+	bool "Disable dumping current IB1 and IB2 in post-mortem dump"
+	default n
+	depends on MSM_KGSL
+	---help---
+	  For a more compact kernel log the IB1 and IB2 embedded dump
+	  can be turned off with this option.  Some IB dumps take up
+	  so much space that vital other information gets cut from the
+	  post-mortem dump.
+
+config MSM_KGSL_PSTMRTMDMP_RB_HEX
+	bool "Use hex version for ring-buffer in post-mortem dump"
+	default n
+	depends on MSM_KGSL
+	---help---
+	  Use hex version for the ring-buffer in the post-mortem dump, instead
+	  of the human readable version.
+
+config MSM_KGSL_2D
+	tristate "MSM 2D graphics driver. Required for OpenVG"
+	default y
+	depends on MSM_KGSL && !ARCH_MSmonarudoX27 && !ARCH_MSmonarudoX27A && !(ARCH_QSD8X50 && !MSM_SOC_REV_A)
+
+config MSM_KGSL_DRM
+	bool "Build a DRM interface for the MSM_KGSL driver"
+	depends on MSM_KGSL && DRM
+
+config KGSL_PER_PROCESS_PAGE_TABLE
+	bool "Enable Per Process page tables for the KGSL driver"
+	default n
+	depends on !MSM_KGSL_DRM
+	---help---
+	  The MMU will use per process pagetables when enabled.
+
+config MSM_KGSL_PAGE_TABLE_SIZE
+	hex "Size of pagetables"
+	default 0xFFF0000
+	---help---
+	  Sets the pagetable size used by the MMU.  The max value
+	  is 0xFFF0000 or (256M - 64K).
+
+config MSM_KGSL_PAGE_TABLE_COUNT
+	int "Minimum of concurrent pagetables to support"
+	default 8
+	depends on KGSL_PER_PROCESS_PAGE_TABLE
+	---help---
+	  Specify the number of pagetables to allocate at init time
+	  This is the number of concurrent processes that are guaranteed to
+	  to run at any time.  Additional processes can be created dynamically
+	  assuming there is enough contiguous memory to allocate the pagetable.
+
+config MSM_KGSL_MMU_PAGE_FAULT
+	bool "Force the GPU MMU to page fault for unmapped regions"
+	default y
+
+config MSM_KGSL_DISABLE_SHADOW_WRITES
+	bool "Disable register shadow writes for context switches"
+	default n
+	depends on MSM_KGSL
+
+config MSM_KGSL_DEFAULT_GPUMMU
+	bool "Prefer gpummu than iommu"
+	default n
+
+config MSM_KGSL_PAGE_TABLE_SIZE_FOR_IOMMU
+	hex "Size of pagetables for iommu"
+	default 0x1FE00000
+	---help---
+	Sets the pagetable size used by the IOMMU.  The max value
+	is 0x1FE00000 or (512M - 1536K - little interval).
+
+config MSM_KGSL_KILL_HANG_PROCESS
+	bool "Enable killing recoverable gpu hang process routine"
+	default n
+	---help---
+	We only enable this config in CRC branch.
+
+config MSM_KGSL_GPU_USAGE
+	bool "Enable sysfs node of GPU usage per process"
+	default n
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm_rb31/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm_rb31/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/gpu/msm_rb31/Kconfig	2013-06-24 02:50:40.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/gpu/msm_rb31/Kconfig	2013-08-01 23:37:45.000000000 -0600
@@ -118,6 +118,6 @@
 
 config MSM_KGSL_KILL_HANG_PROCESS
 	bool "Enable killing recoverable gpu hang process routine"
-	default y
+	default n
 	---help---
 	We only enable this config in CRC branch.
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/hid/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/hid/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -31,6 +31,29 @@
 
 	  If unsure, say Y.
 
+#Start UHID change
+config UHID
+	tristate "User-space I/O driver support for HID subsystem"
+	depends on HID
+	default y
+	---help---
+	Say Y here if you want to provide HID I/O Drivers from user-space.
+	This allows to write I/O drivers in user-space and feed the data from
+	the device into the kernel. The kernel parses the HID reports, loads the
+	corresponding HID Device Driver or provides input devices on top of your
+	user-space device.
+
+	This driver cannot be used to parse HID-reports in user-space and write
+	special HID-drivers. You should use hidraw for that.
+	Instead, this driver allows to write the transport-layer driver in
+	user-space like USB-HID and Bluetooth-HID do in kernel-space.
+
+	If unsure, say N.
+
+	To compile this driver as a module, choose M here: the
+	module will be called uhid.
+#End UHID change
+
 config HID_BATTERY_STRENGTH
 	bool
 	depends on HID && POWER_SUPPLY && HID = POWER_SUPPLY
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/Makefile monarudo-jb-3.4.10-e22f38b/drivers/hid/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/hid/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -9,6 +9,10 @@
 
 obj-$(CONFIG_HID)		+= hid.o
 
+#Start UHID change
+obj-y              += uhid.o
+#End UHID change
+ 
 hid-$(CONFIG_HIDRAW)		+= hidraw.o
 
 hid-logitech-y		:= hid-lg.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/uhid.c monarudo-jb-3.4.10-e22f38b/drivers/hid/uhid.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/hid/uhid.c	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/hid/uhid.c	2013-08-01 23:38:02.000000000 -0600
@@ -0,0 +1,568 @@
+/*
+ * User-space I/O driver support for HID subsystem
+ * Copyright (c) 2012 David Herrmann
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/atomic.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/hid.h>
+#include <linux/input.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/uhid.h>
+#include <linux/wait.h>
+
+#define UHID_NAME	"uhid"
+#define UHID_BUFSIZE	32
+
+struct uhid_device {
+	struct mutex devlock;
+	bool running;
+
+	__u8 *rd_data;
+	uint rd_size;
+
+	struct hid_device *hid;
+	struct uhid_event input_buf;
+
+	wait_queue_head_t waitq;
+	spinlock_t qlock;
+	__u8 head;
+	__u8 tail;
+	struct uhid_event *outq[UHID_BUFSIZE];
+
+	struct mutex report_lock;
+	wait_queue_head_t report_wait;
+	atomic_t report_done;
+	atomic_t report_id;
+	struct uhid_event report_buf;
+};
+
+static struct miscdevice uhid_misc;
+
+static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)
+{
+	__u8 newhead;
+
+	newhead = (uhid->head + 1) % UHID_BUFSIZE;
+
+	if (newhead != uhid->tail) {
+		uhid->outq[uhid->head] = ev;
+		uhid->head = newhead;
+		wake_up_interruptible(&uhid->waitq);
+	} else {
+		hid_warn(uhid->hid, "Output queue is full\n");
+		kfree(ev);
+	}
+}
+
+static int uhid_queue_event(struct uhid_device *uhid, __u32 event)
+{
+	unsigned long flags;
+	struct uhid_event *ev;
+
+	ev = kzalloc(sizeof(*ev), GFP_KERNEL);
+	if (!ev)
+		return -ENOMEM;
+
+	ev->type = event;
+
+	spin_lock_irqsave(&uhid->qlock, flags);
+	uhid_queue(uhid, ev);
+	spin_unlock_irqrestore(&uhid->qlock, flags);
+
+	return 0;
+}
+
+static int uhid_hid_start(struct hid_device *hid)
+{
+	struct uhid_device *uhid = hid->driver_data;
+
+	return uhid_queue_event(uhid, UHID_START);
+}
+
+static void uhid_hid_stop(struct hid_device *hid)
+{
+	struct uhid_device *uhid = hid->driver_data;
+
+	hid->claimed = 0;
+	uhid_queue_event(uhid, UHID_STOP);
+}
+
+static int uhid_hid_open(struct hid_device *hid)
+{
+	struct uhid_device *uhid = hid->driver_data;
+
+	return uhid_queue_event(uhid, UHID_OPEN);
+}
+
+static void uhid_hid_close(struct hid_device *hid)
+{
+	struct uhid_device *uhid = hid->driver_data;
+
+	uhid_queue_event(uhid, UHID_CLOSE);
+}
+
+static int uhid_hid_input(struct input_dev *input, unsigned int type,
+			  unsigned int code, int value)
+{
+	struct hid_device *hid = input_get_drvdata(input);
+	struct uhid_device *uhid = hid->driver_data;
+	unsigned long flags;
+	struct uhid_event *ev;
+
+	ev = kzalloc(sizeof(*ev), GFP_ATOMIC);
+	if (!ev)
+		return -ENOMEM;
+
+	ev->type = UHID_OUTPUT_EV;
+	ev->u.output_ev.type = type;
+	ev->u.output_ev.code = code;
+	ev->u.output_ev.value = value;
+
+	spin_lock_irqsave(&uhid->qlock, flags);
+	uhid_queue(uhid, ev);
+	spin_unlock_irqrestore(&uhid->qlock, flags);
+
+	return 0;
+}
+
+static int uhid_hid_parse(struct hid_device *hid)
+{
+	struct uhid_device *uhid = hid->driver_data;
+
+	return hid_parse_report(hid, uhid->rd_data, uhid->rd_size);
+}
+
+static int uhid_hid_get_raw(struct hid_device *hid, unsigned char rnum,
+			    __u8 *buf, size_t count, unsigned char rtype)
+{
+	struct uhid_device *uhid = hid->driver_data;
+	__u8 report_type;
+	struct uhid_event *ev;
+	unsigned long flags;
+	int ret;
+	size_t uninitialized_var(len);
+	struct uhid_feature_answer_req *req;
+
+	if (!uhid->running)
+		return -EIO;
+
+	switch (rtype) {
+	case HID_FEATURE_REPORT:
+		report_type = UHID_FEATURE_REPORT;
+		break;
+	case HID_OUTPUT_REPORT:
+		report_type = UHID_OUTPUT_REPORT;
+		break;
+	case HID_INPUT_REPORT:
+		report_type = UHID_INPUT_REPORT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = mutex_lock_interruptible(&uhid->report_lock);
+	if (ret)
+		return ret;
+
+	ev = kzalloc(sizeof(*ev), GFP_KERNEL);
+	if (!ev) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	spin_lock_irqsave(&uhid->qlock, flags);
+	ev->type = UHID_FEATURE;
+	ev->u.feature.id = atomic_inc_return(&uhid->report_id);
+	ev->u.feature.rnum = rnum;
+	ev->u.feature.rtype = report_type;
+
+	atomic_set(&uhid->report_done, 0);
+	uhid_queue(uhid, ev);
+	spin_unlock_irqrestore(&uhid->qlock, flags);
+
+	ret = wait_event_interruptible_timeout(uhid->report_wait,
+				atomic_read(&uhid->report_done), 5 * HZ);
+
+	smp_rmb();
+	if (!ret || !uhid->running) {
+		ret = -EIO;
+	} else if (ret < 0) {
+		ret = -ERESTARTSYS;
+	} else {
+		spin_lock_irqsave(&uhid->qlock, flags);
+		req = &uhid->report_buf.u.feature_answer;
+
+		if (req->err) {
+			ret = -EIO;
+		} else {
+			ret = 0;
+			len = min(count,
+				min_t(size_t, req->size, UHID_DATA_MAX));
+			memcpy(buf, req->data, len);
+		}
+
+		spin_unlock_irqrestore(&uhid->qlock, flags);
+	}
+
+	atomic_set(&uhid->report_done, 1);
+
+unlock:
+	mutex_unlock(&uhid->report_lock);
+	return ret ? ret : len;
+}
+
+static int uhid_hid_output_raw(struct hid_device *hid, __u8 *buf, size_t count,
+			       unsigned char report_type)
+{
+	struct uhid_device *uhid = hid->driver_data;
+	__u8 rtype;
+	unsigned long flags;
+	struct uhid_event *ev;
+
+	switch (report_type) {
+	case HID_FEATURE_REPORT:
+		rtype = UHID_FEATURE_REPORT;
+		break;
+	case HID_OUTPUT_REPORT:
+		rtype = UHID_OUTPUT_REPORT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (count < 1 || count > UHID_DATA_MAX)
+		return -EINVAL;
+
+	ev = kzalloc(sizeof(*ev), GFP_KERNEL);
+	if (!ev)
+		return -ENOMEM;
+
+	ev->type = UHID_OUTPUT;
+	ev->u.output.size = count;
+	ev->u.output.rtype = rtype;
+	memcpy(ev->u.output.data, buf, count);
+
+	spin_lock_irqsave(&uhid->qlock, flags);
+	uhid_queue(uhid, ev);
+	spin_unlock_irqrestore(&uhid->qlock, flags);
+
+	return count;
+}
+
+static struct hid_ll_driver uhid_hid_driver = {
+	.start = uhid_hid_start,
+	.stop = uhid_hid_stop,
+	.open = uhid_hid_open,
+	.close = uhid_hid_close,
+	.hidinput_input_event = uhid_hid_input,
+	.parse = uhid_hid_parse,
+};
+
+static int uhid_dev_create(struct uhid_device *uhid,
+			   const struct uhid_event *ev)
+{
+	struct hid_device *hid;
+	int ret;
+
+	if (uhid->running)
+		return -EALREADY;
+
+	uhid->rd_size = ev->u.create.rd_size;
+	if (uhid->rd_size <= 0 || uhid->rd_size > HID_MAX_DESCRIPTOR_SIZE)
+		return -EINVAL;
+
+	uhid->rd_data = kmalloc(uhid->rd_size, GFP_KERNEL);
+	if (!uhid->rd_data)
+		return -ENOMEM;
+
+	if (copy_from_user(uhid->rd_data, ev->u.create.rd_data,
+			   uhid->rd_size)) {
+		ret = -EFAULT;
+		goto err_free;
+	}
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		ret = PTR_ERR(hid);
+		goto err_free;
+	}
+
+	strncpy(hid->name, ev->u.create.name, 127);
+	hid->name[127] = 0;
+	strncpy(hid->phys, ev->u.create.phys, 63);
+	hid->phys[63] = 0;
+	strncpy(hid->uniq, ev->u.create.uniq, 63);
+	hid->uniq[63] = 0;
+
+	hid->ll_driver = &uhid_hid_driver;
+	hid->hid_get_raw_report = uhid_hid_get_raw;
+	hid->hid_output_raw_report = uhid_hid_output_raw;
+	hid->bus = ev->u.create.bus;
+	hid->vendor = ev->u.create.vendor;
+	hid->product = ev->u.create.product;
+	hid->version = ev->u.create.version;
+	hid->country = ev->u.create.country;
+	hid->driver_data = uhid;
+	hid->dev.parent = uhid_misc.this_device;
+
+	uhid->hid = hid;
+	uhid->running = true;
+
+	ret = hid_add_device(hid);
+	if (ret) {
+		hid_err(hid, "Cannot register HID device\n");
+		goto err_hid;
+	}
+
+	return 0;
+
+err_hid:
+	hid_destroy_device(hid);
+	uhid->hid = NULL;
+	uhid->running = false;
+err_free:
+	kfree(uhid->rd_data);
+	return ret;
+}
+
+static int uhid_dev_destroy(struct uhid_device *uhid)
+{
+	if (!uhid->running)
+		return -EINVAL;
+
+	
+	uhid->running = false;
+	smp_wmb();
+	atomic_set(&uhid->report_done, 1);
+	wake_up_interruptible(&uhid->report_wait);
+
+	hid_destroy_device(uhid->hid);
+	kfree(uhid->rd_data);
+
+	return 0;
+}
+
+static int uhid_dev_input(struct uhid_device *uhid, struct uhid_event *ev)
+{
+	if (!uhid->running)
+		return -EINVAL;
+
+	hid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input.data,
+			 min_t(size_t, ev->u.input.size, UHID_DATA_MAX), 0);
+
+	return 0;
+}
+
+static int uhid_dev_feature_answer(struct uhid_device *uhid,
+				   struct uhid_event *ev)
+{
+	unsigned long flags;
+
+	if (!uhid->running)
+		return -EINVAL;
+
+	spin_lock_irqsave(&uhid->qlock, flags);
+
+	
+	if (atomic_read(&uhid->report_id) != ev->u.feature_answer.id)
+		goto unlock;
+	if (atomic_read(&uhid->report_done))
+		goto unlock;
+
+	memcpy(&uhid->report_buf, ev, sizeof(*ev));
+	atomic_set(&uhid->report_done, 1);
+	wake_up_interruptible(&uhid->report_wait);
+
+unlock:
+	spin_unlock_irqrestore(&uhid->qlock, flags);
+	return 0;
+}
+
+static int uhid_char_open(struct inode *inode, struct file *file)
+{
+	struct uhid_device *uhid;
+
+	uhid = kzalloc(sizeof(*uhid), GFP_KERNEL);
+	if (!uhid)
+		return -ENOMEM;
+
+	mutex_init(&uhid->devlock);
+	mutex_init(&uhid->report_lock);
+	spin_lock_init(&uhid->qlock);
+	init_waitqueue_head(&uhid->waitq);
+	init_waitqueue_head(&uhid->report_wait);
+	uhid->running = false;
+	atomic_set(&uhid->report_done, 1);
+
+	file->private_data = uhid;
+	nonseekable_open(inode, file);
+
+	return 0;
+}
+
+static int uhid_char_release(struct inode *inode, struct file *file)
+{
+	struct uhid_device *uhid = file->private_data;
+	unsigned int i;
+
+	uhid_dev_destroy(uhid);
+
+	for (i = 0; i < UHID_BUFSIZE; ++i)
+		kfree(uhid->outq[i]);
+
+	kfree(uhid);
+
+	return 0;
+}
+
+static ssize_t uhid_char_read(struct file *file, char __user *buffer,
+				size_t count, loff_t *ppos)
+{
+	struct uhid_device *uhid = file->private_data;
+	int ret;
+	unsigned long flags;
+	size_t len;
+
+	
+	if (count < sizeof(__u32))
+		return -EINVAL;
+
+try_again:
+	if (file->f_flags & O_NONBLOCK) {
+		if (uhid->head == uhid->tail)
+			return -EAGAIN;
+	} else {
+		ret = wait_event_interruptible(uhid->waitq,
+						uhid->head != uhid->tail);
+		if (ret)
+			return ret;
+	}
+
+	ret = mutex_lock_interruptible(&uhid->devlock);
+	if (ret)
+		return ret;
+
+	if (uhid->head == uhid->tail) {
+		mutex_unlock(&uhid->devlock);
+		goto try_again;
+	} else {
+		len = min(count, sizeof(**uhid->outq));
+		if (copy_to_user(buffer, uhid->outq[uhid->tail], len)) {
+			ret = -EFAULT;
+		} else {
+			kfree(uhid->outq[uhid->tail]);
+			uhid->outq[uhid->tail] = NULL;
+
+			spin_lock_irqsave(&uhid->qlock, flags);
+			uhid->tail = (uhid->tail + 1) % UHID_BUFSIZE;
+			spin_unlock_irqrestore(&uhid->qlock, flags);
+		}
+	}
+
+	mutex_unlock(&uhid->devlock);
+	return ret ? ret : len;
+}
+
+static ssize_t uhid_char_write(struct file *file, const char __user *buffer,
+				size_t count, loff_t *ppos)
+{
+	struct uhid_device *uhid = file->private_data;
+	int ret;
+	size_t len;
+
+	
+	if (count < sizeof(__u32))
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&uhid->devlock);
+	if (ret)
+		return ret;
+
+	memset(&uhid->input_buf, 0, sizeof(uhid->input_buf));
+	len = min(count, sizeof(uhid->input_buf));
+	if (copy_from_user(&uhid->input_buf, buffer, len)) {
+		ret = -EFAULT;
+		goto unlock;
+	}
+
+	switch (uhid->input_buf.type) {
+	case UHID_CREATE:
+		ret = uhid_dev_create(uhid, &uhid->input_buf);
+		break;
+	case UHID_DESTROY:
+		ret = uhid_dev_destroy(uhid);
+		break;
+	case UHID_INPUT:
+		ret = uhid_dev_input(uhid, &uhid->input_buf);
+		break;
+	case UHID_FEATURE_ANSWER:
+		ret = uhid_dev_feature_answer(uhid, &uhid->input_buf);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+unlock:
+	mutex_unlock(&uhid->devlock);
+
+	
+	return ret ? ret : count;
+}
+
+static unsigned int uhid_char_poll(struct file *file, poll_table *wait)
+{
+	struct uhid_device *uhid = file->private_data;
+
+	poll_wait(file, &uhid->waitq, wait);
+
+	if (uhid->head != uhid->tail)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static const struct file_operations uhid_fops = {
+	.owner		= THIS_MODULE,
+	.open		= uhid_char_open,
+	.release	= uhid_char_release,
+	.read		= uhid_char_read,
+	.write		= uhid_char_write,
+	.poll		= uhid_char_poll,
+	.llseek		= no_llseek,
+};
+
+static struct miscdevice uhid_misc = {
+	.fops		= &uhid_fops,
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= UHID_NAME,
+};
+
+static int __init uhid_init(void)
+{
+	return misc_register(&uhid_misc);
+}
+
+static void __exit uhid_exit(void)
+{
+	misc_deregister(&uhid_misc);
+}
+
+module_init(uhid_init);
+module_exit(uhid_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Herrmann <dh.herrmann@gmail.com>");
+MODULE_DESCRIPTION("User-space I/O driver support for HID subsystem");
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/akm8963.c monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/akm8963.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/akm8963.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/akm8963.c	2013-08-01 23:38:02.000000000 -0600
@@ -325,7 +325,7 @@
 
 static void AKECS_SetYPR(
 	struct akm8963_data *akm,
-	int *rbuf)
+	int32_t *rbuf)
 {
 	uint32_t ready;
 	AKM_DATA(&akm->i2c->dev, "AKM8963 %s: flag =0x%X", __func__,
@@ -360,6 +360,16 @@
 		input_report_abs(akm->input, ABS_RY, rbuf[6]);
 		input_report_abs(akm->input, ABS_RZ, rbuf[7]);
 		input_report_abs(akm->input, ABS_RUDDER, rbuf[8]);
+
+		
+		
+		input_report_abs(akm->input, ABS_GAS,   rbuf[12]);
+		input_report_abs(akm->input, ABS_BRAKE, rbuf[13]);
+		input_report_abs(akm->input, ABS_HAT2X, rbuf[14]);
+		input_report_abs(akm->input, ABS_HAT2Y, rbuf[15]);
+		input_report_abs(akm->input, ABS_HAT3X, rbuf[16]);
+		input_report_abs(akm->input, ABS_HAT3Y, rbuf[17]);
+		
 	}
 	
 	if (ready & ORI_DATA_READY) {
@@ -1187,6 +1197,19 @@
 			-5760, 5760, 0, 0);
 	input_set_abs_params(*input, ABS_HAT1Y,
 			0, 3, 0, 0);
+	
+	input_set_abs_params(*input, ABS_GAS,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_BRAKE,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_HAT2X,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_HAT2Y,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_HAT3X,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_HAT3Y,
+			-32768, 32767, 0, 0);
 
 	
 	(*input)->name = "compass";
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/bma250_bosch.c monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/bma250_bosch.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/bma250_bosch.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/bma250_bosch.c	2013-08-01 23:38:02.000000000 -0600
@@ -25,6 +25,7 @@
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 #endif
+#include <linux/wakelock.h>
 
 #include <linux/bma250.h>
 #define D(x...) printk(KERN_DEBUG "[GSNR][BMA250_BOSCH] " x)
@@ -53,6 +54,7 @@
 	struct mutex value_mutex;
 	struct mutex enable_mutex;
 	struct mutex mode_mutex;
+	struct mutex sig_mo_mutex;
 	struct delayed_work work;
 	struct work_struct irq_work;
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -67,12 +69,19 @@
 
 	struct bma250_platform_data *pdata;
 	short offset_buf[3];
+
+#ifdef CONFIG_SIG_MOTION
+	struct input_dev *input_sig_motion;
+	atomic_t en_sig_motion;
+	int ref_count;
+	struct wake_lock sig_wake_lock;
+#endif
 };
 
 struct bma250_data *gdata;
 
 #ifdef CONFIG_CIR_ALWAYS_READY
-#define BMA250_ENABLE_INT1 1
+#define CONFIG_BMA250_ENABLE_INT1 1
 static int cir_flag = 0;
 static int power_key_pressed = 0;
 #endif
@@ -83,13 +92,27 @@
 static void bma250_late_resume(struct early_suspend *h);
 #endif
 
+#define I2C_RETRY_COUNT  10
+
 static int bma250_smbus_read_byte(struct i2c_client *client,
 		unsigned char reg_addr, unsigned char *data)
 {
 	s32 dummy;
-	dummy = i2c_smbus_read_byte_data(client, reg_addr);
-	if (dummy < 0)
+	int retry = 0;
+
+	for (retry = 0; retry < I2C_RETRY_COUNT; retry++) {
+		dummy = i2c_smbus_read_byte_data(client, reg_addr);
+		if (dummy < 0) {
+			mdelay(10);
+			continue;
+		} else
+			break;
+	}
+
+	if (dummy < 0) {
+		E("%s: i2c_smbus_read_byte_data fails, dummy = %d\n", __func__, dummy);
 		return -1;
+	}
 	*data = dummy & 0x000000ff;
 
 	return 0;
@@ -99,9 +122,22 @@
 		unsigned char reg_addr, unsigned char *data)
 {
 	s32 dummy;
-	dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
-	if (dummy < 0)
+	int retry = 0;
+
+	for (retry = 0; retry < I2C_RETRY_COUNT; retry++) {
+		dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+		if (dummy < 0) {
+			mdelay(10);
+			continue;
+		} else
+			break;
+	}
+
+	if (dummy < 0) {
+		E("%s: i2c_smbus_write_byte_data fails, dummy = %d\n", __func__, dummy);
 		return -1;
+	}
+
 	return 0;
 }
 
@@ -109,9 +145,22 @@
 		unsigned char reg_addr, unsigned char *data, unsigned char len)
 {
 	s32 dummy;
-	dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
-	if (dummy < 0)
+	int retry = 0;
+
+	for (retry = 0; retry < I2C_RETRY_COUNT; retry++) {
+		dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+		if (dummy < 0) {
+			mdelay(10);
+			continue;
+		} else
+			break;
+	}
+
+	if (dummy < 0) {
+		E("%s: i2c_smbus_read_i2c_block_data fails, dummy = %d\n", __func__, dummy);
 		return -1;
+	}
+
 	return 0;
 }
 
@@ -119,12 +168,40 @@
 {
 	int comres = 0;
 	unsigned char data1;
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
 
 #ifdef CONFIG_CIR_ALWAYS_READY
 	if(cir_flag && Mode == BMA250_MODE_SUSPEND) {
 	    return 0;
 	} else {
 #endif
+	I("%s++: mode = %d, bma250->ref_count = %d\n", __func__, Mode, bma250->ref_count);
+
+	mutex_lock(&bma250->mode_mutex);
+	if (BMA250_MODE_SUSPEND == Mode) {
+		if (bma250->ref_count > 0) {
+			bma250->ref_count--;
+			if (0 < bma250->ref_count) {
+				mutex_unlock(&bma250->mode_mutex);
+				I("%s--11: mode = %d, bma250->ref_count = %d\n", __func__, Mode, bma250->ref_count);
+				return 0;
+			}
+		}
+
+	} else {
+		bma250->ref_count++;
+		if (1 < bma250->ref_count) {
+			mutex_unlock(&bma250->mode_mutex);
+			I("%s--22: mode = %d, bma250->ref_count = %d\n", __func__, Mode, bma250->ref_count);
+			return 0;
+		}
+
+		
+		if (bma250->pdata->power_LPM) {
+			D("%s: Set to High Power mode!!\n", __func__);
+			bma250->pdata->power_LPM(0);
+		}
+	}
 
 	if (Mode < 3) {
 		comres = bma250_smbus_read_byte(client,
@@ -147,6 +224,12 @@
 					BMA250_EN_LOW_POWER, 0);
 			data1  = BMA250_SET_BITSLICE(data1,
 					BMA250_EN_SUSPEND, 1);
+
+			
+			if (bma250->pdata->power_LPM) {
+				I("%s: Set to Low Power mode!!\n", __func__);
+				bma250->pdata->power_LPM(1);
+			}
 			break;
 		default:
 			break;
@@ -161,10 +244,12 @@
 	}
 #endif
 
+	mutex_unlock(&bma250->mode_mutex);
 
+	I("%s--33: mode = %d, bma250->ref_count = %d\n", __func__, Mode, bma250->ref_count);
 	return comres;
 }
-#ifdef BMA250_ENABLE_INT1
+#ifdef CONFIG_BMA250_ENABLE_INT1
 static int bma250_set_int1_pad_sel(struct i2c_client *client, unsigned char
 		int1sel)
 {
@@ -321,7 +406,13 @@
 
 
 	comres = bma250_smbus_read_byte(client, BMA250_INT_ENABLE1_REG, &data1);
+	if (comres)
+		E("%s: bma250_smbus_read_byte(BMA250_INT_ENABLE1_REG) fails\n", __func__);
+
 	comres = bma250_smbus_read_byte(client, BMA250_INT_ENABLE2_REG, &data2);
+	if (comres)
+		E("%s: bma250_smbus_read_byte(BMA250_INT_ENABLE2_REG) fails\n", __func__);
+
 
 	value = value & 1;
 	switch (InterruptType) {
@@ -546,7 +637,8 @@
 	return comres;
 }
 
-#if defined(BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
+#if defined(CONFIG_BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
+#if 0
 static int bma250_get_interruptstatus1(struct i2c_client *client, unsigned char
 		*intstatus)
 {
@@ -558,6 +650,7 @@
 
 	return comres;
 }
+#endif
 
 #if 0
 static int bma250_get_HIGH_first(struct i2c_client *client, unsigned char
@@ -1701,7 +1794,7 @@
 	if (bma250_get_mode(bma250->bma250_client, &data) < 0)
 		return sprintf(buf, "Read error\n");
 
-	return sprintf(buf, "%d\n", data);
+	return sprintf(buf, "%d %d\n", data, bma250->ref_count);
 }
 
 static ssize_t bma250_mode_store(struct device *dev,
@@ -1712,10 +1805,12 @@
 	int error;
 	struct i2c_client *client = to_i2c_client(dev);
 	struct bma250_data *bma250 = i2c_get_clientdata(client);
-	I("bma250_mode_store\n");
 	error = strict_strtoul(buf, 10, &data);
 	if (error)
 		return error;
+
+	I("%s: data = %lu\n", __func__, data);
+
 	if (bma250_set_mode(bma250->bma250_client, (unsigned char) data) < 0)
 	    return -EINVAL;
 
@@ -1785,10 +1880,10 @@
 	int pre_enable = atomic_read(&bma250->enable);
 	int i = 0;
 
+	I("%s: enable = %d\n", __func__, enable);
+
 	mutex_lock(&bma250->enable_mutex);
 	if (enable) {
-		if (bma250->pdata->power_LPM)
-			bma250->pdata->power_LPM(0);
 
 		if (pre_enable == 0) {
 			bma250_set_mode(bma250->bma250_client,
@@ -1805,14 +1900,6 @@
 			cancel_delayed_work_sync(&bma250->work);
 			atomic_set(&bma250->enable, 0);
 		}
-
-#ifdef CONFIG_CIR_ALWAYS_READY
-		if (bma250->pdata->power_LPM && !cir_flag)
-#else
-
-		if (bma250->pdata->power_LPM)
-#endif
-			bma250->pdata->power_LPM(1);
 	}
 
 	if ((bma250->pdata->gs_kvalue & (0x67 << 24)) != (0x67 << 24)) {
@@ -1846,12 +1933,129 @@
 	error = strict_strtoul(buf, 10, &data);
 	if (error)
 		return error;
+
+	I("%s: data = %lu\n", __func__, data);
+
 	if ((data == 0) || (data == 1))
 		bma250_set_enable(dev, data);
 
 	return count;
 }
 
+
+static ssize_t bma250_en_sig_motion_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", atomic_read(&bma250->en_sig_motion));
+
+}
+
+
+static int bma250_set_en_slope_int(struct bma250_data *bma250,
+		int en)
+{
+	int err;
+	struct i2c_client *client = bma250->bma250_client;
+
+	if (client == NULL) {
+		E("%s: client == NULL!!", __func__);
+		return -1;
+	}
+
+	if (en) {
+		err = bma250_set_slope_duration(client, 0x03);
+		if (err)
+			E("%s: bma250_set_slope_duration() fails!\n", __func__);
+
+		err = bma250_set_slope_threshold(client, 0x28);
+		if (err)
+			E("%s: bma250_set_slope_threshold() fails!\n", __func__);
+
+		
+		err = bma250_set_Int_Enable(client, 5, 1);
+		if (err)
+			E("%s: bma250_set_Int_Enable(5, 1) fails!\n", __func__);
+
+		err = bma250_set_Int_Enable(client, 6, 1);
+		if (err)
+			E("%s: bma250_set_Int_Enable(6, 1) fails!\n", __func__);
+
+		err = bma250_set_Int_Enable(client, 7, 1);
+		if (err)
+			E("%s: bma250_set_Int_Enable(7, 1) fails!\n", __func__);
+
+		err = bma250_set_int1_pad_sel(client, PAD_SLOP);
+		if (err)
+			E("%s: bma250_set_int1_pad_sel() fails!\n", __func__);
+	} else {
+		err = bma250_set_Int_Enable(client, 5, 0);
+		if (err)
+			E("%s: bma250_set_Int_Enable(5, 0) fails!\n", __func__);
+
+		err = bma250_set_Int_Enable(client, 6, 0);
+		if (err)
+			E("%s: bma250_set_Int_Enable(6, 0) fails!\n", __func__);
+
+		err = bma250_set_Int_Enable(client, 7, 0);
+		if (err)
+			E("%s: bma250_set_Int_Enable(7, 0) fails!\n", __func__);
+	}
+	return err;
+}
+
+
+static int bma250_set_en_sig_motion(struct bma250_data *bma250,
+		int en)
+{
+	int err = 0;
+
+	mutex_lock(&bma250->sig_mo_mutex);
+	I("%s++: en = %d, mutex locked\n", __func__, en);
+
+	if (en) {
+		bma250_set_mode(bma250->bma250_client,
+				bma250_MODE_NORMAL);
+		bma250_set_en_slope_int(bma250, en);
+	} else {
+		bma250_set_en_slope_int(bma250, en);
+		bma250_set_mode(bma250->bma250_client,
+				BMA250_MODE_SUSPEND);
+	}
+
+	mutex_unlock(&bma250->sig_mo_mutex);
+	I("%s--: mutex unlocked\n", __func__);
+
+	return err;
+}
+
+
+static ssize_t bma250_en_sig_motion_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	I("%s: data = %lu\n", __func__, data);
+
+	if ((data == 0) || (data == 1)) {
+		bma250_set_en_sig_motion(bma250, data);
+		atomic_set(&bma250->en_sig_motion, data);
+	}
+
+	return count;
+}
+
+
 static ssize_t bma250_enable_int_store(struct device *dev,
 		struct device_attribute *attr,
 		const char *buf, size_t count)
@@ -2875,6 +3079,8 @@
 		NULL, bma250_enable_int_store);
 static DEVICE_ATTR(int_mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
 		bma250_int_mode_show, bma250_int_mode_store);
+static DEVICE_ATTR(en_sig_motion, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_en_sig_motion_show, bma250_en_sig_motion_store);
 static DEVICE_ATTR(slope_duration, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
 		bma250_slope_duration_show, bma250_slope_duration_store);
 static DEVICE_ATTR(slope_threshold, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
@@ -2943,6 +3149,7 @@
 	&dev_attr_enable.attr,
 	&dev_attr_enable_int.attr,
 	&dev_attr_int_mode.attr,
+	&dev_attr_en_sig_motion.attr,
 	&dev_attr_slope_duration.attr,
 	&dev_attr_slope_threshold.attr,
 	&dev_attr_high_g_duration.attr,
@@ -2980,8 +3187,7 @@
 };
 
 
-#ifdef CONFIG_CIR_ALWAYS_READY
-#if defined(BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
+#if defined(CONFIG_BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
 unsigned char *orient_st[] = {"upward looking portrait upright",   \
 	"upward looking portrait upside-down",   \
 		"upward looking landscape left",   \
@@ -2996,25 +3202,21 @@
 	struct bma250_data *bma250 = container_of((struct work_struct *)work,
 			struct bma250_data, irq_work);
 
-	unsigned char status = 0;
 	
 	
 	
-	bma250_get_interruptstatus1(bma250->bma250_client, &status);
-	I("bma250_irq_work_func, status = 0x%x\n", status);
-	input_report_rel(bma250->input_cir,
-		SLOP_INTERRUPT,
-		SLOPE_INTERRUPT_X_NEGATIVE_HAPPENED);
-	input_report_rel(bma250->input_cir,
-		SLOP_INTERRUPT,
-		SLOPE_INTERRUPT_Y_NEGATIVE_HAPPENED);
-	input_report_rel(bma250->input_cir,
-		SLOP_INTERRUPT,
-		SLOPE_INTERRUPT_X_HAPPENED);
-	input_report_rel(bma250->input_cir,
-		SLOP_INTERRUPT,
-		SLOPE_INTERRUPT_Y_HAPPENED);
-	input_sync(bma250->input_cir);
+	
+	
+	
+	I("bma250_irq_work_func++\n");
+	wake_lock_timeout(&(bma250->sig_wake_lock), 1*HZ);
+	I("%s: wake_lock!\n", __func__);
+
+#ifdef CONFIG_SIG_MOTION
+	input_report_rel(bma250->input_sig_motion,
+		SLOP_INTERRUPT, 1);
+	input_sync(bma250->input_sig_motion);
+#endif
 	enable_irq(bma250->IRQ);
 
 }
@@ -3040,7 +3242,6 @@
 
 }
 #endif
-#endif 
 static int bma250_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
@@ -3048,6 +3249,7 @@
 	unsigned char tempvalue;
 	struct bma250_data *data;
 	struct input_dev *dev;
+	struct input_dev *dev_sig_motion;
 #ifdef CONFIG_CIR_ALWAYS_READY
 	struct input_dev *dev_cir;
 	struct class *bma250_powerkey_class = NULL;
@@ -3084,7 +3286,7 @@
 	bma250_set_bandwidth(client, BMA250_BW_SET);
 	bma250_set_range(client, BMA250_RANGE_SET);
 
-	data->pdata = kmalloc(sizeof(*data->pdata), GFP_KERNEL);
+	data->pdata = kzalloc(sizeof(*data->pdata), GFP_KERNEL);
 	if (data->pdata == NULL) {
 		dev_err(&client->dev,
 			"failed to allocate memory for pdata: %d\n", err);
@@ -3109,9 +3311,9 @@
 	gdata = data;
 	D("%s: layout = %d\n", __func__, gdata->chip_layout);
 
-#if defined(BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
+#if defined(CONFIG_BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
 #endif
-#ifdef BMA250_ENABLE_INT1
+#ifdef CONFIG_BMA250_ENABLE_INT1
 	
 #endif
 
@@ -3127,7 +3329,7 @@
 	bma250_set_int2_pad_sel(client, PAD_FLAT);
 #endif
 
-#if defined(BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
+#if defined(CONFIG_BMA250_ENABLE_INT1) || defined(BMA250_ENABLE_INT2)
 	data->IRQ = client->irq;
 	err = request_irq(data->IRQ, bma250_irq_handler, IRQF_TRIGGER_RISING,
 			"bma250", data);
@@ -3155,6 +3357,18 @@
 	    return -ENOMEM;
 	}
 #endif
+
+
+#ifdef CONFIG_SIG_MOTION
+	dev_sig_motion = input_allocate_device();
+	if (!dev_sig_motion) {
+	    kfree(data);
+	    input_free_device(dev_sig_motion);
+	    return -ENOMEM;
+	}
+#endif
+
+
 	dev->name = SENSOR_NAME;
 	dev->id.bustype = BUS_I2C;
 #ifdef CONFIG_CIR_ALWAYS_READY
@@ -3164,6 +3378,16 @@
 	input_set_capability(dev_cir, EV_REL, SLOP_INTERRUPT);
 	input_set_drvdata(dev_cir, data);
 #endif
+
+
+#ifdef CONFIG_SIG_MOTION
+	dev_sig_motion->name = "sig_motion";
+	dev_sig_motion->id.bustype = BUS_I2C;
+
+	input_set_capability(dev_sig_motion, EV_REL, SLOP_INTERRUPT);
+	input_set_drvdata(dev_sig_motion, data);
+#endif
+
 	input_set_capability(dev, EV_ABS, ORIENT_INTERRUPT);
 	input_set_capability(dev, EV_ABS, FLAT_INTERRUPT);
 	input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, 0, 0);
@@ -3185,11 +3409,22 @@
 	}
 #endif
 
+#ifdef CONFIG_SIG_MOTION
+	err = input_register_device(dev_sig_motion);
+	if (err < 0) {
+	    goto err_register_input_device_sig_motion;
+	}
+#endif
+
 	data->input = dev;
 #ifdef CONFIG_CIR_ALWAYS_READY
 	data->input_cir = dev_cir;
 #endif
 
+#ifdef CONFIG_SIG_MOTION
+	data->input_sig_motion = dev_sig_motion;
+#endif
+
 #ifdef HTC_ATTR
 
 
@@ -3253,8 +3488,15 @@
 
 	mutex_init(&data->value_mutex);
 	mutex_init(&data->mode_mutex);
+	mutex_init(&data->sig_mo_mutex);
 	mutex_init(&data->enable_mutex);
 
+#ifdef CONFIG_SIG_MOTION
+	data->ref_count = 0;
+	atomic_set(&data->en_sig_motion, 0);
+#endif
+	wake_lock_init(&(data->sig_wake_lock), WAKE_LOCK_SUSPEND, "sig_motion");
+
 	I("%s: BMA250 BOSCH driver probe successful", __func__);
 
 	return 0;
@@ -3268,12 +3510,21 @@
 	class_destroy(bma250_powerkey_class);
 #endif
 err_create_class:
+
+#ifdef CONFIG_SIG_MOTION
+	input_unregister_device(data->input_sig_motion);
+err_register_input_device_sig_motion:
+#endif
+
 #ifdef CONFIG_CIR_ALWAYS_READY
 	input_unregister_device(data->input_cir);
 err_register_input_cir_device:
 #endif
 	input_unregister_device(data->input);
 err_register_input_device:
+#ifdef CONFIG_SIG_MOTION
+	input_free_device(dev_sig_motion);
+#endif
 #ifdef CONFIG_CIR_ALWAYS_READY
 	input_free_device(dev_cir);
 #endif
@@ -3341,7 +3592,7 @@
 {
 	struct bma250_data *data = i2c_get_clientdata(client);
 
-	D("%s++\n", __func__);
+	I("%s++\n", __func__);
 
 	mutex_lock(&data->enable_mutex);
 	if (atomic_read(&data->enable) == 1) {
@@ -3350,18 +3601,7 @@
 		cancel_delayed_work_sync(&data->work);
 	}
 	mutex_unlock(&data->enable_mutex);
-
-#ifdef CONFIG_CIR_ALWAYS_READY
-	
-	if (data && (data->pdata->power_LPM) && !cir_flag){
-#else
-
-	if (data && (data->pdata->power_LPM)){
-#endif
-	    I("suspend + power_LPM\n");
-		data->pdata->power_LPM(1);
-	}
-
+	I("%s--\n", __func__);
 	return 0;
 }
 
@@ -3369,7 +3609,7 @@
 {
 	struct bma250_data *data = i2c_get_clientdata(client);
 
-	D("%s++\n", __func__);
+	I("%s++\n", __func__);
 
 	mutex_lock(&data->enable_mutex);
 	if (atomic_read(&data->enable) == 1) {
@@ -3379,7 +3619,7 @@
 				msecs_to_jiffies(atomic_read(&data->delay)));
 	}
 	mutex_unlock(&data->enable_mutex);
-
+	I("%s--\n", __func__);
 	return 0;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/cm3629.c monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/cm3629.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/cm3629.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/cm3629.c	2013-08-01 23:38:02.000000000 -0600
@@ -49,7 +49,7 @@
 #define Max_open_value 50
 #ifdef POLLING_PROXIMITY
 #define POLLING_DELAY		200
-#define TH_ADD			5
+#define TH_ADD			10
 #endif
 static int record_init_fail = 0;
 static void sensor_irq_do_work(struct work_struct *work);
@@ -65,7 +65,12 @@
 static DECLARE_DELAYED_WORK(report_near_work, report_near_do_work);
 static int inter_error = 0;
 static int is_probe_success;
-
+static int lightsensor_cali;
+static int psensor_cali;
+static int min_adc = 255;
+static int call_count = 0;
+static int record_adc[6] = {0};
+static int avg_min_adc = 0;
 struct cm3629_info {
 	struct class *cm3629_class;
 	struct device *ls_dev;
@@ -329,6 +334,7 @@
 	int ret = 0;
 	char cmd[3];
 	char ls_cmd;
+	uint32_t als_step_temp = 0;
 
 	if (als_step == NULL)
 		return -EFAULT;
@@ -376,7 +382,11 @@
 
 
 	if (!lpi->ls_calibrate && !lpi->ws_calibrate) {
+		als_step_temp = *als_step;
 		*als_step = (*als_step) * lpi->als_gadc / lpi->als_kadc;
+		if( ((*als_step)*lpi->als_kadc) < (als_step_temp*lpi->als_gadc)) {
+			*als_step = (*als_step) + 1;
+		}
 		if (*als_step > 0xFFFF)
 			*als_step = 0xFFFF;
 	}
@@ -593,8 +603,8 @@
 			input_sync(lpi->ps_input_dev);
 		}
 	}
-	D("[PS][cm3629] proximity %s, ps_adc=%d, High thd= %d, interrupt_flag %d\n",
-	  val ? "FAR" : "NEAR", ps_adc, ps_thd_set, interrupt_flag);
+	D("[PS][cm3629] proximity %s, ps_adc=%d, High thd= %d, interrupt_flag %d, calibration %d\n",
+	  val ? "FAR" : "NEAR", ps_adc, ps_thd_set, interrupt_flag, psensor_cali);
 	if (lpi->dynamical_threshold == 1 && val == 0 && lpi->mfg_mode != MFG_MODE &&
 			pocket_mode_flag != 1 && psensor_enable_by_touch != 1 &&
 				time_before(lpi->j_end, (lpi->j_start + NEAR_DELAY_TIME))) {
@@ -682,11 +692,11 @@
 		printk(KERN_ERR "[LS][cm3629 error] %s fail\n", __func__);
 
 	if ((i == 0) || (adc_value == 0))
-		D("[LS][cm3629] %s: ADC=0x%03X, Level=%d, l_thd equal 0, h_thd = 0x%x \n",
-			__func__, adc_value, level, *(lpi->cali_table + i));
+		D("[LS][cm3629] %s: ADC=0x%03X, Level=%d, l_thd equal 0, h_thd = 0x%x, calibration %d \n",
+			__func__, adc_value, level, *(lpi->cali_table + i), lightsensor_cali);
 	else
-		D("[LS][cm3629] %s: ADC=0x%03X, Level=%d, l_thd = 0x%x, h_thd = 0x%x \n",
-			__func__, adc_value, level, *(lpi->cali_table + (i - 1)) + 1, *(lpi->cali_table + i));
+		D("[LS][cm3629] %s: ADC=0x%03X, Level=%d, l_thd = 0x%x, h_thd = 0x%x, calibration %d \n",
+			__func__, adc_value, level, *(lpi->cali_table + (i - 1)) + 1, *(lpi->cali_table + i), lightsensor_cali);
 	current_lightsensor_adc = adc_value;
 	lpi->current_level = level;
         lpi->current_adc = adc_value;
@@ -847,24 +857,36 @@
 	int i = 0;
 	int ret = 0;
 	char cmd[3];
-
 	
 	if (lpi->ps_enable == 0)
 		return;
 
 	ret = get_stable_ps_adc_value(&ps_adc1, &ps_adc2);
 
-	if ((ps_adc1 == 0) || (ret < 0)) {
-		queue_delayed_work(lpi->lp_wq, &polling_work,
-			msecs_to_jiffies(POLLING_DELAY));
-		return;
+	if (min_adc > ps_adc1) {
+		avg_min_adc = 0;
+		min_adc = ps_adc1;
+		if (call_count < 3) {
+			avg_min_adc = min_adc;
+			for (i = 0; i < 5; i++)
+				record_adc[i] = avg_min_adc;
+		} else {
+			record_adc[5] = min_adc;
+			for (i = 1 ;i <= 5; i++) {
+				avg_min_adc = avg_min_adc + record_adc[i];
+			}
+			D("[PS][cm3629] %s: record_adc[1-5]: %d, %d, %d, %d, %d\n", __func__, record_adc[1], record_adc[2], record_adc[3], record_adc[4], record_adc[5]);
+			avg_min_adc = avg_min_adc / 5;
+			if ((min_adc - avg_min_adc) >= lpi->ps_th_add)
+				avg_min_adc = min_adc;
+		}
 	}
 
 	for (i = lpi->ps_base_index; i >= 1; i--) {
-		if (ps_adc1 > lpi->mapping_table[i])
+		if (avg_min_adc > lpi->mapping_table[i])
 			break;
-		else if ((ps_adc1 > lpi->mapping_table[(i-1)]) &&
-		    (ps_adc1 <= lpi->mapping_table[i])) {
+		else if ((avg_min_adc > lpi->mapping_table[(i-1)]) &&
+		    (avg_min_adc <= lpi->mapping_table[i])) {
 			lpi->ps_base_index = (i-1);
 
 			if (i == (lpi->mapping_size - 1))
@@ -873,7 +895,7 @@
 				lpi->ps1_thd_set = (lpi->mapping_table[i] +
 						   lpi->ps_th_add);
 
-			if (lpi->ps1_thd_set <= ps_adc1)
+			if (lpi->ps1_thd_set <= avg_min_adc)
 				lpi->ps1_thd_set = 0xFF;
 
 			
@@ -888,13 +910,29 @@
 
 			_cm3629_I2C_Write2(lpi->cm3629_slave_address,
 				PS_1_thd, cmd, 3);
-			D("[PS][cm3629] SET THD: lpi->ps1_thd_set = %d,"
-				" cmd[0] = 0x%x, cmd[1] = 0x%x\n",
-				lpi->ps1_thd_set, cmd[0], cmd[1]);
+			D("[PS][cm3629] SET THD1: lpi->ps1_thd_set = %d,"
+				" cmd[0] = 0x%x, cmd[1] = 0x%x, avg_min_adc = %d\n",
+				lpi->ps1_thd_set, cmd[0], cmd[1], avg_min_adc);
 			break;
 		}
 	}
-
+	if (avg_min_adc == 0 && lpi->ps1_thd_set != (lpi->mapping_table[0] + lpi->ps_th_add)) {
+		lpi->ps1_thd_set = (lpi->mapping_table[0] + lpi->ps_th_add);
+		
+		cmd[0] = lpi->ps1_thd_set;
+		if (lpi->ps1_thh_diff == 0)
+			cmd[1] = lpi->ps1_thd_set + 1;
+		else
+			cmd[1] = lpi->ps1_thd_set + lpi->ps1_thh_diff;
+                if (cmd[1] < cmd[0])
+			cmd[1] = cmd[0];
+
+		_cm3629_I2C_Write2(lpi->cm3629_slave_address,
+			PS_1_thd, cmd, 3);
+		D("[PS][cm3629] SET THD2: lpi->ps1_thd_set = %d,"
+			" cmd[0] = 0x%x, cmd[1] = 0x%x, avg_min_adc = %d\n",
+			lpi->ps1_thd_set, cmd[0], cmd[1], avg_min_adc);
+	}
 	queue_delayed_work(lpi->lp_wq, &polling_work,
 		msecs_to_jiffies(POLLING_DELAY));
 }
@@ -1009,7 +1047,7 @@
 	psensor_initial_cmd(lpi);
 
 	if (lpi->dynamical_threshold == 1 && lpi->mfg_mode != MFG_MODE &&
-			pocket_mode_flag != 1 && psensor_enable_by_touch != 1 && phone_status ==1) {
+			pocket_mode_flag != 1 && psensor_enable_by_touch != 1 ) {
 		
 		D("[PS][cm3629] default report FAR ");
 		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, 1);
@@ -1045,7 +1083,7 @@
 		return ret;
 	}
 	if (lpi->dynamical_threshold == 1 && lpi->mfg_mode != MFG_MODE &&
-		pocket_mode_flag != 1 && psensor_enable_by_touch != 1 && phone_status ==1) {
+		pocket_mode_flag != 1 && psensor_enable_by_touch != 1 ) {
 
 			msleep(40);
 			ret = get_stable_ps_adc_value(&ps_adc1, &ps_adc2);
@@ -1075,7 +1113,7 @@
 {
 	int ret = -EIO;
 	char cmd[2];
-
+	int i;
 	mutex_lock(&ps_enable_mutex);
 
 	D("[PS][cm3629] %s %d\n", __func__, lpi->ps_enable);
@@ -1119,6 +1157,13 @@
 	lpi->ps_enable = 0;
 	if (lpi->dynamical_threshold == 1 && lpi->mfg_mode != MFG_MODE) {
 		cancel_delayed_work(&polling_work);
+
+		if ((call_count >= 3) && (record_adc[5] < Max_open_value) && lpi->psensor_opened) {
+			for (i=0;i<5;i++)
+				record_adc[i] = record_adc[i+1];
+		}
+		D("[PS][cm3629] %s: record_adc[0-4]: %d, %d, %d, %d, %d\n", __func__, record_adc[0], record_adc[1], record_adc[2], record_adc[3], record_adc[4]);
+		min_adc = 255;
 		lpi->ps_base_index = (lpi->mapping_size - 1);
 		if (lpi->ps1_thd_set > Max_open_value) {
 			lpi->ps1_thd_set = lpi->original_ps_thd_set;
@@ -1142,12 +1187,16 @@
 {
 	struct cm3629_info *lpi = lp_info;
 
-	D("[PS][cm3629] %s\n", __func__);
+	D("[PS][cm3629] %s, calibration:%d\n", __func__, psensor_cali);
+
+	psensor_enable_by_touch_driver(0);
 
 	if (lpi->psensor_opened)
 		return -EBUSY;
 
 	lpi->psensor_opened = 1;
+	if (call_count < 3)
+		call_count++;
 
 	return 0;
 }
@@ -1157,7 +1206,6 @@
 	struct cm3629_info *lpi = lp_info;
 
 	D("[PS][cm3629] %s\n", __func__);
-	phone_status = 0;
 	lpi->psensor_opened = 0;
 
 	return ps_hal_enable ? psensor_disable(lpi) : 0 ;
@@ -1220,10 +1268,12 @@
 	D("[LS][cm3629] %s: ALS calibrated als_kadc=0x%x\n",
 			__func__, als_kadc);
 
-	if (als_kadc >> 16 == ALS_CALIBRATED)
+	if (als_kadc >> 16 == ALS_CALIBRATED) {
 		lpi->als_kadc = als_kadc & 0xFFFF;
-	else {
+		lightsensor_cali = 1;
+	} else {
 		lpi->als_kadc = 0;
+		lightsensor_cali = 0;
 		D("[LS][cm3629] %s: no ALS calibrated\n", __func__);
 	}
 	current_lightsensor_kadc = lpi->als_kadc;
@@ -1277,6 +1327,7 @@
 	ps_conf1_val = lpi->ps_conf1_val;
 	
 	if (ps_kparam1 >> 16 == PS_CALIBRATED) {
+		psensor_cali = 1;
 		lpi->inte_ps1_canc = (uint8_t) (ps_kparam2 & 0xFF);
 		lpi->inte_ps2_canc = (uint8_t) ((ps_kparam2 >> 8) & 0xFF);
 		if (lpi->ps_calibration_rule == 3) {
@@ -1322,6 +1373,7 @@
 		  "inte_ps2_canc = 0x%02X, ((ps_kparam2 >> 16) & 0xFF) = 0x%X\n", __func__,
 		  lpi->inte_ps1_canc, lpi->inte_ps2_canc, ((ps_kparam2 >> 16) & 0xFF));
 	} else {
+		psensor_cali = 0;
 		if (lpi->ps_calibration_rule >= 1) {
 			lpi->ps1_thd_set = lpi->ps1_thd_no_cal;
 			lpi->ps2_thd_set = lpi->ps2_thd_no_cal;
@@ -1416,7 +1468,7 @@
 	struct cm3629_info *lpi = lp_info;
 	int rc = 0;
 
-	D("[LS][cm3629] %s\n", __func__);
+	D("[LS][cm3629] %s, calibration:%d\n", __func__, lightsensor_cali);
 	if (lpi->lightsensor_opened) {
 		pr_err("[LS][cm3629 error]%s: already opened\n", __func__);
 		rc = -EBUSY;
@@ -2236,44 +2288,29 @@
 				const char *buf, size_t count)
 {
 	int phone_status1 = 0;
-	int ret;
 	struct cm3629_info *lpi = lp_info;
-#ifdef POLLING_PROXIMITY
-	uint8_t ps_adc1 = 0;
-	uint8_t ps_adc2 = 0;
-	int index = 0;
-#endif
 
 	sscanf(buf, "%d" , &phone_status1);
 
 	phone_status = phone_status1;
-
 	D("[PS][cm3629] %s: phone_status = %d\n", __func__, phone_status);
-	if (phone_status == 2 && ps_hal_enable == 1 && lpi->dynamical_threshold == 1) {
+	return count; 
+
+	if ((phone_status == 1 || phone_status == 3) && (call_count < 2))
+		call_count++;
+
+
+	if (phone_status == 2 && ps_hal_enable == 1 && lpi->dynamical_threshold == 1
+		&&(lpi->mapping_table != NULL)) {
+
 		
 		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, 1);
 		input_sync(lpi->ps_input_dev);
 
 
-		msleep(40);
-		ret = get_stable_ps_adc_value(&ps_adc1, &ps_adc2);
-		while (index <= 10 && ps_adc1 == 0) {
-			D("[PS][cm3629]ps_adca = 0 retry");
-			ret = get_stable_ps_adc_value(&ps_adc1, &ps_adc2);
-			if (ps_adc1 != 0) {
-				D("[PS][cm3629]retry work");
-				break;
-			}
-			mdelay(1);
-			index++;
-		}
-
-		D("[PS][cm3629] INITIAL ps_adc1 = 0x%02X\n", ps_adc1);
-		if ((ret == 0) && (lpi->mapping_table != NULL))
 			queue_delayed_work(lpi->lp_wq, &polling_work,
 				msecs_to_jiffies(POLLING_DELAY));
 	}
-
 	return count;
 }
 static DEVICE_ATTR(PhoneApp_status, 0666, phone_status_show, phone_status_store);
@@ -2615,7 +2652,7 @@
 	lpi->ps_debounce = pdata->ps_debounce;
 	lpi->ps_delay_time = pdata->ps_delay_time;
 	lpi->no_need_change_setting = pdata->no_need_change_setting;
-	lpi->ps_th_add = TH_ADD;
+	lpi->ps_th_add = (pdata->ps_th_add) ? pdata->ps_th_add : TH_ADD;
 	lpi->dark_level = pdata->dark_level;
 
 	lp_info = lpi;
@@ -2680,10 +2717,10 @@
 	wake_lock_init(&(lpi->ps_wake_lock), WAKE_LOCK_SUSPEND, "proximity");
 
 	psensor_set_kvalue(lpi);
-	lpi->ps1_thd_set = lpi->ps1_thd_set + 50;
-	if (lpi->dynamical_threshold == 1)
+	if (lpi->dynamical_threshold == 1) {
+	        lpi->ps1_thd_set = lpi->ps1_thd_set + 50;
 		lpi->original_ps_thd_set = lpi->ps1_thd_set;
-
+	}
 	ret = cm3629_setup(lpi);
 	if (ret < 0) {
 		pr_err("[PS_ERR][cm3629 error]%s: cm3629_setup error!\n", __func__);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -68,14 +68,14 @@
 	  If you say yes here you get support for Bosch Sensortec's
 	  acceleration sensors BMA250.
 
-config BOSCH_BMA250_ENABLE_INT1
+config BMA250_ENABLE_INT1
 	tristate "BMA250 acceleration sensor interrupt INT1 support"
 	depends on BOSCH_BMA250=y
         help
 	  If you say yes here you get INT1 support for Bosch Sensortec's
 	  acceleration sensors BMA250.
 
-config BOSCH_BMA250_ENABLE_INT2
+config BMA250_ENABLE_INT2
 	tristate "BMA250 acceleration sensor interrupt INT2 support"
 	depends on BOSCH_BMA250=y
 	help
@@ -88,6 +88,12 @@
 	help
 	  BMA250 G-sensor Driver implemented by HTC.
 
+config SENSORS_ONLY_BMA250
+	tristate "BMA250 acceleration sensor support"
+	depends on I2C=y
+	help
+	  BMA250 ONLY G-sensor Driver implemented by HTC.
+
 config SENSORS_BMA2X2
 	tristate "BMA255/BMA250E/BMA222E/BMA280 acceleration sensor support"
 	depends on I2C=y
@@ -161,7 +167,13 @@
         tristate "TI RT5501 AMP Driver"
 	depends on I2C=y
         help
-          TI RT5501 AMP Driver implemented by HTC.
+          RichTek RT5501 AMP Driver implemented by HTC.
+
+config AMP_RT5501_DELAY
+        tristate "RichTek RT5501 AMP Delay Workaround"
+	depends on I2C=y
+        help
+          RichTek RT5501 AMP Delay Workaround for pop noise of headset enable.
 
 config AMP_TFA9887
         tristate "NXP TFA9887 Speaker AMP Driver"
@@ -200,4 +212,9 @@
 	help
 	  Enable CIR Always Ready
 
+config SIG_MOTION
+        bool "BMA250 Significant Motion"
+	default n
+	help
+	  Enable BMA250 Significant Motion feature
 endmenu
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/Makefile monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -24,6 +24,7 @@
 obj-$(CONFIG_SENSORS_R3GD20)    += r3gd20.o
 obj-$(CONFIG_SENSORS_BMA250)	+= bma250.o
 obj-$(CONFIG_BOSCH_BMA250)      += bma250_bosch.o
+obj-$(CONFIG_SENSORS_ONLY_BMA250)      += bma250_without_Ecompass.o
 obj-$(CONFIG_VP_A1028)          += a1028.o
 obj-$(CONFIG_TPS65200)          += tps65200.o
 obj-$(CONFIG_SENSORS_BMA2X2)    += bma2x2_driver.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/r3gd20.c monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/r3gd20.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/r3gd20.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/r3gd20.c	2013-08-01 23:38:02.000000000 -0600
@@ -131,6 +131,12 @@
 #define HTC_WQ 1
 #define HTC_SUSPEND 1
 #define HTC_ATTR 1
+#define cywee
+
+#ifdef cywee
+#define FIFO_LEVEL_MESK		0x1F
+#endif
+
 
 #define HW_WAKE_UP_TIME 160
 
@@ -556,8 +562,15 @@
 		if ((odr_table[i].poll_rate_ms <= poll_interval_ms) || (i == 0))
 			break;
 	}
-
+#ifdef cywee
+	if (poll_interval_ms > 20) {
+		config[1] = 0x00;
+	} else {
+		config[1] = 0x40;
+	}
+#else
 	config[1] = odr_table[i].mask;
+#endif
 	config[1] |= (ENABLE_ALL_AXES + PM_NORMAL);
 
 	if (atomic_read(&gyro->enabled)) {
@@ -572,6 +585,25 @@
 	return err;
 }
 
+#ifdef cywee
+static int r3gd20_get_status(struct r3gd20_data *gyro ,unsigned char *status)
+{
+	int err = 0;
+	unsigned char gyro_out[2];
+
+	gyro_out[0] = (FIFO_SRC_REG); 
+
+	err = r3gd20_i2c_read(gyro, gyro_out, 1);
+	if (err < 0)
+		E("%s: r3gd20_i2c_read() fails, err = %d\n", __func__, err);
+
+	status[0] = gyro_out[0] & FIFO_LEVEL_MESK;
+
+	return err;
+}
+#endif
+
+
 static int r3gd20_get_data(struct r3gd20_data *gyro,
 			     struct r3gd20_triple *data)
 {
@@ -625,14 +657,34 @@
 	struct r3gd20_data *gyro = g_gyro;
 	struct r3gd20_triple data_out;
 	int err;
+	unsigned char status = 0;
 
 	mutex_lock(&gyro->lock);
+
+#ifdef cywee
+	err = r3gd20_get_status(gyro, &status);
+	if (err < 0)
+		dev_err(&gyro->client->dev, "get_gyroscope_status failed\n");
+	else {
+		while(status > 0){
+			err = r3gd20_get_data(gyro, &data_out);
+			if (err < 0)
+				dev_err(&gyro->client->dev, "get_gyroscope_data failed\n");
+			else
+				r3gd20_report_values(gyro, &data_out);
+			status --;
+		}
+	}
+#else
 	err = r3gd20_get_data(gyro, &data_out);
 	if (err < 0)
 		dev_err(&gyro->client->dev, "get_gyroscope_data failed\n");
 	else
 		r3gd20_report_values(gyro, &data_out);
 
+
+#endif
+
 	mutex_unlock(&gyro->lock);
 
 	DIF("interval = %d, gyro->is_suspended = %d\n", gyro->input_poll_dev->
@@ -646,6 +698,59 @@
 }
 #endif 
 
+#ifdef cywee
+static int r3gd20_hw_init(struct r3gd20_data *gyro)
+{
+	int err;
+	u8 buf[6];
+
+	buf[0] = 0x20 ;
+	buf[1] = 0x40 | 0x08 | 0x07 | 0x30;
+	err = r3gd20_i2c_write(gyro, buf, 1);
+	if (err < 0) {
+		E("%s: r3gd20_i2c_write fails 111\n", __func__);
+		return err;
+	}
+
+	buf[0] = 0x23 ;
+	buf[1] = 0x20;
+	err = r3gd20_i2c_write(gyro, buf, 1);
+	if (err < 0) {
+		E("%s: r3gd20_i2c_write fails 222\n", __func__);
+		return err;
+	}
+
+	buf[0] = 0x24 ; 
+	buf[1] = 0x40;
+	err = r3gd20_i2c_write(gyro, buf, 1);
+	if (err < 0) {
+		E("%s: r3gd20_i2c_write fails 333\n", __func__);
+		return err;
+	}
+
+	buf[0] = FIFO_CTRL_REG; 
+	buf[1] = 0x40 | 0x1F;
+	err = r3gd20_i2c_write(gyro, buf, 1);
+	if (err < 0) {
+		E("%s: r3gd20_i2c_write fails 444\n", __func__);
+		return err;
+	}
+
+	buf[0] = 0x22 ; 
+	buf[1] = 0x00;
+	err = r3gd20_i2c_write(gyro, buf, 1);
+	if (err < 0) {
+		E("%s: r3gd20_i2c_write fails 444\n", __func__);
+		return err;
+	}
+
+	gyro->hw_initialized = 1;
+
+	return err;
+}
+
+#else 
+
 static int r3gd20_hw_init(struct r3gd20_data *gyro)
 {
 	int err;
@@ -674,6 +779,7 @@
 
 	return err;
 }
+#endif
 
 static void r3gd20_device_power_off(struct r3gd20_data *dev_data)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/rt5501.c monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/rt5501.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/i2c/chips/rt5501.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/i2c/chips/rt5501.c	2013-08-01 23:38:02.000000000 -0600
@@ -758,6 +758,9 @@
                 msleep(1);
             }
 
+#ifdef CONFIG_AMP_RT5501_DELAY
+			msleep(50);
+#endif
             pr_info("%s: enable gpio %d\n",__func__,pdata->gpio_rt5501_spk_en);
             gpio_direction_output(pdata->gpio_rt5501_spk_en, 1);
             rt5501_query.gpiostatus = AMP_GPIO_ON;
@@ -1033,7 +1036,7 @@
 			INIT_DELAYED_WORK(&rt5501_query.volume_ramp_work, volume_ramp_func);
 			gpio_wq = create_workqueue("rt5501_gpio_off");
 			INIT_DELAYED_WORK(&rt5501_query.gpio_off_work, hs_imp_gpio_off);
-            notifier.id = HEADSET_REG_MIC_BIAS;
+            notifier.id = HEADSET_REG_HS_INSERT;
             notifier.func = rt5501_headset_detect;
             headset_notifier_register(&notifier);
         }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/gpio_input.c monarudo-jb-3.4.10-e22f38b/drivers/input/misc/gpio_input.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/gpio_input.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/misc/gpio_input.c	2013-08-01 23:38:02.000000000 -0600
@@ -26,6 +26,10 @@
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 
+#if defined(CONFIG_PWRKEY_STATUS_API) || defined(CONFIG_PWRKEY_WAKESRC_LOG)
+#include <linux/module.h>
+#endif
+
 #ifdef CONFIG_POWER_KEY_LED
 #include <linux/leds-pm8921.h>
 
@@ -92,13 +96,20 @@
 
 static DEVICE_ATTR(vol_wakeup, 0664, vol_wakeup_show, vol_wakeup_store);
 
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+static uint16_t power_key_gpio;
+uint16_t get_power_key_gpio(void)
+{
+	return power_key_gpio;
+}
+EXPORT_SYMBOL(get_power_key_gpio);
+#endif
 
 #ifdef CONFIG_PWRKEY_STATUS_API
 static uint8_t power_key_state;
 static spinlock_t power_key_state_lock;
 
 #define PWRKEY_PRESS_DUE 1*HZ
-#include <linux/module.h>
 static void init_power_key_api(void)
 {
 	spin_lock_init(&power_key_state_lock);
@@ -253,6 +264,11 @@
 	return 1;
 }
 
+#if defined(CONFIG_PM8921_BMS) && (CONFIG_HTC_BATT_8960)
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
+#endif
+
+
 #ifdef CONFIG_POWER_KEY_CLR_RESET
 #include <mach/restart.h>
 int set_restart_to_ramdump(const char *msg);
@@ -267,6 +283,9 @@
 	if (!pocket_mode && pre_power_key_led_status == 1 && !is_rrm1_mode()) {
 		
 		set_hw_reason(0);
+#if defined(CONFIG_PM8921_BMS) && (CONFIG_HTC_BATT_8960)
+		pm8921_store_hw_reset_reason(1);
+#endif
 		clear_hw_reset();
 		set_restart_to_ramdump("Powerkey Hard Reset - SW");
 		msm_restart(0, NULL);
@@ -672,6 +691,10 @@
 		if (err < 0)
 			goto err_gpio_get_irq_num_failed;
 		if (ds->info->keymap[i].code == KEY_POWER) {
+#ifdef CONFIG_PWRKEY_WAKESRC_LOG
+			power_key_gpio = ds->info->keymap[i].gpio;
+			KEY_LOGI("Power Key gpio = %d", power_key_gpio);
+#endif
 			power_key_intr_flag = 0;
 			value = gpio_get_value(ds->info->keymap[i].gpio);
 			req_flags = value ? IRQF_TRIGGER_FALLING: IRQF_TRIGGER_RISING;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/input/misc/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/misc/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -668,4 +668,22 @@
 	help
 	  Say Y here if you want to support power key LED.
 
+config PWRKEY_WAKESRC_LOG
+	tristate "Power key wake up source log"
+	default n
+	help
+	  Say Y here if you want to check power key wake up source log.
+
+config INPUT_FPC1080
+       default n
+       tristate "FPC1080 fingerprint sensor support"
+       depends on SPI_MASTER
+
+config FPC1080_NAVIGATION
+       tristate "FPC1080 fingerprint sensor navigation support"
+       depends on INPUT_FPC1080
+
+config FPC1080_MOUSE
+       tristate "FPC1080 fingerprint sensor mouse support"
+       depends on INPUT_FPC1080
 endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/Makefile monarudo-jb-3.4.10-e22f38b/drivers/input/misc/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/misc/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/misc/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -60,4 +60,5 @@
 obj-$(CONFIG_PMIC8058_OTHC)             += pmic8058-othc.o
 obj-$(CONFIG_INPUT_PMIC8058_VIBRA_MEMLESS) += pmic8058-vib-memless.o
 obj-$(CONFIG_BOSCH_BMA150)              += bma150.o
-obj-$(CONFIG_INPUT_DUMMY_KEYPAD)        += dummy_keypad.o
\ No newline at end of file
+obj-$(CONFIG_INPUT_DUMMY_KEYPAD)        += dummy_keypad.o
+obj-$(CONFIG_INPUT_FPC1080)             += fpc1080.o
\ No newline at end of file
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -1007,4 +1007,14 @@
 
           If unsure, say N.
 
+config TOUCHSCREEN_MAX1187X
+        tristate "Maxim max1187X touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a Maxim max11871 touchscreen connected
+          to your system. max11871 conforms to the Maxim Touch Protocol
+          (MTP) defined by Maxim.
+
+          If unsure, say N.
+
 endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/Makefile monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -59,6 +59,7 @@
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_3K)       += synaptics_3200.o rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_MAX11871)      += max11871.o
+obj-$(CONFIG_TOUCHSCREEN_MAX1187X)      += max1187x.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C) +=synaptics/
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/synaptics_3200.c monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/synaptics_3200.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/input/touchscreen/synaptics_3200.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/input/touchscreen/synaptics_3200.c	2013-08-01 23:38:02.000000000 -0600
@@ -38,6 +38,7 @@
 #include <linux/wait.h>
 
 #define SYN_I2C_RETRY_TIMES 10
+#define SYN_UPDATE_RETRY_TIMES 5
 #define SHIFT_BITS 10
 #define SYN_WIRELESS_DEBUG
 #define SYN_CALIBRATION_CONTROL
@@ -1806,7 +1807,7 @@
 		printk(KERN_INFO "[TP]%s: Failed to obtain touchpad IRQ %d. Code: %d.", __func__, ts->gpio_irq, ret);
 		return ret;
 	}
-	if (ts->gpio_reset) {
+	if (ts->gpio_reset && !ts->i2c_err_handler_en) {
 		ret = gpio_request(ts->gpio_reset, "synaptics_reset");
 		if (ret)
 			printk(KERN_INFO "[TP]%s: Failed to obtain reset pin: %d. Code: %d.", __func__, ts->gpio_reset, ret);
@@ -2992,6 +2993,16 @@
 		wait_event_interruptible_timeout(ts->syn_fw_wait, atomic_read(&ts->syn_fw_condition),
 							msecs_to_jiffies(wait_time));
 	}
+	ts->i2c_err_handler_en = pdata->i2c_err_handler_en;
+	if (ts->i2c_err_handler_en) {
+		ts->gpio_reset = pdata->gpio_reset;
+		ts->use_irq = 1;
+		if (ts->gpio_reset) {
+			ret = gpio_request(ts->gpio_reset, "synaptics_reset");
+			if (ret)
+				printk(KERN_INFO "[TP]%s: Failed to obtain reset pin: %d. Code: %d.", __func__, ts->gpio_reset, ret);
+		}
+	}
 
 	for (i = 0; i < 10; i++) {
 		ret = i2c_syn_read(ts->client, get_address_base(ts, 0x01, DATA_BASE), &data, 1);
@@ -3066,7 +3077,11 @@
 		}
 		if (pdata->tw_pin_mask) {
 			ts->tw_pin_mask = pdata->tw_pin_mask;
-			ret = syn_get_tw_vendor(ts, pdata->gpio_irq);
+			for (i=0; i<SYN_UPDATE_RETRY_TIMES; i++) {
+				ret = syn_get_tw_vendor(ts, pdata->gpio_irq);
+				if (ret == 0)
+					break;
+			}
 			if (ret < 0) {
 				printk(KERN_ERR "[TP] TOUCH_ERR: syn_get_tw_vendor fail\n");
 				goto err_init_failed;
@@ -3112,7 +3127,11 @@
 	}
 
 #ifndef SYN_DISABLE_CONFIG_UPDATE
-	ret = syn_config_update(ts, pdata->gpio_irq);
+	for (i=0; i<SYN_UPDATE_RETRY_TIMES; i++) {
+		ret = syn_config_update(ts, pdata->gpio_irq);
+		if (ret >= 0)
+			break;
+	}
 	if (ret < 0) {
 		printk(KERN_ERR "[TP] TOUCH_ERR: syn_config_update fail\n");
 		goto err_init_failed;
@@ -3610,7 +3629,7 @@
 
 static int synaptics_ts_resume(struct i2c_client *client)
 {
-	int ret;
+	int ret, i;
 	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
 	printk(KERN_INFO "[TP] %s: enter\n", __func__);
 
@@ -3641,6 +3660,17 @@
 		}
 		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
 		input_sync(ts->input_dev);
+	} else if (ts->htc_event == SYN_AND_REPORT_TYPE_B) {
+		if (ts->package_id >= 3400) {
+			for (i = 0; i < ts->finger_support; i++) {
+				input_mt_slot(ts->input_dev, i);
+				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+				input_sync(ts->input_dev);
+				
+			}
+			ts->tap_suppression = 0;
+			ts->finger_pressed = 0;
+		}
 	} else if (ts->htc_event == SYN_AND_REPORT_TYPE_HTC) {
 		input_report_abs(ts->input_dev, ABS_MT_AMPLITUDE, 0);
 		input_report_abs(ts->input_dev, ABS_MT_POSITION, 1 << 31);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/Makefile monarudo-jb-3.4.10-e22f38b/drivers/media/video/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -212,7 +212,9 @@
 
 obj-y	+= davinci/
 
+ifeq ($(CONFIG_MSM_CAMERA),y)
 obj-$(CONFIG_MSM_CAMERA) += msm/
+endif
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += msm/wfd/
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
 #obj-$(CONFIG_MSM_VIDC) += msm_vidc/
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/HtcActOisBinder.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/HtcActOisBinder.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/HtcActOisBinder.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/HtcActOisBinder.c	2013-08-01 23:38:00.000000000 -0600
@@ -189,6 +189,7 @@
 		return;
 
 	pr_info("[OIS]  %s  start\n", __func__);
+	pr_info("[OIS]  %s  FW_Version=0x%x\n", __func__, RdFwVr());
 
 #if 0
 	RegReadA_lc898111(0x027F, &ois_data_8); 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/OisFil.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/OisFil.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/OisFil.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/OisFil.h	2013-08-01 23:38:00.000000000 -0600
@@ -355,33 +355,33 @@
 { 0x1840, 0x3AD15349},
 { 0x1841, 0x3AD15349},
 { 0x1842, 0x3F7FFD5D},
-{ 0x1843, 0x3B515235},
-{ 0x1844, 0x3B515235},
-{ 0x1845, 0x3F7FFABB},
-{ 0x1846, 0x3CAE6500},
-{ 0x1847, 0x3CAE6500},
-{ 0x1848, 0x3F7FDCDF},
+{ 0x1843, 0x3CAE6500},
+{ 0x1844, 0x3CAE6500},
+{ 0x1845, 0x3F7FDCDF},
+{ 0x1846, 0x3BAE6DFA},
+{ 0x1847, 0x3BAE6DFA},
+{ 0x1848, 0x3F7FF737},
 { 0x1849, 0x3C2E6AFC},
 { 0x184A, 0x3C2E6AFC},
 { 0x184B, 0x3F7FEE6F},
-{ 0x184C, 0x3BAE6DFA},
-{ 0x184D, 0x3BAE6DFA},
-{ 0x184E, 0x3F7FF737},
+{ 0x184C, 0x3CAE6500},
+{ 0x184D, 0x3CAE6500},
+{ 0x184E, 0x3F7FDCDF},
 { 0x1850, 0x3487E361},
 { 0x1851, 0x3487E361},
 { 0x1852, 0x3F7FFD5D},
-{ 0x1853, 0x3507E2AE},
-{ 0x1854, 0x3507E2AE},
-{ 0x1855, 0x3F7FFABB},
-{ 0x1856, 0x36626C97},
-{ 0x1857, 0x36626C97},
-{ 0x1858, 0x3F7FDCDF},
+{ 0x1853, 0x36626C97},
+{ 0x1854, 0x36626C97},
+{ 0x1855, 0x3F7FDCDF},
+{ 0x1856, 0x3562783E},
+{ 0x1857, 0x3562783E},
+{ 0x1858, 0x3F7FF737},
 { 0x1859, 0x35E2745C},
 { 0x185A, 0x35E2745C},
 { 0x185B, 0x3F7FEE6F},
-{ 0x185C, 0x3562783E},
-{ 0x185D, 0x3562783E},
-{ 0x185E, 0x3F7FF737},
+{ 0x185C, 0x36626C97},
+{ 0x185D, 0x36626C97},
+{ 0x185E, 0x3F7FDCDF},
 { 0x1860, 0x3F800000},
 { 0x1861, 0x00000000},
 { 0x1862, 0x00000000},
@@ -431,7 +431,7 @@
 { 0x1891, 0x3F800000},
 { 0x1892, 0x00000000},
 { 0x1893, 0x3F800000},
-{ 0x1894, 0x3DCCCCCD},
+{ 0x1894, 0x3F004DCE},
 { 0x1895, 0x3A83126F},
 { 0x1896, 0x3F800000},
 { 0x1897, 0x3F004DCE},
@@ -515,33 +515,33 @@
 { 0x1940, 0x3AD15349},
 { 0x1941, 0x3AD15349},
 { 0x1942, 0x3F7FFD5D},
-{ 0x1943, 0x3B515235},
-{ 0x1944, 0x3B515235},
-{ 0x1945, 0x3F7FFABB},
-{ 0x1946, 0x3CAE6500},
-{ 0x1947, 0x3CAE6500},
-{ 0x1948, 0x3F7FDCDF},
+{ 0x1943, 0x3CAE6500},
+{ 0x1944, 0x3CAE6500},
+{ 0x1945, 0x3F7FDCDF},
+{ 0x1946, 0x3BAE6DFA},
+{ 0x1947, 0x3BAE6DFA},
+{ 0x1948, 0x3F7FF737},
 { 0x1949, 0x3C2E6AFC},
 { 0x194A, 0x3C2E6AFC},
 { 0x194B, 0x3F7FEE6F},
-{ 0x194C, 0x3BAE6DFA},
-{ 0x194D, 0x3BAE6DFA},
-{ 0x194E, 0x3F7FF737},
+{ 0x194C, 0x3CAE6500},
+{ 0x194D, 0x3CAE6500},
+{ 0x194E, 0x3F7FDCDF},
 { 0x1950, 0x3487E361},
 { 0x1951, 0x3487E361},
 { 0x1952, 0x3F7FFD5D},
-{ 0x1953, 0x3507E2AE},
-{ 0x1954, 0x3507E2AE},
-{ 0x1955, 0x3F7FFABB},
-{ 0x1956, 0x36626C97},
-{ 0x1957, 0x36626C97},
-{ 0x1958, 0x3F7FDCDF},
+{ 0x1953, 0x36626C97},
+{ 0x1954, 0x36626C97},
+{ 0x1955, 0x3F7FDCDF},
+{ 0x1956, 0x3562783E},
+{ 0x1957, 0x3562783E},
+{ 0x1958, 0x3F7FF737},
 { 0x1959, 0x35E2745C},
 { 0x195A, 0x35E2745C},
 { 0x195B, 0x3F7FEE6F},
-{ 0x195C, 0x3562783E},
-{ 0x195D, 0x3562783E},
-{ 0x195E, 0x3F7FF737},
+{ 0x195C, 0x36626C97},
+{ 0x195D, 0x36626C97},
+{ 0x195E, 0x3F7FDCDF},
 { 0x1960, 0x3F800000},
 { 0x1961, 0x00000000},
 { 0x1962, 0x00000000},
@@ -591,7 +591,7 @@
 { 0x1991, 0x3F800000},
 { 0x1992, 0x00000000},
 { 0x1993, 0x3F800000},
-{ 0x1994, 0x3DCCCCCD},
+{ 0x1994, 0x3F004DCE},
 { 0x1995, 0x3A83126F},
 { 0x1996, 0x3F800000},
 { 0x1997, 0x3F004DCE},
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/Ois.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/Ois.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/Ois.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/Ois.h	2013-08-01 23:38:00.000000000 -0600
@@ -1,4 +1,4 @@
-#define	FW_VER			0x0005
+#define	FW_VER			0x0007
 #define StAdjPar StAdjPar_lc898111
 #define UsStpSiz UsStpSiz_lc898111
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/OisIni.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/OisIni.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/LC898111/OisIni.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/LC898111/OisIni.c	2013-08-01 23:38:00.000000000 -0600
@@ -663,10 +663,10 @@
 	RegWriteA( GPANSTTSETI1FTR,	0x58 );		
 	RegWriteA( GPANSTTSETI2FTR,	0x00 );		
 #else
-	RegWriteA( GPANSTTSETGAIN, 	0x00 );		
+	RegWriteA( GPANSTTSETGAIN, 	0x10 );		
 	RegWriteA( GPANSTTSETISTP, 	0x00 );		
-	RegWriteA( GPANSTTSETI1FTR,	0xB0 );		
-	RegWriteA( GPANSTTSETI2FTR,	0xB0 );		
+	RegWriteA( GPANSTTSETI1FTR,	0x90 );		
+	RegWriteA( GPANSTTSETI2FTR,	0x90 );		
 #endif
 	RegWriteA( GPANSTTSETL2FTR, 0x00 );		
 	RegWriteA( GPANSTTSETL3FTR,	0x00 );		
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/lc898212_act.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/lc898212_act.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/lc898212_act.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/lc898212_act.c	2013-08-01 23:38:00.000000000 -0600
@@ -16,6 +16,7 @@
 #include <mach/gpio.h>
 
 #define	LC898212_TOTAL_STEPS_NEAR_TO_FAR			  30 
+#define	LC898212_STEP_NEAR_10CM			  28
 #define LC898212_TOTAL_STEPS_NEAR_TO_FAR_RAWCHIP_AF                        256 
 
 #define REG_VCM_I2C_ADDR			0xe4
@@ -27,6 +28,11 @@
 #define DEFAULT_INFINITY 0x7000
 #define DEFAULT_MACRO -0x7000
 
+int16_t lc898212_kernel_step_table[LC898212_TOTAL_STEPS_NEAR_TO_FAR+1]
+	= {0x48C0, 0x4560, 0x4201, 0x3FBF, 0x3D7D, 0x3AA8, 0x37D3, 0x34FB, 0x3223, 0x2EDF,
+		0x2B9A, 0x2925, 0x26AF, 0x2339, 0x1FC4, 0x1A8B, 0x1552, 0x0C86, 0x03BA, 0x0132,
+		0xFEA9, 0xFBB9, 0xF8CA, 0xF559, 0xF1E8, 0xEEA8, 0xEB69, 0xE639, 0xE10A, 0xD191, 0xC218};
+
 
 DEFINE_MUTEX(lc898212_act_mutex);
 static struct msm_actuator_ctrl_t lc898212_act_t;
@@ -95,44 +101,7 @@
 	gpio_free(lc898212_msm_actuator_info->vcm_pwd);
 	msleep(1);
 }
-#define Q_NUMBER (0x100)
-#define	TO_Q(v)	((v)*Q_NUMBER)
-#define BACK_Q(v) ((v)/Q_NUMBER)
-
-static const int32_t dof[]={
-
-    TO_Q(100.00/100.0),
-    TO_Q(98.04/100.0),
-    TO_Q(96.08/100.0),
-    TO_Q(94.12/100.0),
-    TO_Q(92.16/100.0),
-    TO_Q(90.19/100.0),
-    TO_Q(88.23/100.0),
-    TO_Q(86.03/100.0),
-    TO_Q(83.82/100.0),
-    TO_Q(81.62/100.0),
-    TO_Q(79.41/100.0),
-    TO_Q(77.20/100.0),
-    TO_Q(75.00/100.0),
-    TO_Q(72.55/100.0),
-    TO_Q(70.10/100.0),
-    TO_Q(67.65/100.0),
-    TO_Q(65.20/100.0),
-    TO_Q(62.01/100.0),
-    TO_Q(58.82/100.0),
-    TO_Q(55.15/100.0),
-    TO_Q(51.47/100.0),
-    TO_Q(47.30/100.0),
-    TO_Q(43.14/100.0),
-    TO_Q(38.48/100.0),
-    TO_Q(33.82/100.0),
-    TO_Q(28.67/100.0),
-    TO_Q(23.53/100.0),
-    TO_Q(17.88/100.0),
-    TO_Q(12.23/100.0),
-    TO_Q(6.11/100.0),
-    TO_Q(0.00/100.0),
-};
+
 int32_t lc898212_msm_actuator_init_table(
 	struct msm_actuator_ctrl_t *a_ctrl)
 {
@@ -153,29 +122,36 @@
 	a_ctrl->step_position_table =
 		kmalloc(sizeof(uint16_t) * (a_ctrl->set_info.total_steps + 1),
 			GFP_KERNEL);
-    
 	if (a_ctrl->step_position_table) {
 		uint16_t i = 0;
-		int16_t infinity = DEFAULT_INFINITY;
-		int16_t macro = DEFAULT_MACRO;
-		int32_t full_range = 0;
+		int16_t infinity = lc898212_kernel_step_table[0];
+		int16_t macro = lc898212_kernel_step_table[LC898212_STEP_NEAR_10CM];
+		int16_t min_value = lc898212_kernel_step_table[a_ctrl->set_info.total_steps];
 
 		if (a_ctrl->af_OTP_info.VCM_OTP_Read) {
 			infinity = a_ctrl->af_OTP_info.VCM_Infinity;
 			macro = a_ctrl->af_OTP_info.VCM_Macro;
+			min_value = a_ctrl->af_OTP_info.VCM_Top_Mech;
 		}
 
-		full_range = (int32_t)infinity + (int32_t)-macro;
-		pr_info("%s infinity=%x macro=%x full_range=%x\n",__func__, infinity, macro, full_range);
-
 		a_ctrl->step_position_table[0] = a_ctrl->initial_code = infinity;
-		pr_info("%s initial_code=%x infinity=%x final=%x\n", __func__, a_ctrl->initial_code, infinity, a_ctrl->step_position_table[0]);
+		pr_info("%s infinity=%x macro=%x min_value=%x\n",__func__, infinity, macro, min_value);
 
 		for (i = 1; i <= a_ctrl->set_info.total_steps; i++) {
-			a_ctrl->step_position_table[i] = BACK_Q(full_range*dof[i]) + macro;
+
+			if (a_ctrl->af_OTP_info.VCM_OTP_Read) {
+				a_ctrl->step_position_table[i] = infinity +
+					(lc898212_kernel_step_table[i] - lc898212_kernel_step_table[0]) * (macro - infinity) /
+					(lc898212_kernel_step_table[LC898212_STEP_NEAR_10CM] - lc898212_kernel_step_table[0]);
+
+				if ((int16_t)a_ctrl->step_position_table[i] < min_value)
+					a_ctrl->step_position_table[i] = min_value;
+			} else
+				a_ctrl->step_position_table[i] = lc898212_kernel_step_table[i];
+
 			pr_info("%s af table[%d]=%x (%d)\n",__func__, i, a_ctrl->step_position_table[i], (int16_t)a_ctrl->step_position_table[i]);
 		}
-		
+
 		a_ctrl->curr_step_pos = 0;
 		a_ctrl->curr_region_index = 0;
 	} else {
@@ -251,6 +227,9 @@
     int32_t rc = 0;
     int dir = *(int*)params;
 
+	if(a_ctrl->enable_focus_step_log)
+		pr_info("%s next_lens_position: %x (%d)\n", __func__, next_lens_position, (int16_t)next_lens_position);
+
     rc = msm_camera_i2c_write(&a_ctrl->i2c_client,
             0xa1,
             next_lens_position,
@@ -334,8 +313,7 @@
 {0x99, 0x00},
 {0x9A, 0x00},
 };
-
-static struct msm_camera_i2c_reg_conf lc898212_settings_2_0x11[] = {
+static struct msm_camera_i2c_reg_conf lc898212_settings_2_0x12[] = {
 {0x88, 0x70},
 {0x92, 0x00},
 {0xA0, 0x01},
@@ -356,8 +334,8 @@
 {0x45, 0x90},
 {0x46, 0x61},
 {0x47, 0xB0},
-{0x48, 0x65},
-{0x49, 0xB0},
+{0x48, 0x72},
+{0x49, 0x10},
 {0x76, 0x0C},
 {0x77, 0x50},
 {0x4A, 0x28},
@@ -374,7 +352,7 @@
 {0x59, 0xF0},
 {0x4C, 0x40},
 {0x4D, 0x30},
-{0x78, 0x40},
+{0x78, 0x60},
 {0x79, 0x00},
 {0x4E, 0x7F},
 {0x4F, 0xF0},
@@ -417,7 +395,7 @@
 {0x31, 0x00},
 };
 
-static struct msm_camera_i2c_reg_conf lc898212_settings_2_0x12[] = {
+static struct msm_camera_i2c_reg_conf lc898212_settings_2_0x13[] = {
 {0x88, 0x70},
 {0x92, 0x00},
 {0xA0, 0x01},
@@ -438,8 +416,8 @@
 {0x45, 0x90},
 {0x46, 0x61},
 {0x47, 0xB0},
-{0x48, 0x72},
-{0x49, 0x10},
+{0x48, 0x65},
+{0x49, 0xB0},
 {0x76, 0x0C},
 {0x77, 0x50},
 {0x4A, 0x28},
@@ -456,7 +434,7 @@
 {0x59, 0xF0},
 {0x4C, 0x40},
 {0x4D, 0x30},
-{0x78, 0x60},
+{0x78, 0x40},
 {0x79, 0x00},
 {0x4E, 0x7F},
 {0x4F, 0xF0},
@@ -499,7 +477,7 @@
 {0x31, 0x00},
 };
 
-static struct msm_camera_i2c_reg_conf lc898212_settings_2_0x13[] = {
+static struct msm_camera_i2c_reg_conf lc898212_settings_2_default[] = {
 {0x88, 0x70},
 {0x92, 0x00},
 {0xA0, 0x01},
@@ -514,39 +492,39 @@
 
 {0x40, 0x80},
 {0x41, 0x10},
-{0x42, 0x74},
+{0x42, 0x71},
 {0x43, 0x10},
-{0x44, 0x8c},
-{0x45, 0xd0},
-{0x46, 0x67},
-{0x47, 0x30},
-{0x48, 0x47},
-{0x49, 0xf0},
-{0x76, 0x10},
+{0x44, 0x8F},
+{0x45, 0x50},
+{0x46, 0x61},
+{0x47, 0xB0},
+{0x48, 0x65},
+{0x49, 0xB0},
+{0x76, 0x08},
 {0x77, 0x50},
-{0x4A, 0x40},
-{0x4B, 0x30},
+{0x4A, 0x28},
+{0x4B, 0x70},
 {0x50, 0x04},
 {0x51, 0xF0},
 {0x52, 0x76},
 {0x53, 0x10},
-{0x54, 0x28},
-{0x55, 0x70},
+{0x54, 0x16},
+{0x55, 0xC0},
 {0x56, 0x00},
 {0x57, 0x00},
 {0x58, 0x7F},
 {0x59, 0xF0},
 {0x4C, 0x40},
 {0x4D, 0x30},
-{0x78, 0x40},
+{0x78, 0x20},
 {0x79, 0x00},
 {0x4E, 0x7F},
 {0x4F, 0xF0},
 {0x6E, 0x00},
 {0x6F, 0x00},
-{0x72, 0x15},
-{0x73, 0x70},
-{0x74, 0x55},
+{0x72, 0x18},
+{0x73, 0xE0},
+{0x74, 0x4E},
 {0x75, 0x30},
 {0x30, 0x00},
 {0x31, 0x00},
@@ -573,14 +551,15 @@
 {0x6C, 0x80},
 {0x6D, 0x10},
 
-{0x76, 0x0c},
+{0x76, 0x08},
 {0x77, 0x50},
-{0x78, 0x40},
+{0x78, 0x20},
 {0x79, 0x00},
 {0x30, 0x00},
 {0x31, 0x00},
 };
 
+
 static struct msm_camera_i2c_reg_conf lc898212_settings_3[] = {
 {0x3A, 0x00},
 {0x3B, 0x00}, 
@@ -900,7 +879,7 @@
 
     switch (a_ctrl->af_OTP_info.VCM_Vendor_Id_Version) {
         case 0x11:
-            rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_0x11, ARRAY_SIZE(lc898212_settings_2_0x11), MSM_CAMERA_I2C_BYTE_DATA);
+            rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_default, ARRAY_SIZE(lc898212_settings_2_default), MSM_CAMERA_I2C_BYTE_DATA);
             break;
         case 0x12:
             rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_0x12, ARRAY_SIZE(lc898212_settings_2_0x12), MSM_CAMERA_I2C_BYTE_DATA);
@@ -909,8 +888,8 @@
             rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_0x13, ARRAY_SIZE(lc898212_settings_2_0x13), MSM_CAMERA_I2C_BYTE_DATA);
             break;
         
-        default: 
-            rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_0x13, ARRAY_SIZE(lc898212_settings_2_0x13), MSM_CAMERA_I2C_BYTE_DATA);
+        default:
+            rc = msm_camera_i2c_write_tbl (&a_ctrl->i2c_client,lc898212_settings_2_default, ARRAY_SIZE(lc898212_settings_2_default), MSM_CAMERA_I2C_BYTE_DATA);
             break;
         break;
     }
@@ -1116,6 +1095,10 @@
 		.a_create_subdevice = lc898212_act_create_subdevice,
 		.a_config = lc898212_act_config,
 		.is_cal_supported = 1, 
+		.small_step_damping = 17,
+		.medium_step_damping = 20,
+		.big_step_damping = 30,
+		.is_af_infinity_supported = 0,
 	},
 
 	.i2c_client = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/msm_actuator.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/msm_actuator.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/msm_actuator.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/msm_actuator.c	2013-08-01 23:38:00.000000000 -0600
@@ -218,6 +218,8 @@
 {
 	int32_t rc = 0;
 	LINFO("%s called\n", __func__);
+	if (!a_ctrl->step_position_table)
+	    return rc;
 
 	if (a_ctrl->step_position_table[a_ctrl->curr_step_pos] !=
 		a_ctrl->initial_code) {
@@ -246,6 +248,7 @@
 	case CFG_GET_ACTUATOR_INFO:
 		cdata.is_af_supported = 1;
 		cdata.is_ois_supported = a_ctrl->actuator_ext_ctrl.is_ois_supported;
+		cdata.is_af_infinity_supported = a_ctrl->actuator_ext_ctrl.is_af_infinity_supported;
 		cdata.cfg.get_info = a_ctrl->get_info;
 		if (copy_to_user((void *)argp,
 				 &cdata,
@@ -254,6 +257,7 @@
 		break;
 	case CFG_SET_ACTUATOR_INFO:
 		a_ctrl->set_info = cdata.cfg.set_info;
+		a_ctrl->enable_focus_step_log = cdata.enable_focus_step_log;
 		rc = a_ctrl->func_tbl.actuator_init_table(a_ctrl);
 		if (rc < 0)
 			LERROR("%s init table failed %d\n", __func__, rc);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/msm_actuator.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/msm_actuator.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/msm_actuator.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/msm_actuator.h	2013-08-01 23:38:00.000000000 -0600
@@ -100,6 +100,7 @@
 	af_algo_t af_algo; 
 	int ois_ready_version; 
 	uint8_t ois_mfgtest_in_progress; 
+	uint8_t enable_focus_step_log;
 	struct msm_actuator_get_ois_info_t get_ois_info;
 	struct msm_actuator_get_ois_tbl_t get_ois_tbl;
 	struct msm_actuator_af_OTP_info_t af_OTP_info;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/rumbas_act.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/rumbas_act.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/rumbas_act.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/rumbas_act.c	2013-08-01 23:38:00.000000000 -0600
@@ -1223,6 +1223,10 @@
 		pr_info("[RUMBA_S]  VCM lens position = %d\n", positon);
 	}
 
+	if(a_ctrl->enable_focus_step_log)
+		pr_info("%s next_lens_position: %d, positon: %d, VCM_Macro: %d, VCM_Infinity: %d\n", __func__,
+			next_lens_position, positon, a_ctrl->af_OTP_info.VCM_Macro, a_ctrl->af_OTP_info.VCM_Infinity);
+
 	memset(byte_data, 0, sizeof(byte_data));
 	byte_data[0] = (positon & 0xFF00) >> 8;
 	byte_data[1] = positon & 0x00FF;
@@ -1774,6 +1778,10 @@
 		.a_create_subdevice = rumbas_act_create_subdevice,
 		.a_config = rumbas_act_config,
 		.is_ois_supported = 1,
+		.small_step_damping = 47,
+		.medium_step_damping = 75,
+		.big_step_damping = 100,
+		.is_af_infinity_supported = 0,
 		
 		.do_vcm_on_cb	= rumbas_do_cam_vcm_on_cb,
 		.do_vcm_off_cb	= rumbas_do_cam_vcm_off_cb,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/ti201_act.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/ti201_act.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/actuators/ti201_act.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/actuators/ti201_act.c	2013-08-01 23:38:00.000000000 -0600
@@ -264,6 +264,9 @@
 {
 	int32_t rc = 0;
 
+	if(a_ctrl->enable_focus_step_log)
+		pr_info("%s next_lens_position: %d\n", __func__, next_lens_position);
+
 	rc = msm_camera_i2c_write(&a_ctrl->i2c_client,
 		REG_VCM_CODE_MSB,
 		((next_lens_position & 0x0300) >> 8),	
@@ -531,6 +534,10 @@
 #if defined(CONFIG_ACT_OIS_BINDER)
 		.is_ois_supported = 1,
 #endif
+		.small_step_damping = 47,
+		.medium_step_damping = 75,
+		.big_step_damping = 100,
+		.is_af_infinity_supported = 0,
 	},
 
 	.i2c_client = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/io/msm_camera_i2c.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/io/msm_camera_i2c.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/io/msm_camera_i2c.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/io/msm_camera_i2c.c	2013-08-01 23:38:00.000000000 -0600
@@ -12,7 +12,7 @@
 
 #include "msm_camera_i2c.h"
 
-#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_DUMMY)\
+#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DELUXE_J) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_IMPRESSION_J)\
 			|| defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
 
 #define MAX_I2C_RETRIES 20
@@ -57,7 +57,7 @@
 			.buf   = rxdata,
 		},
 	};
-#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_DUMMY)\
+#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DELUXE_J) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_IMPRESSION_J)\
 		|| defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
 	rc = i2c_transfer_retry(dev_client->client->adapter, msgs, 2);
 #else
@@ -81,7 +81,7 @@
 			.buf = txdata,
 		 },
 	};
-#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_DUMMY)\
+#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DELUXE_J) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_IMPRESSION_J)\
 			|| defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
 	rc = i2c_transfer_retry(dev_client->client->adapter, msg, 1);
 #else
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -61,6 +61,13 @@
 	---help---
 	  Support for AR0260 sensor driver.
 
+config AS0260
+	bool "Sensor as0260"
+	depends on MSM_CAMERA
+	default n
+	---help---
+	  Support for AS0260 sensor driver.
+
 config OV2722
 	bool "Sensor ov2722"
 	depends on MSM_CAMERA
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm.c	2013-08-01 23:38:00.000000000 -0600
@@ -3387,6 +3387,16 @@
 	return rc;
 
 }
+
+static void msm_cam_server_send_error_evt(
+		struct msm_cam_media_controller *pmctl, int evt_type)
+{
+	struct v4l2_event v4l2_ev;
+	v4l2_ev.type = evt_type;
+	ktime_get_ts(&v4l2_ev.timestamp);
+	v4l2_event_queue(pmctl->pcam_ptr->pvdev, &v4l2_ev);
+}
+
 static void msm_cam_server_subdev_notify(struct v4l2_subdev *sd,
 				unsigned int notification, void *arg)
 {
@@ -3394,6 +3404,7 @@
 	struct msm_sensor_ctrl_t *s_ctrl;
 	struct msm_camera_sensor_info *sinfo;
 	struct msm_camera_device_platform_data *camdev;
+	struct msm_cam_media_controller *p_mctl = NULL;
 	uint8_t csid_core = 0;
 
 	if (notification == NOTIFY_CID_CHANGE ||
@@ -3497,7 +3508,15 @@
 	case NOTIFY_GESTURE_CAM_EVT:
 		rc = v4l2_subdev_call(g_server_dev.gesture_device,
 			core, ioctl, VIDIOC_MSM_GESTURE_CAM_EVT, arg);
-		break;		
+		break;
+	case NOTIFY_VFE_CAMIF_ERROR: {
+		p_mctl = msm_camera_get_mctl(g_server_dev.pcam_active->mctl_handle);
+		if (p_mctl)
+			msm_cam_server_send_error_evt(p_mctl,
+				V4L2_EVENT_PRIVATE_START +
+				MSM_CAM_APP_NOTIFY_ERROR_EVENT);
+		break;
+	}
 	default:
 		break;
 	}
@@ -3846,6 +3865,8 @@
 				       (void *)act_sdev);
 
 	is_actuator_probe_success = 1; 
+	pr_info("%s: actuator_info->board_info->type=%s", __func__, actuator_info->board_info->type);
+	pr_info("%s: actuator_info->board_info->addr=0x%x", __func__, actuator_info->board_info->addr);
 
 	return rc;
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm.h	2013-08-01 23:38:00.000000000 -0600
@@ -155,6 +155,7 @@
 	NOTIFY_AXI_IRQ,
 	NOTIFY_GESTURE_EVT, 
 	NOTIFY_GESTURE_CAM_EVT, 
+	NOTIFY_VFE_CAMIF_ERROR,
 	NOTIFY_INVALID
 };
 
@@ -443,7 +444,7 @@
 	uint32_t server_evt_id;
 	struct msm_cam_server_mctl_inst mctl[MAX_NUM_ACTIVE_CAMERA];
 	uint32_t mctl_handle_cnt;
-	
+
 	int use_count;
 	
 	struct msm_isp_ops *isp_subdev[MSM_MAX_CAMERA_CONFIGS];
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl_buf.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl_buf.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl_buf.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl_buf.c	2013-08-01 23:38:00.000000000 -0600
@@ -253,7 +253,8 @@
 				&pcam_inst->free_vq, list) {
 			buf_phyaddr = (unsigned long)
 				videobuf2_to_pmem_contig(&buf->vidbuf, 0);
-			D("%s vb_idx=%d,vb_paddr=0x%x,phyaddr=0x%x\n",
+			if (!buf_phyaddr || !vb_phyaddr)
+			pr_info("%s vb_idx=%d,vb_paddr=0x%x,phyaddr=0x%x\n",
 				__func__, buf->vidbuf.v4l2_buf.index,
 				buf_phyaddr, vb_phyaddr);
 			if (vb_phyaddr == buf_phyaddr) {
@@ -402,7 +403,8 @@
 		buf_phyaddr = (unsigned long)
 				videobuf2_to_pmem_contig(&buf->vidbuf, 0) +
 				offset;
-		D("%s vb_idx=%d,vb_paddr=0x%x ch0=0x%x\n",
+		if (!buf_phyaddr)
+		pr_info("%s vb_idx=%d,vb_paddr=0x%x ch0=0x%x\n",
 			__func__, buf->vidbuf.v4l2_buf.index,
 			buf_phyaddr, fbuf->ch_paddr[0]);
 		if (fbuf->ch_paddr[0] == buf_phyaddr) {
@@ -765,6 +767,8 @@
 	list_for_each_entry(buf, &pcam_inst->free_vq, list) {
 		buf_phyaddr =
 			(uint32_t) videobuf2_to_pmem_contig(&buf->vidbuf, 0);
+		if (!buf_phyaddr)
+			pr_info("%s buf_phyaddr is null", __func__);
 		if (free_buf->ch_paddr[0] == buf_phyaddr) {
 			D("%s buf = 0x%x ", __func__, free_buf->ch_paddr[0]);
 			buf->state = MSM_BUFFER_STATE_UNUSED;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl.c	2013-08-01 23:38:00.000000000 -0600
@@ -306,6 +306,10 @@
 		cdata.is_af_supported = 0;
 		cdata.is_ois_supported = 0;
 		cdata.is_cal_supported = 0; 
+		cdata.small_step_damping = 0;
+		cdata.medium_step_damping = 0;
+		cdata.big_step_damping = 0;
+		cdata.is_af_infinity_supported = 1;
 		rc = 0;
 
 		if (p_mctl->actctrl->a_config) {
@@ -318,6 +322,10 @@
 			cdata.is_af_supported = 1;
 			cdata.is_ois_supported = p_mctl->actctrl->is_ois_supported;
 			cdata.is_cal_supported = p_mctl->actctrl->is_cal_supported; 
+			cdata.small_step_damping = p_mctl->actctrl->small_step_damping;
+			cdata.medium_step_damping = p_mctl->actctrl->medium_step_damping;
+			cdata.big_step_damping = p_mctl->actctrl->big_step_damping;
+			cdata.is_af_infinity_supported = p_mctl->actctrl->is_af_infinity_supported;
 
 			cdata.cfg.cam_name =
 				(enum af_camera_name)sdata->
@@ -424,7 +432,7 @@
 		else
 			rc = p_mctl->isp_sdev->isp_config(p_mctl, cmd, arg);
 		break;
-			
+
 	case MSM_CAM_IOCTL_SET_PERF_LOCK: {
 		int perf_lock_enable;
 		if (copy_from_user(&perf_lock_enable, argp, sizeof(perf_lock_enable))) {
@@ -652,7 +660,7 @@
 		if (p_mctl->isp_sdev && p_mctl->isp_sdev->isp_open) {
 			rc = p_mctl->isp_sdev->isp_open(
 				p_mctl->isp_sdev->sd, p_mctl);
-	
+
 			if (rc < 0) {
 				pr_err("%s: isp init failed: %d\n",
 					__func__, rc);
@@ -762,7 +770,7 @@
 		}
 		p_mctl->apps_id = apps_id;
 		p_mctl->opencnt++;
-		
+
 	} else {
 		D("%s: camera is already open", __func__);
 	}
@@ -876,7 +884,7 @@
 	if (p_mctl->actctrl->a_power_down)
 		p_mctl->actctrl->a_power_down(
 			p_mctl->sdata->actuator_info);
-	
+
 	if (p_mctl->sdata->use_rawchip) {
 #ifdef CONFIG_RAWCHIP
 		rawchip_release();
@@ -1102,7 +1110,7 @@
 		return rc;
 	}
 
-	D("%s active %d\n", __func__, pcam->mctl_node.active);		
+	D("%s active %d\n", __func__, pcam->mctl_node.active);
 	rc = msm_setup_v4l2_event_queue(&pcam_inst->eventHandle,
 					pcam->mctl_node.pvdev);
 	if (rc < 0) {
@@ -1184,7 +1192,7 @@
 			return rc;
 		}
 		pmctl = NULL;
-	}	
+	}
 	pcam_inst->streamon = 0;
 	pcam->mctl_node.dev_inst_map[pcam_inst->image_mode] = NULL;
 	if (pcam_inst->vbqueue_initialized)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl_pp.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl_pp.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_mctl_pp.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_mctl_pp.c	2013-08-01 23:38:00.000000000 -0600
@@ -153,7 +153,8 @@
 		buf_phyaddr = (unsigned long)
 			videobuf2_to_pmem_contig(&buf->vidbuf, 0) +
 			offset;
-		D("%s vb_idx=%d,vb_paddr=0x%x ch0=0x%x\n",
+		if (!buf_phyaddr)
+		pr_info("%s vb_idx=%d,vb_paddr=0x%x ch0=0x%x\n",
 		  __func__, buf->vidbuf.v4l2_buf.index,
 		  buf_phyaddr, fbuf->ch_paddr[0]);
 		if (fbuf->ch_paddr[0] == buf_phyaddr) {
@@ -315,7 +316,8 @@
 			pcam_inst->buf_offset[buf_idx][i].data_offset;
 			pp_frame->mp[i].fd = (int)mem->vaddr;
 			pp_frame->mp[i].length = mem->size;
-			D("%s frame id %d buffer %d plane %d phy addr 0x%x"
+			if (!pp_frame->mp[i].phy_addr)
+			pr_info("%s frame id %d buffer %d plane %d phy addr 0x%x"
 				" fd %d length %d\n", __func__,
 				pp_frame->frame_id, buf_idx, i,
 				(uint32_t)pp_frame->mp[i].phy_addr,
@@ -551,14 +553,6 @@
 			kfree(zoom);
 			return -EFAULT;
 		}
-		if ((void *)zoom->pp_frame_cmd.src_buf_handle == NULL ||
-			(void *)zoom->pp_frame_cmd.dest_buf_handle == NULL) {
-			pr_err("%s: src_buf_handle 0x%x dest_buf_handle 0x%x\n",
-				__func__, zoom->pp_frame_cmd.src_buf_handle, zoom->pp_frame_cmd.dest_buf_handle);
-			rc = -EINVAL;
-			kfree(zoom);
-			break;
-		}
 		D("%s: src=0x%x, dest=0x%x,cookie=0x%x,action=0x%x,path=0x%x",
 				__func__, zoom->pp_frame_cmd.src_buf_handle,
 				zoom->pp_frame_cmd.dest_buf_handle,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_vfe32.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_vfe32.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_vfe32.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_vfe32.c	2013-08-01 23:38:00.000000000 -0600
@@ -59,6 +59,8 @@
 static uint32_t vfe_clk_rate;
 static void vfe32_send_isp_msg(struct vfe32_ctrl_type *vctrl,
         uint32_t isp_msg_id);
+static atomic_t recovery_active;
+static uint32_t recover_irq_mask0, recover_irq_mask1;
 
 struct vfe32_isr_queue_cmd {
 	struct list_head list;
@@ -579,6 +581,7 @@
 	vfe32_ctrl->frame_skip_cnt = 31;
 	vfe32_ctrl->frame_skip_pattern = 0xffffffff;
 	vfe32_ctrl->snapshot_frame_cnt = 0;
+	atomic_set(&recovery_active, 0);
 }
 
 static void vfe32_program_dmi_cfg(enum VFE32_DMI_RAM_SEL bankSel)
@@ -2816,8 +2819,14 @@
 				vfe32_AXI_WM_CFG[vfe32_ctrl->outpath.out0.ch0]);
 				msm_io_w(0, vfe32_ctrl->vfebase +
 				vfe32_AXI_WM_CFG[vfe32_ctrl->outpath.out0.ch1]);
+				vfe32_ctrl->liveshot_state = VFE_STATE_HW_STOP_REQUESTED;
+				msm_io_w_mb(1, vfe32_ctrl->vfebase +
+					VFE_REG_UPDATE_CMD);
 			}
 			break;
+		case VFE_STATE_HW_STOP_REQUESTED:
+			vfe32_ctrl->liveshot_state = VFE_STATE_HW_STOPPED;
+			break;
 		case VFE_STATE_STOP_REQUESTED:
 			if (vfe32_ctrl->outpath.output_mode &
 					VFE32_OUTPUT_MODE_PRIMARY) {
@@ -2945,6 +2954,32 @@
 {
 	unsigned long flags;
 
+	if (atomic_read(&recovery_active) == 1) {
+		pr_info("Recovery restart stream\n");
+		msm_io_w(0x3FFF,
+			vfe32_ctrl->vfebase + VFE_BUS_CMD);
+		msm_io_w(recover_irq_mask0, vfe32_ctrl->vfebase + VFE_IRQ_MASK_0);
+		msm_io_w(recover_irq_mask1, vfe32_ctrl->vfebase + VFE_IRQ_MASK_1);
+
+		if (vfe32_ctrl->liveshot_state == VFE_STATE_START_REQUESTED ||
+			vfe32_ctrl->liveshot_state == VFE_STATE_STARTED ||
+			vfe32_ctrl->liveshot_state == VFE_STATE_HW_STOP_REQUESTED) {
+			pr_info("Liveshot recovery\n");
+			vfe32_ctrl->outpath.out0.capture_cnt = 1;
+			vfe32_ctrl->vfe_capture_count =
+				vfe32_ctrl->outpath.out0.capture_cnt;
+			vfe32_ctrl->liveshot_state = VFE_STATE_START_REQUESTED;
+		}
+		msm_io_w_mb(0x3,
+			vfe32_ctrl->vfebase + VFE_REG_UPDATE_CMD);
+		pr_info("camif cfg: 0x%x\n", msm_io_r(vfe32_ctrl->vfebase + 0x1EC));
+		msm_io_w_mb(0x4, vfe32_ctrl->vfebase + 0x1E0);
+		msm_io_w_mb(0x1, vfe32_ctrl->vfebase + 0x1E0);
+		atomic_set(&recovery_active, 0);
+		pr_info("Recovery restart done\n");
+		return;
+	}
+
 	atomic_set(&vfe32_ctrl->vstate, 0);
 
 	spin_lock_irqsave(&vfe32_ctrl->stop_flag_lock, flags);
@@ -3010,7 +3045,11 @@
 		pr_err("vfe32_irq: camif errors\n");
 		reg_value = msm_io_r(vfe32_ctrl->vfebase + VFE_CAMIF_STATUS);
 		pr_err("camifStatus  = 0x%x\n", reg_value);
-		vfe32_send_isp_msg(vfe32_ctrl, MSG_ID_CAMIF_ERROR);
+		if (reg_value & ~0x80000000) {
+			v4l2_subdev_notify(&vfe32_ctrl->subdev,
+				NOTIFY_VFE_CAMIF_ERROR, (void *)NULL);
+			vfe32_send_isp_msg(vfe32_ctrl, MSG_ID_CAMIF_ERROR);
+		}
 	}
 
 	if (errStatus & VFE32_IMASK_BHIST_OVWR)
@@ -3117,6 +3156,8 @@
 		vfe32_ctrl->operation_mode == VFE_OUTPUTS_JPEG_AND_THUMB ||
 		vfe32_ctrl->operation_mode == VFE_OUTPUTS_RAW ||
 		vfe32_ctrl->liveshot_state == VFE_STATE_STARTED ||
+		vfe32_ctrl->liveshot_state == VFE_STATE_HW_STOP_REQUESTED ||
+		vfe32_ctrl->liveshot_state == VFE_STATE_HW_STOPPED ||
 		vfe32_ctrl->liveshot_state == VFE_STATE_STOP_REQUESTED ||
 		vfe32_ctrl->liveshot_state == VFE_STATE_STOPPED) &&
 		(vfe32_ctrl->vfe_capture_count <= 1)) || free_buf;
@@ -3699,6 +3740,8 @@
 static void axi32_do_tasklet(unsigned long data)
 {
 	unsigned long flags;
+	uint8_t  axi_busy_flag = true;
+	uint32_t halt_timeout = 100;
 	struct axi_ctrl_t *axi_ctrl = (struct axi_ctrl_t *)data;
 	struct vfe32_isr_queue_cmd *qcmd = NULL;
 
@@ -3721,11 +3764,13 @@
 		spin_unlock_irqrestore(&axi_ctrl->tasklet_lock,
 			flags);
 
-		if (qcmd->vfeInterruptStatus0 &
-				VFE_IRQ_STATUS0_CAMIF_SOF_MASK)
-			v4l2_subdev_notify(&axi_ctrl->subdev,
-				NOTIFY_VFE_IRQ,
-				(void *)VFE_IRQ_STATUS0_CAMIF_SOF_MASK);
+		if (!atomic_read(&recovery_active)) {
+			if (qcmd->vfeInterruptStatus0 &
+					VFE_IRQ_STATUS0_CAMIF_SOF_MASK)
+				v4l2_subdev_notify(&axi_ctrl->subdev,
+					NOTIFY_VFE_IRQ,
+					(void *)VFE_IRQ_STATUS0_CAMIF_SOF_MASK);
+		}
 
 		
 		if (qcmd->vfeInterruptStatus0 &
@@ -3742,12 +3787,25 @@
 
 		if (atomic_read(&vfe32_ctrl->vstate)) {
 			if (qcmd->vfeInterruptStatus1 &
-					VFE32_IMASK_ERROR_ONLY_1) {
+					VFE32_IMASK_ERROR_ONLY_1 && atomic_read(&recovery_active) != 1) {
 				pr_err("irq	errorIrq\n");
 				vfe32_process_error_irq(
 					qcmd->vfeInterruptStatus1 &
 					VFE32_IMASK_ERROR_ONLY_1);
 			}
+
+			if ((qcmd->vfeInterruptStatus1 & 0x3FFF00) && atomic_read(&recovery_active) == 2) {
+				while (axi_busy_flag && halt_timeout--) {
+					if (msm_io_r(axi_ctrl->vfebase + VFE_AXI_STATUS) & 0x1)
+						axi_busy_flag = false;
+				}
+				msm_io_w_mb(AXI_HALT_CLEAR, axi_ctrl->vfebase + VFE_AXI_CMD);
+				pr_info("Halt done\n");
+				msm_io_w(0x000003EF, axi_ctrl->vfebase + 0x4);
+				atomic_set(&recovery_active, 1);
+			}
+
+			if(!atomic_read(&recovery_active))
 			v4l2_subdev_notify(&axi_ctrl->subdev,
 				NOTIFY_AXI_IRQ,
 				(void *)qcmd->vfeInterruptStatus0);
@@ -3854,7 +3912,7 @@
 	}
 
 	spin_lock_irqsave(&vfe32_ctrl->stop_flag_lock, flags);
-	if (vfe32_ctrl->stop_ack_pending) {
+	if (vfe32_ctrl->stop_ack_pending || atomic_read(&recovery_active)) {
 		irq.vfeIrqStatus0 &= VFE_IMASK_WHILE_STOPPING_0;
 		irq.vfeIrqStatus1 &= VFE_IMASK_WHILE_STOPPING_1;
 	}
@@ -3866,6 +3924,19 @@
 	qcmd->vfeInterruptStatus0 = irq.vfeIrqStatus0;
 	qcmd->vfeInterruptStatus1 = irq.vfeIrqStatus1;
 
+	if ((qcmd->vfeInterruptStatus1 & 0x3FFF00) && !atomic_read(&recovery_active)) {
+		pr_info("Start recovery\n");
+		recover_irq_mask0 = msm_io_r(axi_ctrl->vfebase + VFE_IRQ_MASK_0);
+		recover_irq_mask1 = msm_io_r(axi_ctrl->vfebase + VFE_IRQ_MASK_1);
+		msm_io_w(0x0, axi_ctrl->vfebase + VFE_IRQ_MASK_0);
+		msm_io_w((0x1 << 23), axi_ctrl->vfebase + VFE_IRQ_MASK_1);
+		msm_io_w(VFE_CLEAR_ALL_IRQS, axi_ctrl->vfebase + VFE_IRQ_CLEAR_0);
+		msm_io_w(VFE_CLEAR_ALL_IRQS, axi_ctrl->vfebase + VFE_IRQ_CLEAR_1);
+		msm_io_w(0x2, axi_ctrl->vfebase + 0x1E0);
+		msm_io_w(AXI_HALT, axi_ctrl->vfebase + VFE_AXI_CMD);
+		wmb();
+		atomic_set(&recovery_active, 2);
+	}
 	spin_lock_irqsave(&axi_ctrl->tasklet_lock, flags);
 	list_add_tail(&qcmd->list, &axi_ctrl->tasklet_q);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_vfe32.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_vfe32.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/msm_vfe32.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/msm_vfe32.h	2013-08-01 23:38:00.000000000 -0600
@@ -160,6 +160,8 @@
 	VFE_STATE_STARTED,
 	VFE_STATE_STOP_REQUESTED,
 	VFE_STATE_STOPPED,
+	VFE_STATE_HW_STOP_REQUESTED,
+	VFE_STATE_HW_STOPPED,
 };
 
 #define V32_CAMIF_OFF             0x000001E4
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ar0260_v4l2.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ar0260_v4l2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ar0260_v4l2.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ar0260_v4l2.c	2013-08-01 23:38:00.000000000 -0600
@@ -1483,8 +1483,10 @@
 	}
 
 #ifdef CONFIG_RAWCHIPII
-	Ilp0100_enableIlp0100SensorClock(SENSOR_1);
-	mdelay(35);	
+    if (sdata->htc_image == HTC_CAMERA_IMAGE_YUSHANII_BOARD) {
+    	Ilp0100_enableIlp0100SensorClock(SENSOR_1);
+        mdelay(35);	
+	}
 #endif
 
 #if 0	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/imx135_v4l2.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/imx135_v4l2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/imx135_v4l2.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/imx135_v4l2.c	2013-08-01 23:38:00.000000000 -0600
@@ -3560,13 +3560,15 @@
 	.sensor_id_reg_addr = 0x0016,
 	.sensor_id = 0x135,
 };
+#define SENSOR_REGISTER_MAX_LINECOUNT 0xffff
+#define SENSOR_VERT_OFFSET 4
 
 static struct msm_sensor_exp_gain_info_t imx135_exp_gain_info = {
 	.coarse_int_time_addr = 0x202,
 	.global_gain_addr = 0x204,
-	.vert_offset = 4,
+	.vert_offset = SENSOR_VERT_OFFSET,
 	.min_vert = 4,  
-	.sensor_max_linecount = 65531,  
+	.sensor_max_linecount = SENSOR_REGISTER_MAX_LINECOUNT-SENSOR_VERT_OFFSET,  
 };
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/Makefile monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -21,6 +21,7 @@
 obj-$(CONFIG_S5K3H2YX) += s5k3h2yx_v4l2.o
 obj-$(CONFIG_S5K6A1GX) += s5k6a1gx_v4l2.o
 obj-$(CONFIG_AR0260) += ar0260_v4l2.o
+obj-$(CONFIG_AS0260) += as0260_v4l2.o
 obj-$(CONFIG_IMX074) += imx074_v4l2.o
 obj-$(CONFIG_S5K3L1YX) += s5k3l1yx.o
 obj-$(CONFIG_OV2720) += ov2720.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/msm_sensor.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/msm_sensor.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/msm_sensor.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/msm_sensor.c	2013-08-01 23:38:00.000000000 -0600
@@ -217,16 +217,20 @@
 	if (s_ctrl->func_tbl->sensor_adjust_frame_lines)
 		rc = s_ctrl->func_tbl->sensor_adjust_frame_lines(s_ctrl, res);
 
-	if (s_ctrl->prev_dig_gain > 0 && s_ctrl->prev_line > 0){
-		if (s_ctrl->func_tbl->
-			sensor_write_exp_gain_ex != NULL){
-		    s_ctrl->func_tbl->
-		        sensor_write_exp_gain_ex(
-		        s_ctrl,
-		        SENSOR_PREVIEW_MODE,
-		        s_ctrl->prev_gain,
-		        s_ctrl->prev_dig_gain,
-		        s_ctrl->prev_line);
+	if (s_ctrl->func_tbl->sensor_yushanII_set_default_ae) {
+		s_ctrl->func_tbl->sensor_yushanII_set_default_ae(s_ctrl, res);
+	} else {
+		if (s_ctrl->prev_dig_gain > 0 && s_ctrl->prev_line > 0){
+			if (s_ctrl->func_tbl->
+				sensor_write_exp_gain_ex != NULL){
+			    s_ctrl->func_tbl->
+			        sensor_write_exp_gain_ex(
+			        s_ctrl,
+			        SENSOR_PREVIEW_MODE,
+			        s_ctrl->prev_gain,
+			        s_ctrl->prev_dig_gain,
+			        s_ctrl->prev_line);
+			}
 		}
 	}
 
@@ -320,6 +324,28 @@
 		s_ctrl->msm_sensor_reg->default_data_type);
 }
 
+void msm_sensor_group_hold_on_hdr(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	CDBG("%s: called\n", __func__);
+
+	msm_camera_i2c_write_tbl(
+		s_ctrl->sensor_i2c_client,
+		s_ctrl->msm_sensor_reg->group_hold_on_conf_hdr,
+		s_ctrl->msm_sensor_reg->group_hold_on_conf_size_hdr,
+		s_ctrl->msm_sensor_reg->default_data_type);
+}
+
+void msm_sensor_group_hold_off_hdr(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	CDBG("%s: called\n", __func__);
+
+	msm_camera_i2c_write_tbl(
+		s_ctrl->sensor_i2c_client,
+		s_ctrl->msm_sensor_reg->group_hold_off_conf_hdr,
+		s_ctrl->msm_sensor_reg->group_hold_off_conf_size_hdr,
+		s_ctrl->msm_sensor_reg->default_data_type);
+}
+
 int32_t msm_sensor_set_fps(struct msm_sensor_ctrl_t *s_ctrl,
 						struct fps_cfg *fps)
 {
@@ -690,6 +716,13 @@
 
 		
 		mutex_lock(s_ctrl->sensor_first_mutex);
+
+#ifdef CONFIG_RAWCHIPII
+		if(YushanII_Get_reloadInfo() == 0){
+			pr_info("stop YushanII first");
+			Ilp0100_stop();
+		}
+#endif
 		v4l2_subdev_notify(&s_ctrl->sensor_v4l2_subdev,
 			NOTIFY_ISPIF_STREAM, (void *)ISPIF_STREAM(
 			PIX_0, ISPIF_OFF_IMMEDIATELY));
@@ -1295,11 +1328,14 @@
 		s_ctrl->sensor_exp_gain_info->sensor_max_linecount = 0xFFFFFFFF;
 
 	sensor_output_info->sensor_max_linecount = s_ctrl->sensor_exp_gain_info->sensor_max_linecount;
-
-    for (i=0;i<s_ctrl->msm_sensor_reg->num_conf;++i)
+	
+    for (i=0;i<s_ctrl->msm_sensor_reg->num_conf;++i) {
         if (s_ctrl->adjust_y_output_size)
             s_ctrl->msm_sensor_reg->output_settings[i].y_output -= 1;
-
+        if (s_ctrl->adjust_frame_length_line)
+            s_ctrl->msm_sensor_reg->output_settings[i].line_length_pclk *= 2;
+    }
+	
 	
 	 
 	if ((s_ctrl->sensordata->htc_image == HTC_CAMERA_IMAGE_YUSHANII_BOARD) && (s_ctrl->msm_sensor_reg->output_settings_yushanii)) {
@@ -1315,11 +1351,14 @@
 			s_ctrl->msm_sensor_reg->num_conf))
 			rc = -EFAULT;
 	}
-
-    for (i=0;i<s_ctrl->msm_sensor_reg->num_conf;++i)
+	
+    for (i=0;i<s_ctrl->msm_sensor_reg->num_conf;++i) {
         if (s_ctrl->adjust_y_output_size)
             s_ctrl->msm_sensor_reg->output_settings[i].y_output += 1;
-
+        if (s_ctrl->adjust_frame_length_line)
+            s_ctrl->msm_sensor_reg->output_settings[i].line_length_pclk /= 2;
+    }
+    
 	
 	return rc;
 }
@@ -1741,7 +1780,7 @@
 {
 	int32_t rc = 0;
 	uint16_t chipid = 0;
-#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_DUMMY)\
+#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DELUXE_J) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_IMPRESSION_J)\
 		|| defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
 	int i=1;
 #else
@@ -1789,7 +1828,7 @@
 		}
 #endif
 	if (chipid != s_ctrl->sensor_id_info->sensor_id) {
-#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_DUMMY)\
+#if defined(CONFIG_MACH_MONARUDO) || defined(CONFIG_MACH_DELUXE_J) || defined(CONFIG_MACH_DELUXE_R) || defined(CONFIG_MACH_IMPRESSION_J)\
     || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
 		if (chipid == 0x174 && s_ctrl->sensor_id_info->sensor_id == 0x175)
 		{
@@ -1854,7 +1893,7 @@
 #endif
 	}
 
-	
+	if (board_mfg_mode () || s_ctrl->sensordata->htc_image == HTC_CAMERA_IMAGE_YUSHANII_BOARD) {
 #ifdef CONFIG_RAWCHIPII
 		rc = YushanII_probe_init();
 		if (rc < 0) {
@@ -1872,7 +1911,7 @@
 			}
 		}
 #endif
-	
+	}
 
 	if (s_ctrl->func_tbl && s_ctrl->func_tbl->sensor_power_up)
 		rc = s_ctrl->func_tbl->sensor_power_up(s_ctrl);
@@ -2130,4 +2169,28 @@
 
     return filp;
 }
+void msm_dump_otp_to_file(const char* sensor_name, const short* add, const uint8_t* data, size_t count)  
+{  
+    uint8_t *path= "/data/otp.txt";  
+    struct file* f = msm_fopen (path, O_CREAT|O_RDWR|O_TRUNC, 0666);  
+    char buf[512];  
+    int i=0;  
+    int len=0,offset=0;  
+    pr_info ("%s\n",__func__);  
+  
+    if (f) {  
+        len = sprintf (buf,"%s\n",sensor_name);  
+        msm_fwrite (f,offset,buf,len);  
+        offset += len;  
+  
+        for (i=0; i<count; ++i) {  
+            len = sprintf (buf,"0x%x 0x%x\n",add[i],data[i]);  
+            msm_fwrite (f,offset,buf,len);  
+            offset += len;  
+        }  
+        msm_fclose (f);  
+    } else {  
+        pr_err ("%s: fail to open file\n", __func__);  
+    }  
+}  
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/msm_sensor.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/msm_sensor.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/msm_sensor.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/msm_sensor.h	2013-08-01 23:38:00.000000000 -0600
@@ -107,6 +107,12 @@
 	uint8_t group_hold_on_conf_size;
 	struct msm_camera_i2c_reg_conf *group_hold_off_conf;
 	uint8_t group_hold_off_conf_size;
+
+	struct msm_camera_i2c_reg_conf *group_hold_on_conf_hdr;
+	uint8_t group_hold_on_conf_size_hdr;
+	struct msm_camera_i2c_reg_conf *group_hold_off_conf_hdr;
+	uint8_t group_hold_off_conf_size_hdr;
+
 	struct msm_camera_i2c_conf_array *init_settings;
 	uint8_t init_size;
 
@@ -147,6 +153,8 @@
 	void (*sensor_stop_stream) (struct msm_sensor_ctrl_t *);
 	void (*sensor_group_hold_on) (struct msm_sensor_ctrl_t *);
 	void (*sensor_group_hold_off) (struct msm_sensor_ctrl_t *);
+	void (*sensor_group_hold_on_hdr) (struct msm_sensor_ctrl_t *);
+	void (*sensor_group_hold_off_hdr) (struct msm_sensor_ctrl_t *);
 
 	int32_t (*sensor_set_fps) (struct msm_sensor_ctrl_t *,
 			struct fps_cfg *);
@@ -195,6 +203,9 @@
     void (*sensor_yushanII_set_output_format)(struct msm_sensor_ctrl_t *sensor,int res, Ilp0100_structFrameFormat *output_format);
 	void (*sensor_yushanII_set_parm)(struct msm_sensor_ctrl_t *sensor, int res,Ilp0100_structSensorParams *YushanII_sensor);
     void (*sensor_yushanII_set_IQ)(struct msm_sensor_ctrl_t *sensor,int*,int*,int*,struct yushanii_cls*);
+	void(*sensor_yushanII_active_hold)(void);
+	int (*sensor_yushanII_ae_updated)(void);
+	void(*sensor_yushanII_set_default_ae)(struct msm_sensor_ctrl_t *, uint8_t);
 };
 
 struct msm_sensor_ctrl_t {
@@ -242,14 +253,18 @@
 	int hdr_mode;
 	int yushanII_switch_virtual_channel;
 	int adjust_y_output_size;
+	int adjust_frame_length_line;
 	uint8_t driver_ic;
+	bool ews_enable;
+	bool actived_ae;	
 };
 
 void msm_sensor_start_stream(struct msm_sensor_ctrl_t *s_ctrl);
 void msm_sensor_stop_stream(struct msm_sensor_ctrl_t *s_ctrl);
 void msm_sensor_group_hold_on(struct msm_sensor_ctrl_t *s_ctrl);
 void msm_sensor_group_hold_off(struct msm_sensor_ctrl_t *s_ctrl);
-
+void msm_sensor_group_hold_on_hdr(struct msm_sensor_ctrl_t *s_ctrl);
+void msm_sensor_group_hold_off_hdr(struct msm_sensor_ctrl_t *s_ctrl);
 int32_t msm_sensor_set_fps(struct msm_sensor_ctrl_t *s_ctrl,
 			struct fps_cfg   *fps);
 int32_t msm_sensor_write_exp_gain1(struct msm_sensor_ctrl_t *s_ctrl,
@@ -358,6 +373,7 @@
 struct file* msm_fopen(const char* path, int flags, int rights);
 int msm_fwrite(struct file* file, unsigned long long offset, unsigned char* data, unsigned int size);
 void msm_fclose(struct file* file);
+void msm_dump_otp_to_file(const char* sensor_name, const short* add, const uint8_t* data, size_t count);  
 
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ov2722_v4l2.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ov2722_v4l2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ov2722_v4l2.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ov2722_v4l2.c	2013-08-01 23:38:00.000000000 -0600
@@ -38,9 +38,9 @@
 
 
 #if defined(CONFIG_MACH_MONARUDO) ||\
-    defined(CONFIG_MACH_DUMMY) ||\
+    defined(CONFIG_MACH_DELUXE_J) ||\
     defined(CONFIG_MACH_DELUXE_R) ||\
-    defined(CONFIG_MACH_DUMMY) ||\
+    defined(CONFIG_MACH_IMPRESSION_J) ||\
     defined(CONFIG_MACH_DUMMY) ||\
     defined(CONFIG_MACH_DUMMY) ||\
     defined(CONFIG_MACH_DUMMY)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ov4688_v4l2.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ov4688_v4l2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/ov4688_v4l2.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/ov4688_v4l2.c	2013-08-01 23:38:00.000000000 -0600
@@ -3,11 +3,20 @@
 #include "../yushanII/ilp0100_ST_definitions.h"
 #include "../yushanII/ilp0100_ST_api.h"
 
-#define SENSOR_NAME "ov4688"
+#define SENSOR_NAME_I2C_0X20 "ov4688_0x20"
+#define SENSOR_NAME_I2C_0X6C "ov4688_0x6c"
+
 #define PLATFORM_DRIVER_NAME "msm_camera_ov4688"
 #define ov4688_obj ov4688_##obj
 
 #define OV4688_REG_READ_MODE 0x0101
+
+#define OV4688_REG_FLIP_MODE 0x3820	
+#define OV4688_REG_MIRROR_MODE 0x3821	
+#define OV4688_REG_NON_MIRROR_FLIP 0x0000
+#define OV4688_REG_FLIP 0x6
+#define OV4688_REG_MIRROR 0x6
+
 #define OV4688_READ_NORMAL_MODE 0x0000	
 #define OV4688_READ_MIRROR 0x0001			
 #define OV4688_READ_FLIP 0x0002			
@@ -43,12 +52,21 @@
 
 static struct msm_camera_i2c_reg_conf ov4688_start_settings[] = {
 	{0x0100, 0x01},
+
+	{0x301a, 0xf9},
+    {0xffff, 10},
+	{0x301a, 0xf1},
+	{0x4805, 0x00},
+	{0x301a, 0xf0},
+
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_start_settings2[] = {
 	{0x3105, 0x11}, 
-	{0x301a, 0xf0}, 
-	{0x3208, 0x00}, 
+	{0x301a, 0xf1}, 
+	{0x4805, 0x00}, 
+    {0x301a, 0xf0},
+    {0x3208, 0x00},
 	{0x302a, 0x00}, 
 	{0x302a, 0x00}, 
 	{0x302a, 0x00}, 
@@ -63,26 +81,39 @@
 
 static struct msm_camera_i2c_reg_conf ov4688_stop_settings[] = {
 
-	{0x3208, 0x00},
-
 	{0x0100, 0x00},
-
-    {0x3208, 0x10},
-    {0x3208, 0xa0},
+    {0xffff, 100},
+	{0x301a, 0xf9},
+	{0x4805, 0x03},
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_groupon_settings[] = {
-
+	{0x3208, 0x00},
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_groupoff_settings[] = {
+    {0x3208, 0x10},
+	{0x3208, 0xa0},
+};
 
+static struct msm_camera_i2c_reg_conf ov4688_groupon_settings_hdr[] = {
+	{0x3208, 0x01},
 };
 
+static struct msm_camera_i2c_reg_conf ov4688_groupoff_settings_hdr[] = {
+    {0x3208, 0x11},
+};
 
  struct msm_camera_i2c_reg_conf ov4688_prev_settings[] = {
-#if 1
-	{0x4308 , 0x02+1}, 
+    {0xffff, 200},
+    
+    {0x3841 , 0x02},
+    {0x3846 , 0x08},
+    {0x3847 , 0x07},
+    {0x4800 , 0x04},
+    {0x376e , 0x00},
+
+	
 	{0x3632, 0x05},
 	{0x376b, 0x40},
 	{0x3800, 0x00},
@@ -126,58 +157,11 @@
 	{0x4502, 0x44},
 	{0x4601, 0x28},
 	{0x5050, 0x0c}, 
-#else
-    {0x4308 , 0x02}, 
-    {0x3632, 0x05},
-    {0x376b, 0x40},
-    {0x3800, 0x00},
-    {0x3801, 0x08},
-    {0x3802, 0x00},
-    {0x3803, 0x04},
-    {0x3804, 0x0a},
-    {0x3805, 0x97},
-    {0x3806, 0x05},
-    {0x3807, 0xff},
-    {0x3808, 0x05},
-    {0x3809, 0x40},
-    {0x380a, 0x02},
-    {0x380b, 0xf8},
-    {0x380c, 0x04}, 
-    {0x380d, 0xe6},
-    {0x380e, 0x03},
-    {0x380f, 0x1d},
-    {0x3810, 0x00},
-    {0x3811, 0x04},
-    {0x3812, 0x00},
-    {0x3813, 0x02},
-    {0x3814, 0x03},
-    {0x3815, 0x01},
-    {0x3819, 0x01},
-    {0x3820, 0x00},
-    {0x3821, 0x07},
-    {0x3829, 0x00},
-    {0x382a, 0x03},
-    {0x382b, 0x01},
-    {0x382d, 0x7f},
-    {0x3830, 0x08},
-    {0x3836, 0x02},
-    {0x4001, 0x50},
-    {0x4022, 0x03},
-    {0x4023, 0xe7},
-    {0x4024, 0x05},
-    {0x4025, 0x14},
-    {0x4026, 0x05},
-    {0x4027, 0x23},
-    {0x4502, 0x44},
-    {0x4601, 0x28},
-    {0x5050, 0x0c},
-
-#endif
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_video_settings[] = {
 
-
+    {0xffff, 200},
     {0x3632, 0x00},
     {0x376b, 0x20},
 
@@ -187,7 +171,7 @@
     {0x3847 , 0x07},
     {0x4800 , 0x04},
     {0x376e , 0x00},
-    {0x4308 , 0x02+1}, 
+    
 
 
     {0x3800, 0x00},
@@ -235,7 +219,16 @@
 };
 
 struct msm_camera_i2c_reg_conf ov4688_fast_video_settings[] = {
-    {0x4308, 0x02+1}, 
+    
+    {0xffff, 200},
+
+    
+    {0x3841 , 0x02},
+    {0x3846 , 0x08},
+    {0x3847 , 0x07},
+    {0x4800 , 0x04},
+    {0x376e , 0x00},
+
     {0x3632, 0x05},
     {0x376b, 0x40},
     {0x3800, 0x00},
@@ -283,125 +276,69 @@
 };
 
 struct msm_camera_i2c_reg_conf ov4688_4_3_settings[] = {
-#if 1
-
-{0x3632 , 0x00},
-{0x376b , 0x20},
+    {0xffff, 200},
 
 
-{0x3841 , 0x02},
-{0x3846 , 0x08},
-{0x3847 , 0x07},
-{0x4800 , 0x04},
-{0x376e , 0x00},
-{0x4308 , 0x02+1}, 
-
-
-{0x3800 , 0x01},
-{0x3801 , 0x34},
-{0x3802 , 0x00},
-{0x3803 , 0x04},
-{0x3804 , 0x09},
-{0x3805 , 0x4f},
-{0x3806 , 0x05},
-{0x3807 , 0xfb},
-{0x3808 , 0x08},
-{0x3809 , 0x04},
-{0x380a , 0x05},
-{0x380b , 0xf0+1},
-{0x380c , 0x05},
-{0x380d , 0xc0},
-{0x380e , 0x06},
-{0x380f , 0x60},
-{0x3810 , 0x00},
-{0x3811 , 0x04},
-{0x3812 , 0x00},
-{0x3813 , 0x04-1},
-{0x3814 , 0x01},
-{0x3815 , 0x01},
-{0x3819 , 0x01},
-{0x3820 , 0x00},
-{0x3821 , 0x06},
-{0x3829 , 0x00},
-{0x382a , 0x01},
-{0x382b , 0x01},
-{0x382d , 0x7f},
-{0x3830 , 0x04},
-{0x3836 , 0x01},
-
-{0x4001 , 0x40},
-{0x4022 , 0x06},
-{0x4023 , 0x3f},
-{0x4024 , 0x07},
-{0x4025 , 0x6c},
-{0x4026 , 0x07},
-{0x4027 , 0x7b},
-{0x4502 , 0x40},
-{0x4601 , 0x04},
-{0x5050 , 0x0c},
+    {0x3632 , 0x00},
+    {0x376b , 0x20},
 
 
-#else
-    {0x3632, 0x00},
-    {0x376b, 0x20},
-
     
     {0x3841 , 0x02},
     {0x3846 , 0x08},
     {0x3847 , 0x07},
     {0x4800 , 0x04},
     {0x376e , 0x00},
-    {0x4308 , 0x02}, 
+    
 
-	{0x3800, 0x01},
-	{0x3801, 0x38},
-	{0x3802, 0x00},
-	{0x3803, 0x04},
-	{0x3804, 0x09},
-	{0x3805, 0x4f},
-	{0x3806, 0x05},
-	{0x3807, 0xfb},
-	{0x3808, 0x08},
-	{0x3809, 0x00},
-	{0x380a, 0x05},
-	{0x380b, 0xf0},
-	{0x380c, 0x05},
-	{0x380d, 0xbd},
-	{0x380e, 0x06},
-	{0x380f, 0x60},
-	{0x3810, 0x00},
-	{0x3811, 0x00},
-	{0x3812, 0x00},
-	{0x3813, 0x00},
-	{0x3814, 0x01},
-	{0x3815, 0x01},
-	{0x3819, 0x01},
-	{0x3820, 0x00},
-	{0x3821, 0x06},
-	{0x3829, 0x00},
-	{0x382a, 0x01},
-	{0x382b, 0x01},
-	{0x382d, 0x7f},
-	{0x3830, 0x04},
-	{0x3836, 0x01},
 
-    {0x4001, 0x40},
-    {0x4022, 0x07},
-    {0x4023, 0xcf},
-    {0x4024, 0x09},
-    {0x4025, 0x60},
-    {0x4026, 0x09},
-    {0x4027, 0x6f},
-    {0x4502, 0x40},
-    {0x4601, 0x04},
-    {0x5050, 0x0c},
-#endif
+    {0x3800 , 0x01},
+    {0x3801 , 0x34},
+    {0x3802 , 0x00},
+    {0x3803 , 0x04},
+    {0x3804 , 0x09},
+    {0x3805 , 0x4f},
+    {0x3806 , 0x05},
+    {0x3807 , 0xfb},
+    {0x3808 , 0x08},
+    {0x3809 , 0x04},
+    {0x380a , 0x05},
+    {0x380b , 0xf0+1},
+    {0x380c , 0x05},
+    {0x380d , 0xc0},
+    {0x380e , 0x06},
+    {0x380f , 0x60},
+    {0x3810 , 0x00},
+    {0x3811 , 0x04},
+    {0x3812 , 0x00},
+    {0x3813 , 0x04-1},
+    {0x3814 , 0x01},
+    {0x3815 , 0x01},
+    {0x3819 , 0x01},
+    {0x3820 , 0x00},
+    {0x3821 , 0x06},
+    {0x3829 , 0x00},
+    {0x382a , 0x01},
+    {0x382b , 0x01},
+    {0x382d , 0x7f},
+    {0x3830 , 0x04},
+    {0x3836 , 0x01},
+
+    {0x4001 , 0x40},
+    {0x4022 , 0x06},
+    {0x4023 , 0x3f},
+    {0x4024 , 0x07},
+    {0x4025 , 0x6c},
+    {0x4026 , 0x07},
+    {0x4027 , 0x7b},
+    {0x4502 , 0x40},
+    {0x4601 , 0x04},
+    {0x5050 , 0x0c},
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_hdr_settings[] = {
-	
-	
-#if 1
+    {0xffff, 200},
+
 
    {0x3632 , 0x00},
    {0x376b , 0x20},
@@ -451,7 +388,6 @@
    {0x4601 , 0x04 },
    {0x5050 , 0x0c },
 
- #endif
    {0x3841 , 0x03},
    {0x3846 , 0x08},
    {0x3847 , 0x06},
@@ -461,6 +397,7 @@
 };
 
 struct msm_camera_i2c_reg_conf ov4688_16_9_settings_non_hdr[] = {
+    {0xffff, 200},
 
     {0x3632, 0x00},
     {0x376b, 0x20},
@@ -471,7 +408,7 @@
     {0x3847 , 0x07},
     {0x4800 , 0x04},
     {0x376e , 0x00},
-    {0x4308 , 0x02|1}, 
+   
 
     {0x3800, 0x00},
     {0x3801, 0x00},
@@ -521,7 +458,7 @@
     {0x0103, 0x01},
     {0x3638, 0x00},
     {0x0300, 0x00},
-    {0x0302, 0x32},
+    {0x0302, 0x30}, 
     {0x0303, 0x01}, 
     {0x0304, 0x03},
     {0x030b, 0x00},
@@ -534,6 +471,7 @@
     {0x3002, 0x00},
     {0x3018, 0x72},
     {0x3020, 0x93},
+    {0x3021, 0x03}, 
     {0x3022, 0x01},
     {0x3031, 0x0a},
     {0x3305, 0xf1},
@@ -542,7 +480,7 @@
     {0x3500, 0x00},
     {0x3501, 0x60},
     {0x3502, 0x00},
-    {0x3503, 0x04},
+    {0x3503, 0x04}, 
     {0x3504, 0x00},
     {0x3505, 0x00},
     {0x3506, 0x00},
@@ -579,6 +517,9 @@
     {0x3528, 0x08},
     {0x352a, 0x08},
     {0x3602, 0x00},
+
+	{0x3603, 0x01},    
+
     {0x3604, 0x02},
     {0x3605, 0x00},
     {0x3606, 0x00},
@@ -688,7 +629,7 @@
     {0x4304, 0x00},
     {0x4305, 0x00},
     {0x4306, 0x00},
-    {0x4308 , 0x02}, 
+    {0x4308 , 0x03}, 
 
     {0x4500, 0x6c},
     {0x4501, 0xc4},
@@ -697,11 +638,11 @@
     {0x4813, 0x08},
     {0x481f, 0x40},
     {0x4829, 0x78},
-    {0x4837, 0x1b},
+    {0x4837, 0x1c},
     {0x4b00, 0x2a},
     {0x4b0d, 0x00},
     {0x4d00, 0x04},
-    {0x4d01, 0x18},
+    {0x4d01, 0x42}, 
     {0x4d02, 0xd1},
     {0x4d03, 0x93},
     {0x4d04, 0xf5},
@@ -712,6 +653,14 @@
     {0x500a, 0x00},
     {0x500b, 0x00},
     {0x5032, 0x00},
+
+	
+	{0x5500, 0x00},
+	{0x5501, 0x10},
+	{0x5502, 0x01},
+	{0x5503, 0x0f},
+	
+
     {0x5040, 0x00},
     {0x8000, 0x00},
     {0x8001, 0x00},
@@ -724,13 +673,20 @@
     {0x8008, 0x00},
     {0x3638, 0x00},
     {0x3105, 0x31},
-    {0x301a, 0xf1},
-    {0x3508, 0x07},
-    {0x3601, 0x01},
+    {0x301a, 0xf9}, 
+
+	
+	{0x484b, 0x05},
+	{0x4805, 0x03},
+	{0x3508, 0x07},
+	{0x3601, 0x01},
+	{0x3603, 0x01},
+	
 };
 
 static struct msm_camera_i2c_reg_conf ov4688_zoe_settings[] = {
 
+    {0xffff, 200},
 
     {0x3632, 0x00},
     {0x376b, 0x20},
@@ -741,7 +697,7 @@
     {0x3847 , 0x07},
     {0x4800 , 0x04},
     {0x376e , 0x00},
-    {0x4308 , 0x02+1}, 
+    
 
 
     {0x3800, 0x00},
@@ -756,10 +712,14 @@
     {0x3809, 0x80},
     {0x380a, 0x05},
     {0x380b, 0xf0+1}, 
-    {0x380c, 0x06},
-    {0x380d, 0x48},
-    {0x380e, 0x06},
-    {0x380f, 0x12},
+    {0x380c, 0x09},
+    {0x380d, 0x10},
+    {0x380e, 0x09},
+    {0x380f, 0x2d},
+
+    
+    
+
     {0x3810, 0x00},
     {0x3811, 0x10},
     {0x3812, 0x00},
@@ -785,7 +745,6 @@
     {0x4502, 0x40},
     {0x4601, 0x04},
     {0x5050, 0x0c},
-
 };
 
 static struct v4l2_subdev_info ov4688_subdev_info[] = {
@@ -825,7 +784,8 @@
 
 #define ADD_FRAME_LENGTH_LINES 0x00
 #define ADD_LINE_LENGTH 0x0
-#define PIXEL_CLK 240000000 
+#define PIXEL_CLK 230400000 
+#define De_flicker_pixel_clk 240000000
 
 static struct msm_sensor_output_info_t ov4688_dimensions[] = {
 	{
@@ -835,7 +795,7 @@
 		.y_output = 0x5F0+1, 
 		.line_length_pclk = 0x6c0+ADD_LINE_LENGTH,
 		.frame_length_lines = 0x612+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 1,
 		.is_hdr = 0,
@@ -848,7 +808,7 @@
 		.y_output = 0x2F8+1, 
 		.line_length_pclk = 0xa00+ADD_LINE_LENGTH,  
 		.frame_length_lines = 0x31d+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 2,
 		.is_hdr = 0,
@@ -863,7 +823,7 @@
 		.y_output = 0x5F0+1, 
 		.line_length_pclk = 0x9f0+ADD_LINE_LENGTH,
 		.frame_length_lines = 0x612+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 1,
 		.is_hdr = 0,
@@ -876,7 +836,7 @@
 		.y_output = 0x2F8+1, 
 		.line_length_pclk = 0x600+ADD_LINE_LENGTH,  
 		.frame_length_lines = 0x31d+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 2,
 		.is_hdr = 0,
@@ -888,9 +848,9 @@
 	{
 		.x_output = 1952, 
 		.y_output = 1089, 
-		.line_length_pclk = 0x8c0+ADD_LINE_LENGTH,
+		.line_length_pclk = 0xaaa+ADD_LINE_LENGTH,
 		.frame_length_lines = 0x4c0+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 1,
 		.is_hdr = 1,
@@ -906,7 +866,7 @@
         .y_output = 0x5F0+1, 
         .line_length_pclk = 0x6c0,
         .frame_length_lines = 0x660+ADD_FRAME_LENGTH_LINES,
-        .vt_pixel_clk = PIXEL_CLK,
+        .vt_pixel_clk = De_flicker_pixel_clk,
         .op_pixel_clk = PIXEL_CLK,
         .binning_factor = 1,
         .is_hdr = 0,
@@ -919,7 +879,7 @@
         .y_output = 0x2F8+1, 
         .line_length_pclk = 0x600+ADD_LINE_LENGTH,  
         .frame_length_lines = 0x31d+ADD_FRAME_LENGTH_LINES,
-        .vt_pixel_clk = PIXEL_CLK,
+        .vt_pixel_clk = De_flicker_pixel_clk,
         .op_pixel_clk = PIXEL_CLK,
         .binning_factor = 2,
         .is_hdr = 0,
@@ -934,7 +894,7 @@
 		.y_output = 0x5F0+1, 
 		.line_length_pclk = 0x6c0+ADD_LINE_LENGTH,
 		.frame_length_lines = 0x612+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK,
 		.binning_factor = 1,
 		.is_hdr = 0,
@@ -947,9 +907,9 @@
 		.y_addr_start = 0x0,
 		.x_output = 0xA80, 
 		.y_output = 0x5F0+1, 
-		.line_length_pclk = 0x6c0*2+ADD_LINE_LENGTH,
-		.frame_length_lines = 0x612+ADD_FRAME_LENGTH_LINES,
-		.vt_pixel_clk = PIXEL_CLK,
+		.line_length_pclk = 0x910,
+		.frame_length_lines = 0x92d,
+		.vt_pixel_clk = De_flicker_pixel_clk,
 		.op_pixel_clk = PIXEL_CLK, 
 		.binning_factor = 1,
 		.is_hdr = 0,
@@ -1002,14 +962,17 @@
 	.sensor_id_reg_addr = 0x300A,
 	.sensor_id = 0x4688,
 };
+#define SENSOR_REGISTER_MAX_LINECOUNT 0xffff
+#define SENSOR_VERT_OFFSET 25
 
 static struct msm_sensor_exp_gain_info_t ov4688_exp_gain_info = {
 	.coarse_int_time_addr = 0x3500,
 	.global_gain_addr = 0x3508,
-	.vert_offset = 25,
+	.vert_offset = SENSOR_VERT_OFFSET, 
 	.min_vert = 4,  
-	.sensor_max_linecount = 65531,  
+	.sensor_max_linecount = SENSOR_REGISTER_MAX_LINECOUNT - SENSOR_VERT_OFFSET,  
 };
+#define SENSOR_VERT_OFFSET_HDR 4
 
 static struct ov4688_hdr_exp_info_t ov4688_hdr_gain_info = {
 	.long_coarse_int_time_addr_h = 0x3500,
@@ -1024,8 +987,8 @@
 	.middle_gain_addr_h = 0x350D,
 	.middle_gain_addr_m = 0x350E,
 	.middle_gain_addr_l = 0x350F,
-	.vert_offset = 4,
-	.sensor_max_linecount = 65531,  
+	.vert_offset = SENSOR_VERT_OFFSET_HDR,
+	.sensor_max_linecount = SENSOR_REGISTER_MAX_LINECOUNT-SENSOR_VERT_OFFSET_HDR,  
 };
 
 int32_t ov4688_set_dig_gain(struct msm_sensor_ctrl_t *s_ctrl, uint16_t dig_gain)
@@ -1049,29 +1012,45 @@
 static int ov4688_sensor_open_init(const struct msm_camera_sensor_info *data)
 {
 	int rc = 0;
-	uint16_t value = 0;
 
 	if (data->sensor_platform_info)
 		ov4688_s_ctrl.mirror_flip = data->sensor_platform_info->mirror_flip;
 
-    pr_info("ov4688_sensor_open_init,ov4688_s_ctrl.mirror_flip=%d",ov4688_s_ctrl.mirror_flip);
+	ov4688_s_ctrl.actived_ae = false;	
+    pr_info("%s: ov4688_s_ctrl.mirror_flip=%d", __func__, ov4688_s_ctrl.mirror_flip);
+
+	 return rc;
+}
 
-	
-	if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_MIRROR_FLIP)
-		value = OV4688_READ_MIRROR_FLIP;
-	else if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_MIRROR)
-		value = OV4688_READ_MIRROR;
-	else if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_FLIP)
-		value = OV4688_READ_FLIP;
-	else
-		value = OV4688_READ_NORMAL_MODE;
 
-    pr_info("ov4688_sensor_open_init,value=%d",value);
-	msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client,
-		OV4688_REG_READ_MODE, value, MSM_CAMERA_I2C_BYTE_DATA);
+int ov4688_write_output_settings_specific(struct msm_sensor_ctrl_t *s_ctrl,
+       uint16_t res)
+{
+	int rc = 0;
+	int16_t read_data = 0;
+
+    pr_info("%s: ov4688_s_ctrl.mirror_flip=%d", __func__, ov4688_s_ctrl.mirror_flip);
+
+	msm_camera_i2c_read(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_MIRROR_MODE, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+	read_data = read_data & 0x1;    
+
+	
+	if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_MIRROR_FLIP) {
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_FLIP_MODE, OV4688_REG_FLIP, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_MIRROR_MODE, (OV4688_REG_MIRROR | read_data), MSM_CAMERA_I2C_BYTE_DATA);
+	}       else if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_MIRROR) {
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_FLIP_MODE, OV4688_REG_NON_MIRROR_FLIP, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_MIRROR_MODE, (OV4688_REG_MIRROR | read_data), MSM_CAMERA_I2C_BYTE_DATA);
+	} else if (ov4688_s_ctrl.mirror_flip == CAMERA_SENSOR_FLIP) {
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_FLIP_MODE, OV4688_REG_FLIP, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_MIRROR_MODE, (OV4688_REG_NON_MIRROR_FLIP | read_data), MSM_CAMERA_I2C_BYTE_DATA);
+	}       else {
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_FLIP_MODE, OV4688_REG_NON_MIRROR_FLIP, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, OV4688_REG_MIRROR_MODE, (OV4688_REG_NON_MIRROR_FLIP | read_data), MSM_CAMERA_I2C_BYTE_DATA);
+	}
 
 	return rc;
-}
+ }
 
 static const char *ov4688Vendor = "ov";
 static const char *ov4688NAME = "ov4688";
@@ -1129,27 +1108,47 @@
 	return rc;
 }
 
-static const struct i2c_device_id ov4688_i2c_id[] = {
-	{SENSOR_NAME, (kernel_ulong_t)&ov4688_s_ctrl},
+static const struct i2c_device_id ov4688_i2c_0x20_id[] = {
+	{SENSOR_NAME_I2C_0X20, (kernel_ulong_t)&ov4688_s_ctrl},
+	{ }
+};
+
+static struct i2c_driver ov4688_i2c_0x20_driver = {
+	.id_table = ov4688_i2c_0x20_id,
+	.probe  = ov4688_i2c_probe,
+	.driver = {
+		.name = SENSOR_NAME_I2C_0X20,
+	},
+};
+
+static const struct i2c_device_id ov4688_i2c_0x6c_id[] = {
+	{SENSOR_NAME_I2C_0X6C, (kernel_ulong_t)&ov4688_s_ctrl},
 	{ }
 };
 
-static struct i2c_driver ov4688_i2c_driver = {
-	.id_table = ov4688_i2c_id,
+static struct i2c_driver ov4688_i2c_0x6c_driver = {
+	.id_table = ov4688_i2c_0x6c_id,
 	.probe  = ov4688_i2c_probe,
 	.driver = {
-		.name = SENSOR_NAME,
+		.name = SENSOR_NAME_I2C_0X6C,
 	},
 };
 
+
 static struct msm_camera_i2c_client ov4688_sensor_i2c_client = {
 	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
 };
 
+
+static int ov4688_read_fuseid(struct sensor_cfg_data *cdata,
+	struct msm_sensor_ctrl_t *s_ctrl);
+static int power_on=false;
 int32_t ov4688_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 {
 	int rc;
 	struct msm_camera_sensor_info *sdata = NULL;
+	struct sensor_cfg_data cdata;
+	power_on=true;
 	pr_info("%s called\n", __func__);
 
 	if (s_ctrl && s_ctrl->sensordata)
@@ -1189,6 +1188,8 @@
 	mdelay(5);
 
 	ov4688_sensor_open_init(sdata);
+
+	ov4688_read_fuseid(&cdata,s_ctrl);
 	return rc;
 
 enable_sensor_power_up_failed:
@@ -1206,6 +1207,7 @@
 {
 	int rc;
 	struct msm_camera_sensor_info *sdata = NULL;
+	power_on=false;
 	pr_info("%s called\n", __func__);
 
 	if (s_ctrl && s_ctrl->sensordata)
@@ -1220,10 +1222,6 @@
 		return -EIO;
 	}
 
-	rc = sdata->camera_power_off();
-	if (rc < 0)
-		pr_info("%s: failed to disable power\n", __func__);
-
 	rc = msm_sensor_set_power_down(s_ctrl);
 	if (rc < 0)
 		pr_info("%s: msm_sensor_power_down failed\n", __func__);
@@ -1235,13 +1233,25 @@
 				 __func__, rc);
 	}
 
+	rc = sdata->camera_power_off();
+	if (rc < 0)
+		pr_info("%s: failed to disable power\n", __func__);
+
 	return rc;
 }
 
 static int __init msm_sensor_init_module(void)
 {
+    int rc =0;
 	pr_info("ov4688 %s\n", __func__);
-	return i2c_add_driver(&ov4688_i2c_driver);
+	rc = i2c_add_driver(&ov4688_i2c_0x6c_driver);
+    if (!rc) {
+	    pr_info("ov4688 %s with i2c address 0x6c fail, try 0x20\n", __func__);
+        ov4688_s_ctrl.sensor_i2c_addr = 0x20;
+        ov4688_s_ctrl.sensor_i2c_driver = &ov4688_i2c_0x20_driver;
+        rc = i2c_add_driver(&ov4688_i2c_0x20_driver);
+    }
+    return rc;
 }
 
 static struct v4l2_subdev_core_ops ov4688_subdev_core_ops = {
@@ -1258,6 +1268,45 @@
 	.video  = &ov4688_subdev_video_ops,
 };
 
+
+static int ov4688_lookup_actuator(struct msm_sensor_ctrl_t *s_ctrl, char *actuator_name)
+{
+	int i;
+	struct msm_camera_sensor_info *sdata;
+	struct msm_actuator_info *actuator_info;
+	int actuator_index = -1;
+
+	if ((s_ctrl == NULL) || (s_ctrl->sensordata == NULL))
+		return -EFAULT;
+	if (actuator_name == NULL)
+		return -EFAULT;
+
+	sdata = (struct msm_camera_sensor_info *) s_ctrl->sensordata;
+
+	for(i=0; i<sdata->num_actuator_info_table; i++) {
+		actuator_info = &sdata->actuator_info_table[i][0];
+		pr_info("index=%d   actuator_info->board_info->type=%s\n", i, actuator_info->board_info->type);
+		if(!strncmp(actuator_info->board_info->type, actuator_name, strlen(actuator_name))) {
+			actuator_index = i;
+			break;
+		}
+	}
+
+	return actuator_index;
+}
+
+#if defined(CONFIG_ACT_OIS_BINDER)
+extern void HtcActOisBinder_set_OIS_OTP(uint8_t *otp_data, uint8_t otp_size);
+
+#define OV4688_LITEON_OIS_OTP_SIZE 34
+const static short ois_addr[3][OV4688_LITEON_OIS_OTP_SIZE] = {
+    
+    {0x16A,0x16B,0x16C,0x16D,0x16E,0x16F,0x170,0x171,0x172,0x173,0x174,0x175,0x176,0x177,0x178,0x179,0x17A,0x17B,0x17C,0x17D,0x17E,0x17F,0x180,0x181,   0x124,0x125,0x12B,0x12C,   0x1B2,0x1B3,0x1B4,0x1B5,0x1B6,0x1B7}, 
+    {0x182,0x183,0x184,0x185,0x186,0x187,0x188,0x189,0x18A,0x18B,0x18C,0x18D,0x18E,0x18F,0x190,0x191,0x192,0x193,0x194,0x195,0x196,0x197,0x198,0x199,   0x142,0x143,0x149,0x014A,   0x1B8,0x1B9,0x1BA,0x1BB,0x1BC,0x1BD}, 
+    {0x19A,0x19B,0x19C,0x19D,0x19E,0x19F,0x1A0,0x1A1,0x1A2,0x1A3,0x1A4,0x1A5,0x1A6,0x1A7,0x1A8,0x1A9,0x1AA,0x1AB,0x1AC,0x1AD,0x1AE,0x1AF,0x1B0,0x1B1,   0x160,0x161,0x167,0x168,   0x1BE,0x1BF,0x1C0,0x1C1,0x1C2,0x1C3}, 
+};
+#endif
+
 static int ov4688_read_fuseid(struct sensor_cfg_data *cdata,
 	struct msm_sensor_ctrl_t *s_ctrl)
 {
@@ -1273,12 +1322,20 @@
 	static int frist= true;
 	uint16_t read_data = 0;
 
+#if defined(CONFIG_ACT_OIS_BINDER)
+	int32_t ois_valid_layer=-1;
+	static uint8_t ois_otp[OV4688_LITEON_OIS_OTP_SIZE];
+#endif
+
     int32_t i,j;
     int32_t rc = 0;
     const int32_t offset = 0x7000;
-    int32_t valid_layer=-1;
+    static int32_t valid_layer=-1;
     uint16_t addr_start=0x7100;
     uint16_t addr_end=0x71ca;
+    struct msm_camera_sensor_info *sdata = (struct msm_camera_sensor_info *) s_ctrl->sensordata;
+    uint8_t driver_ic;
+    int actuator_index = -1;
 
 	if (frist) {
 	    frist = false;
@@ -1332,12 +1389,45 @@
         }
         pr_info("%s: OTP valid layer = %d\n", __func__,  valid_layer);
 
+
+
+#if defined(CONFIG_ACT_OIS_BINDER)
+        
+        for (j=2; j>=0; --j) {
+            for (i=0; i<OV4688_LITEON_OIS_OTP_SIZE; ++i) {
+                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, ois_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+                if (rc < 0){
+                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, ois_addr[j][i]);
+                    return rc;
+                }
+                pr_info("%s: OTP ois_addr 0x%x = 0x%x\n", __func__,  ois_addr[j][i], read_data);
+
+                ois_otp[i]= read_data;
+
+                if (read_data)
+                    ois_valid_layer = j;
+            }
+            if (ois_valid_layer!=-1)
+                break;
+        }
+        pr_info("%s: OTP OIS valid layer = %d\n", __func__,  ois_valid_layer);
+
+
+	if (ois_valid_layer!=-1) {
+		for(i=0; i<OV4688_LITEON_OIS_OTP_SIZE;i ++)
+			pr_info("read out OTP OIS data = 0x%x\n", ois_otp[i]);
+
+		HtcActOisBinder_set_OIS_OTP(ois_otp, OV4688_LITEON_OIS_OTP_SIZE);
+	}
+#endif
+
+
         rc = msm_camera_i2c_write_b(s_ctrl->sensor_i2c_client, 0x0100, 0x00);
         if (rc < 0)
             pr_info("%s: i2c_write_b 0x0100 fail\n", __func__);
     }
-    
-
+    if (board_mfg_mode())
+        msm_dump_otp_to_file (PLATFORM_DRIVER_NAME, addr[valid_layer], otp, sizeof(otp));
     
     cdata->cfg.fuse.fuse_id_word1 = 0;
     cdata->cfg.fuse.fuse_id_word2 = otp[5];
@@ -1377,6 +1467,31 @@
     pr_info("%s: OTP Macro position code (LSByte) = 0x%x\n",    __func__,  cdata->af_value.AF_MACRO_LSB);
     pr_info("%s: OTP VCM top mech. Limit (MSByte) = 0x%x\n",    __func__,  cdata->af_value.VCM_TOP_MECH_MSB);
     pr_info("%s: OTP VCM top mech. Limit (LSByte) = 0x%x\n",    __func__,  cdata->af_value.VCM_TOP_MECH_LSB);
+
+
+	if (sdata->num_actuator_info_table > 1)
+	{
+		driver_ic = otp[3];
+		pr_info("%s: driver_ic=%d\n", __func__, driver_ic);
+
+		if (driver_ic == 0x21) { 
+			actuator_index = ov4688_lookup_actuator(s_ctrl, "ti201_act");
+		} else if (driver_ic == 0x11) { 
+			actuator_index = ov4688_lookup_actuator(s_ctrl, "lc898212_act");
+		} else if (driver_ic == 0x1)  { 
+			actuator_index = ov4688_lookup_actuator(s_ctrl, "rumbas_act");
+		}
+
+		if (actuator_index >= 0 && actuator_index < sdata->num_actuator_info_table)
+			sdata->actuator_info = &sdata->actuator_info_table[actuator_index][0];
+		else {
+			pr_info("%s: Actuator lookup fail, use the default actuator in board file\n", __func__);
+		}
+
+		pr_info("%s: sdata->actuator_info->board_info->type=%s", __func__, sdata->actuator_info->board_info->type);
+		pr_info("%s: sdata->actuator_info->board_info->addr=0x%x", __func__, sdata->actuator_info->board_info->addr);
+	}
+
 	return 0;
 }
 
@@ -1502,13 +1617,13 @@
 
 	if(short_line > 198)
 		short_line = 198;
-	if(short_line < 2)
+	if(short_line < 2)	
 		short_line = 2;
 
 	long_line = short_line*4;
 
-	if(long_line > 1584)
-		long_line = 1584;
+	if(long_line > 1008)	
+		long_line = 1008;
 	if(long_line < 8)
 		long_line = 8;
 
@@ -1517,118 +1632,38 @@
 		long_line,
 		short_line);
 
-	s_ctrl->func_tbl->sensor_group_hold_on(s_ctrl);
-	mdelay(250);
+	if (s_ctrl->func_tbl->sensor_group_hold_on_hdr)
+		s_ctrl->func_tbl->sensor_group_hold_on_hdr(s_ctrl);
+
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
 		s_ctrl->sensor_output_reg_addr->frame_length_lines, fl_lines,
 		MSM_CAMERA_I2C_WORD_DATA);
-	
-#if 0
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_coarse_int_time_addr_h, long_line>>8,
-		MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_coarse_int_time_addr_l, (long_line&0x00ff),
-		MSM_CAMERA_I2C_BYTE_DATA);
-#else
-
 
 	
+	
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_h, long_line>>12, MSM_CAMERA_I2C_BYTE_DATA);
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_m, (long_line>>4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_l, (long_line<<4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
 
-
-
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_gain_addr_h, gain,
+		ov4688_hdr_gain_info.long_gain_addr_m, gain,
 		MSM_CAMERA_I2C_WORD_DATA);
 
-#if 0
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_gain_addr_h, gain >> 8, MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_gain_addr_m, gain & 0x00ff, MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.long_gain_addr_l, 0x0, MSM_CAMERA_I2C_BYTE_DATA);
-#endif
-#endif
-#if 0
-	long_exp.AnalogGainCodeBlue = gain;
-	long_exp.AnalogGainCodeGreen = gain;
-	long_exp.AnalogGainCodeRed = gain;
-	long_exp.ExposureTime = long_line;
-	long_exp.DigitalGainCodeBlue = 256;
-	long_exp.DigitalGainCodeGreen = 256;
-	long_exp.DigitalGainCodeRed = 256;
-
-	Ilp0100_updateSensorParamsLong(long_exp);
-#endif
 	
-#if 0
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.short_coarse_int_time_addr_h, (short_line)>>8,
-		MSM_CAMERA_I2C_BYTE_DATA);
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.short_coarse_int_time_addr_l, (short_line & 0x00ff),
-		MSM_CAMERA_I2C_BYTE_DATA);
-#else
-#if 0
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_coarse_int_time_addr_h, short_line >> 8, MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_coarse_int_time_addr_m, short_line & 0x00ff, MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_coarse_int_time_addr_l, 0x0, MSM_CAMERA_I2C_BYTE_DATA);
-#endif
 	
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_h, short_line>>12, MSM_CAMERA_I2C_BYTE_DATA);
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_m, (short_line>>4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_l, (short_line<<4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
 
-
 	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_gain_addr_h, gain,
+		ov4688_hdr_gain_info.middle_gain_addr_m, gain,
 		MSM_CAMERA_I2C_WORD_DATA);
 
-#if 0
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_gain_addr_h, gain >> 8, MSM_CAMERA_I2C_BYTE_DATA);
-
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_gain_addr_m, gain & 0x00ff, MSM_CAMERA_I2C_BYTE_DATA);
+	if (s_ctrl->func_tbl->sensor_group_hold_off_hdr)
+		s_ctrl->func_tbl->sensor_group_hold_off_hdr(s_ctrl);
 
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.middle_gain_addr_l, 0x0, MSM_CAMERA_I2C_BYTE_DATA);
-#endif
-#endif
+	ov4688_s_ctrl.actived_ae = false;
 
-#if 0 
-	
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		ov4688_hdr_gain_info.global_gain_addr, gain,
-		MSM_CAMERA_I2C_BYTE_DATA);
-#endif
-
-#if 0
-	short_exp.AnalogGainCodeBlue = gain;
-	short_exp.AnalogGainCodeGreen = gain;
-	short_exp.AnalogGainCodeRed = gain;
-	short_exp.ExposureTime = short_line;
-	short_exp.DigitalGainCodeBlue = 256;
-	short_exp.DigitalGainCodeGreen = 256;
-	short_exp.DigitalGainCodeRed = 256;
-
-	Ilp0100_updateSensorParamsShortOrNormal(short_exp);
-#endif
-
-	s_ctrl->func_tbl->sensor_group_hold_off(s_ctrl);
 	return 0;
 
 }
@@ -1720,42 +1755,26 @@
 }
 
 void ov4688_start_stream_non_hdr(struct msm_sensor_ctrl_t *s_ctrl){
-	uint16_t data;
-	pr_info("ov4688_start_stream,non-HDR");
 
-	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
-		0x100, 0x01,
-		MSM_CAMERA_I2C_BYTE_DATA);
-	mdelay(10);
+
+	pr_info("ov4688_start_stream,non-HDR");
 
 	msm_camera_i2c_write_tbl(
-		s_ctrl->sensor_i2c_client, 
-		ov4688_start_settings2, 
-		ARRAY_SIZE(ov4688_start_settings2), 
-		MSM_CAMERA_I2C_BYTE_DATA);
+    		s_ctrl->sensor_i2c_client,
+    		ov4688_start_settings,
+    		ARRAY_SIZE(ov4688_start_settings),
+    		MSM_CAMERA_I2C_BYTE_DATA);
 
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x3500, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x3500:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x3501, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x3501:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x3502, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x3502:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x380e, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x380e:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x380f, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x380f:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x380c, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x380c:0x%x",data);
-	msm_camera_i2c_read(s_ctrl->sensor_i2c_client,
-		0x380d, &data, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("ov4688 0x380d:0x%x",data);
+	mdelay(10);
 
+    if (power_on) {
+    	msm_camera_i2c_write_tbl(
+    		s_ctrl->sensor_i2c_client,
+    		ov4688_start_settings2,
+    		ARRAY_SIZE(ov4688_start_settings2),
+    		MSM_CAMERA_I2C_BYTE_DATA);
+           power_on=0;
+    }
 }
 
 void ov4688_start_stream(struct msm_sensor_ctrl_t *s_ctrl)
@@ -1773,14 +1792,8 @@
 int ov4688_write_hdr_outdoor_flag(struct msm_sensor_ctrl_t *s_ctrl, uint8_t is_outdoor)
 {
     int indoor_line_length, outdoor_line_length;
-    indoor_line_length = 9600;
-    outdoor_line_length = 6000;
-    if(s_ctrl->sensordata->sensor_cut == 0){
-	indoor_line_length = indoor_line_length /2;
-	outdoor_line_length = outdoor_line_length /2;
-    }
-
-    return 0;
+    indoor_line_length = 2730;
+    outdoor_line_length = 1760;
 
     if (is_outdoor)
         msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
@@ -1859,15 +1872,73 @@
     *channel_offset = 70;
 }
 
+void ov4688_yushanII_active_hold(void)
+{
+	pr_info("[CAM]%s,actived_ae=%d", __func__, ov4688_s_ctrl.actived_ae);
+	if (!ov4688_s_ctrl.actived_ae) {
+		msm_camera_i2c_write(ov4688_s_ctrl.sensor_i2c_client, 0x3208, 0xe1, MSM_CAMERA_I2C_BYTE_DATA);
+		ov4688_s_ctrl.actived_ae = true;
+	}
+}
+
+int ov4688_yushanII_ae_updated(void)
+{
+	return ov4688_s_ctrl.actived_ae;
+}
+
+void ov4688_yushanII_set_default_ae(struct msm_sensor_ctrl_t *s_ctrl, uint8_t res)
+{
+	uint32_t long_line =0x1d4;	
+	uint32_t short_line = 0x75;
+	uint16_t gain = 0x3f7;
+
+	pr_info("[CAM]%s, res=%d", __func__, res);
+
+	if (res == 4) {	
+		
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_h, long_line>>12, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_m, (long_line>>4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_l, (long_line<<4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			ov4688_hdr_gain_info.long_gain_addr_m, gain,
+			MSM_CAMERA_I2C_WORD_DATA);
+
+		
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_h, short_line>>12, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_m, (short_line>>4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.middle_coarse_int_time_addr_l, (short_line<<4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			ov4688_hdr_gain_info.middle_gain_addr_m, gain,
+			MSM_CAMERA_I2C_WORD_DATA);
+	} else {
+		long_line = s_ctrl->msm_sensor_reg->output_settings[res].frame_length_lines/2;	
+		gain = 0x80;	
+
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_h, long_line>>12, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_m, (long_line>>4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, ov4688_hdr_gain_info.long_coarse_int_time_addr_l, (long_line<<4)&0xff, MSM_CAMERA_I2C_BYTE_DATA);
+
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			ov4688_hdr_gain_info.long_gain_addr_m, gain,
+			MSM_CAMERA_I2C_WORD_DATA);
+	}
+
+}
+
 static struct msm_sensor_fn_t ov4688_func_tbl = {
 	.sensor_start_stream = ov4688_start_stream,
 	.sensor_stop_stream = msm_sensor_stop_stream,
 	.sensor_group_hold_on = msm_sensor_group_hold_on,
 	.sensor_group_hold_off = msm_sensor_group_hold_off,
+	.sensor_group_hold_on_hdr = msm_sensor_group_hold_on_hdr,
+	.sensor_group_hold_off_hdr = msm_sensor_group_hold_off_hdr,
 	.sensor_set_fps = msm_sensor_set_fps,
 	.sensor_write_exp_gain_ex = ov4688_write_exp_gain1_ex,
 	.sensor_write_hdr_exp_gain_ex = ov4688_write_hdr_exp_gain1_ex,
-	.sensor_write_snapshot_exp_gain_ex = msm_sensor_write_exp_gain1_ex,
+	
+	.sensor_write_snapshot_exp_gain_ex = ov4688_write_exp_gain1_ex,
 	.sensor_write_snapshot_exp_gain = msm_sensor_write_exp_gain1,
 	.sensor_setting = msm_sensor_setting_parallel,
 	.sensor_set_sensor_mode = msm_sensor_set_sensor_mode,
@@ -1882,6 +1953,10 @@
 	.sensor_yushanII_set_output_format = ov4688_yushanII_set_output_format,
 	.sensor_yushanII_set_parm = ov4688_yushanII_set_parm,
 	.sensor_yushanII_set_IQ = ov4688_yushanII_set_IQ,
+	.sensor_write_output_settings_specific = ov4688_write_output_settings_specific,	
+	.sensor_yushanII_active_hold = ov4688_yushanII_active_hold,
+	.sensor_yushanII_ae_updated = ov4688_yushanII_ae_updated,
+	.sensor_yushanII_set_default_ae = ov4688_yushanII_set_default_ae,
 };
 
 static struct msm_sensor_reg_t ov4688_regs = {
@@ -1893,8 +1968,12 @@
 	.group_hold_on_conf = ov4688_groupon_settings,
 	.group_hold_on_conf_size = ARRAY_SIZE(ov4688_groupon_settings),
 	.group_hold_off_conf = ov4688_groupoff_settings,
-	.group_hold_off_conf_size =
-		ARRAY_SIZE(ov4688_groupoff_settings),
+	.group_hold_off_conf_size = ARRAY_SIZE(ov4688_groupoff_settings),
+	.group_hold_on_conf_hdr = ov4688_groupon_settings_hdr,
+	.group_hold_on_conf_size_hdr = ARRAY_SIZE(ov4688_groupon_settings_hdr),
+	.group_hold_off_conf_hdr = ov4688_groupoff_settings_hdr,
+	.group_hold_off_conf_size_hdr = ARRAY_SIZE(ov4688_groupoff_settings_hdr),
+
 	.init_settings = &ov4688_init_conf[0],
 	.init_size = ARRAY_SIZE(ov4688_init_conf),
 
@@ -1909,14 +1988,14 @@
 static struct msm_sensor_ctrl_t ov4688_s_ctrl = {
 	.msm_sensor_reg = &ov4688_regs,
 	.sensor_i2c_client = &ov4688_sensor_i2c_client,
-	.sensor_i2c_addr = 0x6C,
+	.sensor_i2c_addr = 0x6c,
 	.sensor_output_reg_addr = &ov4688_reg_addr,
 	.sensor_id_info = &ov4688_id_info,
 	.sensor_exp_gain_info = &ov4688_exp_gain_info,
 	.cam_mode = MSM_SENSOR_MODE_INVALID,
 	.csi_params = &ov4688_csi_params_array[0],
 	.msm_sensor_mutex = &ov4688_mut,
-	.sensor_i2c_driver = &ov4688_i2c_driver,
+	.sensor_i2c_driver = &ov4688_i2c_0x6c_driver,
 	.sensor_v4l2_subdev_info = ov4688_subdev_info,
 	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov4688_subdev_info),
 	.sensor_v4l2_subdev_ops = &ov4688_subdev_ops,
@@ -1924,6 +2003,7 @@
 	.sensor_first_mutex = &ov4688_sensor_init_mut, 
 	.yushanII_switch_virtual_channel = 1,
 	.adjust_y_output_size = 1,
+	.adjust_frame_length_line = 1,
 };
 
 module_init(msm_sensor_init_module);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/vd6869_v4l2.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/vd6869_v4l2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/sensors/vd6869_v4l2.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/sensors/vd6869_v4l2.c	2013-08-01 23:38:00.000000000 -0600
@@ -57,6 +57,22 @@
 	uint32_t sensor_max_linecount; 
 };
 
+static struct msm_camera_i2c_reg_conf otp_settings_cut09[] = {
+       {0x44c0, 0x01},
+       {0x4500, 0x01},
+       {0x44ec, 0x01},
+       {0x44ed, 0x80},
+       {0x44f0, 0x04},
+       {0x44f1, 0xb0},
+       {0x452c, 0x01},
+       {0x452d, 0x80},
+       {0x4530, 0x04},
+       {0x4531, 0xb0},
+	{0x3305, 0x00},
+       {0x3303, 0x01},
+	{0x3304, 0x00},
+       {0x3301, 0x02},
+};
 
 static struct msm_camera_i2c_reg_conf otp_settings_cut10[] = {
        {0x44c0, 0x01},
@@ -4403,15 +4419,6 @@
 	ARRAY_SIZE(vd6869_zoe_settings_cut10), 0, MSM_CAMERA_I2C_BYTE_DATA},
 };
 
-static struct msm_camera_i2c_reg_conf vd6869_09E_Analog_Setting[] = {
-	{},
-};
-
-static struct msm_camera_i2c_conf_array vd6869_confs_09E_analog_setting[] = {
-	{&vd6869_09E_Analog_Setting[0],
-	ARRAY_SIZE(vd6869_09E_Analog_Setting), 0, MSM_CAMERA_I2C_BYTE_DATA},
-};
-
 static struct msm_sensor_output_info_t vd6869_dimensions_cut10[] = {
 	{
 		.x_addr_start = 0,
@@ -4604,23 +4611,27 @@
 	.sensor_id_reg_addr = 0x0,
 	.sensor_id = 0x0365,
 };
+#define SENSOR_REGISTER_MAX_LINECOUNT 0xffff
+#define SENSOR_VERT_OFFSET 25
 
 static struct msm_sensor_exp_gain_info_t vd6869_exp_gain_info = {
 	.coarse_int_time_addr = 0x202,
 	.global_gain_addr = 0x204,
-	.vert_offset = 25,
+	.vert_offset = SENSOR_VERT_OFFSET, 
 	.min_vert = 4,  
-	.sensor_max_linecount = 65525,  
+	.sensor_max_linecount = SENSOR_REGISTER_MAX_LINECOUNT-SENSOR_VERT_OFFSET,  
 };
 
+#define SENSOR_VERT_OFFSET_HDR 4
+
 static struct vd6869_hdr_exp_info_t vd6869_hdr_gain_info = {
 	.long_coarse_int_time_addr_h = 0x32e5,
 	.long_coarse_int_time_addr_l = 0x32e6,
 	.short_coarse_int_time_addr_h = 0x32f0,
 	.short_coarse_int_time_addr_l = 0x32f1,
 	.global_gain_addr = 0x32e7,
-	.vert_offset = 4,
-	.sensor_max_linecount = 65531,  
+	.vert_offset = SENSOR_VERT_OFFSET_HDR,
+	.sensor_max_linecount = SENSOR_REGISTER_MAX_LINECOUNT-SENSOR_VERT_OFFSET_HDR,  
 };
 
 
@@ -4782,18 +4793,30 @@
 {
 	int rc = 0;
 
-	if (data->sensor_platform_info)
+	if (data->sensor_platform_info){
 		vd6869_s_ctrl.mirror_flip = data->sensor_platform_info->mirror_flip;
 
-	if(vd6869_s_ctrl.driver_ic == 0x11){
-		if(data->sensor_platform_info->sensor_mount_angle == ANGLE_90){
-			vd6869_s_ctrl.mirror_flip = CAMERA_SENSOR_NONE;
-			data->sensor_platform_info->mirror_flip = CAMERA_SENSOR_NONE;
-		}
+		if(vd6869_s_ctrl.driver_ic == 0x11){
+			if(data->sensor_platform_info->sensor_mount_angle == ANGLE_90){
+				vd6869_s_ctrl.mirror_flip = CAMERA_SENSOR_NONE;
+			}
+			else if(data->sensor_platform_info->sensor_mount_angle == ANGLE_270){
+				vd6869_s_ctrl.mirror_flip = CAMERA_SENSOR_MIRROR_FLIP;
+			}
+		}else if(vd6869_s_ctrl.driver_ic == 0x1){
+			if(data->sensor_platform_info->sensor_mount_angle == ANGLE_270){
+				vd6869_s_ctrl.mirror_flip = CAMERA_SENSOR_NONE;
+			}
+		}else
+			pr_info("%s vd6869_s_ctrl->sensordata->sensor_cut=%d", __func__, vd6869_s_ctrl.sensordata->sensor_cut);
+		data->sensor_platform_info->mirror_flip = vd6869_s_ctrl.mirror_flip;
+		pr_info("vd6869_sensor_open_init,vd6869_s_ctrl.mirror_flip=%d,data->sensor_platform_info->mirror_flip=%d", vd6869_s_ctrl.mirror_flip, data->sensor_platform_info->mirror_flip);
+		pr_info("vd6869_sensor_open_init,sensor_mount_angle=%d", data->sensor_platform_info->sensor_mount_angle);
+		pr_info("vd6869_sensor_open_init,vd6869_s_ctrl.driver_ic=%d", vd6869_s_ctrl.driver_ic);
+		
+		vd6869_s_ctrl.ews_enable = data->sensor_platform_info->ews_enable;
+		pr_info("vd6869_s_ctrl.ews_enable=%d", vd6869_s_ctrl.ews_enable);
 	}
-	pr_info("vd6869_sensor_open_init,vd6869_s_ctrl.mirror_flip=%d,data->sensor_platform_info->mirror_flip=%d", vd6869_s_ctrl.mirror_flip, data->sensor_platform_info->mirror_flip);
-	pr_info("vd6869_sensor_open_init,sensor_mount_angle=%d", data->sensor_platform_info->sensor_mount_angle);
-	pr_info("vd6869_sensor_open_init,vd6869_s_ctrl.driver_ic=%d", vd6869_s_ctrl.driver_ic);
 	return rc;
 }
 
@@ -4917,12 +4940,6 @@
 	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
 };
 
-static void vd6869_apply_analog_setting(struct msm_sensor_ctrl_t *s_ctrl){
-	msm_sensor_write_conf_array
-		(s_ctrl->sensor_i2c_client, &vd6869_confs_09E_analog_setting[0], 0);
-}
-
-
 static int vd6869_shut_down_otp(struct msm_sensor_ctrl_t *s_ctrl,uint16_t addr, uint16_t data){
 	int rc=0,i;
 	for(i = 0; i < OTP_WAIT_TIMEOUT;i++){
@@ -4943,6 +4960,51 @@
 	return rc;
 }
 
+static int vd6869_cut09_init_otp(struct msm_sensor_ctrl_t *s_ctrl){
+	int i,rc = 0;
+	uint16_t read_data = 0;
+
+	
+	for(i = 0 ;i < OTP_WAIT_TIMEOUT; i++) {
+		rc = msm_camera_i2c_write_tbl(
+			s_ctrl->sensor_i2c_client
+			, otp_settings_cut09,
+			ARRAY_SIZE(otp_settings_cut09),
+			MSM_CAMERA_I2C_BYTE_DATA);
+
+		if(rc < 0)
+			pr_err("%s write otp init table error.... retry", __func__);
+		else{
+			pr_info("%s OTP table init done",__func__);
+			break;
+		}
+		mdelay(1);
+	}
+
+	
+	for(i = 0 ;i < OTP_WAIT_TIMEOUT; i++){
+		
+		rc = msm_camera_i2c_read(
+			s_ctrl->sensor_i2c_client,
+			(0x3302),&read_data,
+			MSM_CAMERA_I2C_BYTE_DATA);
+
+		if(rc < 0){
+			pr_err("%s read OTP status error",__func__);
+		} else if(read_data == 0x00){
+			rc = vd6869_shut_down_otp(s_ctrl,0x44c0,0x00);
+			if(rc < 0)
+				return rc;
+			rc = vd6869_shut_down_otp(s_ctrl,0x4500,0x00);
+			if(rc < 0)
+				return rc;
+			break;
+		}
+		mdelay(1);
+	}
+	return rc;
+}
+
 static int vd6869_cut10_init_otp(struct msm_sensor_ctrl_t *s_ctrl){
 	int i,rc = 0;
 	uint16_t read_data = 0;
@@ -5045,13 +5107,18 @@
 
 
 #define VD6869_LITEON_OTP_SIZE 0x12
-const static short otp_addr[3][VD6869_LITEON_OTP_SIZE] = {
+const static short new_otp_addr[3][VD6869_LITEON_OTP_SIZE] = {
     
     {0x3C8,0x3C9,0x3CA,0x3CB,0x3CC,0x3A0,0x3A1,0x3A2,0x3CD,0x3CE,0x3C0,0x3C1,0x3C2,0x3C3,0x3C4,0x3C5,0x3C6,0x3C7}, 
     {0x3D8,0x3D9,0x3DA,0x3DB,0x3DC,0x380,0x381,0x382,0x3DD,0x3DE,0x3D0,0x3D1,0x3D2,0x3D3,0x3D4,0x3D5,0x3D6,0x3D7}, 
     {0x3B8,0x3B9,0x3BA,0x3BB,0x3BC,0x388,0x389,0x38A,0x3BD,0x3BE,0x3B0,0x3B1,0x3B2,0x3B3,0x3B4,0x3B5,0x3B6,0x3B7}, 
 };
-
+const static short old_otp_addr[3][VD6869_LITEON_OTP_SIZE] = {
+    
+    {0x3C8,0x3C9,0x3CA,0x3CB,0x3CC,0x3A0,0x3A1,0x3A2,0x3CD,0x3CE,0x3C0,0x3C1,0x3C2,0x3C3,0x3C4,0x3C5,0x3C6,0x3C7}, 
+    {0x3D8,0x3D9,0x3DA,0x3DB,0x3DC,0x380,0x381,0x382,0x3DD,0x3DE,0x3D0,0x3D1,0x3D2,0x3D3,0x3D4,0x3D5,0x3D6,0x3D7}, 
+    {0x3B8,0x3B9,0x3BA,0x3BB,0x3BC,0x388,0x389,0x3AA,0x3BD,0x3BE,0x3B0,0x3B1,0x3B2,0x3B3,0x3B4,0x3B5,0x3B6,0x3B7}, 
+};
 
 #if defined(CONFIG_ACT_OIS_BINDER)
 extern void HtcActOisBinder_set_OIS_OTP(uint8_t *otp_data, uint8_t otp_size);
@@ -5065,27 +5132,6 @@
 };
 #endif
 
-static void vd6869_dump_otp_to_file(const short* add, const uint8_t* data, size_t count)
-{
-    uint8_t *path= "/data/vd6869_otp.txt";
-    struct file* f = msm_fopen (path, O_CREAT|O_RDWR|O_TRUNC, 0666);
-    char buf[512];
-    int i=0;
-    int len=0;
-    pr_info ("%s\n",__func__);
-
-    if (f) {
-        for (i=0; i<count; ++i) {
-            len += sprintf (buf+len,"0x%x 0x%x\n",add[i],data[i]);
-        }
-
-        msm_fwrite (f,0,buf,len);
-        msm_fclose (f);
-    } else {
-        pr_err ("%s: fail to open file\n", __func__);
-    }
-}
-
 int vd6869_read_fuseid_liteon(struct sensor_cfg_data *cdata,
 	struct msm_sensor_ctrl_t *s_ctrl, bool first)
 {
@@ -5094,6 +5140,7 @@
 	const int32_t offset = 0x33fa;
 	static int32_t valid_layer=-1;
 	uint16_t ews_data[4] = {0};
+
     static uint8_t otp[VD6869_LITEON_OTP_SIZE];
 #if defined(CONFIG_ACT_OIS_BINDER)
 	int32_t ois_valid_layer=-1;
@@ -5112,26 +5159,39 @@
 				}
 				pr_info("%s: read OTP 0x%x = 0x%x\n", __func__, (0x3F4 + i), ews_data[i]);
 			}
-
-			if (ews_data[0]==0 && ews_data[1]==0 && ews_data[2]==0 && ews_data[3]==1) {
-				pr_info("%s: Apply OTP ECC enable", __func__);
-			} else {
-				
-				vd6869_cut10_init_otp_NO_ECC(s_ctrl);
-				pr_info("%s: Apply OTP ECC disable", __func__);
-			}
+			if(vd6869_s_ctrl.ews_enable){
+				if (ews_data[0]==0 && ews_data[1]==0 && ews_data[2]==0 && ews_data[3]==1) {
+					vd6869_cut10_init_otp(s_ctrl);				
+					pr_info("%s: Apply OTP ECC enable", __func__);
+				} else {
+					
+					vd6869_cut10_init_otp_NO_ECC(s_ctrl);
+					pr_info("%s: Apply OTP ECC disable", __func__);
+				}
+			}else {
+                vd6869_cut10_init_otp(s_ctrl);              
+				pr_info("%s: Apply OTP ECC enable, vd6869_s_ctrl.ews_enable=%d", __func__, vd6869_s_ctrl.ews_enable);
+            }
 		}
 
         
         for (j=2; j>=0; --j) {
             for (i=0; i<VD6869_LITEON_OTP_SIZE; ++i) {
-                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
-                if (rc < 0){
-                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, otp_addr[j][i]);
-                    return rc;
+                if(vd6869_s_ctrl.ews_enable){
+                    rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, old_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+	                if (rc < 0){
+	                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, old_otp_addr[j][i]);
+	                    return rc;
+	                }
+	                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  old_otp_addr[j][i], read_data);
+                }else{
+	                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, new_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+	                if (rc < 0){
+	                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, new_otp_addr[j][i]);
+	                    return rc;
+	                }
+	                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  new_otp_addr[j][i], read_data);
                 }
-                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  otp_addr[j][i], read_data);
-
                 otp[i]= read_data;
 
                 if (read_data)
@@ -5178,12 +5238,11 @@
     vd6869_ver = otp[2]; 
     cdata->sensor_ver = otp[2];
 
-    
-    if(vd6869_ver == 0x0A){
-        vd6869_apply_analog_setting(s_ctrl);
-    }
     if (board_mfg_mode()) {
-        vd6869_dump_otp_to_file (otp_addr[valid_layer], otp, VD6869_LITEON_OTP_SIZE);
+        if(vd6869_s_ctrl.ews_enable) 
+            msm_dump_otp_to_file (PLATFORM_DRIVER_NAME, old_otp_addr[valid_layer], otp, VD6869_LITEON_OTP_SIZE);
+        else
+            msm_dump_otp_to_file (PLATFORM_DRIVER_NAME, new_otp_addr[valid_layer], otp, VD6869_LITEON_OTP_SIZE);
     }
     
     cdata->cfg.fuse.fuse_id_word1 = 0;
@@ -5230,65 +5289,60 @@
 int vd6869_read_fuseid_sharp(struct sensor_cfg_data *cdata,
 	struct msm_sensor_ctrl_t *s_ctrl,bool first)
 {
-	int32_t rc = 0;
-	int i,j;
-	int otp_date = 0;
-	uint16_t read_data = 0;
-	static uint8_t OTP[OTP_SIZE] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-	static uint8_t OTP_FUSE[OTP_FUSE_SIZE] = {0,0,0,0,0,0,0,0,0,0,0,0};
-	static uint8_t OTP_DATE[2] ={0,0};
+    #define SHARP_OTP_SIZE 0x12
+    const static short sharp_otp_addr[3][SHARP_OTP_SIZE] = {
+        
+        {0x3A0,0x3A1,0x3C0,0x3C1,0x3C2,0x3C3,0x3C4,0x3C5,0x3C6,0x3C7,0x3C8,0x3C9,0x3CA,0x3CB,0x3CC,0x3CD,0x3CE,0x3CF},
+        {0x380,0x381,0x3D0,0x3D1,0x3D2,0x3D3,0x3D4,0x3D5,0x3D6,0x3D7,0x3D8,0x3D9,0x3DA,0x3DB,0x3DC,0x3DD,0x3DE,0x3DF},
+        {0x388,0x389,0x3B0,0x3B1,0x3B2,0x3B3,0x3B4,0x3B5,0x3B6,0x3B7,0x3B8,0x3B9,0x3BA,0x3BB,0x3BC,0x3BD,0x3BE,0x3BF}
+    };
+    #define SHARP_FUSEID_SIZE 0xc
+    const static short sharp_fuseid_addr[SHARP_FUSEID_SIZE]={0x3f4,0x3f5,0x3f6,0x3f7,0x3f8,0x3f9,0x3fa,0x3fb,0x3fc,0x3fd,0x3fe,0x3ff};
+
+    int32_t rc = 0;
+    int i,j;
+    uint16_t read_data = 0;
+    static uint8_t otp[SHARP_OTP_SIZE+SHARP_FUSEID_SIZE];
+    const int32_t offset = 0x33fa;
+    static int32_t valid_layer=-1;
 #if defined(CONFIG_ACT_OIS_BINDER)
-	const int32_t offset = 0x33fa;
-	int32_t ois_valid_layer=-1;
-	static uint8_t ois_otp[VD6869_LITEON_OIS_OTP_SIZE];
+    int32_t ois_valid_layer=-1;
+    static uint8_t ois_otp[VD6869_LITEON_OIS_OTP_SIZE];
 #endif
 
-	pr_info("%s called \n", __func__);
-
-	if (first) {
-
-		
-		for (i = 0; i < OTP_SIZE; i++) {
-			rc = vd6869_i2c_read(
-					s_ctrl->sensor_i2c_client,
-					(0x37ba + i), &read_data,
-					MSM_CAMERA_I2C_BYTE_DATA);
-			if (rc < 0){
-				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, (0x37ba + i));
-				return rc;
-			}
-			OTP[i] = (uint8_t)(read_data&0x00FF);
-			read_data = 0;
-		}
-
-		for (j = 0; j < OTP_FUSE_SIZE; j++) {
-			rc = vd6869_i2c_read(
-					s_ctrl->sensor_i2c_client,
-					(0x37ee + j), &read_data,
-					MSM_CAMERA_I2C_BYTE_DATA);
-			if (rc < 0){
-				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, (0x37ee + j));
-				return rc;
-			}
-			OTP_FUSE[j] = (uint8_t)(read_data&0x00FF);
-			read_data = 0;
-		}
-
-		for (otp_date= 0; otp_date < 2; otp_date++) {
-			rc = vd6869_i2c_read(
-					s_ctrl->sensor_i2c_client,
-					(0x379A + otp_date), &read_data,
-					MSM_CAMERA_I2C_BYTE_DATA);
-			if (rc < 0){
-				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, (0x379A + otp_date));
-				return rc;
-			}
-			OTP_DATE[otp_date] = (uint8_t)(read_data&0x00FF);
-			read_data = 0;
-		}
+    if (first) {
+        
+        for (j=2; j>=0; --j) {
+           for (i=0; i<SHARP_OTP_SIZE; ++i) {
+               rc = vd6869_i2c_read(s_ctrl->sensor_i2c_client, sharp_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+               if (rc < 0){
+                   pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, sharp_otp_addr[j][i]);
+                   return rc;
+               }
+               pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  sharp_otp_addr[j][i], read_data);
+
+               otp[i]= read_data;
+
+               if (read_data)
+                   valid_layer = j;
+           }
+           if (valid_layer!=-1)
+               break;
+        }
+        pr_info("%s: OTP valid layer = %d\n", __func__,  valid_layer);
+        
+        for (i=0;i<SHARP_FUSEID_SIZE;++i) {
+            rc = vd6869_i2c_read(s_ctrl->sensor_i2c_client, sharp_fuseid_addr[i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+            if (rc < 0){
+               pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, sharp_fuseid_addr[i]);
+               return rc;
+            }
+            pr_info("%s: OTP fuseid 0x%x = 0x%x\n", __func__,  sharp_fuseid_addr[i], read_data);
 
+            otp[i+SHARP_OTP_SIZE]= read_data;
+        }
 
-#if defined(CONFIG_ACT_OIS_BINDER)
+    #if defined(CONFIG_ACT_OIS_BINDER)
         
         for (j=2; j>=0; --j) {
             for (i=0; i<VD6869_LITEON_OIS_OTP_SIZE; ++i) {
@@ -5309,144 +5363,257 @@
         }
         pr_info("%s: OTP OIS valid layer = %d\n", __func__,  ois_valid_layer);
 
+    	if (ois_valid_layer!=-1) {
+    		for(i=0; i<VD6869_LITEON_OIS_OTP_SIZE;i ++)
+    			pr_info("read out OTP OIS data = 0x%x\n", ois_otp[i]);
+
+    		HtcActOisBinder_set_OIS_OTP(ois_otp, VD6869_LITEON_OIS_OTP_SIZE);
+    	}
+    #endif
+    }
+    if (board_mfg_mode())
+        msm_dump_otp_to_file (PLATFORM_DRIVER_NAME, sharp_otp_addr[valid_layer], otp, sizeof (otp));
 
-	if (ois_valid_layer!=-1) {
-		for(i=0; i<VD6869_LITEON_OIS_OTP_SIZE;i ++)
-			pr_info("read out OTP OIS data = 0x%x\n", ois_otp[i]);
-
-		HtcActOisBinder_set_OIS_OTP(ois_otp, VD6869_LITEON_OIS_OTP_SIZE);
-	}
-#endif
-
-
-		vd6869_year_mon = OTP_DATE[0];
-		vd6869_date = OTP_DATE[1];
-		pr_info("vd6869_year_mon=0x%x\n", vd6869_year_mon);
-		pr_info("vd6869_date=0x%x\n", vd6869_date);
-
-		pr_info("%s: VenderID=%x,LensID=%x,SensorID=%02x, DriverId=%02x\n", __func__,
-		OTP[8], OTP[9], OTP[10], OTP[11]);
-		pr_info("%s: ModuleFuseID= %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
-			OTP_FUSE[0], OTP_FUSE[1], OTP_FUSE[2], OTP_FUSE[3], OTP_FUSE[4], OTP_FUSE[5], OTP_FUSE[6], OTP_FUSE[7], OTP_FUSE[8], OTP_FUSE[9], OTP_FUSE[10], OTP_FUSE[11]);
-
-		vd6869_ver = OTP[10];  
-		cdata->sensor_ver = OTP[10];
-
-		
-		if(vd6869_ver == 0x0A){
-			vd6869_apply_analog_setting(s_ctrl);
-		}
-		cdata->cfg.fuse.fuse_id_word1 = 0;
-		cdata->cfg.fuse.fuse_id_word2 =
-			(OTP_FUSE[0]<<24) |
-			(OTP_FUSE[1]<<16) |
-			(OTP_FUSE[2]<<8) |
-			(OTP_FUSE[3]);
-		cdata->cfg.fuse.fuse_id_word3 =
-			(OTP_FUSE[4]<<24) |
-			(OTP_FUSE[5]<<16) |
-			(OTP_FUSE[6]<<8) |
-			(OTP_FUSE[7]);
-		cdata->cfg.fuse.fuse_id_word4 =
-			(OTP_FUSE[8]<<24) |
-			(OTP_FUSE[9]<<16) |
-			(OTP_FUSE[10]<<8) |
-			(OTP_FUSE[11]);
-
-		pr_info("vd6869: fuse->fuse_id_word1:%x\n",
-			cdata->cfg.fuse.fuse_id_word1);
-		pr_info("vd6869: fuse->fuse_id_word2:0x%08x\n",
-			cdata->cfg.fuse.fuse_id_word2);
-		pr_info("vd6869: fuse->fuse_id_word3:0x%08x\n",
-			cdata->cfg.fuse.fuse_id_word3);
-		pr_info("vd6869: fuse->fuse_id_word4:0x%08x\n",
-			cdata->cfg.fuse.fuse_id_word4);
-		pr_info("vd6869: VCM START:0x%02x\n", OTP[0] << 8 | OTP[1]);
-		pr_info("vd6869: Infinity position:0x%02x\n", OTP[2] << 8 | OTP[3]);
-		pr_info("vd6869: Macro position:0x%02x\n",	OTP[4] << 8 | OTP[5]);
+    vd6869_year_mon = otp[0];
+    vd6869_date = otp[1];
 
-		
-		cdata->af_value.VCM_START_MSB = OTP[0];
-		cdata->af_value.VCM_START_LSB = OTP[1];
-		cdata->af_value.AF_INF_MSB = OTP[2];
-		cdata->af_value.AF_INF_LSB = OTP[3];
-		cdata->af_value.AF_MACRO_MSB = OTP[4];
-		cdata->af_value.AF_MACRO_LSB = OTP[5];
-		cdata->af_value.ACT_ID = OTP[12];
-		pr_info("VCM_START_MSB =0x%x\n", cdata->af_value.VCM_START_MSB);
-		pr_info("VCM_START_LSB =0x%x\n", cdata->af_value.VCM_START_LSB);
-		pr_info("AF_INF_MSB =0x%x\n", cdata->af_value.AF_INF_MSB);
-		pr_info("AF_INF_LSB =0x%x\n", cdata->af_value.AF_INF_LSB);
-		pr_info("AF_MACRO_MSB =0x%x\n", cdata->af_value.AF_MACRO_MSB);
-		pr_info("AF_MACRO_LSB =0x%x\n", cdata->af_value.AF_MACRO_LSB);
-		pr_info("ACT_ID =0x%x\n", cdata->af_value.ACT_ID);
-	} else {
-		cdata->af_value.VCM_START_MSB = OTP[0];
-		cdata->af_value.VCM_START_LSB = OTP[1];
-		cdata->af_value.AF_INF_MSB = OTP[2];
-		cdata->af_value.AF_INF_LSB = OTP[3];
-		cdata->af_value.AF_MACRO_MSB = OTP[4];
-		cdata->af_value.AF_MACRO_LSB = OTP[5];
-		cdata->af_value.ACT_ID = OTP[12];
-
-		cdata->sensor_ver = OTP[10];
-
-		cdata->cfg.fuse.fuse_id_word1 = 0;
-		cdata->cfg.fuse.fuse_id_word2 =
-			(OTP_FUSE[0]<<24) |
-			(OTP_FUSE[1]<<16) |
-			(OTP_FUSE[2]<<8) |
-			(OTP_FUSE[3]);
-		cdata->cfg.fuse.fuse_id_word3 =
-			(OTP_FUSE[4]<<24) |
-			(OTP_FUSE[5]<<16) |
-			(OTP_FUSE[6]<<8) |
-			(OTP_FUSE[7]);
-		cdata->cfg.fuse.fuse_id_word4 =
-			(OTP_FUSE[8]<<24) |
-			(OTP_FUSE[9]<<16) |
-			(OTP_FUSE[10]<<8) |
-			(OTP_FUSE[11]);
-	}
-	return 0;
+    cdata->sensor_ver = vd6869_ver = otp[0xc];
+    cdata->cfg.fuse.fuse_id_word1 = 0;
+    cdata->cfg.fuse.fuse_id_word2 =
+        (otp[0x12]<<24) |
+        (otp[0x13]<<16) |
+        (otp[0x14]<<8) |
+        (otp[0x15]);
+    cdata->cfg.fuse.fuse_id_word3 =
+        (otp[0x16]<<24) |
+        (otp[0x17]<<16) |
+        (otp[0x18]<<8) |
+        (otp[0x19]);
+    cdata->cfg.fuse.fuse_id_word4 =
+        (otp[0x1a]<<24) |
+        (otp[0x1b]<<16) |
+        (otp[0x1c]<<8) |
+        (otp[0x1d]);
+    
+    cdata->af_value.VCM_START_MSB = otp[2];
+    cdata->af_value.VCM_START_LSB = otp[3];
+    cdata->af_value.AF_INF_MSB = otp[4];
+    cdata->af_value.AF_INF_LSB = otp[5];
+    cdata->af_value.AF_MACRO_MSB = otp[6];
+    cdata->af_value.AF_MACRO_LSB = otp[7];
+    cdata->af_value.ACT_ID = otp[0xe];
+
+    pr_info("vd6869_year_mon=0x%x\n", vd6869_year_mon);
+    pr_info("vd6869_date=0x%x\n", vd6869_date);
+    pr_info("%s: VenderID=%x,LensID=%x,SensorID=%02x, DriverId=%02x\n", __func__,
+        otp[0xa], otp[0xb], otp[0xc], otp[0xd]);
+    pr_info("%s: ModuleFuseID= %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
+        otp[0x12], otp[0x13], otp[0x14], otp[0x15], otp[0x16], otp[0x17], otp[0x18], otp[0x19], otp[0x1a], otp[0x1b], otp[0x1c], otp[0x1d]);
+
+    pr_info("vd6869: fuse->fuse_id_word1:%x\n",cdata->cfg.fuse.fuse_id_word1);
+    pr_info("vd6869: fuse->fuse_id_word2:0x%08x\n",cdata->cfg.fuse.fuse_id_word2);
+    pr_info("vd6869: fuse->fuse_id_word3:0x%08x\n",cdata->cfg.fuse.fuse_id_word3);
+    pr_info("vd6869: fuse->fuse_id_word4:0x%08x\n",cdata->cfg.fuse.fuse_id_word4);
+
+    pr_info("vd6869: VCM START:0x%02x\n", cdata->af_value.VCM_START_MSB << 8 |cdata->af_value.VCM_START_LSB);
+    pr_info("vd6869: Infinity position:0x%02x\n", cdata->af_value.AF_INF_MSB << 8 | cdata->af_value.AF_INF_LSB);
+    pr_info("vd6869: Macro position:0x%02x\n", cdata->af_value.AF_MACRO_MSB << 8 | cdata->af_value.AF_MACRO_LSB);
+
+    pr_info("VCM_START_MSB =0x%x\n", cdata->af_value.VCM_START_MSB);
+    pr_info("VCM_START_LSB =0x%x\n", cdata->af_value.VCM_START_LSB);
+    pr_info("AF_INF_MSB =0x%x\n", cdata->af_value.AF_INF_MSB);
+    pr_info("AF_INF_LSB =0x%x\n", cdata->af_value.AF_INF_LSB);
+    pr_info("AF_MACRO_MSB =0x%x\n", cdata->af_value.AF_MACRO_MSB);
+    pr_info("AF_MACRO_LSB =0x%x\n", cdata->af_value.AF_MACRO_LSB);
+    pr_info("ACT_ID =0x%x\n", cdata->af_value.ACT_ID);
 
+    return 0;
 }
 
-
-
-
-int32_t vd6869_read_otp_valid_layer(struct msm_sensor_ctrl_t *s_ctrl, int8_t *valid_layer, bool first)
+int vd6869_read_fuseid_liteon_mfg_core(struct sensor_cfg_data *cdata,
+	struct msm_sensor_ctrl_t *s_ctrl, bool first,uint8_t* otp )
 {
+    int32_t i,j;
     int32_t rc = 0;
     const int32_t offset = 0x33fa;
+    int32_t valid_layer=-1;
+
+
+#if defined(CONFIG_ACT_OIS_BINDER)
+    int32_t ois_valid_layer=-1;
+    static uint8_t ois_otp[VD6869_LITEON_OIS_OTP_SIZE];
+#endif
     uint16_t read_data = 0;
-    int j=2,i=0;
-    static int8_t layer=-1;
+
     if (first) {
+        
         for (j=2; j>=0; --j) {
             for (i=0; i<VD6869_LITEON_OTP_SIZE; ++i) {
-                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+                if(vd6869_s_ctrl.ews_enable){
+	                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, old_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+	                if (rc < 0){
+	                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__,old_otp_addr[j][i]);
+	                    return rc;
+	                }
+	                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  old_otp_addr[j][i], read_data);
+                }else{
+	                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, new_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+	                if (rc < 0){
+	                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__,new_otp_addr[j][i]);
+	                    return rc;
+	                }
+	                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  new_otp_addr[j][i], read_data);
+                }
+                otp[i]= read_data;
+
+                if (read_data)
+                    valid_layer = j;
+            }
+            if (valid_layer!=-1)
+                break;
+        }
+        pr_info("%s: OTP valid layer = %d\n", __func__,  valid_layer);
+
+#if defined(CONFIG_ACT_OIS_BINDER)
+        
+        for (j=2; j>=0; --j) {
+            for (i=0; i<VD6869_LITEON_OIS_OTP_SIZE; ++i) {
+                rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, ois_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
                 if (rc < 0){
-                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, otp_addr[j][i]);
+                    pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, ois_addr[j][i]);
                     return rc;
                 }
-                pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  otp_addr[j][i], read_data);
+                pr_info("%s: OTP ois_addr 0x%x = 0x%x\n", __func__,  ois_addr[j][i], read_data);
+
+                ois_otp[i]= read_data;
 
                 if (read_data)
-                    layer = j;
+                    ois_valid_layer = j;
             }
-            if (layer!=-1)
+            if (ois_valid_layer!=-1)
                 break;
         }
+        pr_info("%s: OTP OIS valid layer = %d\n", __func__,  ois_valid_layer);
+
+
+    if (ois_valid_layer!=-1) {
+        for(i=0; i<VD6869_LITEON_OIS_OTP_SIZE;i ++)
+            pr_info("read out OTP OIS data = 0x%x\n", ois_otp[i]);
+
+        HtcActOisBinder_set_OIS_OTP(ois_otp, VD6869_LITEON_OIS_OTP_SIZE);
+    }
+#endif
+
+
     }
+    
+    vd6869_ver = otp[2]; 
+    cdata->sensor_ver = otp[2];
 
-    *valid_layer = layer;
-    pr_info("%s: OTP valid layer = %d\n", __func__,  *valid_layer);
-    return rc;
+    
+    cdata->cfg.fuse.fuse_id_word1 = 0;
+    cdata->cfg.fuse.fuse_id_word2 = otp[5];
+    cdata->cfg.fuse.fuse_id_word3 = otp[6];
+    cdata->cfg.fuse.fuse_id_word4 = otp[7];
+
+    
+    cdata->af_value.VCM_BIAS = otp[8];
+    cdata->af_value.VCM_OFFSET = otp[9];
+    cdata->af_value.VCM_BOTTOM_MECH_MSB = otp[0xa];
+    cdata->af_value.VCM_BOTTOM_MECH_LSB = otp[0xb];
+    cdata->af_value.AF_INF_MSB = otp[0xc];
+    cdata->af_value.AF_INF_LSB = otp[0xd];
+    cdata->af_value.AF_MACRO_MSB = otp[0xe];
+    cdata->af_value.AF_MACRO_LSB = otp[0xf];
+    cdata->af_value.VCM_TOP_MECH_MSB = otp[0x10];
+    cdata->af_value.VCM_TOP_MECH_LSB = otp[0x11];
+    cdata->af_value.VCM_VENDOR_ID_VERSION = otp[4];
+    pr_info("%s: OTP Module vendor = 0x%x\n",               __func__,  otp[0]);
+    pr_info("%s: OTP LENS = 0x%x\n",                        __func__,  otp[1]);
+    pr_info("%s: OTP Sensor Version = 0x%x\n",              __func__,  otp[2]);
+    pr_info("%s: OTP Driver IC Vendor & Version = 0x%x\n",  __func__,  otp[3]);
+    pr_info("%s: OTP Actuator vender ID & Version = 0x%x\n",__func__,  otp[4]);
+
+    pr_info("%s: OTP fuse 0 = 0x%x\n", __func__,  cdata->cfg.fuse.fuse_id_word1);
+    pr_info("%s: OTP fuse 1 = 0x%x\n", __func__,  cdata->cfg.fuse.fuse_id_word2);
+    pr_info("%s: OTP fuse 2 = 0x%x\n", __func__,  cdata->cfg.fuse.fuse_id_word3);
+    pr_info("%s: OTP fuse 3 = 0x%x\n", __func__,  cdata->cfg.fuse.fuse_id_word4);
+
+    pr_info("%s: OTP BAIS Calibration data = 0x%x\n",           __func__,  cdata->af_value.VCM_BIAS);
+    pr_info("%s: OTP OFFSET Calibration data = 0x%x\n",         __func__,  cdata->af_value.VCM_OFFSET);
+    pr_info("%s: OTP VCM bottom mech. Limit (MSByte) = 0x%x\n", __func__,  cdata->af_value.VCM_BOTTOM_MECH_MSB);
+    pr_info("%s: OTP VCM bottom mech. Limit (LSByte) = 0x%x\n", __func__,  cdata->af_value.VCM_BOTTOM_MECH_LSB);
+    pr_info("%s: OTP Infinity position code (MSByte) = 0x%x\n", __func__,  cdata->af_value.AF_INF_MSB);
+    pr_info("%s: OTP Infinity position code (LSByte) = 0x%x\n", __func__,  cdata->af_value.AF_INF_LSB);
+    pr_info("%s: OTP Macro position code (MSByte) = 0x%x\n",    __func__,  cdata->af_value.AF_MACRO_MSB);
+    pr_info("%s: OTP Macro position code (LSByte) = 0x%x\n",    __func__,  cdata->af_value.AF_MACRO_LSB);
+    pr_info("%s: OTP VCM top mech. Limit (MSByte) = 0x%x\n",    __func__,  cdata->af_value.VCM_TOP_MECH_MSB);
+    pr_info("%s: OTP VCM top mech. Limit (LSByte) = 0x%x\n",    __func__,  cdata->af_value.VCM_TOP_MECH_LSB);
+
+    return 0;
+
+}
+int vd6869_read_fuseid_liteon_mfg(struct sensor_cfg_data *cdata,
+	struct msm_sensor_ctrl_t *s_ctrl, bool first)
+{
+#define VD6869_LITEON_OTP_SIZE 0x12
+
+    uint8_t otp_ecc[VD6869_LITEON_OTP_SIZE];
+    uint8_t otp_no_ecc[VD6869_LITEON_OTP_SIZE];
+    int i=0;
+    int match=1;
+
+    vd6869_read_fuseid_liteon_mfg_core (cdata, s_ctrl, first, otp_ecc);
+    vd6869_cut10_init_otp_NO_ECC(s_ctrl);
+    vd6869_read_fuseid_liteon_mfg_core (cdata, s_ctrl, first, otp_no_ecc);
+    vd6869_cut10_init_otp (s_ctrl);
+    for (i=0;i<VD6869_LITEON_OTP_SIZE;++i) {
+
+        if (otp_ecc[i] != otp_no_ecc[i]) {
+            pr_info ("%s: cmp_otp otp not match at 0x%x ecc/no_ecc=0x%x/0x%x",__func__,i,otp_ecc[i],otp_no_ecc[i]);
+            match=0;
+        }
+    }
+
+    if (match)
+    {
+        pr_info ("%s: cmp_otp otp match",__func__);
+    }
+
+    return 0;
 }
 
+int32_t vd6869_read_otp_valid_layer(struct msm_sensor_ctrl_t *s_ctrl, int8_t *valid_layer, bool first)
+{
+	int32_t rc = 0;
+	const int32_t offset = 0x33fa;
+	uint16_t read_data = 0;
+	int j=2,i=0;
+	static int8_t layer=-1;
+	if (first) {
+		for (j=2; j>=0; --j) {
+			for (i=0; i<VD6869_LITEON_OTP_SIZE; ++i) {
+				rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, new_otp_addr[j][i]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+				if (rc < 0){
+					pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, new_otp_addr[j][i]);
+					return rc;
+				}
+				pr_info("%s: OTP addr 0x%x = 0x%x\n", __func__,  new_otp_addr[j][i], read_data);
 
-int vd6869_read_module_vendor(struct msm_sensor_ctrl_t *s_ctrl, uint8_t valid_layer, uint8_t* module_vendor, uint8_t* driver_ic,bool first)
+				if (read_data)
+					layer = j;
+			}
+			if (layer!=-1)
+				break;
+		}
+	}
+
+	*valid_layer = layer;
+	pr_info("%s: OTP valid layer = %d\n", __func__,  *valid_layer);
+	return rc;
+}
+
+int vd6869_read_module_vendor(struct msm_sensor_ctrl_t *s_ctrl, uint8_t valid_layer, uint8_t* module_vendor, uint8_t* driver_ic, bool first)
 {
 	int32_t rc = 0;
 	uint16_t read_data = 0;
@@ -5463,18 +5630,22 @@
 				rc = vd6869_cut10_init_otp(s_ctrl);
 				if (rc<0)
 					return rc;
+			}else if(s_ctrl->sensordata->sensor_cut == 0){
+				rc = vd6869_cut09_init_otp(s_ctrl);
+				if (rc<0)
+					return rc;
 			}
 
-			rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, otp_addr[valid_layer][0]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+			rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, new_otp_addr[valid_layer][0]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
 			if (rc < 0) {
-				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, otp_addr[valid_layer][0]+offset);
+				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, new_otp_addr[valid_layer][0]+offset);
 				return rc;
 			}
 			moduler = (uint8_t)(read_data&0x00FF);
 
-			rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, otp_addr[valid_layer][3]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
+			rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, new_otp_addr[valid_layer][3]+offset, &read_data, MSM_CAMERA_I2C_BYTE_DATA);
 			if (rc < 0) {
-				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, otp_addr[valid_layer][3]+offset);
+				pr_err("%s: msm_camera_i2c_read 0x%x failed\n", __func__, new_otp_addr[valid_layer][3]+offset);
 				return rc;
 			}
 			driver = (uint8_t)(read_data&0x00FF);
@@ -5537,16 +5708,20 @@
 
 	if (first) {
 		if (s_ctrl->sensordata->sensor_cut == 1) {
-			rc = vd6869_cut10_init_otp(s_ctrl);
+				rc = vd6869_cut10_init_otp(s_ctrl);
 			if (rc<0)
 				return rc;
 		}
 
-		rc = vd6869_read_otp_valid_layer (s_ctrl,&valid_layer,first);
-		if (rc<0) {
-			pr_err("%s: failed %d\n", __func__, rc);
-			first = false;
-			return rc;
+		if(vd6869_s_ctrl.ews_enable)
+			pr_info("%s, vd6869_s_ctrl.ews_enable=%d", __func__, vd6869_s_ctrl.ews_enable);
+		else{
+			rc = vd6869_read_otp_valid_layer (s_ctrl,&valid_layer,first);
+			if (rc<0) {
+				pr_err("%s: failed %d\n", __func__, rc);
+				first = false;
+				return rc;
+			}
 		}
 	}
 
@@ -5569,15 +5744,14 @@
 			actuator_index = vd6869_lookup_actuator(s_ctrl, "ti201_act");
 		} else if (driver_ic == 0x11) { 
 			actuator_index = vd6869_lookup_actuator(s_ctrl, "lc898212_act");
-		} else { 
+		} else if (driver_ic == 0x1)  { 
 			actuator_index = vd6869_lookup_actuator(s_ctrl, "rumbas_act");
 		}
 
 		if (actuator_index >= 0 && actuator_index < sdata->num_actuator_info_table)
 			sdata->actuator_info = &sdata->actuator_info_table[actuator_index][0];
 		else {
-			pr_err("%s: actuator lookup fail\n", __func__);
-			return -1;
+			pr_info("%s: Actuator lookup fail, use the default actuator in board file\n", __func__);
 		}
 
 		pr_info("%s: sdata->actuator_info->board_info->type=%s", __func__, sdata->actuator_info->board_info->type);
@@ -5589,7 +5763,11 @@
 			rc = vd6869_read_fuseid_sharp (cdata,s_ctrl,first);
 			break;
 		case 0x2:
-			rc = vd6869_read_fuseid_liteon (cdata,s_ctrl,first);
+		#if defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY) || defined(CONFIG_MACH_DUMMY)
+		    if (board_mfg_mode())
+		        rc = vd6869_read_fuseid_liteon_mfg (cdata,s_ctrl,first);
+		#endif
+		    rc = vd6869_read_fuseid_liteon (cdata,s_ctrl,first);
 			break;
 		default:
 			pr_err("%s unknown module vendor = 0x%x\n",__func__, module_vendor);
@@ -5606,6 +5784,7 @@
 	struct msm_camera_sensor_info *sdata = NULL;
 	uint16_t sensor_version = 0x01;
 	struct sensor_cfg_data cdata;
+
 	pr_info("%s called\n", __func__);
 
 	if (s_ctrl && s_ctrl->sensordata)
@@ -5640,13 +5819,20 @@
 		pr_info("%s msm_sensor_power_up failed\n", __func__);
 		goto enable_sensor_power_up_failed;
 	}
-	vd6869_sensor_open_init(sdata);
-
 	
 	msm_camera_i2c_read(s_ctrl->sensor_i2c_client, 0x45B0, &sensor_version, MSM_CAMERA_I2C_BYTE_DATA);
+
+	if(sensor_version == 0x00){
+		s_ctrl->sensordata->sensor_cut = 0;
+	} else {
+		s_ctrl->sensordata->sensor_cut = 1;
+	}
+	vd6869_sensor_open_init(sdata);
+
 	if(sensor_version == 0x00){
 		pr_info("vd6869 apply cut 09 setting");
 		s_ctrl->sensordata->sensor_cut = 0;
+		vd6869_read_fuseid(&cdata,s_ctrl);
 	} else {
 		if(vd6869_s_ctrl.msm_sensor_reg != NULL){
 			pr_info("vd6869 apply cut 10 setting");
@@ -6131,7 +6317,7 @@
 
 	rc = msm_camera_i2c_write(vd6869_s_ctrl.sensor_i2c_client,
 		VD6869_REG_READ_MODE, value, MSM_CAMERA_I2C_BYTE_DATA);
-	pr_info("chuck-value=%d\n", value);
+	pr_info("value=%d\n", value);
 	if (rc < 0) {
 		pr_err("%s set mirror_flip failed\n", __func__);
 		return rc;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/ilp0100_ST_definitions.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/ilp0100_ST_definitions.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/ilp0100_ST_definitions.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/ilp0100_ST_definitions.h	2013-08-01 23:38:00.000000000 -0600
@@ -78,9 +78,10 @@
 #define INTR_MODE_CHANGE_REQUEST			0x00000080
 #define INTR_LONGEXP_GLACE_STATS_READY		0x00000100
 #define INTR_LONGEXP_HISTOGRAM_STATS_READY	0x00000200
+#define INTR_START_OF_SHORTFRAME 			0x00000800
 #define INTR_SHORTEXP_GLACE_STATS_READY		0x00010000
 #define INTR_SHORTEXP_HISTOGRAM_STATS_READY	0x00020000
-#define INTR_ITPOINT_LONG					0x00200000
+#define INTR_ITPOINT_LONG					0x002000000
 #define INTR_ITPOINT_SHORT_OR_NORMAL		0x00400000
 #define INTR_ITPOINT_MERGED					0x00800000
 
@@ -105,7 +106,8 @@
 							INTR_IDLE_COMPLETE|\
 							INTR_MODE_CHANGE_COMPLETE|\
 							INTR_START_OF_FRAME|\
-							INTR_END_OF_FRAME
+							INTR_END_OF_FRAME|\
+							INTR_START_OF_SHORTFRAME
 #define ENABLE_ALL_ERROR_INTR				INTR_RXPHY_ERROR|INTR_CSI2RX_ERROR|INTR_SMIA_UNPACK_ERROR|INTR_P2W_FIFO_ERROR|INTR_LTYPE_RETAG_ERROR|INTR_HDR_MERGE_ERROR|INTR_TONE_MAP_ERROR|INTR_MISC_SYS_ERROR|INTR_CSI2TX_ERROR|INTR_TXPHY_ERROR|INTR_INCORRECT_WORD_COUNT|INCORRECT_LSCP2P_BUFFER
 #define ENABLE_RECOMMENDED_DEBUG_INTR_PIN1	ENABLE_ALL_ERROR_INTR
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/yushanII.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/yushanII.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/yushanII.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/yushanII.c	2013-08-01 23:38:00.000000000 -0600
@@ -51,6 +51,8 @@
 static struct class *yushanII_class;
 static dev_t yushanII_devno;
 
+static struct msm_sensor_ctrl_t *g_sensor = NULL;	
+
 int yushanII_intr0, yushanII_intr1;
 atomic_t interrupt, interrupt2;
 
@@ -63,6 +65,9 @@
 
 static struct YushanII_ctrl *YushanIICtrl = NULL;
 
+int YushanII_Get_reloadInfo(void){
+	return reload_firmware;
+}
 
 void YushanII_reload_firmware(void){
 	reload_firmware = 1;
@@ -486,6 +491,9 @@
 	pr_info("[CAM]%s,res=%d,is_hdr=%d",
 		__func__, res,sensor->msm_sensor_reg->output_settings[res].is_hdr);
 	YushanII_login_start();
+
+	g_sensor = sensor;	
+
 	
 	if(sensor->msm_sensor_reg->output_settings[res].is_hdr)
 		sensor->sensordata->hdr_mode = 1;
@@ -530,7 +538,6 @@
 		
 		Ilp0100_interruptEnable(ENABLE_HTC_INTR, INTR_PIN_0);
 		Ilp0100_interruptEnable(ENABLE_RECOMMENDED_DEBUG_INTR_PIN1, INTR_PIN_1);
-		Ilp0100_stop();
 		if (sensor->yushanII_switch_virtual_channel) {
 		    Ilp0100_setVirtualChannelShortOrNormal(1);
 		    Ilp0100_setVirtualChannelLong(0);
@@ -547,7 +554,6 @@
 		
 		Ilp0100_interruptEnable(ENABLE_NO_INTR, INTR_PIN_0);
 		Ilp0100_interruptEnable(ENABLE_RECOMMENDED_DEBUG_INTR_PIN1, INTR_PIN_1);
-		Ilp0100_stop();
 		if (sensor->yushanII_switch_virtual_channel) {
 	        Ilp0100_setVirtualChannelShortOrNormal(0);
 	        Ilp0100_setVirtualChannelLong(1);
@@ -579,6 +585,8 @@
 
 	YushanII_login_start();
 
+	g_sensor = sensor;	
+
 	sensor->sensordata->hdr_mode = 0;
 
 	YushanII_set_frontcam_parm(sensor,res,&YushanII_init,&YushanII_sensor);
@@ -958,10 +966,12 @@
 
 int YushanII_got_INT0(void __user *argp){
 	struct yushanii_stats_event_ctrl event;
+	static int got_short = 0;	
 
 	Ilp0100_interruptReadStatus(&pInterruptId, INTR_PIN_0);
 	
 	event.type = pInterruptId;
+
 	Ilp0100_interruptClearStatus(pInterruptId, INTR_PIN_0);
 	enable_irq(yushanII_intr0);
 	switch(pInterruptId){
@@ -977,6 +987,18 @@
 		case MODE_CHANGE_COMPLETE:
 			pr_info("[CAM]%s, MODE_CHANGE_COMPLETE", __func__);
 			break;
+		case START_OF_SHORTFRAME:
+			if (g_sensor->func_tbl->sensor_yushanII_ae_updated) {
+				if (g_sensor->func_tbl->sensor_yushanII_ae_updated() == 0) {
+					got_short++;
+					if (got_short >= 2) {
+						if (g_sensor->func_tbl->sensor_yushanII_active_hold)
+							g_sensor->func_tbl->sensor_yushanII_active_hold();
+						got_short = 0;
+					}
+				}
+			}
+			break;
 	}
 	if(copy_to_user((void *)argp, &event, sizeof(struct yushanii_stats_event_ctrl))){
 		pr_err("[CAM]%s, copy to user error\n", __func__);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/yushanII.h monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/yushanII.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/msm/yushanII/yushanII.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/msm/yushanII/yushanII.h	2013-08-01 23:38:00.000000000 -0600
@@ -89,6 +89,7 @@
 };
 
 void YushanII_Init(struct msm_sensor_ctrl_t *sensor,int res);
+int YushanII_Get_reloadInfo(void);
 void YushanII_reload_firmware(void);
 int YushanII_probe_init(void);
 void YushanII_probe_deinit(void);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/v4l2-device.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/v4l2-device.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/v4l2-device.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/v4l2-device.c	2013-08-01 23:38:00.000000000 -0600
@@ -180,7 +180,7 @@
 	}
 #endif
 
-#if defined(CONFIG_MACH_DUMMY)
+#if defined(CONFIG_MACH_DELUXE_J)
 	if (v4l2_dev->subdevs.prev == NULL)
 		return -EINVAL;
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/videobuf2-msm-mem.c monarudo-jb-3.4.10-e22f38b/drivers/media/video/videobuf2-msm-mem.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/media/video/videobuf2-msm-mem.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/media/video/videobuf2-msm-mem.c	2013-08-01 23:38:00.000000000 -0600
@@ -350,6 +350,8 @@
 	mem = vb2_plane_cookie(vb, plane_no);
 	BUG_ON(!mem);
 	MAGIC_CHECK(mem->magic, MAGIC_PMEM);
+	if (!mem->mapped_phyaddr)
+		pr_err("%s mem->mapped_phyaddr is null", __func__);
 	return mem->mapped_phyaddr;
 }
 EXPORT_SYMBOL_GPL(videobuf2_to_pmem_contig);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/fpr/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/misc/fpr/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/fpr/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/misc/fpr/Kconfig	2013-08-01 23:37:45.000000000 -0600
@@ -0,0 +1,11 @@
+#
+# TI's shared transport line discipline and the protocol
+# drivers (BT, FM and GPS)
+#
+menu "Vadality finger printer SPI driver"
+config FPR_SPI
+	bool "SPI driver for finger print"
+    default n
+	help
+         SPI driver for finger print
+endmenu
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/fpr/Makefile monarudo-jb-3.4.10-e22f38b/drivers/misc/fpr/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/fpr/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/misc/fpr/Makefile	2013-08-01 23:38:08.000000000 -0600
@@ -0,0 +1,16 @@
+#
+# Makefile for TI's shared transport line discipline
+# and its protocol drivers (BT, FM, GPS)
+#
+obj-$(CONFIG_FPR_SPI) 		+= vfsSpiDrv.o
+
+INCLUDE_DIR += -I$(PWD)
+
+EXTRA_CFLAGS += $(INCLUDE_DIR) -DPLATFORM_BIG_ENDIAN=1 -DVCS_FEATURE_SENSOR_WINDSOR=0
+
+#ifeq (${BUILDTYPE}, Debug)
+	EXTRA_CFLAGS += -DDEBUG=0
+#else
+#	EXTRA_CFLAGS += -DDEBUG=0
+#endif
+
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/misc/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/misc/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -733,4 +733,5 @@
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/mpu3050/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
+source "drivers/misc/fpr/Kconfig"
 endmenu
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/Makefile monarudo-jb-3.4.10-e22f38b/drivers/misc/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/misc/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -81,3 +81,4 @@
 obj-$(CONFIG_CABLE_DETECT_8930) += cable_detect_8930.o
 obj-y += time_helper.o
 obj-y += state_helper.o
+obj-$(CONFIG_FPR_SPI)	+=fpr/
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/qseecom.c monarudo-jb-3.4.10-e22f38b/drivers/misc/qseecom.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/misc/qseecom.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/misc/qseecom.c	2013-08-01 23:38:02.000000000 -0600
@@ -39,11 +39,13 @@
 #include <mach/scm.h>
 #include <mach/peripheral-loader.h>
 #include "qseecom_legacy.h"
+#include <linux/completion.h>
 
 #define QSEECOM_DEV			"qseecom"
 #define QSEOS_VERSION_13		0x13
 #define QSEOS_VERSION_14		0x14
 #define QSEOS_CHECK_VERSION_CMD		0x00001803;
+#define WAIT_PIL_TIMEOUT               20000
 
 enum qseecom_command_scm_resp_type {
 	QSEOS_APP_ID = 0xEE01,
@@ -201,6 +203,9 @@
 	atomic_t          ioctl_count;
 };
 
+DECLARE_COMPLETION(qseecomd_finish);
+DECLARE_COMPLETION(pil_work_finished);
+
 static int qsee_vote_for_clock(int32_t);
 static void qsee_disable_clock_vote(int32_t);
 
@@ -1461,6 +1466,7 @@
 		return -ENODEV;
 	}
 
+	wait_for_completion_timeout(&pil_work_finished, msecs_to_jiffies(WAIT_PIL_TIMEOUT));
 	switch (cmd) {
 	case QSEECOM_IOCTL_REGISTER_LISTENER_REQ: {
 		pr_debug("ioctl register_listener_req()\n");
@@ -1470,6 +1476,8 @@
 		wake_up_all(&data->abort_wq);
 		if (ret)
 			pr_err("failed qseecom_register_listener: %d\n", ret);
+		if (((struct qseecom_register_listener_req *)argp)->listener_id == 10)
+			complete_all(&qseecomd_finish);
 		break;
 	}
 	case QSEECOM_IOCTL_UNREGISTER_LISTENER_REQ: {
@@ -1483,6 +1491,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_SEND_CMD_REQ: {
+		pr_debug("ioctl send_cmd_req()\n");
 		
 		mutex_lock(&app_access_lock);
 		atomic_inc(&data->ioctl_count);
@@ -1495,6 +1504,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_SEND_MODFD_CMD_REQ: {
+		pr_debug("ioctl send_modfd_cmd_req()\n");
 		
 		mutex_lock(&app_access_lock);
 		atomic_inc(&data->ioctl_count);
@@ -1507,6 +1517,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_RECEIVE_REQ: {
+		pr_debug("ioctl receive_req()\n");
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_receive_req(data);
 		atomic_dec(&data->ioctl_count);
@@ -1516,6 +1527,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_SEND_RESP_REQ: {
+		pr_debug("ioctl send_resp_req()\n");
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_send_resp();
 		atomic_dec(&data->ioctl_count);
@@ -1525,6 +1537,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_SET_MEM_PARAM_REQ: {
+		pr_debug("ioctl set_param_req()\n");
 		ret = qseecom_set_client_mem_param(data, argp);
 		if (ret)
 			pr_err("failed Qqseecom_set_mem_param request: %d\n",
@@ -1532,6 +1545,8 @@
 		break;
 	}
 	case QSEECOM_IOCTL_LOAD_APP_REQ: {
+		pr_debug("ioctl load_app_req()\n");
+		wait_for_completion(&qseecomd_finish);
 		mutex_lock(&app_access_lock);
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_load_app(data, argp);
@@ -1542,6 +1557,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_UNLOAD_APP_REQ: {
+		pr_debug("ioctl unload_app_req()\n");
 		mutex_lock(&app_access_lock);
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_unload_app(data);
@@ -1552,6 +1568,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_GET_QSEOS_VERSION_REQ: {
+		pr_debug("ioctl get_qseos_version_req()\n");
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_get_qseos_version(data, argp);
 		if (ret)
@@ -1560,6 +1577,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_PERF_ENABLE_REQ:{
+		pr_debug("ioctl perf_enable_req()\n");
 		atomic_inc(&data->ioctl_count);
 		ret = qsee_vote_for_clock(CLK_DFAB);
 		if (ret)
@@ -1568,12 +1586,14 @@
 		break;
 	}
 	case QSEECOM_IOCTL_PERF_DISABLE_REQ:{
+		pr_debug("ioctl perf_disable_req()\n");
 		atomic_inc(&data->ioctl_count);
 		qsee_disable_clock_vote(CLK_DFAB);
 		atomic_dec(&data->ioctl_count);
 		break;
 	}
 	case QSEECOM_IOCTL_LOAD_EXTERNAL_ELF_REQ: {
+		pr_debug("ioctl load_external_elf_req()\n");
 		data->released = true;
 		if (qseecom.qseos_version == QSEOS_VERSION_13) {
 			pr_err("Loading External elf image unsupported in rev 0x13\n");
@@ -1590,6 +1610,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_UNLOAD_EXTERNAL_ELF_REQ: {
+		pr_debug("ioctl unload_external_elf_req()\n");
 		data->released = true;
 		if (qseecom.qseos_version == QSEOS_VERSION_13) {
 			pr_err("Unloading External elf image unsupported in rev 0x13\n");
@@ -1606,6 +1627,7 @@
 		break;
 	}
 	case QSEECOM_IOCTL_APP_LOADED_QUERY_REQ: {
+		pr_debug("ioctl app_loaded_query_req()\n");
 		mutex_lock(&app_access_lock);
 		atomic_inc(&data->ioctl_count);
 		ret = qseecom_query_app_loaded(data, argp);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/card/block.c monarudo-jb-3.4.10-e22f38b/drivers/mmc/card/block.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/card/block.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/mmc/card/block.c	2013-08-01 23:38:03.000000000 -0600
@@ -2192,7 +2192,7 @@
 				break;
 			
 			try_recovery++;
-			if (try_recovery < 2 && card->do_remove == 0) {
+			if (try_recovery <= 3 && card->do_remove == 0) {
 				do_reinit = 1;
 				goto recovery;
 			} else {
@@ -2206,7 +2206,7 @@
 			err = mmc_blk_reset(md, card->host, type);
 			
 			try_recovery++;
-			if (try_recovery < 2 && card->do_remove == 0) {
+			if (try_recovery <= 3 && card->do_remove == 0) {
 				do_reinit = 1;
 				goto recovery;
 			} else {
@@ -2224,7 +2224,7 @@
 			}
 			
 			try_recovery++;
-			if (try_recovery < 2 && card->do_remove == 0) {
+			if (try_recovery <= 3 && card->do_remove == 0) {
 				do_reinit = 1;
 				goto recovery;
 			} else {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/core/core.c monarudo-jb-3.4.10-e22f38b/drivers/mmc/core/core.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/core/core.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/mmc/core/core.c	2013-08-01 23:38:03.000000000 -0600
@@ -278,6 +278,7 @@
 	unsigned long flags;
 	int timeout;
 	int is_storage_encrypting = 0;
+	int urgent_bkops = 0;
 
 	BUG_ON(!card);
 	if (!card->ext_csd.bkops_en || !(card->host->caps2 & MMC_CAP2_BKOPS))
@@ -290,12 +291,14 @@
 		spin_lock_irqsave(&card->host->lock, flags);
 		mmc_card_clr_check_bkops(card);
 		spin_unlock_irqrestore(&card->host->lock, flags);
-		if (mmc_is_exception_event(card, EXT_CSD_URGENT_BKOPS) || is_storage_encrypting)
+		urgent_bkops = mmc_is_exception_event(card, EXT_CSD_URGENT_BKOPS);
+		if (urgent_bkops || card->host->bkops_check_status || is_storage_encrypting) {
 			if (card->ext_csd.raw_bkops_status >= EXT_CSD_BKOPS_LEVEL_2 || is_storage_encrypting) {
 				spin_lock_irqsave(&card->host->lock, flags);
 				mmc_card_set_need_bkops(card);
 				spin_unlock_irqrestore(&card->host->lock, flags);
 			}
+		}
 	}
 
 	if (mmc_card_doing_bkops(card) || !mmc_card_need_bkops(card) || card->host->bkops_trigger == ENCRYPT_MAGIC_NUMBER2) {
@@ -313,7 +316,8 @@
 	if (is_storage_encrypting)
 		timeout = 50000;
 
-	pr_info("%s: %s\n", mmc_hostname(card->host), __func__);
+	pr_info("%s: %s, level %d\n", mmc_hostname(card->host), __func__,
+		card->ext_csd.raw_bkops_status);
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			EXT_CSD_BKOPS_START, 1, timeout);
 	if (err) {
@@ -2290,7 +2294,7 @@
 		}
 	}
 #ifdef CONFIG_PM_RUNTIME
-       if (mmc_bus_manual_resume(host))
+       if (mmc_bus_manual_resume(host) && !host->bkops_started)
                host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
 #endif
 
@@ -2369,17 +2373,30 @@
 						__func__, status, err, host->bkops_timer.need_bkops);
 					err = -EBUSY;
 				} else {
-					if (host->bkops_timer.need_bkops == 0)
-						host->bkops_count++;
 					pr_warning("%s: card ready status %x needbkops %u bkops_count %d\n",
 						__func__, status, host->bkops_timer.need_bkops, host->bkops_count);
 				}
 			}
 		} else {
-			host->bkops_count++;
-			pr_warning("%s: needbkops %u, bkops_count %d\n",
+			pr_debug("%s: needbkops %u, bkops_count %d\n",
 						__func__, host->bkops_timer.need_bkops, host->bkops_count);
-			host->bkops_timer.need_bkops = 0;
+			if (host->long_bkops && (mmc_read_bkops_status(host->card) == 0)) {
+				host->bkops_count++;
+				pr_info("%s: bkops_status %d, count %d\n", mmc_hostname(host),
+					host->card->ext_csd.raw_bkops_status, host->bkops_count);
+				if (host->card->ext_csd.raw_bkops_status == EXT_CSD_BKOPS_LEVEL_0) {
+					if (host->bkops_count > 20) {
+						pr_debug("%s: set need_bkops 0\n", mmc_hostname(host));
+						host->bkops_timer.need_bkops = 0;
+						host->bkops_count = 0;
+					}
+				} else
+					host->bkops_count = 0;
+			} else {
+				pr_debug("%s: set need_bkops 0\n", mmc_hostname(host));
+				host->bkops_timer.need_bkops = 0;
+				host->bkops_count = 0;
+			}
 		}
 	} else
 		pr_err("%s: mmc_send_status fail err= %d\n", __func__, err);
@@ -2402,7 +2419,8 @@
 
 	mmc_bus_get(host);
 	if (mmc_bus_manual_resume(host)) {
-		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
+		if (!host->bkops_started)
+			host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
 		mmc_bus_put(host);
 		return 0;
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/core/mmc.c monarudo-jb-3.4.10-e22f38b/drivers/mmc/core/mmc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/core/mmc.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/mmc/core/mmc.c	2013-08-01 23:38:03.000000000 -0600
@@ -933,9 +933,14 @@
 		}
 	}
 	
-	if (card->ext_csd.rev >= 6)
+	if (card->ext_csd.rev >= 6) {
 		card->wr_perf = 14;
-	else if (card->cid.manfid == 0x45) {
+		
+		if (card->cid.manfid == 0x15) {
+			card->host->bkops_check_status = 1;
+			pr_info("%s: set bkops_check_status\n", mmc_hostname(card->host));
+		}
+	} else if (card->cid.manfid == 0x45) {
 		
 		if ((card->ext_csd.sectors == 31105024) && !strcmp(card->cid.prod_name, "SEM16G"))
 			card->wr_perf = 12;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/host/msm_sdcc.c monarudo-jb-3.4.10-e22f38b/drivers/mmc/host/msm_sdcc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/mmc/host/msm_sdcc.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/mmc/host/msm_sdcc.c	2013-08-01 23:38:03.000000000 -0600
@@ -64,6 +64,7 @@
 #include "msm_sdcc.h"
 #include "msm_sdcc_dml.h"
 #include <mach/msm_rtb_disable.h> 
+#include <mach/board.h>
 
 #define DRIVER_NAME "msm-sdcc"
 
@@ -95,6 +96,13 @@
 #endif
 #define MAX_CONTINUOUS_TUNING_COUNT 10
 
+static int ac_charging = 0;
+static void msmsdcc_cable_notifier_func(int type);
+static struct t_usb_status_notifier usb_status_notifier = {
+	.name = "msmsdcc_ac_detect",
+	.func = msmsdcc_cable_notifier_func,
+};
+
 #if defined(CONFIG_DEBUG_FS)
 static void msmsdcc_dbg_createhost(struct msmsdcc_host *);
 static struct dentry *debugfs_dir;
@@ -174,6 +182,11 @@
 }
 #endif
 
+static void msmsdcc_cable_notifier_func(int type)
+{
+	ac_charging = (type == CONNECT_TYPE_AC) ? 1: 0;
+}
+
 static char *mmc_type_str(unsigned int slot_type)
 {
 	switch (slot_type) {
@@ -6655,7 +6668,6 @@
 	return -EAGAIN;
 }
 
-static int emmc_bkops_prerun = 0;
 #define EMMC_BKOPS_PRERUN_TIMER	180000
 static int msmsdcc_pm_prepare_suspend(struct device *dev)
 {
@@ -6684,18 +6696,24 @@
 		pr_info("%s: %s leave\n", mmc_hostname(host->mmc), __func__);
 		return err;
 	}
-
+	
+	if (!is_mmc_platform(host->plat))
+		return 0;
 	mmc_claim_host(mmc);
 
+	pr_debug("%s: bkops_trigger %d need_bkops %d\n",
+		mmc_hostname(host->mmc), mmc->bkops_trigger, mmc->bkops_timer.need_bkops);
+	if (mmc->bkops_check_status && ac_charging)
+		mmc->long_bkops = 1;
+	else {
+		mmc->long_bkops = 0;
+		if (mmc->bkops_timer.need_bkops > 240000)
+			mmc->bkops_timer.need_bkops = 0;
+	}
 	mmc->bkops_alarm_set = 0;
-	if (mmc->bkops_trigger || mmc->bkops_timer.need_bkops || emmc_bkops_prerun) {
-		if (emmc_bkops_prerun) {
-			mmc->bkops_timer.need_bkops = EMMC_BKOPS_PRERUN_TIMER; 
-			emmc_bkops_prerun = 0;
-			mmc->bkops_trigger = 0;
-		}
+	if (mmc->bkops_trigger || mmc->bkops_timer.need_bkops) {
 		if (!mmc->bkops_timer.need_bkops) {
-			mmc->bkops_timer.need_bkops = mmc->bkops_trigger; 
+			mmc->bkops_timer.need_bkops = mmc->long_bkops? 3600000 : mmc->bkops_trigger;
 			mmc->bkops_timer.bkops_start = 0;
 			mmc->bkops_trigger = 0;
 		}
@@ -6718,9 +6736,12 @@
 
 	if (mmc->bkops_started) {
 		mmc->bkops_trigger = 0;
-		pr_info("%s: bkops remain %d\n", mmc_hostname(host->mmc),
-				mmc->bkops_timer.need_bkops);
-		alarm_sec = ((u32)mmc->bkops_timer.need_bkops + 999) / 1000;
+		if (mmc->long_bkops)
+			alarm_sec = 30;
+		else
+			alarm_sec = ((u32)mmc->bkops_timer.need_bkops + 999) / 1000;
+		pr_info("%s: bkops remain %d, ac_charging %d, alarm_sec %li\n", mmc_hostname(host->mmc),
+				mmc->bkops_timer.need_bkops, ac_charging, alarm_sec);
 		interval = ktime_set(alarm_sec, 0);
 		next_alarm = ktime_add(alarm_get_elapsed_realtime(), interval);
 
@@ -6756,6 +6777,9 @@
 		return ;
 	}
 #endif
+	
+	if (!is_mmc_platform(host->plat))
+		return;
 
 	if (is_mmc_platform(host->plat)) {
 		if (mmc->bkops_alarm_set) {
@@ -6773,6 +6797,7 @@
 				if (mmc_card_doing_bkops(mmc->card))
 					mmc_card_clr_doing_bkops(mmc->card);
 				spin_unlock_irqrestore(&mmc->lock, flags);
+				#if 0
 				if (mmc_bus_needs_resume(mmc)) {
 					spin_lock_irqsave(&mmc->lock, flags);
 					mmc->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
@@ -6784,6 +6809,7 @@
 					else
 						pr_info("%s: %s suspend_host success\n", mmc_hostname(host->mmc), __func__);
 				}
+				#endif
 			} else
 				pr_info("%s: %s mmc_bkops_resume_task fail\n", mmc_hostname(host->mmc), __func__);
 
@@ -6936,6 +6962,7 @@
 		return ret;
 	}
 #endif
+	htc_usb_register_notifier(&usb_status_notifier);
 	return platform_driver_register(&msmsdcc_driver);
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/ethernet/msm/msm_rmnet_bam.c monarudo-jb-3.4.10-e22f38b/drivers/net/ethernet/msm/msm_rmnet_bam.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/ethernet/msm/msm_rmnet_bam.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/ethernet/msm/msm_rmnet_bam.c	2013-08-01 23:38:00.000000000 -0600
@@ -85,20 +85,6 @@
 	uint8_t in_reset;
 };
 
-#define TX_DT_TP_L0_INTERVAL 5000
-#define TX_DT_TP_L1_INTERVAL 200
-#define TX_DT_TP_L2_INTERVAL 200
-#define TX_DT_TP_L1_TIME 30000
-#define TX_DT_TP_MIN_SIZE (10*1024)
-#define TX_DT_TP_L1_SIZE (40*1024)
-static struct timer_list	tx_throttle_timer;
-static bool enable_trottle = false;
-static unsigned long current_tx_bytes = 0;
-static unsigned long previous_tx_bytes = 0;
-static unsigned int tx_throttle_counter = 0;
-static unsigned int tx_throttle_level = 0;
-static unsigned long tx_throttle_limited_size = 2048;
-
 #ifdef CONFIG_MSM_RMNET_DEBUG
 static unsigned long timeout_us;
 
@@ -213,136 +199,6 @@
 DEVICE_ATTR(timeout, 0664, timeout_show, timeout_store);
 #endif
 
-static void rmnet_bam_tx_dt (unsigned long param)
-{
-	struct net_device		*dev = (struct net_device *) param;
-	struct rmnet_private		*unet = netdev_priv(dev);
-	unsigned long		tp;
-
-	switch (tx_throttle_level) {
-	case 0:
-		tp = ((unet->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L0_INTERVAL)*1000;
-
-		DBG2("previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (unet->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = unet->stats.tx_bytes;
-
-		if ( tp < TX_DT_TP_MIN_SIZE ) {
-			DBG0("current tp less than: %d, not enable DT\n", TX_DT_TP_MIN_SIZE);
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L0_INTERVAL);
-		}
-		else if ( tp < TX_DT_TP_L1_SIZE )
-		{
-			DBG0("enable DT, migrate to level 2\n");
-			tx_throttle_limited_size = TX_DT_TP_MIN_SIZE/(1000/TX_DT_TP_L2_INTERVAL);
-			enable_trottle = true;
-			tx_throttle_level = 2;
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		}
-		else
-		{
-			DBG0("enable DT, migrate to level 1\n");
-			tx_throttle_limited_size = (tp/2)/(1000/TX_DT_TP_L1_INTERVAL);
-			enable_trottle = true;
-			tx_throttle_level = 1;
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L1_INTERVAL);
-		}
-		add_timer(&tx_throttle_timer);
-		break;
-	case 1:
-		tp = ((unet->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L1_INTERVAL)*1000;
-
-		DBG2("previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (unet->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = unet->stats.tx_bytes;
-		netif_wake_queue (dev);
-
-		tx_throttle_counter++;
-		if ( tx_throttle_counter > (TX_DT_TP_L1_TIME/TX_DT_TP_L1_INTERVAL) ) {
-			DBG0("tx_throttle_counter: %d reach time: %d, migrate to level 2\n", tx_throttle_counter,TX_DT_TP_L1_INTERVAL);
-			tx_throttle_level = 2;
-			tx_throttle_limited_size = TX_DT_TP_MIN_SIZE/(1000/TX_DT_TP_L2_INTERVAL);
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		}
-		else
-		{
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L1_INTERVAL);
-		}
-		add_timer(&tx_throttle_timer);
-		break;
-	case 2:
-		tp = ((unet->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L2_INTERVAL)*1000;
-
-		DBG2("previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (unet->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = unet->stats.tx_bytes;
-		netif_wake_queue(dev);
-
-		tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		add_timer(&tx_throttle_timer);
-		break;
-	default:
-		DBG0("Invalid level.\n");
-	}
-}
-
-static ssize_t rmnet_bam_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	DBG0("%s\n",__func__);
-
-	return sprintf(buf, "enable=%d, level=%d\n", enable_trottle, tx_throttle_level);
-}
-
-static ssize_t rmnet_bam_store(struct device *dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-	int value;
-	struct net_device	*ndev = to_net_dev(dev);
-	struct rmnet_private		*unet = netdev_priv(ndev);
-	static int previous_value = 0;
-
-	if (sscanf(buf, "%d", &value) != 1)
-		return -EINVAL;
-
-	if (value == previous_value)
-		return count;
-	else
-		previous_value = value;
-
-	DBG0("%s enable=%d\n", __func__, value);
-
-	switch (value) {
-	case 0:
-		
-		del_timer_sync (&tx_throttle_timer);
-		tx_throttle_level = 0;
-		tx_throttle_counter = 0;
-		enable_trottle = false;
-		netif_wake_queue(ndev);
-		break;
-	case 1:
-		
-		tx_throttle_level = 0;
-		tx_throttle_counter = 0;
-		current_tx_bytes = 0;
-		previous_tx_bytes = unet->stats.tx_bytes;
-		init_timer(&tx_throttle_timer);
-		tx_throttle_timer.function = rmnet_bam_tx_dt;
-		tx_throttle_timer.data = (unsigned long) ndev;
-		tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L0_INTERVAL);
-		add_timer(&tx_throttle_timer);
-		break;
-	default:
-		DBG0("Invalid parameter.\n");
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(throttle, S_IRUSR | S_IWUSR, rmnet_bam_show, rmnet_bam_store);
-
 static int rmnet_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 
 static __be16 rmnet_ip_type_trans(struct sk_buff *skb, struct net_device *dev)
@@ -471,26 +327,12 @@
 	dev_kfree_skb_any(skb);
 
 	spin_lock_irqsave(&p->tx_queue_lock, flags);
-	
-	if ( enable_trottle == false )
-	{
-		if (netif_queue_stopped(dev) &&
-			msm_bam_dmux_is_ch_low(p->ch_id)) {
-			DBG0("%s: Low WM hit, waking queue=%p\n",
-				__func__, skb);
-			netif_wake_queue(dev);
-		}
-	}
-	else
-	{
-		if (netif_queue_stopped(dev) && msm_bam_dmux_is_ch_low(p->ch_id) && (current_tx_bytes <= tx_throttle_limited_size))
-		{
-			DBG0("%s: Low WM hit, waking queue=%p, current_tx_bytes=%lu\n",
-				__func__, skb, current_tx_bytes);
-			netif_wake_queue(dev);
-		}
+	if (netif_queue_stopped(dev) &&
+		msm_bam_dmux_is_ch_low(p->ch_id)) {
+		DBG0("%s: Low WM hit, waking queue=%p\n",
+			__func__, skb);
+		netif_wake_queue(dev);
 	}
-	
 	spin_unlock_irqrestore(&p->tx_queue_lock, flags);
 }
 
@@ -650,23 +492,10 @@
 	}
 
 	spin_lock_irqsave(&p->tx_queue_lock, flags);
-	
-	if ( enable_trottle == false )
-	{
-		if (msm_bam_dmux_is_ch_full(p->ch_id)) {
-			netif_stop_queue(dev);
-			DBG0("%s: High WM hit, stopping queue=%p\n",    __func__, skb);
-		}
-	}
-	else
-	{
-		current_tx_bytes += skb->len;
-		if (msm_bam_dmux_is_ch_full(p->ch_id) || (current_tx_bytes > tx_throttle_limited_size)) {
-			netif_stop_queue(dev);
-			DBG0("%s: High WM hit, stopping queue=%p, current_tx_bytes=%lu\n",    __func__, skb, current_tx_bytes);
-		}
+	if (msm_bam_dmux_is_ch_full(p->ch_id)) {
+		netif_stop_queue(dev);
+		DBG0("%s: High WM hit, stopping queue=%p\n",    __func__, skb);
 	}
-	
 	spin_unlock_irqrestore(&p->tx_queue_lock, flags);
 
 exit:
@@ -951,11 +780,6 @@
 			return ret;
 		}
 
-		
-		if (device_create_file(d, &dev_attr_throttle))
-			continue;
-		
-
 #ifdef CONFIG_MSM_RMNET_DEBUG
 		if (device_create_file(d, &dev_attr_timeout))
 			continue;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/usb/rmnet_usb_ctrl.c monarudo-jb-3.4.10-e22f38b/drivers/net/usb/rmnet_usb_ctrl.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/usb/rmnet_usb_ctrl.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/usb/rmnet_usb_ctrl.c	2013-08-01 23:37:59.000000000 -0600
@@ -735,6 +735,7 @@
 		usb_free_urb(sndurb);
 		kfree(out_ctlreq);
 #ifdef HTC_DEBUG_QMI_STUCK
+		del_timer(&context->timer);
 		kfree(context);
 #endif	
 		return result;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/usb/usbnet.c monarudo-jb-3.4.10-e22f38b/drivers/net/usb/usbnet.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/usb/usbnet.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/usb/usbnet.c	2013-08-01 23:37:59.000000000 -0600
@@ -46,9 +46,6 @@
 			(RX_MAX_QUEUE_MEMORY/(dev)->rx_urb_size) : 4)
 #define	TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
 			(RX_MAX_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
-#define TX_SMALL_QUEUE_MEMORY (4 * 1518)
-#define TX_QLEN_SMALL(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
-			(TX_SMALL_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
 
 #define TX_TIMEOUT_JIFFIES	(5*HZ)
 
@@ -72,20 +69,6 @@
 static bool enable_tx_rx_debug = false;
 static bool	usb_pm_debug_enabled = false;
 
-#define TX_DT_TP_L0_INTERVAL 5000
-#define TX_DT_TP_L1_INTERVAL 200
-#define TX_DT_TP_L2_INTERVAL 200
-#define TX_DT_TP_L1_TIME 30000
-#define TX_DT_TP_MIN_SIZE (10*1024)
-#define TX_DT_TP_L1_SIZE (40*1024)
-static struct timer_list	tx_throttle_timer;
-static bool enable_trottle = false;
-static unsigned long current_tx_bytes = 0;
-static unsigned long previous_tx_bytes = 0;
-static unsigned int tx_throttle_counter = 0;
-static unsigned int tx_throttle_level = 0;
-static unsigned long tx_throttle_limited_size = 2048;
-
 
 int usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)
 {
@@ -1146,22 +1129,8 @@
 	case 0:
 		net->trans_start = jiffies;
 		__usbnet_queue_skb(&dev->txq, skb, tx_start);
-		
-		if ( enable_trottle == false )
-		{
-			
-			if (dev->txq.qlen >= TX_QLEN (dev))
-				netif_stop_queue (net);
-		}
-		else
-		{
-			current_tx_bytes += length;
-			if (dev->txq.qlen >= TX_QLEN_SMALL (dev) || (current_tx_bytes > tx_throttle_limited_size))
-			{
-				netif_stop_queue (net);
-			}
-		}
-		
+		if (dev->txq.qlen >= TX_QLEN (dev))
+			netif_stop_queue (net);
 	}
 	spin_unlock_irqrestore (&dev->txq.lock, flags);
 
@@ -1251,21 +1220,8 @@
 			if (dev->rxq.qlen < qlen)
 				queue_work(usbnet_wq, &dev->bh_w);
 		}
-		
-		if ( enable_trottle == false )
-		{
-			
-			if (dev->txq.qlen < TX_QLEN (dev))
-				netif_wake_queue (dev->net);
-		}
-		else
-		{
-			if (dev->txq.qlen < TX_QLEN_SMALL (dev) && (current_tx_bytes <= tx_throttle_limited_size))
-			{
-				netif_wake_queue (dev->net);
-			}
-		}
-		
+		if (dev->txq.qlen < TX_QLEN (dev))
+			netif_wake_queue (dev->net);
 	}
 }
 
@@ -1278,137 +1234,6 @@
 	usbnet_bh(param);
 }
 
-static void usbnet_tx_dt (unsigned long param)
-{
-	struct usbnet		*dev = (struct usbnet *) param;
-	unsigned long		tp;
-
-	switch (tx_throttle_level) {
-	case 0:
-		tp = ((dev->net->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L0_INTERVAL)*1000;
-
-		if  ( enable_tx_rx_debug )
-			netdev_info(dev->net, "[RMNET_D]> previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (dev->net->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = dev->net->stats.tx_bytes;
-
-		if ( tp < TX_DT_TP_MIN_SIZE ) {
-			netdev_info(dev->net, "[RMNET_D]> current tp less than: %d, not enable DT\n", TX_DT_TP_MIN_SIZE);
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L0_INTERVAL);
-		}
-		else if ( tp < TX_DT_TP_L1_SIZE )
-		{
-			netdev_info(dev->net, "[RMNET_D]> enable DT, migrate to level 2\n");
-			tx_throttle_limited_size = TX_DT_TP_MIN_SIZE/(1000/TX_DT_TP_L2_INTERVAL);
-			enable_trottle = true;
-			tx_throttle_level = 2;
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		}
-		else
-		{
-			netdev_info(dev->net, "[RMNET_D]> enable DT, migrate to level 1\n");
-			tx_throttle_limited_size = (tp/2)/(1000/TX_DT_TP_L1_INTERVAL);
-			enable_trottle = true;
-			tx_throttle_level = 1;
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L1_INTERVAL);
-		}
-		add_timer(&tx_throttle_timer);
-		break;
-	case 1:
-		tp = ((dev->net->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L1_INTERVAL)*1000;
-		if  ( enable_tx_rx_debug )
-			netdev_info(dev->net, "[RMNET_D]> previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (dev->net->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = dev->net->stats.tx_bytes;
-		netif_wake_queue (dev->net);
-
-		tx_throttle_counter++;
-		if ( tx_throttle_counter > (TX_DT_TP_L1_TIME/TX_DT_TP_L1_INTERVAL) ) {
-			netdev_info(dev->net, "[RMNET_D]> tx_throttle_counter: %d reach time: %d, migrate to level 2\n", tx_throttle_counter,TX_DT_TP_L1_INTERVAL);
-			tx_throttle_level = 2;
-			tx_throttle_limited_size = TX_DT_TP_MIN_SIZE/(1000/TX_DT_TP_L2_INTERVAL);
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		}
-		else
-		{
-			tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L1_INTERVAL);
-		}
-		add_timer(&tx_throttle_timer);
-		break;
-	case 2:
-		tp = ((dev->net->stats.tx_bytes-previous_tx_bytes)/TX_DT_TP_L2_INTERVAL)*1000;
-		if  ( enable_tx_rx_debug )
-			netdev_info(dev->net, "[RMNET_D]> previous tx bytes: %lu, current tx bytes: %lu, tp: %lu\n", previous_tx_bytes, (dev->net->stats.tx_bytes), tp);
-
-		current_tx_bytes = 0;
-		previous_tx_bytes = dev->net->stats.tx_bytes;
-		netif_wake_queue(dev->net);
-
-		tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L2_INTERVAL);
-		add_timer(&tx_throttle_timer);
-		break;
-	default:
-		netdev_info(dev->net,"[RMNET_D]> Invalid level.\n");
-	}
-}
-
-static ssize_t usbnet_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct net_device	*ndev = to_net_dev(dev);
-	struct usbnet		*unet = netdev_priv(ndev);
-
-	netdev_info(unet->net,"[RMNET_D]> %s\n",__func__);
-
-	return sprintf(buf, "enable=%d, level=%d\n", enable_trottle, tx_throttle_level);
-}
-
-static ssize_t usbnet_store(struct device *dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-	int value;
-	struct net_device	*ndev = to_net_dev(dev);
-	struct usbnet		*unet = netdev_priv(ndev);
-	static int previous_value = 0;
-
-	if (sscanf(buf, "%d", &value) != 1)
-		return -EINVAL;
-
-	if (value == previous_value)
-		return count;
-	else
-		previous_value = value;
-
-	netdev_info(unet->net,"[RMNET_D]> %s enable=%d\n", __func__, value);
-
-	switch (value) {
-	case 0:
-		
-		del_timer_sync (&tx_throttle_timer);
-		tx_throttle_level = 0;
-		tx_throttle_counter = 0;
-		enable_trottle = false;
-		break;
-	case 1:
-		
-		tx_throttle_level = 0;
-		tx_throttle_counter = 0;
-		current_tx_bytes = 0;
-		previous_tx_bytes = unet->net->stats.tx_bytes;
-		init_timer(&tx_throttle_timer);
-		tx_throttle_timer.function = usbnet_tx_dt;
-		tx_throttle_timer.data = (unsigned long) unet;
-		tx_throttle_timer.expires = jiffies + msecs_to_jiffies(TX_DT_TP_L0_INTERVAL);
-		add_timer(&tx_throttle_timer);
-		break;
-	default:
-		netdev_info(unet->net,"[RMNET_D]> Invalid parameter.\n");
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(throttle, S_IRUSR | S_IWUSR, usbnet_show, usbnet_store);
 
 
 void usbnet_disconnect (struct usb_interface *intf)
@@ -1437,11 +1262,6 @@
 		   dev->driver_info->description);
 	
 
-	
-	netdev_info(dev->net, "[RMNET_D]> remove device flag file\n");
-	device_remove_file(&intf->dev, &dev_attr_throttle);
-	
-
 	net = dev->net;
 	unregister_netdev (net);
 
@@ -1623,14 +1443,6 @@
 	if (dev->driver_info->flags & FLAG_LINK_INTR)
 		netif_carrier_off(net);
 
-	
-	netdev_info(dev->net, "[RMNET_D]> create device flag file\n");
-	if ( device_create_file(&net->dev, &dev_attr_throttle) ) {
-		netdev_info(dev->net, "[RMNET_D]> failed to create device flag file\n");
-		device_remove_file(&net->dev, &dev_attr_throttle);
-	}
-	
-
 	return 0;
 
 out4:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4330/Makefile monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4330/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4330/Makefile	2013-06-24 02:50:50.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4330/Makefile	2013-08-01 23:38:08.000000000 -0600
@@ -19,7 +19,7 @@
 	-DTOE -DDHD_BCMEVENTS -DSHOW_EVENTS -DDONGLEOVERLAYS -DOEM_ANDROID   \
 	-DBCMDBG -DCONFIG_FIRST_SCAN -DAPSTA_CONCURRENT -DBRCM_WPSAP -DWL_CFG80211_STA_EVENT -DUSE_KTHREAD_API \
 	-DCUSTOM_OOB_GPIO_NUM=46 -DOOB_INTR_ONLY -DMMC_SDIO_ABORT -DEMBEDDED_PLATFORM -DCUSTOMER_HW2 -DDHD_PRINT_DEBUG   \
-	-DPNO_SUPPORT -DBCMSDIO -DDHD_GPL -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWIFI_ACT_FRAME -DKEEP_ALIVE -DDHD_DEBUG -DWL_ENABLE_P2P_IF\
+	-DPNO_SUPPORT -DBCMSDIO -DDHD_GPL -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWIFI_ACT_FRAME -DKEEP_ALIVE -DDHD_DEBUG -DWL_ENABLE_P2P_IF -DHAVE_FREE_NETDEV\
 	-DDHD_USE_IDLECOUNT -DCSCAN -DHTC_KlocWork -DWL_CFG80211 -DWLP2P -DWL_COMPAT_WIRELESS -DENABLE_INSMOD_NO_FW_LOAD -DBCMWAPI_WAI -DBCMWAPI_WPI \
 	-Wall -Wstrict-prototypes -Werror                                    \
 	-Idrivers/net/wireless/bcmdhd_4330 -Idrivers/net/wireless/bcmdhd_4330/include
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4334/Makefile monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4334/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4334/Makefile	2013-06-24 02:50:50.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4334/Makefile	2013-08-01 23:38:08.000000000 -0600
@@ -21,7 +21,7 @@
 	-DCUSTOM_OOB_GPIO_NUM=46 -DOOB_INTR_ONLY -DMMC_SDIO_ABORT -DEMBEDDED_PLATFORM -DCUSTOMER_HW2 -DDHD_PRINT_DEBUG   \
 	-DPNO_SUPPORT -DBCMSDIO -DDHD_GPL -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWIFI_ACT_FRAME -DKEEP_ALIVE -DDHD_DEBUG -DWL_ENABLE_P2P_IF\
 	-DDHD_USE_IDLECOUNT -DCSCAN -DHTC_KlocWork -DWL_CFG80211 -DWLP2P -DWL_COMPAT_WIRELESS -DENABLE_INSMOD_NO_FW_LOAD -DBCMWAPI_WAI -DBCMWAPI_WPI \
-	-DDHD_USE_STATIC_BUF -DOLD_CFG_80211 \
+	-DDHD_USE_STATIC_BUF -DOLD_CFG_80211 -DHAVE_FREE_NETDEV\
 	-Wall -Wstrict-prototypes -Werror                                    \
 	-Idrivers/net/wireless/bcmdhd_4334 -Idrivers/net/wireless/bcmdhd_4334/include
 	#-I$(M) -I$(M)/include
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_cfg80211.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_cfg80211.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_cfg80211.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_cfg80211.c	2013-08-01 23:38:00.000000000 -0600
@@ -191,7 +191,6 @@
 
 #if defined(COEX_DHCP)
 
-#define BT_DHCP_eSCO_FIX
 #define BT_DHCP_USE_FLAGS
 #define BT_DHCP_OPPR_WIN_TIME	500
 #define BT_DHCP_FLAG_FORCE_TIME 3500
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_common.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_common.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_common.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_common.c	2013-08-01 23:38:00.000000000 -0600
@@ -1401,6 +1401,8 @@
 		goto fail;
 	}
 
+	printf("@@@@@ prepare to enable filter \n");
+
 	str = "pkt_filter_enable";
 	str_len = strlen(str);
 	bcm_strncpy_s(buf, sizeof(buf), str, str_len);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd.h monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd.h	2013-08-01 23:38:00.000000000 -0600
@@ -910,6 +910,7 @@
 	DHDHTC_POWER_CTRL_USER_CONFIG,
 	DHDHTC_POWER_CTRL_WIFI_PHONE,
 	DHDHTC_POWER_CTRL_FOTA_DOWNLOADING,
+	DHDHTC_POWER_CTRL_KDDI_APK,
 	DHDHTC_POWER_CTRL_MAX_NUM,
 };
 extern int dhdhtc_update_wifi_power_mode(int is_screen_off);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_linux.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_linux.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_linux.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_linux.c	2013-08-01 23:38:00.000000000 -0600
@@ -703,7 +703,7 @@
 #ifdef PKT_FILTER_SUPPORT
 	int i;
 
-	DHD_TRACE(("%s: enter\n", __FUNCTION__));
+	DHD_ERROR(("%s: enter\n", __FUNCTION__));
 	if (dhd_pkt_filter_enable) {
 		for (i = 0; i < dhd->pktfilter_count; i++) {
 			dhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);
@@ -717,7 +717,7 @@
 #ifdef PKT_FILTER_SUPPORT
 	int i;
 
-	DHD_TRACE(("%s: enter, value = %d\n", __FUNCTION__, value));
+	DHD_ERROR(("%s: @@@@@@@ enter, value = %d\n", __FUNCTION__, value));
 	
 	
 	if (dhd_pkt_filter_enable && (!value ||
@@ -899,6 +899,11 @@
 				}
 #endif
 
+#ifdef PKT_FILTER_SUPPORT
+				
+ 				dhd_enable_packet_filter(1, dhd);
+#endif
+
 				
 				dhdhtc_set_power_control(0, DHDHTC_POWER_CTRL_BROWSER_LOAD_PAGE);
 				ret = dhdhtc_update_wifi_power_mode(is_screen_off);
@@ -906,6 +911,14 @@
 					DHD_ERROR(("%s Set dhdhtc_update_wifi_power_mode error %d\n", __FUNCTION__, ret));
 					goto exit;
 				}
+                
+                DHD_ERROR(("Clear KDDI APK bit when screen off\n"));
+				dhdhtc_set_power_control(0, DHDHTC_POWER_CTRL_KDDI_APK);
+				ret = dhdhtc_update_wifi_power_mode(is_screen_off);
+				if(ret < 0){
+					DHD_ERROR(("%s Set dhdhtc_update_wifi_power_mode error %d\n", __FUNCTION__, ret));
+					goto exit;
+				}
 				ret = dhdhtc_update_dtim_listen_interval(is_screen_off);
 				if(ret < 0){
 					DHD_ERROR(("%s Set dhdhtc_update_dtim_listen_interval error %d\n", __FUNCTION__, ret));
@@ -931,6 +944,10 @@
 
 				
 				DHD_TRACE(("%s: Remove extra suspend setting \n", __FUNCTION__));
+#ifdef PKT_FILTER_SUPPORT
+                
+                dhd_enable_packet_filter(0, dhd);
+#endif 
 
 #ifdef PNO_SUPPORT
 				ret = dhd_set_pfn(dhd, 0);
@@ -1051,6 +1068,7 @@
 		return -1;
 	}
 
+
 	if (dhdhtc_power_ctrl_mask) {
 		printf("power active. ctrl_mask: 0x%x\n", dhdhtc_power_ctrl_mask);
 		pm_type = PM_OFF;
@@ -4433,7 +4451,7 @@
 #endif 
 	uint retry_max = 10;
 #if defined(ARP_OFFLOAD_SUPPORT)
-	int arpoe = 0;
+	int arpoe = 1;
 #endif
 	int scan_assoc_time = 40;
 	int scan_unassoc_time = 80;
@@ -4673,13 +4691,7 @@
 #endif 
 	}
 
-	
-	if (get_tamper_sf() == 0)
-	DHD_ERROR(("Firmware up: op_mode=0x%04x, "
-		"Broadcom Dongle Host Driver mac="MACDBG"\n",
-		dhd->op_mode,
-		MAC2STRDBG(dhd->mac.octet)));
-	else
+    
 	DHD_ERROR(("Firmware up: op_mode=0x%04x, Broadcom Dongle Host Driver\n",
 		dhd->op_mode));
 	
@@ -5017,7 +5029,7 @@
 	dhd_arp_enable = arpoe;
 #endif 
 
-#if 0 
+#if 1 
 #ifdef PKT_FILTER_SUPPORT
 	
 	dhd->pktfilter_count = 5;
@@ -6370,6 +6382,8 @@
 	return ret;
 }
 
+void wl_android_traffic_monitor(struct net_device *);
+
 int net_os_set_suspend(struct net_device *dev, int val, int force)
 {
 	int ret = 0;
@@ -6384,6 +6398,11 @@
 		ret = dhd_suspend_resume_helper(dhd, val, force);
 #endif
 	}
+    
+    if(val == 1) {
+        wl_android_traffic_monitor(dev);
+    }
+    
 	return ret;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_sdio.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_sdio.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/dhd_sdio.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/dhd_sdio.c	2013-08-01 23:38:00.000000000 -0600
@@ -2310,6 +2310,7 @@
 }
 
 static int bus_txctl_failed_num = 0;
+extern volatile bool dhd_mmc_suspend;
 
 int rxglom_fail_count = RXGLOM_FAIL_COUNT;
 int max_cntl_timeout =  MAX_CNTL_TIMEOUT;
@@ -2461,13 +2462,19 @@
 				DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
 			} else if (ret < 0) {
 #if 1
-			
-			DHD_ERROR(("%s: sdio error %d, abort command and terminate frame 2.\n",
-			__FUNCTION__, ret));
-			bus->dhd->busstate = DHD_BUS_DOWN;
-			dhd_os_send_hang_message(bus->dhd);
+                
+                DHD_ERROR(("%s: sdio error %d, abort command and terminate frame 2.\n",
+                            __FUNCTION__, ret));
+                if(!dhd_mmc_suspend) {
+                    bus->dhd->busstate = DHD_BUS_DOWN;
+                    dhd_os_send_hang_message(bus->dhd);
+                }
+                else {
+                     DHD_ERROR(("%s: mmc is in suspend state, not send hang event\n",
+                                                             __FUNCTION__));
+                }
 #else
-			
+                
 				DHD_ERROR(("%s: sdio error %d, abort command and terminate frame.\n",
 				          __FUNCTION__, ret));
 				bus->tx_sderrs++;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/Makefile monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -21,8 +21,9 @@
 	-DCUSTOM_OOB_GPIO_NUM=46 -DOOB_INTR_ONLY -DMMC_SDIO_ABORT -DEMBEDDED_PLATFORM -DCUSTOMER_HW2 -DDHD_PRINT_DEBUG   \
 	-DPNO_SUPPORT -DBCMSDIO -DDHD_GPL -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWIFI_ACT_FRAME -DKEEP_ALIVE -DWL_ENABLE_P2P_IF\
 	-DDHD_USE_IDLECOUNT -DCSCAN -DHTC_KlocWork -DWL_CFG80211 -DWLP2P -DWL_COMPAT_WIRELESS -DENABLE_INSMOD_NO_FW_LOAD -DBCMWAPI_WAI -DBCMWAPI_WPI \
-	-DDHD_USE_STATIC_BUF -DOLD_CFG_80211 \
+	-DDHD_USE_STATIC_BUF -DOLD_CFG_80211 -DHAVE_FREE_NETDEV \
 	-DSUPPORT_MULTIPLE_REVISION -DENABLE_BCN_LI_BCN_WAKEUP -DWL11U -DVSDB -DHT40_GO -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST -DSUPPORT_MULTIPLE_REVISION -DUSE_CID_CHECK -DCONFIG_CONTROL_PM \
+    -DARP_OFFLOAD_SUPPORT \
 	-DWLLXIW -DUSE_IW \
 	-Wall -Wstrict-prototypes -Werror                                    \
 	-I$(M) -I$(M)/include \
@@ -81,6 +82,8 @@
 #HTC TX TRACKING feature
 DHDCFLAGS += -DHTC_TX_TRACKING
 
+#HTC_REDUCE_FIRST_SCAN
+DHDCFLAGS += -DREDUCE_FIRST_SCAN
 
 ifdef COMPAT_WIRELESS
 NOSTDINC_FLAGS := -I$(COMPAT_WIRELESS)/include/ \
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wl_android.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wl_android.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wl_android.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wl_android.c	2013-08-01 23:38:00.000000000 -0600
@@ -547,19 +547,20 @@
 	return bytes_written;
 }
 
-#define TRAFFIC_SUPER_HIGH_WATER_MARK	2600*(3000/1000)
-#define TRAFFIC_HIGH_WATER_MARK			2300*(3000/1000)
-#define TRAFFIC_LOW_WATER_MARK			256*(3000/1000)
+#define TRAFFIC_SUPER_HIGH_WATER_MARK	2600
+#define TRAFFIC_HIGH_WATER_MARK			2300
+#define TRAFFIC_LOW_WATER_MARK			256
 typedef enum traffic_ind {
 	TRAFFIC_STATS_NORMAL = 0,
 	TRAFFIC_STATS_HIGH,
 	TRAFFIC_STATS_SUPER_HIGH,
 } traffic_ind_t;
 
-
+static int screen_off = 0;
 static int traffic_stats_flag = TRAFFIC_STATS_NORMAL;
 static unsigned long current_traffic_count = 0;
 static unsigned long last_traffic_count = 0;
+static unsigned long last_traffic_count_jiffies = 0;
 
 #ifdef CONFIG_PERFLOCK
 #include <mach/perflock.h>
@@ -658,23 +659,38 @@
 	unsigned long rx_packets_count = 0;
 	unsigned long tx_packets_count = 0;
 	unsigned long traffic_diff = 0;
+    unsigned long jiffies_diff = 0;
 
 	
 	dhd_get_txrx_stats(dev, &rx_packets_count, &tx_packets_count);
 	current_traffic_count = rx_packets_count + tx_packets_count;
 
-	if (current_traffic_count >= last_traffic_count) {
-		traffic_diff = current_traffic_count - last_traffic_count;
+	if ((current_traffic_count >= last_traffic_count && (jiffies - last_traffic_count_jiffies) >= 3*HZ) || screen_off) {
+        
+        if (screen_off) {
+            printf("set traffic = 0 and relase performace lock when screen off");
+            traffic_diff = 0;
+        }
+        else {
+        
+            jiffies_diff = jiffies - last_traffic_count_jiffies;
+            if (jiffies_diff < 7*HZ) {
+                traffic_diff = (current_traffic_count - last_traffic_count) / jiffies_diff * HZ;
+            }
+            else {
+                traffic_diff = 0;
+            }
+        }
         switch (traffic_stats_flag) {
         case TRAFFIC_STATS_NORMAL:
 			if (traffic_diff > TRAFFIC_HIGH_WATER_MARK) {
 				traffic_stats_flag = TRAFFIC_STATS_HIGH;
 				wlan_lock_perf();
-				printf("lock cpu here, traffic-count=%ld\n", traffic_diff / 3);
+				printf("lock cpu here, traffic-count=%ld\n", traffic_diff);
                 if (traffic_diff > TRAFFIC_SUPER_HIGH_WATER_MARK) {
                     traffic_stats_flag = TRAFFIC_STATS_SUPER_HIGH;
                     wlan_lock_multi_core(dev);
-                    printf("lock 2nd cpu here, traffic-count=%ld\n", traffic_diff / 3);
+                    printf("lock 2nd cpu here, traffic-count=%ld\n", traffic_diff);
                 }
 			}
             break;
@@ -682,23 +698,23 @@
             if (traffic_diff > TRAFFIC_SUPER_HIGH_WATER_MARK) {
                 traffic_stats_flag = TRAFFIC_STATS_SUPER_HIGH;
                 wlan_lock_multi_core(dev);
-				printf("lock 2nd cpu here, traffic-count=%ld\n", traffic_diff / 3);
+				printf("lock 2nd cpu here, traffic-count=%ld\n", traffic_diff);
             }
             else if (traffic_diff < TRAFFIC_LOW_WATER_MARK) {
 				traffic_stats_flag = TRAFFIC_STATS_NORMAL;
 				wlan_unlock_perf();
-				printf("unlock cpu here, traffic-count=%ld\n", traffic_diff / 3);
+				printf("unlock cpu here, traffic-count=%ld\n", traffic_diff);
 			}
             break;
         case TRAFFIC_STATS_SUPER_HIGH:
 			if (traffic_diff < TRAFFIC_SUPER_HIGH_WATER_MARK) {
                 traffic_stats_flag = TRAFFIC_STATS_HIGH;
                 wlan_unlock_multi_core(dev);
-				printf("unlock 2nd cpu here, traffic-count=%ld\n", traffic_diff / 3);
+				printf("unlock 2nd cpu here, traffic-count=%ld\n", traffic_diff);
                 if (traffic_diff < TRAFFIC_LOW_WATER_MARK) {
                     traffic_stats_flag = TRAFFIC_STATS_NORMAL;
                     wlan_unlock_perf();
-                    printf("unlock cpu here, traffic-count=%ld\n", traffic_diff / 3);
+                    printf("unlock cpu here, traffic-count=%ld\n", traffic_diff);
                 }
             }
             break;
@@ -706,6 +722,7 @@
             break;
         }
 	}
+    last_traffic_count_jiffies = jiffies;
 	last_traffic_count = current_traffic_count;
 	
 }
@@ -1537,7 +1554,6 @@
 static int active_period = 20000; 
 static int wl_android_active_expired = 0;
 struct timer_list *wl_android_active_timer = NULL;
-static int screen_off = 0;
 
 static void wl_android_act_time_expire(void)
 {
@@ -1679,6 +1695,15 @@
 			dhdhtc_set_power_control(1, DHDHTC_POWER_CTRL_FOTA_DOWNLOADING);
 			dhdhtc_update_wifi_power_mode(screen_off);
 			break;
+		
+		case 40:
+			dhdhtc_set_power_control(0, DHDHTC_POWER_CTRL_KDDI_APK);
+			dhdhtc_update_wifi_power_mode(screen_off);
+			break;
+		case 41:
+			dhdhtc_set_power_control(1, DHDHTC_POWER_CTRL_KDDI_APK);
+			dhdhtc_update_wifi_power_mode(screen_off);
+			break;
 
 		case 87: 
 			printf("wifilock release\n");
@@ -3151,20 +3176,34 @@
 #ifdef PKT_FILTER_SUPPORT
 	else if (strnicmp(command, CMD_RXFILTER_START, strlen(CMD_RXFILTER_START)) == 0) {
 		
+		printf("@@@@@ %s enter CMD_RXFILTER_START\n",__FUNCTION__); 
+#if 0
 		snprintf(command, 3, "OK");
 		bytes_written = strlen("OK");
+#else		
 		/*bytes_written = net_os_set_packet_filter(net, 1);*/
+		//bytes_written = net_os_set_packet_filter(net, 1);
+		bytes_written = net_os_enable_packet_filter(net, 1);
+
+#endif		
 		
 	}
 	else if (strnicmp(command, CMD_RXFILTER_STOP, strlen(CMD_RXFILTER_STOP)) == 0) {
 		
+		printf("@@@@@ %s enter CMD_RXFILTER_STOP\n",__FUNCTION__); 
+#if 0
 		snprintf(command, 3, "OK");
 		bytes_written = strlen("OK");
+#else		
 		/*bytes_written = net_os_set_packet_filter(net, 0);*/
+		bytes_written = net_os_enable_packet_filter(net, 0);
+
+#endif
 		
 	}
 	else if (strnicmp(command, CMD_RXFILTER_ADD, strlen(CMD_RXFILTER_ADD)) == 0) {
 		
+#if 0		
 #ifdef BCM4329_LOW_POWER
 		if (LowPowerMode == 1) {
 			data = (struct dd_pkt_filter_s *)&command[32];
@@ -3177,14 +3216,21 @@
 		wl_android_set_pktfilter(net, (struct dd_pkt_filter_s *)&command[32]);
 		snprintf(command, 3, "OK");
 		bytes_written = strlen("OK");
-		/*
-		int filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
-		bytes_written = net_os_rxfilter_add_remove(net, TRUE, filter_num);
-		*/
+		
+#else
+		int filter_num;
+		printf("@@@@@ %s enter CMD_RXFILTER_ADD\n",__FUNCTION__); 
+		
+		filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
+ 		bytes_written = net_os_rxfilter_add_remove(net, TRUE, filter_num);
+
+
+#endif		
 		
 	}
 	else if (strnicmp(command, CMD_RXFILTER_REMOVE, strlen(CMD_RXFILTER_REMOVE)) == 0) {
 		
+#if 0
 #ifdef BCM4329_LOW_POWER
 		if (LowPowerMode == 1) {
 			data = (struct dd_pkt_filter_s *)&command[32];
@@ -3197,10 +3243,14 @@
 		wl_android_set_pktfilter(net, (struct dd_pkt_filter_s *)&command[32]);
 		snprintf(command, 3, "OK");
 		bytes_written = strlen("OK");
-		/*
-		int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
-		bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);
-		*/
+#else
+		int filter_num;
+
+		printf("@@@@@ %s enter CMD_RXFILTER_REMOVE\n",__FUNCTION__); 
+
+        filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
+        bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);		
+#endif		
 		
 	}
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wl_cfg80211.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wl_cfg80211.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wl_cfg80211.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wl_cfg80211.c	2013-08-01 23:38:00.000000000 -0600
@@ -1811,6 +1811,12 @@
 static bool g_first_broadcast_scan = TRUE;
 #endif 
 
+#ifdef REDUCE_FIRST_SCAN
+#define FIRST_SCAN_ACTIVE_DWELL_TIME_MS 40
+#define FIRST_SCAN_PASSIVE_DWELL_TIME_MS 0
+static bool first_broadcast_scan = TRUE;
+#endif 
+
 void wl_abort_scan(struct work_struct *work);
 DECLARE_DELAYED_WORK(abort_scan, wl_abort_scan);
 void wl_abort_scan(struct work_struct *work)
@@ -1898,6 +1904,10 @@
 	bool is_first_init_2g_scan = false;
 #endif 
 
+#ifdef REDUCE_FIRST_SCAN
+    bool is_first_scan = false;
+#endif 
+
 	WL_DBG(("Enter \n"));
 
 	if (!request || !wl) {
@@ -1938,6 +1948,13 @@
 
 #endif 
 
+#ifdef REDUCE_FIRST_SCAN
+        if (ndev == wl_to_prmry_ndev(wl) && first_broadcast_scan == true) {
+            first_broadcast_scan = false;
+            is_first_scan = true;
+        }
+#endif 
+
 		n_channels = request->n_channels;
 		n_ssids = request->n_ssids;
 		
@@ -1964,6 +1981,15 @@
 			params->params.active_time = FIRST_SCAN_ACTIVE_DWELL_TIME_MS;
 #endif 
 
+#ifdef REDUCE_FIRST_SCAN
+        
+        if (is_first_scan) {
+            WL_INFO(("Reduce first scan time\n"));
+            params->params.active_time = FIRST_SCAN_ACTIVE_DWELL_TIME_MS;
+            params->params.passive_time = FIRST_SCAN_PASSIVE_DWELL_TIME_MS;
+        }
+#endif 
+
 		params->version = htod32(ESCAN_REQ_VERSION);
 		params->action =  htod16(action);
 #if defined(CUSTOMER_HW4) && defined(DUAL_ESCAN_RESULT_BUFFER)
@@ -9321,8 +9347,8 @@
 					WL_DBG(("%s:netdev not ready\n", iter->ndev->name));
 				else
 					WL_ERR(("%s:error (%d)\n", iter->ndev->name, err));
-				iter->ndev->ieee80211_ptr->ps = pm ? true: false;
 			}
+			iter->ndev->ieee80211_ptr->ps = pm ? true: false;
 		}
 	}
 	 else { 
@@ -10430,6 +10456,9 @@
 	err = __wl_cfg80211_up(wl);
 	if (unlikely(err))
 		WL_ERR(("__wl_cfg80211_up failed\n"));
+#ifdef REDUCE_FIRST_SCAN
+    first_broadcast_scan = TRUE;
+#endif 
 	mutex_unlock(&wl->usr_sync);
 	return err;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wldev_common.c monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wldev_common.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/net/wireless/bcmdhd_4335/wldev_common.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/net/wireless/bcmdhd_4335/wldev_common.c	2013-08-01 23:38:00.000000000 -0600
@@ -499,15 +499,13 @@
     wldev_set_pktfilter_enable_by_id(dev, 106, enable);
         printf("%s: pkt_filter id:106 %s\n", __FUNCTION__, (enable)?"enable":"disable");
 	}
-
-	if(!enable){
+	if (!enable) {
 		wldev_set_pktfilter_enable_by_id(dev, 107, enable);
-			printf("%s: pkt_filter id:107 %s\n", __FUNCTION__, (enable)?"enable":"disable");
+		printf("%s: pkt_filter id:107 %s\n", __FUNCTION__, (enable)?"enable":"disable");
 
 		wldev_set_pktfilter_enable_by_id(dev, 108, enable);
-	        printf("%s: pkt_filter id:108 %s\n", __FUNCTION__, (enable)?"enable":"disable");
+		printf("%s: pkt_filter id:108 %s\n", __FUNCTION__, (enable)?"enable":"disable");
 	}
-
         return 0;
 }
 #ifdef SOFTAP
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/power/pm8921-bms-htc.c monarudo-jb-3.4.10-e22f38b/drivers/power/pm8921-bms-htc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/power/pm8921-bms-htc.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/power/pm8921-bms-htc.c	2013-08-01 23:38:01.000000000 -0600
@@ -30,6 +30,7 @@
 #include <linux/mutex.h>
 #include <mach/board_htc.h>
 #include <mach/htc_restart_handler.h>
+#include <asm/uaccess.h>
 
 #ifdef CONFIG_HTC_BATT_8960
 #include "mach/htc_battery_cell.h"
@@ -64,8 +65,17 @@
 #define AMUX_TRIM_2			0x322
 #define TEST_PROGRAM_REV	0x339
 
+
 #define OCV_UPDATE_STORAGE	0x105
-#define OCV_UPDATE_STORAGE_USE_MASK	0x0F
+#define OCV_UPDATE_STORAGE_USE_MASK		(1)
+#define OCV_HW_RESET_MASK			(1<<1)
+
+#define BMS_STORE_MAGIC_NUM		0xDDAACC00
+#define BMS_STORE_MAGIC_OFFSET		1056
+#define BMS_STORE_SOC_OFFSET		1060
+#define BMS_STORE_OCV_OFFSET		1064
+#define BMS_STORE_CC_OFFSET		1068
+#define BMS_STORE_CURRTIME_OFFSET		1072
 
 #define BATT_MAX_OCV_UV		5000000
 #define BATT_MIN_OCV_UV		0
@@ -141,6 +151,7 @@
 	int			soc_rbatt_suspend;
 	int			default_rbatt_mohm;
 	unsigned int	rconn_mohm;
+	int			store_batt_data_soc_thre;
 	int			amux_2_trim_delta;
 	uint16_t		prev_last_good_ocv_raw;
 	int			usb_chg_plugged_ready;
@@ -219,9 +230,12 @@
 static int bms_end_cc_uah;
 
 static int ocv_update_stop_active_mask = OCV_UPDATE_STOP_BIT_CABLE_IN |
-											OCV_UPDATE_STOP_BIT_ATTR_FILE;
+											OCV_UPDATE_STOP_BIT_ATTR_FILE |
+											OCV_UPDATE_STOP_BIT_BOOT_UP;
 static int ocv_update_stop_reason;
 static int level_dropped_after_cable_out = 5;
+static int level_dropped_after_boot_up = 5;
+static int new_boot_soc;
 static int bms_discharge_percent;
 static int is_ocv_update_start;
 struct mutex ocv_update_lock;
@@ -325,6 +339,51 @@
 module_param_cb(last_real_fcc_batt_temp, &bms_last_real_fcc_batt_temp_param_ops,
 					&last_real_fcc_batt_temp, 0644);
 
+static ssize_t kernel_write(struct file *file, const char *buf,
+	size_t count, loff_t pos)
+{
+	mm_segment_t old_fs;
+	ssize_t res;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	
+	res = vfs_write(file, (const char __user *)buf, count, &pos);
+	set_fs(old_fs);
+
+	return res;
+}
+
+int emmc_misc_write(int val, int offset)
+{
+	char filename[32] = "";
+	int w_val = val;
+	struct file *filp = NULL;
+	ssize_t nread;
+	int pnum = get_partition_num_by_name("misc");
+
+	if (pnum < 0) {
+		pr_info("%s: unknown partition number for misc partition\n", __func__);
+		return 0;
+	}
+	sprintf(filename, "/dev/block/mmcblk0p%d", pnum);
+
+	filp = filp_open(filename, O_RDWR, 0);
+	if (IS_ERR(filp)) {
+		pr_info("%s: unable to open file: %s\n", __func__, filename);
+		return PTR_ERR(filp);
+	}
+
+	filp->f_pos = offset;
+	nread = kernel_write(filp, (char *)&w_val, sizeof(int), filp->f_pos);
+	pr_info("%s: %X (%d)\n", __func__, w_val, nread);
+
+	if (filp)
+		filp_close(filp, NULL);
+
+	return 1;
+}
+
 static int pm_bms_get_rt_status(struct pm8921_bms_chip *chip, int irq_id)
 {
 	return pm8xxx_read_irq_stat(chip->dev->parent,
@@ -958,6 +1017,44 @@
 		*uv -= MBG_TRANSIENT_ERROR_UV;
 }
 
+int pm8921_store_hw_reset_reason(int is_hw_reset)
+{
+	int rc = 0;
+	u8 reset = 0;
+	u8 ocv_hw_reset_old = 0, ocv_hw_reset = 0;
+
+	if (!the_chip) {
+		pr_err("%s called before initialization\n", __func__);
+		return -EINVAL;
+	}
+
+	if (is_hw_reset)
+		reset = BIT(1);
+	else
+		reset = 0;
+
+	
+	rc = pm8xxx_readb(the_chip->dev->parent, OCV_UPDATE_STORAGE, &ocv_hw_reset_old);
+	if (rc) {
+		pr_err("%s: failed to read addr = %d, rc=%d\n",
+				__func__, OCV_UPDATE_STORAGE, rc);
+	}
+
+	pm_bms_masked_write(the_chip, OCV_UPDATE_STORAGE, OCV_HW_RESET_MASK, reset);
+
+	rc = pm8xxx_readb(the_chip->dev->parent, OCV_UPDATE_STORAGE, &ocv_hw_reset);
+	if (rc) {
+		pr_err("%s: failed to read addr = %d, rc=%d\n",
+				__func__, OCV_UPDATE_STORAGE, rc);
+	}
+
+	pr_info("%s OCV_UPDATE_STORAGE=0x%x->0x%x\n", __func__, ocv_hw_reset_old, ocv_hw_reset);
+
+	return (int)ocv_hw_reset;
+}
+
+EXPORT_SYMBOL(pm8921_store_hw_reset_reason);
+
 static int read_soc_params_raw(struct pm8921_bms_chip *chip,
 				struct pm8921_soc_params *raw)
 {
@@ -1812,6 +1909,15 @@
 		bms_discharge_percent = 0;
 		disable_ocv_update_with_reason(false, OCV_UPDATE_STOP_BIT_CABLE_IN);
 	}
+	if (new_boot_soc &&
+			((new_boot_soc - *result) >=
+				level_dropped_after_boot_up)) {
+		pr_info("OCV can be update due to %d - %d >= %d\n",
+				new_boot_soc, *result,
+				level_dropped_after_boot_up);
+		new_boot_soc = 0;
+		disable_ocv_update_with_reason(false, OCV_UPDATE_STOP_BIT_BOOT_UP);
+	}
 	if (the_chip->level_ocv_update_stop_begin &&
 			the_chip->level_ocv_update_stop_end) {
 		if (*result >= the_chip->level_ocv_update_stop_begin &&
@@ -1884,6 +1990,11 @@
 	int batt_temp, rc;
 	struct pm8xxx_adc_chan_result result;
 	struct pm8921_soc_params raw;
+	struct timespec xtime;
+	unsigned long currtime_ms;
+
+	xtime = CURRENT_TIME;
+	currtime_ms = xtime.tv_sec * MSEC_PER_SEC + xtime.tv_nsec / NSEC_PER_MSEC;
 
 	if (the_chip == NULL)
 		return;
@@ -1971,11 +2082,24 @@
 			last_charge_increase = last_charge_increase % 100;
 		}
 	}
-	pr_info("end_percent = %d%% last_charge_increase = %d"
-			"last_chargecycles = %d\n",
-			the_chip->end_percent,
-			last_charge_increase,
-			last_chargecycles);
+
+	
+	if (the_chip->store_batt_data_soc_thre > 0
+			&& !usb_chg_plugged_in()
+			&& bms_end_percent < the_chip->store_batt_data_soc_thre
+			&& board_mfg_mode() == 5 ) {
+		emmc_misc_write(BMS_STORE_MAGIC_NUM, BMS_STORE_MAGIC_OFFSET);
+		emmc_misc_write(bms_end_percent, BMS_STORE_SOC_OFFSET);
+		emmc_misc_write(raw.last_good_ocv_uv, BMS_STORE_OCV_OFFSET);
+		emmc_misc_write(raw.cc, BMS_STORE_CC_OFFSET);
+		emmc_misc_write(currtime_ms, BMS_STORE_CURRTIME_OFFSET);
+	}
+
+	pr_info("end_percent=%d%%, last_charge_increase=%d, last_chargecycles=%d, "
+			"board_mfg_mode=%d, bms_end_percent=%d, last_good_ocv_uv=%d, raw.cc=%x, "
+			"currtime_ms=%ld\n",
+			the_chip->end_percent, last_charge_increase, last_chargecycles,
+			board_mfg_mode(), bms_end_percent, raw.last_good_ocv_uv, raw.cc, currtime_ms);
 	the_chip->start_percent = -EINVAL;
 	the_chip->end_percent = -EINVAL;
 	pm_bms_masked_write(the_chip, BMS_TOLERANCES,
@@ -2270,6 +2394,13 @@
 				= bms_battery_data->default_rbatt_mohm;
 		chip->delta_rbatt_mohm
 				= bms_battery_data->delta_rbatt_mohm;
+		if (bms_battery_data->level_ocv_update_stop_begin
+			&& bms_battery_data->level_ocv_update_stop_end) {
+			chip->level_ocv_update_stop_begin = bms_battery_data->level_ocv_update_stop_begin;
+			chip->level_ocv_update_stop_end = bms_battery_data->level_ocv_update_stop_end;
+			ocv_update_stop_active_mask = ocv_update_stop_active_mask |
+											OCV_UPDATE_STOP_BIT_BATT_LEVEL;
+		}
 	} else {
 		pr_err("bms_battery_data doesn't exist (id=%d)\n",
 					batt_id);
@@ -3033,10 +3164,13 @@
 static int __devinit pm8921_bms_probe(struct platform_device *pdev)
 {
 	int rc = 0;
-	int vbatt;
+	int vbatt, curr_soc;
 	struct pm8921_bms_chip *chip;
 	const struct pm8921_bms_platform_data *pdata
 				= pdev->dev.platform_data;
+	struct pm8921_soc_params raw;
+	struct timespec xtime;
+	unsigned long currtime_ms;
 #ifdef CONFIG_HTC_BATT_8960
 	const struct pm8921_charger_batt_param *chg_batt_param;
 #endif
@@ -3048,6 +3182,9 @@
 		return -EINVAL;
 	}
 
+	xtime = CURRENT_TIME;
+	currtime_ms = xtime.tv_sec * MSEC_PER_SEC + xtime.tv_nsec / NSEC_PER_MSEC;
+
 	chip = kzalloc(sizeof(struct pm8921_bms_chip), GFP_KERNEL);
 	if (!chip) {
 		pr_err("Cannot allocate pm_bms_chip\n");
@@ -3061,17 +3198,12 @@
 	chip->i_test = pdata->i_test;
 	chip->v_failure = pdata->v_failure;
 	chip->rconn_mohm = pdata->rconn_mohm;
+	chip->store_batt_data_soc_thre = pdata->store_batt_data_soc_thre;
 	chip->criteria_sw_est_ocv = pdata->criteria_sw_est_ocv;
 	chip->rconn_mohm_sw_est_ocv = pdata->rconn_mohm_sw_est_ocv;
 	chip->cc_backup_uv = 0;
 	chip->ocv_reading_at_100 = 0;
 	chip->ocv_backup_uv = 0;
-	if (pdata->level_ocv_update_stop_begin && pdata->level_ocv_update_stop_end) {
-		chip->level_ocv_update_stop_begin = pdata->level_ocv_update_stop_begin;
-		chip->level_ocv_update_stop_end = pdata->level_ocv_update_stop_end;
-		ocv_update_stop_active_mask = ocv_update_stop_active_mask |
-										OCV_UPDATE_STOP_BIT_BATT_LEVEL;
-	}
 	chip->start_percent = -EINVAL;
 	chip->end_percent = -EINVAL;
 	chip->batt_temp_channel = pdata->bms_cdata.batt_temp_channel;
@@ -3141,12 +3273,38 @@
 	pm8921_bms_enable_irq(chip, PM8921_BMS_OCV_FOR_R);
 
 	get_battery_uvolts(chip, &vbatt);
-	pr_info("OK battery_capacity_at_boot=%d volt = %d ocv = %d\n",
-				pm8921_bms_get_percent_charge(),
-				vbatt, last_ocv_uv);
+	curr_soc = pm8921_bms_get_percent_charge();
+
+	
+	if (batt_stored_magic_num == BMS_STORE_MAGIC_NUM
+			&& the_chip->store_batt_data_soc_thre > 0
+			&& (curr_soc - batt_stored_soc) > 5
+			&& (currtime_ms - batt_stored_time_ms) < 3600000 ) {
+		read_soc_params_raw(the_chip, &raw);
+		chip->cc_backup_uv = raw.cc - batt_stored_cc_uv;
+		chip->ocv_backup_uv = last_ocv_uv = batt_stored_ocv_uv;
+		chip->ocv_reading_at_100 = 0;
+		write_backup_cc_uv(chip->cc_backup_uv);
+		write_backup_ocv_at_100(chip->ocv_reading_at_100);
+		write_backup_ocv_uv(chip->ocv_backup_uv);
+
+		new_boot_soc = pm8921_bms_get_percent_charge();
+		
+		disable_ocv_update_with_reason(true, OCV_UPDATE_STOP_BIT_BOOT_UP);
+	}
+	
+	pm8921_store_hw_reset_reason(0);
+
+	pr_info("OK battery_capacity_at_boot=%d, new_boot_soc=%d, volt=%d, "
+			"ocv=%d, batt_magic_num=%x, stored_soc=%d, curr_time=%ld, "
+			"stored_time=%ld\n",
+				curr_soc, new_boot_soc, vbatt, last_ocv_uv,
+				batt_stored_magic_num, batt_stored_soc,
+				currtime_ms, batt_stored_time_ms);
 	pr_info("r_sense=%u,i_test=%u,v_failure=%u,default_rbatt_mohm=%d\n",
 			chip->r_sense, chip->i_test, chip->v_failure,
 			chip->default_rbatt_mohm);
+
 	return 0;
 
 free_irqs:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/power/pm8921-charger-htc.c monarudo-jb-3.4.10-e22f38b/drivers/power/pm8921-charger-htc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/power/pm8921-charger-htc.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/power/pm8921-charger-htc.c	2013-08-01 23:38:01.000000000 -0600
@@ -282,11 +282,13 @@
 	int				cable_in_irq;
 	int				cable_in_gpio;
 	int				is_embeded_batt;
+	int				eoc_ibat_thre_ma;
+	int				ichg_threshold_ua;
+	int 				ichg_regulation_thr_ua;
 	struct delayed_work		update_heartbeat_work;
 	struct delayed_work		eoc_work;
 	struct delayed_work		ovp_check_work;
 	struct delayed_work		recharge_check_work;
-	struct work_struct		unplug_ovp_fet_open_work;
 	struct work_struct		chghot_work;
 	struct delayed_work		unplug_check_work;
 	struct delayed_work		vin_collapse_check_work;
@@ -325,6 +327,7 @@
 static int usb_ovp_disable;
 static int bat_temp_ok_prev = -1;
 static int eoc_count; 
+static int eoc_count_by_curr; 
 
 static int usbin_critical_low_cnt = 0;
 static int pwrsrc_under_rating = 0;
@@ -2176,7 +2179,7 @@
 			"mitigation_level(int): %d;\n", thermal_mitigation);
 
 	len += scnprintf(buf + len, size - len,
-			"eoc_count(int): %d;\n", eoc_count);
+			"eoc_count/by_curr(int): %d/%d;\n", eoc_count, eoc_count_by_curr);
 
 	len += scnprintf(buf + len, size - len,
 			"reverse_boost_disabled(bool): %d;\n", the_chip->disable_reverse_boost_check);
@@ -2463,7 +2466,7 @@
 				pr_err("Failed to set auto_enable rc=%d\n", rc);
 
 			is_batt_full = false;
-			eoc_count = 0;
+			eoc_count = eoc_count_by_curr = 0;
 			is_ac_safety_timeout = is_ac_safety_timeout_twice = false;
 			is_cable_remove = true;
 			usbin_critical_low_cnt = 0;
@@ -2768,7 +2771,7 @@
 {
 	int ichg_meas_ua, vbat_uv;
 	int ichg_meas_ma;
-	int adj_vdd_max_mv, programmed_vdd_max;
+	int adj_vdd_max_mv, programmed_vdd_max, target_vdd_max;
 	int vbat_batt_terminal_uv;
 	int vbat_batt_terminal_mv;
 	int reg_loop;
@@ -2786,11 +2789,6 @@
 	}
 
 	reg_loop = pm_chg_get_regulation_loop(chip);
-	if (!(reg_loop & VDD_LOOP_ACTIVE_BIT)) {
-		pr_debug("Exiting Vdd loop is not active reg loop=0x%x\n",
-			reg_loop);
-		return;
-	}
 
 	pm8921_bms_get_simultaneous_battery_voltage_and_current(&ichg_meas_ua,
 								&vbat_uv);
@@ -2798,6 +2796,9 @@
 		pr_debug("Exiting ichg_meas_ua = %d > 0\n", ichg_meas_ua);
 		return;
 	}
+
+	if (chip->ichg_threshold_ua)
+		ichg_threshold_ua = chip->ichg_threshold_ua;
 	if (ichg_meas_ua <= ichg_threshold_ua) {
 		pr_debug("Exiting ichg_meas_ua = %d < ichg_threshold_ua = %d\n",
 					ichg_meas_ua, ichg_threshold_ua);
@@ -2810,11 +2811,20 @@
 	vbat_batt_terminal_mv = vbat_batt_terminal_uv/1000;
 	pm_chg_vddmax_get(the_chip, &programmed_vdd_max);
 
-	last_delta_mv = delta_mv =  chip->max_voltage_mv - vbat_batt_terminal_mv;
+	if (!chip->ichg_regulation_thr_ua)
+		target_vdd_max = chip->max_voltage_mv;
+	else if (ichg_meas_ua > chip->ichg_regulation_thr_ua)
+		target_vdd_max = chip->max_voltage_mv;
+	else
+		target_vdd_max = chip->max_voltage_mv + vdd_max_increase_mv;
+
+	last_delta_mv = delta_mv =  target_vdd_max - vbat_batt_terminal_mv;
 	pr_info("%s: rconn_mohm=%d, reg_loop=0x%x, vbat_uv=%d, ichg_ma=%d, "
-			"vbat_terminal_mv=%d, delta_mv=%d\n",
+			"vbat_terminal_mv=%d, delta_mv=%d, ichg_regulation_thr_ua=%d, "
+			"target_vdd_max=%d, ichg_threshold_ua=%d\n",
 			__func__, chip->rconn_mohm, reg_loop, vbat_uv, ichg_meas_ma,
-			vbat_batt_terminal_mv, delta_mv);
+			vbat_batt_terminal_mv, delta_mv, chip->ichg_regulation_thr_ua,
+			target_vdd_max, ichg_threshold_ua);
 	if (delta_mv > delta_threshold_mv && delta_mv <= 0) {
 		pr_debug("skip delta_mv=%d since it is between %d and 0\n",
 				delta_mv, delta_threshold_mv);
@@ -2827,13 +2837,10 @@
 			programmed_vdd_max,
 			adj_vdd_max_mv);
 
-	if (adj_vdd_max_mv < chip->max_voltage_mv) {
-		pr_debug("adj vdd_max lower than default max voltage\n");
-		return;
-	}
-
 	if (adj_vdd_max_mv > (chip->max_voltage_mv + vdd_max_increase_mv))
 		adj_vdd_max_mv = chip->max_voltage_mv + vdd_max_increase_mv;
+	else if ( adj_vdd_max_mv < chip->max_voltage_mv )
+		adj_vdd_max_mv = chip->max_voltage_mv;
 
 	pr_info("%s: adjusting vdd_max_mv to %d from %d to make "
 		"vbat_batt_termial_uv = %d to %d\n",
@@ -3328,11 +3335,8 @@
 
 #define WRITE_BANK_4		0xC0
 #define OVP_DEBOUNCE_TIME 0x06
-static void unplug_ovp_fet_open_worker(struct work_struct *work)
+static void unplug_ovp_fet_open(struct pm8921_chg_chip *chip)
 {
-	struct pm8921_chg_chip *chip = container_of(work,
-				struct pm8921_chg_chip,
-				unplug_ovp_fet_open_work);
 	int chg_gone = 0, active_chg_plugged_in = 0, count = 0, is_wlc_remove = 0;
 	u8 active_mask = 0;
 	u16 ovpreg, ovptestreg;
@@ -3895,7 +3899,7 @@
 			pr_info("too much ovp_trial_count=%d\n", ovp_trial_count);
 			ovp_trial_count = 0;
 		}
-		schedule_work(&chip->unplug_ovp_fet_open_work);
+		unplug_ovp_fet_open(chip);
 	}
 
 	if (!(reg_loop & VIN_ACTIVE_BIT) && (active_path & USB_ACTIVE_BIT) &&
@@ -4050,8 +4054,7 @@
 static irqreturn_t chg_gone_irq_handler(int irq, void *data)
 {
 	struct pm8921_chg_chip *chip = data;
-	u8 reg;
-	int rc, chg_gone, usb_chg_plugged_in, dc_chg_plugged_in;
+	int chg_gone, usb_chg_plugged_in, dc_chg_plugged_in;
 
 	usb_chg_plugged_in = is_usb_chg_plugged_in(chip);
 	dc_chg_plugged_in = is_dc_chg_plugged_in(chip);
@@ -4060,13 +4063,6 @@
 	pr_info("chg_gone=%d, usb_valid=%d, dc_valid=%d, fsm=%d\n",
 			chg_gone, usb_chg_plugged_in, dc_chg_plugged_in,
 			pm_chg_get_fsm_state(data));
-	rc = pm8xxx_readb(chip->dev->parent, CHG_CNTRL_3, &reg);
-	if (rc)
-		pr_err("Failed to read CHG_CNTRL_3 rc=%d\n", rc);
-
-	if (reg & CHG_USB_SUSPEND_BIT)
-		return IRQ_HANDLED;
-	schedule_work(&chip->unplug_ovp_fet_open_work);
 
 	return IRQ_HANDLED;
 }
@@ -4353,7 +4349,8 @@
 
 	pr_info("V=%d mV, I=%d mA, T=%d C, SoC=%d%%, FCC=%d, id=%d mV,"
 			" H=%d, P=%d, CHG=%d, S=%d, FSM=%d, AC=%d, USB=%d, DC=%d, WLC=%d"
-			" iusb_ma=%d, usb_target_ma=%d, OVP=%d, UVP=%d, TM=%d, eoc_count=%d,"
+			" iusb_ma=%d, usb_target_ma=%d, OVP=%d, UVP=%d, TM=%d,"
+			" eoc_count/by_curr=%d/%d,"
 			" vbatdet_low=%d, is_ac_ST=%d, batfet_dis=0x%x, pwrsrc_dis=0x%x,"
 			" is_full=%d, temp_fault=%d, is_bat_warm/cool=%d/%d,"
 			" btm_warm/cool=%d/%d, ichg=%d uA, vph_pwr=%d uV, usbin=%d uV,"
@@ -4363,8 +4360,8 @@
 			health, present, charger_type, status, fsm,
 			ac_online, usb_online, dc_online, !is_wlc_remove,
 			iusb_ma, usb_target_ma, ovp, uvp, thermal_mitigation, eoc_count,
-			vbatdet_low, is_ac_safety_timeout, batt_charging_disabled,
-			pwrsrc_disabled, is_batt_full,
+			eoc_count_by_curr, vbatdet_low, is_ac_safety_timeout,
+			batt_charging_disabled, pwrsrc_disabled, is_batt_full,
 			temp_fault, the_chip->is_bat_warm, the_chip->is_bat_cool,
 			pm8xxx_adc_btm_is_warm(), pm8xxx_adc_btm_is_cool(), ichg, vph_pwr,
 			usbin, dcin, pwrsrc_under_rating, usbin_critical_low_cnt,
@@ -4567,12 +4564,15 @@
 		}
 
 		
-		rc = pm_chg_iterm_get(chip, &iterm_programmed);
+		if (chip->term_current <= PM8921_CHG_ITERM_MAX_MA) {
+			rc = pm_chg_iterm_get(chip, &iterm_programmed);
 
-		if (rc) {
-			pr_err("couldnt read iterm rc = %d\n", rc);
-			return CHG_IN_PROGRESS;
-		}
+			if (rc) {
+				pr_err("couldnt read iterm rc = %d\n", rc);
+				return CHG_IN_PROGRESS;
+			}
+		} else
+			iterm_programmed = chip->term_current;
 
 		ichg_meas_ma = (get_prop_batt_current(chip)) / 1000;
 		pr_debug("iterm_programmed = %d ichg_meas_ma=%d\n",
@@ -4593,11 +4593,14 @@
 
 
 	
-	rc = pm_chg_iterm_get(chip, &iterm_programmed);
-	if (rc) {
-		pr_err("couldnt read iterm rc = %d\n", rc);
-		return CHG_IN_PROGRESS;
-	}
+	if (chip->term_current <= PM8921_CHG_ITERM_MAX_MA) {
+		rc = pm_chg_iterm_get(chip, &iterm_programmed);
+		if (rc) {
+			pr_err("couldnt read iterm rc = %d\n", rc);
+			return CHG_IN_PROGRESS;
+		}
+	} else
+		iterm_programmed = chip->term_current;
 
 	ichg_meas_ma = (get_prop_batt_current(chip)) / 1000;
 	pr_debug("iterm_programmed = %d ichg_meas_ma=%d\n",
@@ -4693,13 +4696,14 @@
 					&rconn_mohm, 0644);
 #define CONSECUTIVE_COUNT	3
 #define EOC_STOP_CHG_COUNT	(CONSECUTIVE_COUNT + 180)
+#define EOC_STOP_CHG_BY_CURR_COUNT	(CONSECUTIVE_COUNT)
 #define CLEAR_FULL_STATE_BY_LEVEL_THR		90
 static void eoc_worker(struct work_struct *work)
 {
 	struct delayed_work *dwork = to_delayed_work(work);
 	struct pm8921_chg_chip *chip = container_of(dwork,
 				struct pm8921_chg_chip, eoc_work);
-	int end, soc = 0;
+	int end, soc = 0, ichg_meas_ma = 0;
 
 	if (!is_ac_safety_timeout)
 		pm_chg_failed_clear(chip, 1);
@@ -4710,7 +4714,7 @@
 		pr_info("%s: End due to fast_chg=%d\n",
 				__func__, pm_chg_get_rt_status(chip, FASTCHG_IRQ));
 		is_batt_full = false;
-		eoc_count = 0;
+		eoc_count = eoc_count_by_curr = 0;
 		is_ac_safety_timeout_twice = false;
 		if (!flag_disable_wakelock)
 			wake_unlock(&chip->eoc_wake_lock);
@@ -4726,12 +4730,21 @@
 
 	if (end == CHG_FINISHED) {
 		eoc_count++;
+		if (chip->eoc_ibat_thre_ma && (eoc_count > CONSECUTIVE_COUNT)) {
+			ichg_meas_ma = (get_prop_batt_current(chip)) / 1000;
+			if (ichg_meas_ma * -1 < chip->eoc_ibat_thre_ma)
+				eoc_count_by_curr++;
+			else
+				eoc_count_by_curr = 0;
+		}
 	} else {
-		eoc_count = 0;
+		eoc_count = eoc_count_by_curr = 0;
 	}
 
-	if (EOC_STOP_CHG_COUNT == eoc_count) {
-		eoc_count = 0;
+	if ((!chip->eoc_ibat_thre_ma && (EOC_STOP_CHG_COUNT == eoc_count)) ||
+			(chip->eoc_ibat_thre_ma &&
+				(EOC_STOP_CHG_BY_CURR_COUNT == eoc_count_by_curr))) {
+		eoc_count = eoc_count_by_curr = 0;
 		is_ac_safety_timeout_twice = false;
 
 		if (is_ext_charging(chip))
@@ -4788,7 +4801,7 @@
 		soc = get_prop_batt_capacity(chip);
 		if (soc < CLEAR_FULL_STATE_BY_LEVEL_THR) {
 			is_batt_full = false;
-			eoc_count = 0;
+			eoc_count = eoc_count_by_curr = 0;
 			pr_info("%s: Clear is_batt_full & eoc_count due to"
 						" Overloading happened, soc=%d\n",
 						__func__, soc);
@@ -5471,11 +5484,13 @@
 		return rc;
 	}
 
-	rc = pm_chg_iterm_set(chip, chip->term_current);
-	if (rc) {
-		pr_err("Failed to set term current to %d rc=%d\n",
-						chip->term_current, rc);
-		return rc;
+	if (chip->term_current <= PM8921_CHG_ITERM_MAX_MA) {
+		rc = pm_chg_iterm_set(chip, chip->term_current);
+		if (rc) {
+			pr_err("Failed to set term current to %d rc=%d\n",
+							chip->term_current, rc);
+			return rc;
+		}
 	}
 
 	
@@ -6123,6 +6138,9 @@
 	chip->dev = &pdev->dev;
 	chip->safety_time = pdata->safety_time;
 	chip->ttrkl_time = pdata->ttrkl_time;
+	chip->ichg_threshold_ua = pdata->ichg_threshold_ua;
+	chip->ichg_regulation_thr_ua
+		= pdata->ichg_regulation_thr_ua;
 	chip->update_time = pdata->update_time;
 	
 	chg_batt_param = htc_battery_cell_get_cur_cell_charger_cdata();
@@ -6173,6 +6191,7 @@
 	else
 		chip->wlc_tx_gpio = 0;
 	chip->is_embeded_batt = pdata->is_embeded_batt;
+	chip->eoc_ibat_thre_ma = pdata->eoc_ibat_thre_ma;
 	chip->cold_thr = pdata->cold_thr;
 	chip->hot_thr = pdata->hot_thr;
 	chip->rconn_mohm = pdata->rconn_mohm;
@@ -6203,8 +6222,6 @@
 	INIT_DELAYED_WORK(&chip->recharge_check_work, recharge_check_worker);
 	INIT_DELAYED_WORK(&chip->vin_collapse_check_work,
 						vin_collapse_check_worker);
-	INIT_WORK(&chip->unplug_ovp_fet_open_work,
-					unplug_ovp_fet_open_worker);
 	INIT_DELAYED_WORK(&chip->unplug_check_work, unplug_check_worker);
 
 	INIT_DELAYED_WORK(&ext_usb_vbat_low_task, ext_usb_vbatdet_irq_handler);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/rtc/alarm.c monarudo-jb-3.4.10-e22f38b/drivers/rtc/alarm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/rtc/alarm.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/rtc/alarm.c	2013-08-01 23:38:02.000000000 -0600
@@ -250,13 +250,13 @@
 		alarms[i].stopped = true;
 		alarms[i].stopped_time = timespec_to_ktime(tmp_time);
 	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	ret = do_settimeofday(&new_time);
+	spin_lock_irqsave(&alarm_slock, flags);
 	alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP].delta =
 		alarms[ANDROID_ALARM_ELAPSED_REALTIME].delta =
 		ktime_sub(alarms[ANDROID_ALARM_ELAPSED_REALTIME].delta,
 			timespec_to_ktime(timespec_sub(tmp_time, new_time)));
-	spin_unlock_irqrestore(&alarm_slock, flags);
-	ret = do_settimeofday(&new_time);
-	spin_lock_irqsave(&alarm_slock, flags);
 	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
 		alarms[i].stopped = false;
 		update_timer_locked(&alarms[i], false);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/scsi/scsi_wait_scan.c monarudo-jb-3.4.10-e22f38b/drivers/scsi/scsi_wait_scan.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/scsi/scsi_wait_scan.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/scsi/scsi_wait_scan.c	2012-08-26 16:02:10.000000000 -0600
@@ -16,7 +16,16 @@
 
 static int __init wait_scan_init(void)
 {
+	/*
+	 * First we need to wait for device probing to finish;
+	 * the drivers we just loaded might just still be probing
+	 * and might not yet have reached the scsi async scanning
+	 */
 	wait_for_device_probe();
+	/*
+	 * and then we wait for the actual asynchronous scsi scan
+	 * to finish.
+	 */
 	scsi_complete_async_scans();
 	return 0;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/slimbus/slim-msm-ctrl.c monarudo-jb-3.4.10-e22f38b/drivers/slimbus/slim-msm-ctrl.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/slimbus/slim-msm-ctrl.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/slimbus/slim-msm-ctrl.c	2013-08-01 23:38:03.000000000 -0600
@@ -742,7 +742,10 @@
 	if (txn->mt == SLIM_MSG_MT_CORE &&
 		mc == SLIM_MSG_MC_BEGIN_RECONFIGURATION) {
 		if (dev->reconf_busy) {
-			wait_for_completion(&dev->reconf);
+			pr_err("Start to wait for completion\n");
+			timeout = wait_for_completion_timeout(&dev->reconf,msecs_to_jiffies(300));
+			if (!timeout)
+				pr_err("Timeout while sending BEGIN_RECONFIGURATION");
 			dev->reconf_busy = false;
 		}
 		
@@ -822,8 +825,11 @@
 	dev->wr_comp = &done;
 	msm_send_msg_buf(ctrl, pbuf, txn->rl);
 	timeout = wait_for_completion_timeout(&done, HZ);
-	if (!timeout)
+	if (!timeout) {
 		dev->wr_comp = NULL;
+		if ( mc >= SLIM_MSG_MC_BEGIN_RECONFIGURATION && mc <= SLIM_MSG_MC_RECONFIGURE_NOW )
+			dev->reconf_busy = false;
+	}
 	if (mc == SLIM_MSG_MC_RECONFIGURE_NOW) {
 		if ((txn->mc == (SLIM_MSG_MC_RECONFIGURE_NOW |
 					SLIM_MSG_CLK_PAUSE_SEQ_FLG)) &&
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/staging/android/binder.c monarudo-jb-3.4.10-e22f38b/drivers/staging/android/binder.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/staging/android/binder.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/staging/android/binder.c	2013-08-01 23:38:03.000000000 -0600
@@ -33,6 +33,7 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/security.h>
 
 #include "binder.h"
 
@@ -1461,6 +1462,10 @@
 			brdr_fp=0x33;
 			goto err_dead_binder;
 		}
+		if (security_binder_transaction(proc->tsk, target_proc->tsk) < 0) {
+			return_error = BR_FAILED_REPLY;
+			goto err_invalid_target_handle;
+		}
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
 			tmp = thread->transaction_stack;
@@ -1610,6 +1615,10 @@
 					fp->cookie, node->cookie);
 				goto err_binder_get_ref_for_node_failed;
 			}
+			if (security_binder_transfer_binder(proc->tsk, target_proc->tsk)) {
+				return_error = BR_FAILED_REPLY;
+				goto err_binder_get_ref_for_node_failed;
+			}
 			ref = binder_get_ref_for_node(target_proc, node);
 			if (ref == NULL) {
 				return_error = BR_FAILED_REPLY;
@@ -1640,6 +1649,10 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_binder_get_ref_failed;
 			}
+			if (security_binder_transfer_binder(proc->tsk, target_proc->tsk)) {
+				return_error = BR_FAILED_REPLY;
+				goto err_binder_get_ref_failed;
+			}
 			if (ref->node->proc == target_proc) {
 				if (fp->type == BINDER_TYPE_HANDLE)
 					fp->type = BINDER_TYPE_BINDER;
@@ -1694,6 +1707,11 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_fget_failed;
 			}
+			if (security_binder_transfer_file(proc->tsk, target_proc->tsk, file) < 0) {
+				fput(file);
+				return_error = BR_FAILED_REPLY;
+				goto err_get_unused_fd_failed;
+			}
 			target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);
 			if (target_fd < 0) {
 				fput(file);
@@ -2724,6 +2742,9 @@
 			ret = -EBUSY;
 			goto err;
 		}
+		ret = security_binder_set_context_mgr(proc->tsk);
+		if (ret < 0)
+			goto err;
 		if (binder_context_mgr_uid != -1) {
 			if (binder_context_mgr_uid != current->cred->euid) {
 				printk(KERN_INFO "binder: BINDER_SET_"
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/staging/android/lowmemorykiller.c monarudo-jb-3.4.10-e22f38b/drivers/staging/android/lowmemorykiller.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/staging/android/lowmemorykiller.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/staging/android/lowmemorykiller.c	2013-08-01 23:38:03.000000000 -0600
@@ -37,6 +37,16 @@
 #include <linux/sched.h>
 #include <linux/rcupdate.h>
 #include <linux/notifier.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/swap.h>
+
+#ifdef CONFIG_HIGHMEM
+	#define _ZONE ZONE_HIGHMEM
+#else
+	#define _ZONE ZONE_NORMAL
+#endif
+
 
 extern void show_meminfo(void);
 static uint32_t lowmem_debug_level = 2;
@@ -68,7 +78,9 @@
 
 static unsigned long lowmem_deathpending_timeout;
 static unsigned long lowmem_fork_boost_timeout;
-static uint32_t lowmem_fork_boost = 1;
+static uint32_t lowmem_fork_boost = 0;
+static uint32_t lowmem_sleep_ms = 1;
+static uint32_t lowmem_only_kswapd_sleep = 1;
 
 #define lowmem_print(level, x...)			\
 	do {						\
@@ -127,6 +139,8 @@
 	}
 }
 
+static DEFINE_MUTEX(scan_mutex);
+
 static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 {
 	struct task_struct *tsk;
@@ -139,11 +153,35 @@
 	int selected_oom_score_adj;
 	int selected_oom_adj = 0;
 	int array_size = ARRAY_SIZE(lowmem_adj);
-	int other_free = global_page_state(NR_FREE_PAGES);
-	int other_file = global_page_state(NR_FILE_PAGES) -
-		global_page_state(NR_SHMEM) - global_page_state(NR_MLOCK);
+	int other_free;
+	int other_file;
+	int reserved_free = 0;
+	unsigned long nr_to_scan = sc->nr_to_scan;
 	int fork_boost = 0;
 	size_t *min_array;
+	struct zone *zone;
+
+	if (nr_to_scan > 0) {
+		if (!mutex_trylock(&scan_mutex)) {
+			if (!(lowmem_only_kswapd_sleep && !current_is_kswapd())) {
+				msleep_interruptible(lowmem_sleep_ms);
+			}
+			return 0;
+		}
+	}
+
+	for_each_zone(zone)
+	{
+		if(is_normal(zone))
+		{
+			reserved_free = zone->watermark[WMARK_MIN] + zone->lowmem_reserve[_ZONE];
+			break;
+		}
+	}
+
+	other_free = global_page_state(NR_FREE_PAGES);
+	other_file = global_page_state(NR_FILE_PAGES) -
+		global_page_state(NR_SHMEM) - global_page_state(NR_MLOCK) ;
 
 	if (lowmem_fork_boost &&
 		time_before_eq(jiffies, lowmem_fork_boost_timeout)) {
@@ -160,7 +198,7 @@
 		array_size = lowmem_minfree_size;
 
 	for (i = 0; i < array_size; i++) {
-		if (other_free < min_array[i] &&
+		if ((other_free - reserved_free) < min_array[i] &&
 		    other_file < min_array[i]) {
 			min_score_adj = lowmem_adj[i];
 			fork_boost = lowmem_fork_boost_minfree[i];
@@ -168,17 +206,21 @@
 		}
 	}
 
-	if (sc->nr_to_scan > 0)
-		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %d\n",
-				sc->nr_to_scan, sc->gfp_mask, other_free,
-				other_file, min_score_adj);
+	if (nr_to_scan > 0)
+		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %d, rfree %d\n",
+				nr_to_scan, sc->gfp_mask, other_free,
+				other_file, min_score_adj, reserved_free);
 	rem = global_page_state(NR_ACTIVE_ANON) +
 		global_page_state(NR_ACTIVE_FILE) +
 		global_page_state(NR_INACTIVE_ANON) +
 		global_page_state(NR_INACTIVE_FILE);
-	if (sc->nr_to_scan <= 0 || min_score_adj == OOM_SCORE_ADJ_MAX + 1) {
+	if (nr_to_scan <= 0 || min_score_adj == OOM_SCORE_ADJ_MAX + 1) {
 		lowmem_print(5, "lowmem_shrink %lu, %x, return %d\n",
-			     sc->nr_to_scan, sc->gfp_mask, rem);
+			     nr_to_scan, sc->gfp_mask, rem);
+
+		if (nr_to_scan > 0)
+			mutex_unlock(&scan_mutex);
+
 		return rem;
 	}
 	selected_oom_score_adj = min_score_adj;
@@ -194,6 +236,11 @@
 		if (time_before_eq(jiffies, lowmem_deathpending_timeout)) {
 			if (test_task_flag(tsk, TIF_MEMDIE)) {
 				rcu_read_unlock();
+				
+				if (!(lowmem_only_kswapd_sleep && !current_is_kswapd())) {
+					msleep_interruptible(lowmem_sleep_ms);
+				}
+				mutex_unlock(&scan_mutex);
 				return 0;
 			}
 		}
@@ -227,11 +274,12 @@
 	}
 	if (selected) {
 		lowmem_print(1, "[%s] send sigkill to %d (%s), oom_adj %d, score_adj %d,"
-			" min_score_adj %d, size %dK, free %dK, file %dK, fork_boost %dK\n",
+			" min_score_adj %d, size %dK, free %dK, file %dK, fork_boost %dK,"
+			" reserved_free %dK\n",
 			     current->comm, selected->pid, selected->comm,
 			     selected_oom_adj, selected_oom_score_adj,
 			     min_score_adj, selected_tasksize << 2,
-			     other_free << 2, other_file << 2, fork_boost << 2);
+			     other_free << 2, other_file << 2, fork_boost << 2, reserved_free << 2);
 		lowmem_deathpending_timeout = jiffies + HZ;
 		if (selected_oom_adj < 7)
 		{
@@ -241,10 +289,18 @@
 		send_sig(SIGKILL, selected, 0);
 		set_tsk_thread_flag(selected, TIF_MEMDIE);
 		rem -= selected_tasksize;
+		rcu_read_unlock();
+		
+		if (!(lowmem_only_kswapd_sleep && !current_is_kswapd())) {
+			msleep_interruptible(lowmem_sleep_ms);
+		}
 	}
+	else
+		rcu_read_unlock();
+
 	lowmem_print(4, "lowmem_shrink %lu, %x, return %d\n",
 		     sc->nr_to_scan, sc->gfp_mask, rem);
-	rcu_read_unlock();
+	mutex_unlock(&scan_mutex);
 	return rem;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/thermal/thermal_sys.c monarudo-jb-3.4.10-e22f38b/drivers/thermal/thermal_sys.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/thermal/thermal_sys.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/thermal/thermal_sys.c	2013-08-01 23:38:02.000000000 -0600
@@ -868,13 +868,13 @@
 	if (result)
 		goto free_mem;
 
-	sprintf(dev->name, "cdev%d", dev->id);
+	snprintf(dev->name, sizeof(dev->name), "cdev%d", dev->id);
 	result =
 	    sysfs_create_link(&tz->device.kobj, &cdev->device.kobj, dev->name);
 	if (result)
 		goto release_idr;
 
-	sprintf(dev->attr_name, "cdev%d_trip_point", dev->id);
+	snprintf(dev->attr_name, sizeof(dev->attr_name), "cdev%d_trip_point", dev->id);
 	sysfs_attr_init(&dev->attr.attr);
 	dev->attr.attr.name = dev->attr_name;
 	dev->attr.attr.mode = 0444;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -1030,6 +1030,13 @@
 	help
 	  Select this module to enable MSM high speed UART driver.
 
+config SERIAL_MSM_HS_DEBUG_RINGBUFFER
+	bool "Capture UART raw data in a ringbuffer for debug purpose."
+	depends on SERIAL_MSM_HS
+	default n
+	help
+	  Capture UART raw data in a ringbuffer for debug purpose.
+
 config SERIAL_IRDA
 	tristate "MSM UART High Speed : Legacy mode IRDA Driver"
 	depends on ARM && ARCH_MSM
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs_brcm.c monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs_brcm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs_brcm.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs_brcm.c	2013-08-01 23:38:01.000000000 -0600
@@ -2220,8 +2220,16 @@
 static void msm_hs_shutdown(struct uart_port *uport)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+	unsigned long flags; 
 
 	printk(KERN_INFO "[BT]=+ S DN +=\n");
+
+	
+	spin_lock_irqsave(&uport->lock, flags);
+	if (use_low_power_wakeup(msm_uport))
+		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
+	spin_unlock_irqrestore(&uport->lock, flags);
+
 	BUG_ON(msm_uport->rx.flush < FLUSH_STOP);
 	tasklet_kill(&msm_uport->tx.tlet);
 #if 1 
@@ -2251,10 +2259,6 @@
 	wake_lock_timeout(&msm_uport->rx.brcm_rx_wake_lock, HZ / 2);
 	
 	wake_lock_timeout(&msm_uport->rx.wake_lock, HZ / 10);
-
-	
-	if (use_low_power_wakeup(msm_uport))
-		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
 #endif
 
 	msm_uport->imr_reg = 0;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs.c monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs.c	2013-08-01 23:38:01.000000000 -0600
@@ -54,6 +54,7 @@
 #include <linux/device.h>
 #include <linux/wakelock.h>
 #include <linux/debugfs.h>
+#include <linux/delay.h>
 #include <asm/atomic.h>
 #include <asm/irq.h>
 
@@ -179,10 +180,221 @@
 static struct platform_driver msm_serial_hs_platform_driver;
 static struct uart_driver msm_hs_driver;
 static struct uart_ops msm_hs_ops;
+static void msm_hs_dump_register(struct uart_port *port);
 
 #define UARTDM_TO_MSM(uart_port) \
 	container_of((uart_port), struct msm_hs_port, uport)
 
+#ifdef CONFIG_QSC_MODEM
+#include <mach/gpiomux.h>
+#define MSM_SERIAL_QSC_HS_ID 1
+#define UART_RX_GPIO 19
+#define UART_RFR_GPIO 21
+#define UART_CTS_GPIO 20
+static inline void read_uart_gpio_mux(void);
+#endif
+
+#ifdef CONFIG_SERIAL_MSM_HS_DEBUG_RINGBUFFER
+#define RING_SIZE (1<<20)
+#define RING_INDEX(x) ((x) & (RING_SIZE-1))
+#define SINGLE_LENGTH 512
+#define DUMP_SIZE (1<<14) 
+
+struct RingBuffer
+{
+	char   raw[RING_SIZE];
+	size_t head;
+	spinlock_t lock;
+};
+
+static struct RingBuffer DbgBuf;
+
+static inline void memcpy_DbgBuffer( void *HexRaw, int size )
+{
+	unsigned long flags;
+	char *raw;
+	int head;
+
+	spin_lock_irqsave(&DbgBuf.lock, flags);
+
+	raw = DbgBuf.raw;
+	head = DbgBuf.head;
+
+	if(head+size > RING_SIZE)
+	{
+		int size1, size2;
+		size1 = RING_SIZE-head;
+		size2 = size-size1;
+		memcpy( raw+head, HexRaw, size1 );
+		memcpy( raw, HexRaw+size1, size2 );
+	}
+	else
+	{
+		memcpy( raw+head, HexRaw, size );
+	}
+
+	DbgBuf.head = RING_INDEX(head+size);
+
+	spin_unlock_irqrestore(&DbgBuf.lock, flags);
+}
+
+static inline int print_raw(char *dest, char *raw, int size)
+{
+	char *start = dest;
+
+	if( size < 0 )
+		return 0;
+
+	while( size-- > 0 )
+		dest += sprintf(dest, "%02x ", *(raw++));
+
+	dest += sprintf(dest, "\n");
+	return dest - start;
+}
+
+void DbgBuffer_printRaw( void *raw, int size, const char* msg)
+{
+	char tmp[SINGLE_LENGTH];
+	char *cur = tmp;
+
+	
+	unsigned long long t;
+	unsigned long nanosec_rem;
+
+	t = cpu_clock(smp_processor_id());
+	nanosec_rem = do_div(t, 1000000000);
+	cur += sprintf( cur, "[%5lu.%06lu][%s]<%d>", (unsigned long) t, nanosec_rem / 1000,
+				  msg ? msg : "", size);
+
+	if( size < 128 )
+		cur += print_raw(cur, raw, size);
+	else
+		cur += sprintf(cur, "Raw_Data_OverSize\n");
+
+	*cur = '\0';
+	cur++;
+
+	memcpy_DbgBuffer( tmp, cur - tmp );
+}
+EXPORT_SYMBOL(DbgBuffer_printRaw);
+
+void DbgBuffer_printLog( const char * fmt, ...)
+{
+	
+	unsigned long long t;
+	unsigned long nanosec_rem;
+	char tmp[SINGLE_LENGTH];
+	char *cur = tmp;
+	va_list args;
+
+	t = cpu_clock(smp_processor_id());
+	nanosec_rem = do_div(t, 1000000000);
+
+	cur += sprintf( cur, "[%5lu.%06lu] ", (unsigned long) t, nanosec_rem / 1000 );
+
+	va_start(args, fmt);
+	cur += vsnprintf(cur, tmp+SINGLE_LENGTH-cur, fmt, args);
+	va_end(args);
+
+	
+	cur++;
+
+	if(unlikely(cur-tmp > SINGLE_LENGTH))
+		memcpy_DbgBuffer( tmp, SINGLE_LENGTH );
+	else
+		memcpy_DbgBuffer( tmp, cur - tmp );
+}
+EXPORT_SYMBOL(DbgBuffer_printLog);
+
+#ifdef CONFIG_QSC_MODEM
+static inline void read_uart_gpio_mux(void)
+{
+	unsigned rx, rfr, cts;
+	rx = msm_gpiomux_read(UART_RX_GPIO);
+	rfr = msm_gpiomux_read(UART_RFR_GPIO);
+	cts = msm_gpiomux_read(UART_CTS_GPIO);
+
+	DbgBuffer_printLog("%s: RX<0x%x> RFR<0x%x> CTS<0x%x>\n", __func__, rx, rfr, cts);
+}
+#endif
+
+void dump_uart_ringbuffer(void)
+{
+	int printed, next_start;
+	char *raw;
+	unsigned long flags;
+	int dump_size = RING_SIZE > DUMP_SIZE ? DUMP_SIZE : RING_SIZE;
+
+#ifdef CONFIG_QSC_MODEM
+	struct msm_hs_port *msm_uport = &q_uart_port[MSM_SERIAL_QSC_HS_ID];
+	msm_hs_dump_register(&msm_uport->uport);
+#endif
+
+	spin_lock_irqsave(&DbgBuf.lock, flags);
+	if( DbgBuf.raw[RING_INDEX(DbgBuf.head-1)] != '\0' )
+	{
+		spin_unlock_irqrestore(&DbgBuf.lock, flags);
+		printk(KERN_ERR "%s: RingBuffer is not correct.\n", __func__);
+		return;
+	}
+
+	raw = kmalloc(RING_SIZE, GFP_KERNEL);
+	if(!raw)
+	{
+		spin_unlock_irqrestore(&DbgBuf.lock, flags);
+		printk(KERN_ERR "%s: tmp buffer couldn't be allocated.\n", __func__);
+		return;
+	}
+	memcpy(raw, DbgBuf.raw + DbgBuf.head, RING_SIZE-DbgBuf.head);
+	memcpy(raw+RING_SIZE-DbgBuf.head, DbgBuf.raw, DbgBuf.head);
+	spin_unlock_irqrestore(&DbgBuf.lock, flags);
+
+	printed =  0;
+	next_start = RING_SIZE - dump_size;
+
+	printk(KERN_INFO "UART Debug Ringbuffer:\n");
+	while( printed < RING_SIZE )
+	{
+		while( raw[next_start++] != '\0' ) {}
+
+		
+		if(printed == 0)
+		{
+			printed = next_start;
+			continue;
+		}
+
+		printk(KERN_INFO "%s", raw + printed);
+		printed = next_start;
+	}
+
+	kfree(raw);
+}
+EXPORT_SYMBOL(dump_uart_ringbuffer);
+#else
+void dump_uart_ringbuffer(void)
+{ return; }
+void DbgBuffer_printRaw( void *raw, int size, const char* msg)
+{ return; }
+void DbgBuffer_printLog( const char * fmt, ...)
+{ return; }
+#endif
+
+static ssize_t show_reg(struct device *dev, struct device_attribute *attr,
+             char *buf)
+{
+   unsigned long flags;
+   struct platform_device *pdev = container_of(dev, struct
+                           platform_device, dev);
+   struct msm_hs_port *msm_uport = &q_uart_port[pdev->id];
+
+   spin_lock_irqsave(&msm_uport->uport.lock, flags);
+   msm_hs_dump_register(&msm_uport->uport);
+   spin_unlock_irqrestore(&msm_uport->uport.lock, flags);
+   dump_uart_ringbuffer();
+   return 1;
+}
+
 static ssize_t show_clock(struct device *dev, struct device_attribute *attr,
 			  char *buf)
 {
@@ -230,6 +442,7 @@
 }
 
 static DEVICE_ATTR(clock, S_IWUSR | S_IRUGO, show_clock, set_clock);
+static DEVICE_ATTR(reg, S_IRUGO, show_reg, NULL);
 
 static inline unsigned int use_low_power_wakeup(struct msm_hs_port *msm_uport)
 {
@@ -254,6 +467,37 @@
 	writel_relaxed(value, uport->membase + offset);
 }
 
+static void msm_hs_dump_register(struct uart_port *uport)
+{
+	unsigned int mr1,mr2,rfwr,dmen,sr,txfs,rxfs,misr,isr,dmrx,ipr,rx_count;
+	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+
+	mr1 = msm_hs_read(uport, UARTDM_MR1_ADDR);
+	mr2 = msm_hs_read(uport, UARTDM_MR2_ADDR);
+	rfwr = msm_hs_read(uport, UARTDM_RFWR_ADDR);
+	dmen= msm_hs_read(uport, UARTDM_DMEN_ADDR);
+	sr = msm_hs_read(uport, UARTDM_SR_ADDR);
+
+	txfs = msm_hs_read(uport, UARTDM_TXFS_ADDR);
+	rxfs =  msm_hs_read(uport, UARTDM_RXFS_ADDR);
+	misr = msm_hs_read(uport, UARTDM_MISR_ADDR);
+	isr = msm_hs_read(uport, UARTDM_ISR_ADDR);
+	dmrx =msm_hs_read(uport, UARTDM_DMRX_ADDR);
+	ipr = msm_hs_read(uport, UARTDM_IPR_ADDR);
+	rx_count = msm_hs_read(uport, UARTDM_RX_TOTAL_SNAP_ADDR);
+
+	DbgBuffer_printLog("%s(): clk_state:0x%x clk_req_off_state:0x%x rx.flush:%u MR1:0x%x, MR2:0x%x, RFWR:0x%x, DMEN:0x%x, SR:0x%x, TXFS:0x%x, RXFS:0x%x, MISR:0x%x, ISR:0x%x, DMRX:0x%x, SNAP:0x%x, IPR:0x%x\n",
+					__func__, msm_uport->clk_state, msm_uport->clk_req_off_state, msm_uport->rx.flush,
+					mr1,mr2,rfwr,dmen,sr,txfs,rxfs,misr,isr,dmrx,rx_count,ipr);
+
+#ifdef CONFIG_QSC_MODEM
+	if (uport->line == MSM_SERIAL_QSC_HS_ID){
+		read_uart_gpio_mux();
+	}
+#endif
+
+}
+
 static void msm_hs_release_port(struct uart_port *port)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(port);
@@ -393,6 +637,7 @@
 	dev = msm_uport->uport.dev;
 
 	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_clock.attr);
+	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_reg.attr);
 	debugfs_remove(msm_uport->loopback_dir);
 
 	dma_unmap_single(dev, msm_uport->rx.mapped_cmd_ptr, sizeof(dmov_box),
@@ -515,8 +760,19 @@
 		rxstale = 1;
 		break;
 	case 9600:
+#ifdef CONFIG_QSC_MODEM
+		if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1")){
+			pr_info("%s: set CSR as 0xff.\n", __func__);
+			msm_hs_write(uport, UARTDM_CSR_ADDR, 0xff);
+			rxstale = 31;
+		}else{
+			msm_hs_write(uport, UARTDM_CSR_ADDR, 0x55);
+			rxstale = 2;
+		}
+#else
 		msm_hs_write(uport, UARTDM_CSR_ADDR, 0x55);
 		rxstale = 2;
+#endif
 		break;
 	case 14400:
 		msm_hs_write(uport, UARTDM_CSR_ADDR, 0x66);
@@ -575,11 +831,24 @@
 		break;
 	}
 	mb();
+#ifdef CONFIG_QSC_MODEM
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1")){
+		pr_info("%s: set 4Mbps as default baud rate for gsbi1.\n", __func__);
+	}else{
+		pr_info("%s: set uart clk by checking bps.\n", __func__);
+		if (bps > 460800) {
+			uport->uartclk = bps * 16;
+		} else {
+			uport->uartclk = 7372800;
+		}
+	}
+#else
 	if (bps > 460800) {
 		uport->uartclk = bps * 16;
 	} else {
 		uport->uartclk = 7372800;
 	}
+#endif
 	spin_unlock_irqrestore(&uport->lock, flags);
 	if (clk_set_rate(msm_uport->clk, uport->uartclk)) {
 		printk(KERN_WARNING "Error setting clock rate on UART\n");
@@ -587,6 +856,12 @@
 		spin_lock_irqsave(&uport->lock, flags);
 		return flags;
 	}
+#ifdef CONFIG_QSC_MODEM
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1")){
+		pr_info("%s: delay 5ms while baud rate is changing.\n", __func__);
+		mdelay(5);
+	}
+#endif
 
 	spin_lock_irqsave(&uport->lock, flags);
 	data = rxstale & UARTDM_IPR_STALE_LSB_BMSK;
@@ -660,14 +935,21 @@
 
 	mutex_lock(&msm_uport->clk_mutex);
 	spin_lock_irqsave(&uport->lock, flags);
-
+#ifdef CONFIG_QSC_MODEM
+	
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1")){
+		pr_info("%s: Set RFR high so remote uart does not send any data.\n", __func__);
+		msm_hs_write(uport, UARTDM_CR_ADDR, RFR_HIGH);
+	}
+#endif
+	
+	msm_hs_write(uport, UARTDM_IMR_ADDR, 0);
 	data = msm_hs_read(uport, UARTDM_DMEN_ADDR);
 	data &= ~UARTDM_RX_DM_EN_BMSK;
 	msm_hs_write(uport, UARTDM_DMEN_ADDR, data);
 
 	
 	bps = uart_get_baud_rate(uport, termios, oldtermios, 200, 4000000);
-
 	
 	if (bps == 200)
 		bps = 3200000;
@@ -735,8 +1017,6 @@
 	uport->ignore_status_mask |= termios->c_iflag & IGNPAR;
 	uport->read_status_mask = (termios->c_cflag & CREAD);
 
-	msm_hs_write(uport, UARTDM_IMR_ADDR, 0);
-
 	
 	uart_update_timeout(uport, c_cflag, bps);
 
@@ -748,10 +1028,19 @@
 		msm_uport->rx.flush = FLUSH_IGNORE;
 		mb();
 		
+		DbgBuffer_printLog("%s: Issue Discard flush\n", __func__);
 		msm_dmov_flush(msm_uport->dma_rx_channel, 0);
 	}
 
+	
 	msm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);
+#ifdef CONFIG_QSC_MODEM
+	
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1")){
+		pr_info("%s: Set RFR low so remote uart can send data.\n", __func__);
+		msm_hs_write(uport, UARTDM_CR_ADDR, RFR_LOW);
+	}
+#endif
 	mb();
 	spin_unlock_irqrestore(&uport->lock, flags);
 	mutex_unlock(&msm_uport->clk_mutex);
@@ -792,6 +1081,7 @@
 	
 	if (msm_uport->rx.flush == FLUSH_NONE) {
 		wake_lock(&msm_uport->rx.wake_lock);
+		DbgBuffer_printLog("%s: Issue discard flush\n", __func__);
 		
 		msm_dmov_flush(msm_uport->dma_rx_channel, 0);
 	}
@@ -843,6 +1133,13 @@
 
 	*tx->command_ptr_ptr = CMD_PTR_LP | DMOV_CMD_ADDR(tx->mapped_cmd_ptr);
 
+#ifdef CONFIG_SERIAL_MSM_HS_DEBUG_RINGBUFFER
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1"))
+	{
+		DbgBuffer_printRaw(&tx_buf->buf[tx_buf->tail], tx_count, "UART_TX");
+	}
+#endif
+
 	
 	tx->tx_count = tx_count;
 	msm_hs_write(uport, UARTDM_NCF_TX_ADDR, tx_count);
@@ -870,6 +1167,7 @@
 		printk(KERN_ERR "Error: rx started in buffer state = %x",
 		       buffer_pending);
 
+	memset(msm_uport->rx.buffer, 0xAA, 512);
 	msm_hs_write(uport, UARTDM_CR_ADDR, RESET_STALE_INT);
 	msm_hs_write(uport, UARTDM_DMRX_ADDR, UARTDM_RX_BUF_SIZE);
 	msm_hs_write(uport, UARTDM_CR_ADDR, STALE_EVENT_ENABLE);
@@ -883,6 +1181,8 @@
 	mb();
 
 	msm_uport->rx.flush = FLUSH_NONE;
+	DbgBuffer_printLog("%s: Queueing Rx Cmd\n", __func__);
+	msm_hs_dump_register(uport);
 	msm_dmov_enqueue_cmd(msm_uport->dma_rx_channel, &msm_uport->rx.xfer);
 
 }
@@ -917,6 +1217,7 @@
 		int rx_count, rx_offset;
 		rx_count = (msm_uport->rx.buffer_pending & 0xFFFF0000) >> 16;
 		rx_offset = (msm_uport->rx.buffer_pending & 0xFFD0) >> 5;
+
 		retval = tty_insert_flip_string(tty, msm_uport->rx.buffer +
 						rx_offset, rx_count);
 		msm_uport->rx.buffer_pending &= (FIFO_OVERRUN |
@@ -949,6 +1250,7 @@
 	unsigned long status;
 	unsigned long flags;
 	unsigned int error_f = 0;
+	unsigned int error_break = 0;
 	struct uart_port *uport;
 	struct msm_hs_port *msm_uport;
 	unsigned int flush;
@@ -979,6 +1281,7 @@
 		status = status & ~(UARTDM_SR_PAR_FRAME_BMSK);
 
 	if (unlikely(status & UARTDM_SR_PAR_FRAME_BMSK)) {
+		DbgBuffer_printLog("%s(): UART PAR_FRAME Error\n", __func__);
 		
 		uport->icount.parity++;
 		error_f = 1;
@@ -989,9 +1292,26 @@
 		}
 	}
 
+	if (unlikely(status & UARTDM_SR_RX_BREAK_BMSK)) {
+		DbgBuffer_printLog("%s(): UART RX BREAK Error\n", __func__);
+		uport->icount.brk++;
+		error_f = 1;
+		error_break = 1;
+		if (!(uport->ignore_status_mask & IGNBRK)) {
+			retval = tty_insert_flip_char(tty, 0, TTY_BREAK);
+			if (!retval)
+				msm_uport->rx.buffer_pending |= TTY_BREAK;
+		}
+	}
+
+	
 	if (error_f)
 		msm_hs_write(uport, UARTDM_CR_ADDR, RESET_ERROR_STATUS);
 
+	
+	if (error_break)
+		msm_hs_write(uport, UARTDM_CR_ADDR, RESET_BREAK_INT);
+
 	if (msm_uport->clk_req_off_state == CLK_REQ_OFF_FLUSH_ISSUED)
 		msm_uport->clk_req_off_state = CLK_REQ_OFF_RXSTALE_FLUSHED;
 	flush = msm_uport->rx.flush;
@@ -1011,6 +1331,13 @@
 	
 	rmb();
 
+#ifdef CONFIG_SERIAL_MSM_HS_DEBUG_RINGBUFFER
+	if (!strcmp(msm_uport->uport.state->port.tty->name,"ttyHS1"))
+	{
+		DbgBuffer_printRaw(msm_uport->rx.buffer, rx_count, "UART_RX");
+	}
+#endif
+
 	if (0 != (uport->read_status_mask & CREAD)) {
 		retval = tty_insert_flip_string(tty, msm_uport->rx.buffer,
 						rx_count);
@@ -1101,6 +1428,7 @@
 
 	msm_uport = container_of(cmd_ptr, struct msm_hs_port, rx.xfer);
 
+	DbgBuffer_printLog("%s: DMOV Rx callback received\n", __func__);
 	tasklet_schedule(&msm_uport->rx.tlet);
 }
 
@@ -1118,6 +1446,9 @@
 	
 	set_rts = TIOCM_RTS & mctrl ? 0 : 1;
 
+	printk(KERN_WARNING "justdebug<smux> %s set_rts<%d>\n", __func__, set_rts);
+	WARN_ON(set_rts);
+
 	data = msm_hs_read(uport, UARTDM_MR1_ADDR);
 	if (set_rts) {
 		
@@ -1267,6 +1598,8 @@
 	if (msm_uport->pclk)
 		clk_disable_unprepare(msm_uport->pclk);
 
+	DbgBuffer_printLog("%s: UART Clock OFF\n", __func__);
+	msm_hs_dump_register(uport);
 	msm_uport->clk_state = MSM_HS_CLK_OFF;
 
 	spin_lock_irqsave(&uport->lock, flags);
@@ -1316,6 +1649,8 @@
 	spin_lock_irqsave(&uport->lock, flags);
 
 	isr_status = msm_hs_read(uport, UARTDM_MISR_ADDR);
+	DbgBuffer_printLog("%s: entry\n", __func__);
+	msm_hs_dump_register(uport);
 
 	
 	if (isr_status & UARTDM_ISR_RXLEV_BMSK) {
@@ -1324,6 +1659,8 @@
 		msm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);
 		
 		mb();
+		DbgBuffer_printLog("%s: UARTDM_ISR_RXLEV_BMSK\n", __func__);
+		msm_hs_dump_register(&msm_uport->uport);
 	}
 	
 	if (isr_status & UARTDM_ISR_RXSTALE_BMSK) {
@@ -1337,6 +1674,7 @@
 
 		if (rx->flush == FLUSH_NONE) {
 			rx->flush = FLUSH_DATA_READY;
+			DbgBuffer_printLog("%s: Issue Graceful Flush\n", __func__);
 			msm_dmov_flush(msm_uport->dma_rx_channel, 1);
 		}
 	}
@@ -1373,6 +1711,8 @@
 		msm_uport->imr_reg &= ~UARTDM_ISR_TXLEV_BMSK;
 		msm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);
 		mb();
+		DbgBuffer_printLog("%s: UARTDM_ISR_TXLEV_BMSK\n", __func__);
+		msm_hs_dump_register(&msm_uport->uport);
 		queue_work(msm_uport->hsuart_wq, &msm_uport->clock_off_w);
 	}
 
@@ -1390,6 +1730,8 @@
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
 
 	spin_lock_irqsave(&uport->lock, flags);
+	DbgBuffer_printLog("%s: entry\n", __func__);
+	msm_hs_dump_register(uport);
 	if (msm_uport->clk_state == MSM_HS_CLK_ON) {
 		msm_uport->clk_state = MSM_HS_CLK_REQUEST_OFF;
 		msm_uport->clk_req_off_state = CLK_REQ_OFF_START;
@@ -1410,6 +1752,8 @@
 
 	mutex_lock(&msm_uport->clk_mutex);
 	spin_lock_irqsave(&uport->lock, flags);
+	DbgBuffer_printLog("%s: entry\n", __func__);
+	msm_hs_dump_register(uport);
 
 	switch (msm_uport->clk_state) {
 	case MSM_HS_CLK_OFF:
@@ -1457,6 +1801,8 @@
 		break;
 	}
 
+	DbgBuffer_printLog("%s: exit\n", __func__);
+	msm_hs_dump_register(uport);
 	spin_unlock_irqrestore(&uport->lock, flags);
 	mutex_unlock(&msm_uport->clk_mutex);
 }
@@ -1471,6 +1817,9 @@
 	struct tty_struct *tty = NULL;
 
 	spin_lock_irqsave(&uport->lock, flags);
+	DbgBuffer_printLog("%s: entry\n", __func__);
+	msm_hs_dump_register(uport);
+
 	if (msm_uport->clk_state == MSM_HS_CLK_OFF)  {
 		if (msm_uport->wakeup.ignore)
 			msm_uport->wakeup.ignore = 0;
@@ -1531,13 +1880,25 @@
 		return ret;
 	}
 
+	
+	msm_hs_write(uport, UARTDM_CR_ADDR, RFR_HIGH);
+
+	data = msm_hs_read(uport, UARTDM_MR2_ADDR);
+	data |= (UARTDM_MR2_RX_BREAK_ZERO_CHAR_OFF |
+			UARTDM_MR2_RX_ERROR_CHAR_OFF);
+
+	msm_hs_write(uport, UARTDM_MR2_ADDR, data);
+	mb();
 
 	if (pdata && pdata->gpio_config) {
+		DbgBuffer_printLog("%s: Configuring UART GPIOs\n", __func__);
 		if (unlikely(pdata->gpio_config(1)))
-				dev_err(uport->dev, "Cannot configure"
-					"gpios\n");
+			dev_err(uport->dev, "Cannot configure gpios\n");
 	}
 
+	DbgBuffer_printLog("%s: after gpio_config(1)\n", __func__);
+	msm_hs_dump_register(uport);
+
 	
 	data = msm_hs_read(uport, UARTDM_MR1_ADDR);
 	data &= ~UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK;
@@ -1564,7 +1925,6 @@
 	msm_hs_write(uport, UARTDM_CR_ADDR, RESET_BREAK_INT);
 	msm_hs_write(uport, UARTDM_CR_ADDR, RESET_STALE_INT);
 	msm_hs_write(uport, UARTDM_CR_ADDR, RESET_CTS);
-	msm_hs_write(uport, UARTDM_CR_ADDR, RFR_LOW);
 	
 	msm_hs_write(uport, UARTDM_CR_ADDR, UARTDM_CR_RX_EN_BMSK);
 
@@ -1627,6 +1987,18 @@
 
 	msm_hs_start_rx_locked(uport);
 
+	data = msm_hs_read(uport, UARTDM_MR2_ADDR);
+        data &= ~(UARTDM_MR2_RX_BREAK_ZERO_CHAR_OFF |
+                        UARTDM_MR2_RX_ERROR_CHAR_OFF);
+
+        msm_hs_write(uport, UARTDM_MR2_ADDR, data);
+        mb();
+
+	
+	msm_hs_write(uport, UARTDM_CR_ADDR, RFR_LOW);
+	DbgBuffer_printLog("%s: after RFR_LOW\n", __func__);
+	msm_hs_dump_register(&msm_uport->uport);
+
 	spin_unlock_irqrestore(&uport->lock, flags);
 	ret = pm_runtime_set_active(uport->dev);
 	if (ret)
@@ -1833,7 +2205,18 @@
 	uport->fifosize = 64;
 	uport->ops = &msm_hs_ops;
 	uport->flags = UPF_BOOT_AUTOCONF;
+
+#ifdef CONFIG_QSC_MODEM
+	if (pdev->id == MSM_SERIAL_QSC_HS_ID){
+		pr_info("%s: set baud rate 4Mbps for gsbi1.\n", __func__);
+		uport->uartclk = 64000000;
+	} else{
+		pr_info("%s: set baud rate 115kbps.\n", __func__);
+		uport->uartclk = 7372800;
+	}
+#else
 	uport->uartclk = 7372800;
+#endif
 	msm_uport->imr_reg = 0x0;
 
 	msm_uport->clk = clk_get(&pdev->dev, "core_clk");
@@ -1892,6 +2275,10 @@
 	if (unlikely(ret))
 		return ret;
 
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_reg.attr);
+	if (unlikely(ret))
+		return ret;
+
 	msm_serial_debugfs_init(msm_uport, pdev->id);
 
 	uport->line = pdev->id;
@@ -1938,6 +2325,8 @@
 	const struct msm_serial_hs_platform_data *pdata =
 					pdev->dev.platform_data;
 
+	DbgBuffer_printLog("%s: entry\n", __func__);
+	msm_hs_dump_register(&msm_uport->uport);
 	if (msm_uport->tx.dma_in_flight) {
 		spin_lock_irqsave(&uport->lock, flags);
 		
@@ -1996,9 +2385,13 @@
 	if (use_low_power_wakeup(msm_uport))
 		free_irq(msm_uport->wakeup.irq, msm_uport);
 
+	DbgBuffer_printLog("%s: shutdown: unconfiguring GPIOs\n", __func__);
 	if (pdata && pdata->gpio_config)
 		if (pdata->gpio_config(0))
 			dev_err(uport->dev, "GPIO config error\n");
+
+	DbgBuffer_printLog("%s: exit\n", __func__);
+	msm_hs_dump_register(uport);
 }
 
 static void __exit msm_serial_hs_exit(void)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs_cir_lite.c monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs_cir_lite.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/serial/msm_serial_hs_cir_lite.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/tty/serial/msm_serial_hs_cir_lite.c	2013-08-01 23:38:01.000000000 -0600
@@ -1062,6 +1062,8 @@
 {
 	int ret;
 	struct msm_hsl_port *msm_hsl_port = UART_TO_MSM(port);
+	unsigned long flags;
+
 	D("%s (): ir, state %d\n", __func__, state);
 	switch (state) {
 	case 0:
@@ -1072,6 +1074,19 @@
 		clk_en(port, 1);
 		break;
 	case 3:
+		if (cir_enable_flg != PATH_CIR) {
+			D("%s path is not CIR. flg = %d\n",
+						__func__, cir_enable_flg);
+			D("%s(): Clear IRDA mode \n", __func__);
+			spin_lock_irqsave(&port->lock, flags);
+			ret = 0;
+			msm_hsl_write(port, ret, UARTDM_IRDA_ADDR);
+			spin_unlock_irqrestore(&port->lock, flags);
+
+			cir_enable_flg = PATH_CIR;
+			if (msm_hsl_port->cir_set_path)
+				msm_hsl_port->cir_set_path(PATH_CIR);
+		}
 		clk_en(port, 0);
 		break;
 	default:
@@ -1449,16 +1464,6 @@
 		cir_enable_flg = PATH_IRDA;
 		if (msm_cir_port->cir_set_path)
 			msm_cir_port->cir_set_path(PATH_IRDA);
-	} else {
-		D("%s(): Clear IRDA mode \n", __func__);
-		spin_lock_irqsave(&port->lock, flags);
-		ret = 0;
-		msm_hsl_write(port, ret, UARTDM_IRDA_ADDR);
-		spin_unlock_irqrestore(&port->lock, flags);
-
-		cir_enable_flg = PATH_CIR;
-		if (msm_cir_port->cir_set_path)
-			msm_cir_port->cir_set_path(PATH_CIR);
 	}
 
 	clk_en(port, 0);
@@ -1798,6 +1803,7 @@
 		return ret;
 
 	debug_base = debugfs_create_dir("msm_serial_cir", NULL);
+
 	if (IS_ERR_OR_NULL(debug_base))
 		E("%s():Cannot create debugfs dir\n", __func__);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/tty_audit.c monarudo-jb-3.4.10-e22f38b/drivers/tty/tty_audit.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/tty/tty_audit.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/tty/tty_audit.c	2013-08-01 23:38:01.000000000 -0600
@@ -15,11 +15,11 @@
 
 struct tty_audit_buf {
 	atomic_t count;
-	struct mutex mutex;	/* Protects all data below */
-	int major, minor;	/* The TTY which the data is from */
+	struct mutex mutex;	
+	int major, minor;	
 	unsigned icanon:1;
 	size_t valid;
-	unsigned char *data;	/* Allocated size N_TTY_BUF_SIZE */
+	unsigned char *data;	
 };
 
 static struct tty_audit_buf *tty_audit_buf_alloc(int major, int minor,
@@ -83,12 +83,6 @@
 	}
 }
 
-/**
- *	tty_audit_buf_push	-	Push buffered data out
- *
- *	Generate an audit message from the contents of @buf, which is owned by
- *	@tsk with @loginuid.  @buf->mutex must be locked.
- */
 static void tty_audit_buf_push(struct task_struct *tsk, uid_t loginuid,
 			       unsigned int sessionid,
 			       struct tty_audit_buf *buf)
@@ -104,12 +98,6 @@
 	buf->valid = 0;
 }
 
-/**
- *	tty_audit_buf_push_current	-	Push buffered data out
- *
- *	Generate an audit message from the contents of @buf, which is owned by
- *	the current task.  @buf->mutex must be locked.
- */
 static void tty_audit_buf_push_current(struct tty_audit_buf *buf)
 {
 	uid_t auid = audit_get_loginuid(current);
@@ -141,11 +129,6 @@
 	tty_audit_buf_put(buf);
 }
 
-/**
- *	tty_audit_fork	-	Copy TTY audit state for a new task
- *
- *	Set up TTY audit state in @sig from current.  @sig needs no locking.
- */
 void tty_audit_fork(struct signal_struct *sig)
 {
 	spin_lock_irq(&current->sighand->siglock);
@@ -153,9 +136,6 @@
 	spin_unlock_irq(&current->sighand->siglock);
 }
 
-/**
- *	tty_audit_tiocsti	-	Log TIOCSTI
- */
 void tty_audit_tiocsti(struct tty_struct *tty, char ch)
 {
 	struct tty_audit_buf *buf;
@@ -189,16 +169,6 @@
 	}
 }
 
-/**
- * tty_audit_push_task	-	Flush task's pending audit data
- * @tsk:		task pointer
- * @loginuid:		sender login uid
- * @sessionid:		sender session id
- *
- * Called with a ref on @tsk held. Try to lock sighand and get a
- * reference to the tty audit buffer if available.
- * Flush the buffer or return an appropriate error code.
- */
 int tty_audit_push_task(struct task_struct *tsk, uid_t loginuid, u32 sessionid)
 {
 	struct tty_audit_buf *buf = ERR_PTR(-EPERM);
@@ -214,10 +184,6 @@
 	}
 	unlock_task_sighand(tsk, &flags);
 
-	/*
-	 * Return 0 when signal->audit_tty set
-	 * but tsk->signal->tty_audit_buf == NULL.
-	 */
 	if (!buf || IS_ERR(buf))
 		return PTR_ERR(buf);
 
@@ -229,13 +195,6 @@
 	return 0;
 }
 
-/**
- *	tty_audit_buf_get	-	Get an audit buffer.
- *
- *	Get an audit buffer for @tty, allocate it if necessary.  Return %NULL
- *	if TTY auditing is disabled or out of memory.  Otherwise, return a new
- *	reference to the buffer.
- */
 static struct tty_audit_buf *tty_audit_buf_get(struct tty_struct *tty)
 {
 	struct tty_audit_buf *buf, *buf2;
@@ -270,7 +229,7 @@
 		buf2 = NULL;
 	}
 	atomic_inc(&buf->count);
-	/* Fall through */
+	
  out:
 	spin_unlock_irq(&current->sighand->siglock);
 	if (buf2)
@@ -278,11 +237,6 @@
 	return buf;
 }
 
-/**
- *	tty_audit_add_data	-	Add data for TTY auditing.
- *
- *	Audit @data of @size from @tty, if necessary.
- */
 void tty_audit_add_data(struct tty_struct *tty, unsigned char *data,
 			size_t size)
 {
@@ -327,11 +281,6 @@
 	tty_audit_buf_put(buf);
 }
 
-/**
- *	tty_audit_push	-	Push buffered data out
- *
- *	Make sure no audit data is pending for @tty on the current process.
- */
 void tty_audit_push(struct tty_struct *tty)
 {
 	struct tty_audit_buf *buf;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/android.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/android.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/android.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/android.c	2013-08-01 23:38:00.000000000 -0600
@@ -166,6 +166,8 @@
 	int (*match)(int product_id, int intrsharing);
 	bool bEnablePerfLock;
 	int autobot_mode;
+	bool bSwitchFunWhileInit;
+	unsigned SwitchFunCombination;
 };
 
 static struct class *android_class;
@@ -1244,8 +1246,8 @@
 		ncm->ethaddr[0], ncm->ethaddr[1], ncm->ethaddr[2],
 		ncm->ethaddr[3], ncm->ethaddr[4], ncm->ethaddr[5]);
 
-	if (c->cdev->gadget)
-		c->cdev->gadget->miMaxMtu = 9000;
+    if (c->cdev->gadget)
+        c->cdev->gadget->miMaxMtu = ETH_FRAME_LEN_MAX - ETH_HLEN;
 	ret = gether_setup_name(c->cdev->gadget, ncm->ethaddr, "usb");
 	if (ret) {
 		pr_err("%s: gether_setup failed\n", __func__);
@@ -2805,6 +2807,11 @@
 	usb_gadget_connect(cdev->gadget);
 	dev->enabled = true;
 	pr_info("%s: ret: %d\n", __func__, ret);
+	if (dev->bSwitchFunWhileInit == true) {
+		pr_info("%s: Switch function while init = %d, func = %d\n", __func__, dev->bSwitchFunWhileInit, dev->SwitchFunCombination);
+		android_switch_function(dev->SwitchFunCombination);
+		dev->bSwitchFunWhileInit = false;
+	}
 }
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/ci13xxx_udc.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/ci13xxx_udc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/ci13xxx_udc.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/ci13xxx_udc.c	2013-08-01 23:38:00.000000000 -0600
@@ -39,7 +39,7 @@
 #define MAX_PRIME_CHECK_RETRY  3 
 
 static DEFINE_SPINLOCK(udc_lock);
-
+extern int USB_disabled;
 static const struct usb_endpoint_descriptor
 ctrl_endpt_out_desc = {
 	.bLength         = USB_DT_ENDPOINT_SIZE,
@@ -212,14 +212,17 @@
 }
 static int hw_device_reset(struct ci13xxx *udc)
 {
+	int delay_count = 25; 
+
 	
 	hw_cwrite(CAP_ENDPTFLUSH, ~0, ~0);
 	hw_cwrite(CAP_USBCMD, USBCMD_RS, 0);
 
 	hw_cwrite(CAP_USBCMD, USBCMD_RST, USBCMD_RST);
-	while (hw_cread(CAP_USBCMD, USBCMD_RST))
-		udelay(10);             
-
+	while (delay_count--  && hw_cread(CAP_USBCMD, USBCMD_RST))
+		udelay(10);
+	if (delay_count < 0)
+		pr_err("USB controller reset failed\n");
 
 	if (udc->udc_driver->notify_event)
 		udc->udc_driver->notify_event(udc,
@@ -516,6 +519,8 @@
 
 static int hw_usb_reset(void)
 {
+	int delay_count = 10; 
+
 	hw_usb_set_address(0);
 
 	
@@ -528,8 +533,10 @@
 	hw_cwrite(CAP_ENDPTCOMPLETE,  0,  0);   
 
 	
-	while (hw_cread(CAP_ENDPTPRIME, ~0))
-		udelay(10);             
+	while (delay_count-- && hw_cread(CAP_ENDPTPRIME, ~0))
+		udelay(10);
+	if (delay_count < 0)
+		pr_err("ENDPTPRIME is not cleared during bus reset\n");
 
 	
 
@@ -1338,7 +1345,7 @@
 static void usb_chg_stop(struct work_struct *w)
 {
 	USB_INFO("disable charger\n");
-	htc_battery_charger_disable();
+	htc_battery_pwrsrc_disable();
 }
 
 static void ep_prime_timer_func(unsigned long data)
@@ -2899,7 +2906,17 @@
 		if (USBi_URI & intr) {
 			USB_INFO("reset\n");
 			isr_statistics.uri++;
-			isr_reset_handler(udc);
+
+			if (board_mfg_mode() == 5 || USB_disabled) {
+				USB_INFO("Offmode / QuickBootMode\n");
+				spin_unlock(udc->lock);
+				if (udc->transceiver)
+					udc->transceiver->notify_usb_disabled();
+				spin_lock(udc->lock);
+				isr_reset_handler(udc);
+			} else {
+				isr_reset_handler(udc);
+			}
 
 			if (udc->transceiver)
 				udc->transceiver->notify_usb_attached();
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/composite.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/composite.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/composite.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/composite.c	2013-08-01 23:38:00.000000000 -0600
@@ -1180,7 +1180,7 @@
 	if (composite->disconnect)
 		composite->disconnect(cdev);
 	if (cdev->delayed_status != 0) {
-		WARN(cdev, "%s: delayed_status is not 0 in disconnect status\n", __func__);
+		WARNING(cdev, "%s: delayed_status is not 0 in disconnect status\n", __func__);
 		cdev->delayed_status = 0;
 	}
 	spin_unlock_irqrestore(&cdev->lock, flags);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_audio_source.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_audio_source.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_audio_source.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_audio_source.c	2013-08-01 23:38:00.000000000 -0600
@@ -506,7 +506,7 @@
 	int ret;
 
 	pr_debug("audio_set_alt intf %d, alt %d\n", intf, alt);
-	printk("[USB]audio_set_alt intf %d alt %d as_alt_1 %d ep_enable %d \n",intf,alt,as_interface_alt_1_desc.bInterfaceNumber,audio->audio_ep_enabled);
+
 	if (intf == as_interface_alt_1_desc.bInterfaceNumber) {
 		if (alt && !audio->audio_ep_enabled) {
 			ret = config_ep_by_speed(cdev->gadget, f, audio->in_ep);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_ncm.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_ncm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_ncm.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_ncm.c	2013-08-01 23:38:00.000000000 -0600
@@ -15,6 +15,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
@@ -49,6 +51,7 @@
 
 	struct ndp_parser_opts_ncm		*parser_opts;
 	bool				is_crc;
+	int                 iCurMaxDataSize;
 
 	spinlock_t			lock;
 };
@@ -67,7 +70,7 @@
 }
 
 
-#define NTB_DEFAULT_IN_SIZE_NCM	9000
+#define NTB_DEFAULT_IN_SIZE_NCM 16384
 #define NTB_OUT_SIZE_NCM		16384
 
 
@@ -150,7 +153,7 @@
 };
 #endif
 
-#define NCAPS	(USB_CDC_NCM_NCAP_ETH_FILTER | USB_CDC_NCM_NCAP_CRC_MODE)
+#define NCAPS	(USB_CDC_NCM_NCAP_ETH_FILTER | USB_CDC_NCM_NCAP_CRC_MODE | USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE)
 
 static struct usb_cdc_ncm_desc ncm_desc = {
 	.bLength =		sizeof ncm_desc,
@@ -512,6 +515,31 @@
 	return;
 }
 
+static void ncm_ep0out_complete2(struct usb_ep *ep, struct usb_request *req)
+{
+u16     in_size;
+struct usb_function	*f = req->context;
+struct f_ncm		*ncm = func_to_ncm(f);
+struct usb_composite_dev *cdev = ep->driver_data;
+
+	req->context = NULL;
+	if (req->status || req->actual != req->length) {
+		DBG(cdev, "Bad control-OUT transfer\n");
+		goto invalid;
+	}
+
+	in_size = get_unaligned_le16(req->buf);
+
+	DBG(cdev, "Set USB_CDC_SET_MAX_DATAGRAM_SIZE %d\n", in_size);
+    gether_change_mtu(in_size - ETH_HLEN);
+    ncm->iCurMaxDataSize = in_size;
+	return;
+
+invalid:
+	usb_ep_set_halt(ep);
+	return;
+}
+
 static int ncm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 {
 	struct f_ncm		*ncm = func_to_ncm(f);
@@ -540,7 +568,7 @@
 		value = w_length > sizeof ntb_parameters_ncm ?
 			sizeof ntb_parameters_ncm : w_length;
 		memcpy(req->buf, &ntb_parameters_ncm, value);
-		VDBG(cdev, "Host asked NTB parameters\n");
+		DBG(cdev, "Host asked NTB parameters\n");
 		break;
 
 	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
@@ -550,7 +578,7 @@
 			goto invalid;
 		put_unaligned_le32(ncm->port.fixed_in_len, req->buf);
 		value = 4;
-		VDBG(cdev, "Host asked INPUT SIZE, sending %d\n",
+		DBG(cdev, "Host asked INPUT SIZE, sending %d\n",
 		     ncm->port.fixed_in_len);
 		break;
 
@@ -577,7 +605,7 @@
 		format = (ncm->parser_opts == &ndp16_opts_ncm) ? 0x0000 : 0x0001;
 		put_unaligned_le16(format, req->buf);
 		value = 2;
-		VDBG(cdev, "Host asked NTB FORMAT, sending %d\n", format);
+		DBG(cdev, "Host asked NTB FORMAT, sending %d\n", format);
 		break;
 	}
 
@@ -611,7 +639,7 @@
 		is_crc = ncm->is_crc ? 0x0001 : 0x0000;
 		put_unaligned_le16(is_crc, req->buf);
 		value = 2;
-		VDBG(cdev, "Host asked CRC MODE, sending %d\n", is_crc);
+		DBG(cdev, "Host asked CRC MODE, sending %d\n", is_crc);
 		break;
 	}
 
@@ -648,7 +676,34 @@
 	
 	
 
-	default:
+    case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+        | USB_CDC_GET_MAX_DATAGRAM_SIZE:
+    {
+        if (w_length < 2 || w_value != 0 || w_index != ncm->ctrl_id)
+            goto invalid;
+        if ((ncm->iCurMaxDataSize == 0) || (ncm->iCurMaxDataSize > ETH_FRAME_LEN_MAX))
+            ncm->iCurMaxDataSize = ETH_FRAME_LEN_MAX;
+        put_unaligned_le16(ncm->iCurMaxDataSize, req->buf);
+        value = 2;
+        DBG(cdev, "Host asked MAX_DATAGRAM_SIZE, sending %d\n", ncm->iCurMaxDataSize);
+        break;
+    }
+
+    case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+        | USB_CDC_SET_MAX_DATAGRAM_SIZE:
+    {
+        if (w_length != 2 || w_value != 0 || w_index != ncm->ctrl_id)
+            goto invalid;
+        DBG(cdev, "Host set MAX_DATAGRAM_SIZE\n");
+        req->complete = ncm_ep0out_complete2;
+        req->length = w_length;
+        req->context = f;
+
+        value = req->length;
+        break;
+    }
+
+    default:
 invalid:
 		DBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
@@ -835,9 +890,11 @@
 	put_ncm(&tmp, opts->dgram_item_len, skb->len - ncb_len);
 	
 
-	if (skb->len > MAX_TX_NONFIXED)
+	if (skb->len > MAX_TX_NONFIXED && (max_size <= (ETH_FRAME_LEN - ETH_HLEN)))
+	{
 		memset(skb_put(skb, max_size - skb->len),
 		       0, max_size - skb->len);
+	}
 
 	return skb;
 }
@@ -1173,6 +1230,7 @@
 			return status;
 		ncm_string_defs[STRING_MAC_IDX].id = status;
 		ecm_desc.iMACAddress = status;
+		ecm_desc.wMaxSegmentSize = cpu_to_le16(ETH_FRAME_LEN_MAX);
 
 		
 		status = usb_string_id(c->cdev);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_projector2.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_projector2.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_projector2.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_projector2.c	2013-08-01 23:38:00.000000000 -0600
@@ -853,12 +853,9 @@
 						ctrl->bRequest, ctrl->wValue, ctrl->wIndex, ctrl->wLength);
 		switch (ctrl->bRequest) {
 			case HSML_08_REQ_MIRROR_LINK:
-
-				if (atomic_read(&prj2_dev->prj2_enable_HSML) != 1) {
-					printk(KERN_INFO "[MIRROR_LINK]%s, set state: 1\n",__func__);
-					atomic_set(&prj2_dev->prj2_enable_HSML, 1);
-					schedule_work(&prj2_dev->notifier_setting_work);
-				}
+				printk(KERN_INFO "[MIRROR_LINK]%s, set state: 1\n",__func__);
+				atomic_set(&prj2_dev->prj2_enable_HSML, 1);
+				schedule_work(&prj2_dev->notifier_setting_work);
 				value = w_length;
 				break;
 			default:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_projector.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_projector.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/f_projector.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/f_projector.c	2013-08-01 23:38:00.000000000 -0600
@@ -81,6 +81,7 @@
 static const char cand_shortname[] = "htc_cand";
 static const char htcmode_shortname[] = "htcmode";
 static ktime_t start;
+extern int htc_battery_set_max_input_current(int target_ma);
 
 struct projector_dev {
 	struct usb_function function;
@@ -1534,6 +1535,10 @@
 					value = w_length;
 				}
 				break;
+			case HSML_06_REQ_SET_MAX_CHARGING_CURRENT:
+				htc_battery_set_max_input_current((int)w_value);
+				value = 0;
+				break;
 
 			default:
 				printk(KERN_INFO "%s: unrecognized request(req=0x%02x, wValue=%d, "
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/htc_attr.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/htc_attr.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/htc_attr.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/htc_attr.c	2013-08-01 23:38:00.000000000 -0600
@@ -315,6 +315,8 @@
 	
 	if (dev->enabled != true) {
 		pr_info("%s: USB driver is not initialize\n", __func__);
+		dev->bSwitchFunWhileInit = true;
+		dev->SwitchFunCombination = func;
 		return 0;
 	}
 	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_bam.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_bam.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_bam.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_bam.c	2013-08-01 23:38:00.000000000 -0600
@@ -206,6 +206,11 @@
 		} else {
 			req->no_interrupt = 1;
 		}
+		
+		req->zero = 1;
+
+		
+		req->zero = 1;
 
 		list_del(&req->list);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_data_hsic.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_data_hsic.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_data_hsic.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_data_hsic.c	2013-08-01 23:38:00.000000000 -0600
@@ -227,6 +227,8 @@
 		} else {
 			req->no_interrupt = 1;
 		}
+		
+		req->zero = 1;
 
 		list_del(&req->list);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_ether.c monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_ether.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_ether.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_ether.c	2013-08-01 23:38:00.000000000 -0600
@@ -61,7 +61,6 @@
 #define RX_EXTRA	20	
 
 #define DEFAULT_QLEN	2	
-#define ETH_FRAME_LEN_MAX       9000
 
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 
@@ -84,6 +83,7 @@
 
 
 
+#ifdef DEBUG
 #undef DBG
 #undef VDBG
 #undef ERROR
@@ -112,6 +112,7 @@
 	xprintk(dev , KERN_ERR , fmt , ## args)
 #define INFO(dev, fmt, args...) \
 	xprintk(dev , KERN_INFO , fmt , ## args)
+#endif 
 
 static struct eth_dev *the_dev;
 
@@ -125,8 +126,8 @@
 	int     iMaxMtuSet = ETH_FRAME_LEN;
 
 	if (the_dev) {
-        if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX)
-            iMaxMtuSet = ETH_FRAME_LEN_MAX;
+        if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX - ETH_HLEN)
+            iMaxMtuSet = ETH_FRAME_LEN_MAX - ETH_HLEN;
 	}
 
 	
@@ -388,14 +389,20 @@
 	struct eth_dev	*dev = container_of(work, struct eth_dev, rx_work);
 	struct sk_buff	*skb;
 	int		status = 0;
+	unsigned int uiCurMtu = 0;
 
 	if (!dev->port_usb)
 		return;
 
+	uiCurMtu = dev->net->mtu + ETH_HLEN;
+	if ((uiCurMtu <= ETH_HLEN) || (uiCurMtu > ETH_FRAME_LEN_MAX))
+	    uiCurMtu = ETH_FRAME_LEN;
+
 	while ((skb = skb_dequeue(&dev->rx_frames))) {
 		if (status < 0
 				|| ETH_HLEN > skb->len
-				|| skb->len > ETH_FRAME_LEN) {
+			
+			    || skb->len > uiCurMtu) {
 			dev->net->stats.rx_errors++;
 			dev->net->stats.rx_length_errors++;
 			DBG(dev, "rx length %d\n", skb->len);
@@ -728,8 +735,8 @@
 		memcpy(ethaddr, the_dev->host_mac, ETH_ALEN);
         if (g) {
             the_dev->miMaxMtu = g->miMaxMtu;
-            if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX)
-                the_dev->net->mtu = ETH_FRAME_LEN_MAX;
+            if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX - ETH_HLEN)
+                the_dev->net->mtu = ETH_FRAME_LEN_MAX - ETH_HLEN;
         }
 		return 0;
 	}
@@ -781,8 +788,8 @@
 		the_dev = dev;
         if (g) {
             the_dev->miMaxMtu = g->miMaxMtu;
-            if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX)
-                the_dev->net->mtu = ETH_FRAME_LEN_MAX;
+            if (the_dev->miMaxMtu == ETH_FRAME_LEN_MAX - ETH_HLEN)
+                the_dev->net->mtu = ETH_FRAME_LEN_MAX - ETH_HLEN;
         }
 		netif_carrier_off(net);
 	}
@@ -802,6 +809,12 @@
 	the_dev = NULL;
 }
 
+int gether_change_mtu(int new_mtu)
+{
+struct eth_dev *dev = the_dev;
+
+    return ueth_change_mtu(dev->net, new_mtu);
+}
 
 /**
  * gether_connect - notify network layer that USB link is active
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_ether.h monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_ether.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/gadget/u_ether.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/gadget/u_ether.h	2013-08-01 23:38:00.000000000 -0600
@@ -63,6 +63,7 @@
 void gether_cleanup(void);
 int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
 		const char *netname);
+int gether_change_mtu(int new_mtu);
 
 struct net_device *gether_connect(struct gether *);
 void gether_disconnect(struct gether *);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/host/ehci-msm-hsic.c monarudo-jb-3.4.10-e22f38b/drivers/usb/host/ehci-msm-hsic.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/host/ehci-msm-hsic.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/host/ehci-msm-hsic.c	2013-08-01 23:38:00.000000000 -0600
@@ -221,10 +221,14 @@
 
 static void ehci_hsic_prevent_sleep(struct msm_hsic_hcd *mehci)
 {
+	s32 latency;
 	if (!in_interrupt()) {
 		if (get_radio_flag() & RADIO_FLAG_USB_UPLOAD)
 			pr_info("%s+\n", __func__);
-		pm_qos_update_request(&mehci->pm_qos_req_dma_htc, msm_cpuidle_get_deep_idle_latency());
+		latency =  msm_cpuidle_get_deep_idle_latency();
+		if (!latency)
+			latency = 2;
+		pm_qos_update_request(&mehci->pm_qos_req_dma_htc, latency);
 		if (get_radio_flag() & RADIO_FLAG_USB_UPLOAD)
 			pr_info("%s-\n", __func__);
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/otg/msm_otg.c monarudo-jb-3.4.10-e22f38b/drivers/usb/otg/msm_otg.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/usb/otg/msm_otg.c	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/usb/otg/msm_otg.c	2013-08-01 23:38:00.000000000 -0600
@@ -41,6 +41,9 @@
 #include <linux/mfd/pm8xxx/pm8921-charger.h>
 #include <linux/mfd/pm8xxx/misc.h>
 #include <linux/power_supply.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <asm/uaccess.h>
 
 #include <mach/clk.h>
 #include <mach/msm_xo.h>
@@ -53,8 +56,9 @@
 #define MSM_USB_BASE	(motg->regs)
 #define DRIVER_NAME	"msm_otg"
 
+extern int htc_battery_set_max_input_current(int target_ma);
 static int htc_otg_vbus;
-static int USB_disabled;
+int USB_disabled;
 static struct msm_otg *the_msm_otg;
 
 static int re_enable_host;
@@ -80,8 +84,10 @@
 {
 	static struct t_usb_status_notifier *notifier;
 	struct msm_otg *motg = container_of(w, struct msm_otg,	notifier_work);
+	struct usb_otg *otg;
 	if (!motg)
 		return;
+	otg = motg->phy.otg;
 
 	motg->connect_type_ready = 1;
 	USBH_INFO("send connect type %d\n", motg->connect_type);
@@ -93,6 +99,12 @@
 		}
 	}
 	mutex_unlock(&notify_sem);
+	if ((board_mfg_mode() == 5 || USB_disabled )&& motg->connect_type == CONNECT_TYPE_USB) { 
+		pm_runtime_put_noidle(otg->phy->dev);
+		pm_runtime_suspend(otg->phy->dev);
+	}
+	if (motg->chg_type == USB_CDP_CHARGER)
+		htc_battery_set_max_input_current(900);
 }
 
 int htc_usb_register_notifier(struct t_usb_status_notifier *notifier)
@@ -531,9 +543,42 @@
 
 static void ulpi_init(struct msm_otg *motg)
 {
+	struct file *fp;
+	mm_segment_t fs;
+	unsigned long addr, val;
+	const char *delim = ",";
+	const char *nextline = "\n";
+	const char *colon = ":";
+	char *buf, *stmp, *valtmp, *result;
+	int ret;
+
 	struct msm_otg_platform_data *pdata = motg->pdata;
 	int *seq = pdata->phy_init_seq;
 
+	fp = filp_open("/data/usb_phy.txt", O_RDONLY,0);
+
+	if(!IS_ERR(fp)){
+		buf = kmalloc(256, GFP_KERNEL);
+		fs = get_fs();
+		set_fs(get_ds());
+		fp->f_op->read(fp,buf,255,&fp->f_pos);
+		set_fs(fs);
+		
+		for (stmp = strsep(&buf, nextline) ; stmp != NULL ; stmp = strsep(&buf, nextline)) {
+			for (valtmp = strsep(&stmp, delim) ; stmp != NULL ; valtmp = strsep(&stmp, delim)) {
+				result = strsep(&valtmp, colon);
+				ret = strict_strtoul(result, 16, &addr);
+				result = strsep(&valtmp, colon);
+				ret = strict_strtoul(result, 16, &val);
+				USBH_INFO("ulpi: file write  0x%02x to 0x%02x", (int)val, (int)addr);
+				ulpi_write(&motg->phy, (int)val, (int)addr);
+			}
+		}
+		kfree(buf);
+		filp_close(fp, NULL);
+		return;
+	}
+
 	if (!seq)
 		return;
 
@@ -1257,6 +1302,7 @@
 	__cancel_delayed_work(&motg->ac_detect_work);
 }
 
+
 static int msm_otg_set_power(struct usb_phy *phy, unsigned mA)
 {
 	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
@@ -1520,6 +1566,27 @@
 
 }
 
+static void usb_disable_work(struct work_struct *w)
+{
+	struct msm_otg *motg = the_msm_otg;
+	struct usb_phy *usb_phy = &motg->phy;
+	USBH_INFO("%s\n", __func__);
+	motg->chg_type = USB_DCP_CHARGER;
+	motg->chg_state = USB_CHG_STATE_DETECTED;
+	msm_otg_start_peripheral(usb_phy->otg, 0);
+	usb_phy->state = OTG_STATE_B_IDLE;
+	queue_work(system_nrt_wq, &motg->sm_work);
+}
+
+static void msm_otg_notify_usb_disabled(void)
+{
+	struct msm_otg *motg = the_msm_otg;
+	struct usb_phy *usb_phy = &motg->phy;
+	USBH_INFO("%s\n", __func__);
+	usb_gadget_vbus_disconnect(usb_phy->otg->gadget);
+	queue_work(system_nrt_wq, &motg->usb_disable_work);
+}
+
 static int msm_otg_set_peripheral(struct usb_otg *otg,
 			struct usb_gadget *gadget)
 {
@@ -2041,12 +2108,15 @@
 			if (test_bit(ID_A, &motg->inputs)) {
 				motg->chg_type = USB_ACA_DOCK_CHARGER;
 				motg->chg_state = USB_CHG_STATE_DETECTED;
+				motg->connect_type = CONNECT_TYPE_UNKNOWN;
 				delay = 0;
 				break;
 			}
 			if (line_state) { 
 				motg->chg_type = USB_PROPRIETARY_CHARGER;
 				motg->chg_state = USB_CHG_STATE_DETECTED;
+				motg->connect_type = CONNECT_TYPE_AC;
+				USBH_INFO("DP > VLGC\n");
 				delay = 0;
 			} else {
 				msm_chg_enable_secondary_det(motg);
@@ -2057,27 +2127,33 @@
 			if (test_bit(ID_A, &motg->inputs)) {
 				motg->chg_type = USB_ACA_A_CHARGER;
 				motg->chg_state = USB_CHG_STATE_DETECTED;
+				motg->connect_type = CONNECT_TYPE_UNKNOWN;
 				delay = 0;
 				break;
 			}
 
-			if (line_state) 
+			if (line_state) {
 				motg->chg_type = USB_PROPRIETARY_CHARGER;
-			else
+				motg->connect_type = CONNECT_TYPE_AC;
+				USBH_INFO("DP > VLGC or/and DM > VLGC\n");
+			} else {
 				motg->chg_type = USB_SDP_CHARGER;
+				motg->connect_type = CONNECT_TYPE_UNKNOWN;
+			}
 
 			motg->chg_state = USB_CHG_STATE_DETECTED;
-			motg->connect_type = CONNECT_TYPE_UNKNOWN;
 			delay = 0;
 		}
 		break;
 	case USB_CHG_STATE_PRIMARY_DONE:
 		vout = msm_chg_check_secondary_det(motg);
-		if (vout)
+		if (vout) {
 			motg->chg_type = USB_DCP_CHARGER;
-		else
+			motg->connect_type = CONNECT_TYPE_AC;
+		} else {
 			motg->chg_type = USB_CDP_CHARGER;
-		motg->connect_type = CONNECT_TYPE_AC;
+			motg->connect_type = CONNECT_TYPE_USB;
+		}
 		motg->chg_state = USB_CHG_STATE_SECONDARY_DONE;
 		
 	case USB_CHG_STATE_SECONDARY_DONE:
@@ -2250,24 +2326,13 @@
 						OTG_STATE_B_PERIPHERAL;
 					break;
 				case USB_SDP_CHARGER:
-					if (USB_disabled) {
-						USBH_INFO("Fake Sleep: disable USB function\n");
-						
-						ulpi_write(otg->phy, 0x2, 0x85);
-						msm_otg_notify_charger(motg,IDEV_CHG_MIN);
-						if (motg->reset_phy_before_lpm)
-							msm_otg_reset(otg->phy);
-						pm_runtime_put_noidle(otg->phy->dev);
-						pm_runtime_suspend(otg->phy->dev);
-					} else {
-						
-						ulpi_write(otg->phy, 0x3, 0x86);
-						msm_otg_notify_charger(motg, IDEV_CHG_MIN);
-						msm_otg_start_peripheral(otg, 1);
-						otg->phy->state = OTG_STATE_B_PERIPHERAL;
-						motg->ac_detect_count = 0;
-						queue_delayed_work(system_nrt_wq, &motg->ac_detect_work, 3 * HZ);
-					 }
+					
+					ulpi_write(otg->phy, 0x3, 0x86);
+					msm_otg_notify_charger(motg, IDEV_CHG_MIN);
+					msm_otg_start_peripheral(otg, 1);
+					otg->phy->state = OTG_STATE_B_PERIPHERAL;
+					motg->ac_detect_count = 0;
+					queue_delayed_work(system_nrt_wq, &motg->ac_detect_work, 2 * HZ);
 					break;
 				default:
 					break;
@@ -2894,7 +2959,7 @@
 	USBH_INFO("%s: count = %d, connect_type = %d\n", __func__,
 			motg->ac_detect_count, motg->connect_type);
 
-	if (motg->connect_type == CONNECT_TYPE_USB || motg->ac_detect_count >= 3)
+	if (motg->connect_type == CONNECT_TYPE_USB || motg->ac_detect_count >= 5)
 		return;
 
 	
@@ -2943,11 +3008,8 @@
 			}
 		}
 #endif
-		motg->ac_detect_count++;
-		if (motg->ac_detect_count == 1)
-			delay = 5 * HZ;
-		else if (motg->ac_detect_count == 2)
-			delay = 10 * HZ;
+		if (motg->ac_detect_count++ < 5)
+			delay = 2 * HZ;
 
 		queue_delayed_work(system_nrt_wq, &motg->ac_detect_work, delay);
 	} else {
@@ -3055,6 +3117,8 @@
 
 	USB_disabled = disable_usb;
 
+	if (!disable_usb)
+		motg->chg_state = USB_CHG_STATE_UNDEFINED;
 	queue_work(system_nrt_wq, &motg->sm_work);
 }
 
@@ -3777,6 +3841,7 @@
 	wake_lock_init(&motg->cable_detect_wlock, WAKE_LOCK_SUSPEND, "msm_usb_cable");
 	msm_otg_init_timer(motg);
 	INIT_WORK(&motg->sm_work, msm_otg_sm_work);
+	INIT_WORK(&motg->usb_disable_work, usb_disable_work);
 	INIT_WORK(&motg->notifier_work, send_usb_connect_notify);
 	INIT_DELAYED_WORK(&motg->ac_detect_work, ac_detect_expired_work);
 	INIT_DELAYED_WORK(&motg->chg_work, msm_chg_detect_work);
@@ -3785,9 +3850,6 @@
 				(unsigned long) motg);
 	motg->ac_detect_count = 0;
 
-	if (board_mfg_mode() == 5) 
-		USB_disabled = 1;
-
 	ret = request_irq(motg->irq, msm_otg_irq, IRQF_SHARED,
 					"msm_otg", motg);
 	if (ret) {
@@ -3799,6 +3861,7 @@
 	phy->set_power = msm_otg_set_power;
 	phy->set_suspend = msm_otg_set_suspend;
 	phy->notify_usb_attached = msm_otg_notify_usb_attached;
+	phy->notify_usb_disabled = msm_otg_notify_usb_disabled;
 	phy->io_ops = &msm_otg_io_ops;
 	phy->send_event = msm_otg_send_event;
 	phy->otg->send_event = msm_otg_send_event2;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/video/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -2408,6 +2408,23 @@
 	  Choose this option if you want to use the Unigfx device as a
 	  framebuffer device. Without the support of PCI & AGP.
 
+
+choice
+	prompt "Select MSM driver branch"
+	default FB_MSM_MAINLINE
+
+config FB_MSM_412
+	bool "Display driver old"
+	help
+	  Old display driver
+
+config FB_MSM_MAINLINE
+	bool "Display driver old"
+	help
+	  New display driver
+endchoice
+
+
 source "drivers/video/msm/Kconfig"
 
 source "drivers/video/omap/Kconfig"
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/Makefile monarudo-jb-3.4.10-e22f38b/drivers/video/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -142,7 +142,8 @@
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
-obj-$(CONFIG_FB_MSM)              += msm/
+obj-$(CONFIG_FB_MSM_MAINLINE)     += msm/
+obj-$(CONFIG_FB_MSM_412)          += msm412/
 obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
 obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/hdmi_msm.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/hdmi_msm.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/hdmi_msm.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/hdmi_msm.c	2013-08-01 23:38:01.000000000 -0600
@@ -2369,8 +2369,6 @@
 	hdmi_msm_state->hdcp_activating = TRUE;
 	mutex_unlock(&hdmi_msm_state_mutex);
 
-	fill_black_screen();
-
 	mutex_lock(&hdcp_auth_state_mutex);
 	hdmi_msm_state->hpd_during_auth = FALSE;
 	hdmi_msm_state->full_auth_done = FALSE;
@@ -2405,8 +2403,6 @@
 	if (ret)
 		goto error;
 
-	unfill_black_screen();
-
 	external_common_state->hdcp_active = TRUE;
 	mutex_lock(&hdmi_msm_state_mutex);
 	hdmi_msm_state->hdcp_activating = FALSE;
@@ -3833,11 +3829,11 @@
 	} else
 		DEV_ERR("Init FAILED: failed to add fb device\n");
 
-	DEV_INFO("HDMI HPD: ON\n");
-
-	rc = hdmi_msm_hpd_on(true);
-	if (rc)
-		goto error;
+	if (hdmi_prim_display) {
+		rc = hdmi_msm_hpd_on(true);
+		if (rc)
+			goto error;
+	}
 
 	if (hdmi_msm_has_hdcp()) {
 		
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/Kconfig monarudo-jb-3.4.10-e22f38b/drivers/video/msm/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -1041,8 +1041,7 @@
 
 config FB_MSM_UNDERFLOW_WORKAROUND
 	bool "Display underflow workaround"
-	default y if !TRACING
-	default n
+	default y
 	---help---
 	  Force underflow color to black to avoid blue splash.
 	  Say Y here after CRC stage.
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -63,6 +63,7 @@
 static void lvds_init(struct msm_fb_data_type *mfd)
 {
 	unsigned int lvds_intf = 0, lvds_phy_cfg0 = 0;
+	mdp_clk_ctrl(1);
 
 	MDP_OUTP(MDP_BASE + 0xc2034, 0x33);
 	usleep(1000);
@@ -92,11 +93,11 @@
 		MDP_OUTP(MDP_BASE + 0xc3064, 0x05);
 		MDP_OUTP(MDP_BASE + 0xc3050, 0x20);
 	} else {
-		MDP_OUTP(MDP_BASE + 0xc3004, 0x62);
+		MDP_OUTP(MDP_BASE + 0xc3004, 0x8f);
 		MDP_OUTP(MDP_BASE + 0xc3008, 0x30);
-		MDP_OUTP(MDP_BASE + 0xc300c, 0xc4);
+		MDP_OUTP(MDP_BASE + 0xc300c, 0xc6);
 		MDP_OUTP(MDP_BASE + 0xc3014, 0x10);
-		MDP_OUTP(MDP_BASE + 0xc3018, 0x05);
+		MDP_OUTP(MDP_BASE + 0xc3018, 0x07);
 		MDP_OUTP(MDP_BASE + 0xc301c, 0x62);
 		MDP_OUTP(MDP_BASE + 0xc3020, 0x41);
 		MDP_OUTP(MDP_BASE + 0xc3024, 0x0d);
@@ -173,7 +174,7 @@
 			
 			MDP_OUTP(MDP_BASE +  0xc2020, 0x00090a0b);
 			
-			MDP_OUTP(MDP_BASE +  0xc2024, 0x151a191a);
+			MDP_OUTP(MDP_BASE +  0xc2024, 0x1518191a);
 			
 			MDP_OUTP(MDP_BASE +  0xc2028, 0x00121314);
 			
@@ -231,6 +232,7 @@
 	usleep(1);
 	
 	MDP_OUTP(MDP_BASE +  0xc3100, lvds_phy_cfg0);
+	mdp_clk_ctrl(0);
 }
 
 static int lvds_off(struct platform_device *pdev)
@@ -244,9 +246,11 @@
 	if (lvds_clk)
 		clk_disable_unprepare(lvds_clk);
 
+	mdp_clk_ctrl(1);
 	MDP_OUTP(MDP_BASE +  0xc3100, 0x0);
 	MDP_OUTP(MDP_BASE + 0xc3000, 0x0);
 	usleep(10);
+	mdp_clk_ctrl(0);
 
 	if (lvds_pdata && lvds_pdata->lcdc_power_save)
 		lvds_pdata->lcdc_power_save(0);
@@ -254,10 +258,6 @@
 	if (lvds_pdata && lvds_pdata->lcdc_gpio_config)
 		ret = lvds_pdata->lcdc_gpio_config(0);
 
-#ifdef CONFIG_MSM_BUS_SCALING
-	mdp_bus_scale_update_request(0);
-#endif
-
 	return ret;
 }
 
@@ -273,9 +273,6 @@
 
 	if (!panel_pixclock_freq)
 		panel_pixclock_freq = mfd->fbi->var.pixclock;
-#ifdef CONFIG_MSM_BUS_SCALING
-	mdp_bus_scale_update_request(2);
-#endif
 	mfd = platform_get_drvdata(pdev);
 
 	if (lvds_clk) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds_chimei_wxga.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds_chimei_wxga.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds_chimei_wxga.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds_chimei_wxga.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -63,15 +63,16 @@
 {
 	int rc = 0;
 
-	if (pdev->id == 0)
+	if (pdev->id == 0) {
 		cm_pdata = pdev->dev.platform_data;
-
-	if (cm_pdata == NULL) {
-		pr_err("%s: no PWM gpio specified\n", __func__);
+		if (cm_pdata == NULL)
+			pr_err("%s: no PWM gpio specified\n", __func__);
 		return 0;
-	} else
+	}
+
+	if (cm_pdata != NULL)
 		bl_lpm = pwm_request(cm_pdata->gpio[0],
-				"backlight");
+			"backlight");
 
 	if (bl_lpm == NULL || IS_ERR(bl_lpm)) {
 		pr_err("%s pwm_request() failed\n", __func__);
@@ -133,7 +134,7 @@
 	pinfo->wait_cycle = 0;
 	pinfo->bpp = 24;
 	pinfo->fb_num = 2;
-	pinfo->clk_rate = 75000000;
+	pinfo->clk_rate = 79400000;
 	pinfo->bl_max = 255;
 	pinfo->bl_min = 1;
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds_frc_fhd.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds_frc_fhd.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/lvds_frc_fhd.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/lvds_frc_fhd.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/Makefile monarudo-jb-3.4.10-e22f38b/drivers/video/msm/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -14,7 +14,6 @@
 
 ifeq ($(CONFIG_FB_MSM_MDP40),y)
 obj-y += mdp4_util.o
-obj-y += mdp4_hsic.o
 else
 obj-y += mdp_hw_init.o
 obj-y += mdp_ppp.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mddihost.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mddihost.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mddihost.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mddihost.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2009, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mddihosti.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mddihosti.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mddihosti.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mddihosti.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_dtv.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_dtv.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_dtv.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_dtv.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -38,6 +38,7 @@
 
 static int dtv_off(struct platform_device *pdev);
 static int dtv_on(struct platform_device *pdev);
+static int dtv_off_sub(void);
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
@@ -45,6 +46,9 @@
 static struct clk *tv_src_clk;
 static struct clk *hdmi_clk;
 static struct clk *mdp_tv_clk;
+static struct platform_device *dtv_pdev;
+static struct workqueue_struct *dtv_work_queue;
+static struct work_struct dtv_off_work;
 
 
 static int mdp4_dtv_runtime_suspend(struct device *dev)
@@ -86,8 +90,41 @@
 static int dtv_off(struct platform_device *pdev)
 {
 	int ret = 0;
+	struct msm_fb_data_type *mfd = NULL;
 
-	ret = panel_next_off(pdev);
+	if (!pdev) {
+		pr_err("%s: FAILED: invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	mfd = platform_get_drvdata(pdev);
+	if (!mfd) {
+		pr_err("%s: FAILED: invalid mfd\n", __func__);
+		return -EINVAL;
+	}
+
+	dtv_pdev = pdev;
+	if (!mfd->suspend.op_suspend) {
+		pr_debug("%s: Queuing work to turn off HDMI core\n", __func__);
+		queue_work(dtv_work_queue, &dtv_off_work);
+	} else {
+		pr_debug("%s: turning off HDMI core\n", __func__);
+		ret = dtv_off_sub();
+	}
+
+	return ret;
+}
+
+static int dtv_off_sub(void)
+{
+	int ret = 0;
+
+	if (!dtv_pdev) {
+		pr_err("%s: FAILED: invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = panel_next_off(dtv_pdev);
 
 	pr_info("%s\n", __func__);
 
@@ -112,18 +149,19 @@
 	return ret;
 }
 
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
-extern atomic_t read_an_complete;
-#endif
+static void dtv_off_work_func(struct work_struct *work)
+{
+	dtv_off_sub();
+}
 
 static int dtv_on(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct msm_fb_data_type *mfd;
 	unsigned long panel_pixclock_freq , pm_qos_rate;
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
-	int timeout = 100;
-#endif
+
+	
+	flush_work_sync(&dtv_off_work);
 
 	mfd = platform_get_drvdata(pdev);
 	panel_pixclock_freq = mfd->fbi->var.pixclock;
@@ -163,17 +201,6 @@
 	pr_info("%s: tv_src_clk=%dkHz, pm_qos_rate=%ldkHz, [%d]\n", __func__,
 		mfd->fbi->var.pixclock/1000, pm_qos_rate, ret);
 	mfd->panel_info.clk_rate = mfd->fbi->var.pixclock;
-
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
-	while(atomic_read(&read_an_complete) && timeout--)
-		msleep(10);
-
-	if(timeout < 0)
-		pr_err("%s: unlikely timeout!\n", __func__);
-	else
-		pr_info("%s: waiting AN read for %d ms\n",
-			__func__, (100-timeout)*10);
-#endif
 	clk_prepare_enable(hdmi_clk);
 	clk_reset(hdmi_clk, CLK_RESET_ASSERT);
 	udelay(20);
@@ -233,6 +260,8 @@
 		return 0;
 	}
 
+	dtv_work_queue = create_singlethread_workqueue("dtv_work");
+	INIT_WORK(&dtv_off_work, dtv_off_work_func);
 	mfd = platform_get_drvdata(pdev);
 
 	if (!mfd)
@@ -302,6 +331,8 @@
 
 static int dtv_remove(struct platform_device *pdev)
 {
+	if (dtv_work_queue)
+		destroy_workqueue(dtv_work_queue);
 #ifdef CONFIG_MSM_BUS_SCALING
 	if (dtv_pdata && dtv_pdata->bus_scale_table &&
 		dtv_bus_scale_handle > 0)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,5 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/*
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -28,7 +29,13 @@
 extern char *mmss_cc_base;	
 extern spinlock_t dsi_clk_lock;
 extern u32 mdp_max_clk;
-extern u32 mdp_min_clk;
+
+extern u64 mdp_max_bw;
+extern u32 mdp_bw_ab_factor;
+extern u32 mdp_bw_ib_factor;
+#define MDP4_BW_AB_DEFAULT_FACTOR (115)	
+#define MDP4_BW_IB_DEFAULT_FACTOR (150)	
+#define MDP_BUS_SCALE_AB_STEP (0x4000000)
 
 #define MDP4_OVERLAYPROC0_BASE	0x10000
 #define MDP4_OVERLAYPROC1_BASE	0x18000
@@ -36,6 +43,7 @@
 
 #define MDP4_VIDEO_BASE 0x20000
 #define MDP4_VIDEO_OFF 0x10000
+#define MDP4_VIDEO_CSC_OFF 0x4000
 
 #define MDP4_RGB_BASE 0x40000
 #define MDP4_RGB_OFF 0x10000
@@ -43,13 +51,6 @@
 #define CS_CONTROLLER_0 0x0707ffff
 #define CS_CONTROLLER_1 0x03073f3f
 
-enum {
-	OVERLAY_PERF_LEVEL1 = 1,
-	OVERLAY_PERF_LEVEL2,
-	OVERLAY_PERF_LEVEL3,
-	OVERLAY_PERF_LEVEL4
-};
-
 typedef int (*cmd_fxn_t)(struct platform_device *pdev);
 
 enum {		
@@ -93,6 +94,12 @@
 #define MDP4_PANEL_WRITEBACK		BIT(6)
 
 enum {
+	OVERLAY_BLT_SWITCH_TG_OFF = 0,
+	OVERLAY_BLT_SWITCH_TG_ON,
+	OVERLAY_BLT_ALWAYS_ON
+};
+
+enum {
 	OVERLAY_MODE_NONE,
 	OVERLAY_MODE_BLT
 };
@@ -114,15 +121,11 @@
 #define INTR_DMA_S_DONE			BIT(2)
 #define INTR_DMA_E_DONE			BIT(3)
 #define INTR_DMA_P_DONE			BIT(4)
-#define INTR_VG1_HISTOGRAM		BIT(5)
-#define INTR_VG2_HISTOGRAM		BIT(6)
 #define INTR_PRIMARY_VSYNC		BIT(7)
 #define INTR_PRIMARY_INTF_UDERRUN	BIT(8)
 #define INTR_EXTERNAL_VSYNC		BIT(9)
 #define INTR_EXTERNAL_INTF_UDERRUN	BIT(10)
 #define INTR_PRIMARY_RDPTR		BIT(11)	
-#define INTR_DMA_P_HISTOGRAM		BIT(17)
-#define INTR_DMA_S_HISTOGRAM		BIT(26)
 #define INTR_OVERLAY2_DONE		BIT(30)
 
 #ifdef CONFIG_FB_MSM_OVERLAY
@@ -184,6 +187,8 @@
 	MDP4_CHROMA_420
 };
 
+#define CSC_MAX_BLOCKS 6
+
 #define MDP4_BLEND_BG_TRANSP_EN		BIT(9)
 #define MDP4_BLEND_FG_TRANSP_EN		BIT(8)
 #define MDP4_BLEND_BG_MOD_ALPHA		BIT(7)
@@ -212,6 +217,7 @@
 #define MDP4_OP_FLIP_UD		BIT(14)
 #define MDP4_OP_FLIP_LR		BIT(13)
 #define MDP4_OP_CSC_EN		BIT(11)
+#define MDP4_OP_DST_DATA_YCBCR	BIT(10)
 #define MDP4_OP_SRC_DATA_YCBCR	BIT(9)
 #define MDP4_OP_SCALEY_FIR 		(0 << 4)
 #define MDP4_OP_SCALEY_MN_PHASE 	(1 << 4)
@@ -234,7 +240,12 @@
 
 #define MDP4_MAX_PLANE		4
 #define VSYNC_PERIOD		16
-#define VSYNC_PERIOD_1080P24	35
+
+#ifdef BLT_RGB565
+#define BLT_BPP 2
+#else
+#define BLT_BPP 3
+#endif
 
 struct mdp4_hsic_regs {
 	int32_t params[NUM_HSIC_PARAM];
@@ -255,7 +266,6 @@
 #define IOMMU_FREE_LIST_MAX 32
 
 struct iommu_free_list {
-	int total;
 	int fndx;
 	struct ion_handle *ihdl[IOMMU_FREE_LIST_MAX];
 };
@@ -284,6 +294,8 @@
 	uint32 src_format;
 	uint32 src_width;	
 	uint32 src_height;	
+	uint32 prev_src_width;	
+	uint32 prev_src_height;	
 	uint32 is_3d;
 	uint32 src_width_3d;	
 	uint32 src_height_3d;	
@@ -295,6 +307,7 @@
 	uint32 dst_h;		
 	uint32 dst_x;		
 	uint32 dst_y;		
+	uint32 dst_format;
 	uint32 flags;
 	uint32 op_mode;
 	uint32 transp;
@@ -305,10 +318,16 @@
 	uint32 is_fg;		
 	uint32 srcp0_addr;	
 	uint32 srcp0_ystride;
+	struct file *srcp0_file;
+	int put0_need;
 	uint32 srcp1_addr;	
 	uint32 srcp1_ystride;
+	struct file *srcp1_file;
+	int put1_need;
 	uint32 srcp2_addr;	
 	uint32 srcp2_ystride;
+	struct file *srcp2_file;
+	int put2_need;
 	uint32 srcp3_addr;	
 	uint32 srcp3_ystride;
 	uint32 fetch_plane;
@@ -340,15 +359,16 @@
 	uint32 ov_cnt;
 	uint32 dmap_cnt;
 	uint32 dmae_cnt;
-	uint32 blt_end;	
+	uint32 blt_end;
 	uint32 blt_ov_koff;
 	uint32 blt_ov_done;
 	uint32 blt_dmap_koff;
 	uint32 blt_dmap_done;
 	uint32 req_clk;
-	uint32 req_bw;
+	uint64 bw_ab_quota;
+	uint64 bw_ib_quota;
 	uint32 luma_align_size;
-	struct mdp4_hsic_regs hsic_regs;
+	struct mdp_overlay_pp_params pp_cfg;
 	struct mdp_overlay req_data;
 	struct completion comp;
 	struct completion dmas_comp;
@@ -378,6 +398,7 @@
 	ulong intr_dsi_err;
 	ulong kickoff_ov0;
 	ulong kickoff_ov1;
+	ulong kickoff_ov2;
 	ulong kickoff_dmap;
 	ulong kickoff_dmae;
 	ulong kickoff_dmas;
@@ -433,15 +454,11 @@
 void mdp4_intr_clear_set(ulong clear, ulong set);
 void mdp4_dma_p_cfg(void);
 unsigned is_mdp4_hw_reset(void);
-void mdp4_overlay_cfg_init(void);
 void mdp4_hw_init(void);
 void mdp4_isr_read(int);
 void mdp4_clear_lcdc(void);
 void mdp4_mixer_blend_init(int mixer_num);
 void mdp4_vg_qseed_init(int vg_num);
-void mdp4_vg_csc_setup(int vp_num);
-void mdp4_mixer_csc_setup(uint32 mixer);
-void mdp4_dmap_csc_setup(void);
 void mdp4_vg_csc_update(struct mdp_csc *p);
 irqreturn_t mdp4_isr(int irq, void *ptr);
 void mdp4_overlay_format_to_pipe(uint32 format, struct mdp4_overlay_pipe *pipe);
@@ -463,9 +480,11 @@
 int mdp4_overlay_dtv_unset(struct msm_fb_data_type *mfd,
 			struct mdp4_overlay_pipe *pipe);
 void mdp4_dmae_done_dtv(void);
-void mdp4_dtv_wait4vsync(int cndx, long long *vtime);
+void mdp4_dtv_wait4vsync(int cndx);
 void mdp4_dtv_vsync_ctrl(struct fb_info *info, int enable);
 void mdp4_dtv_base_swap(int cndx, struct mdp4_overlay_pipe *pipe);
+void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
+int mdp4_dtv_pipe_commit(int cndx, int wait);
 #else
 static inline void mdp4_overlay_dtv_start(void)
 {
@@ -496,7 +515,7 @@
 {
     
 }
-static inline void mdp4_dtv_wait4vsync(int cndx, long long *vtime)
+static inline void mdp4_dtv_wait4vsync(int cndx)
 {
     
 }
@@ -516,6 +535,14 @@
 {
 	
 }
+static inline void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
+{
+	
+}
+static inline int mdp4_dtv_pipe_commit(int cndx, int wait)
+{
+	return 0;
+}
 #endif 
 
 void mdp4_dtv_set_black_screen(void);
@@ -532,13 +559,16 @@
 int mdp4_atv_off(struct platform_device *pdev);
 void mdp4_dsi_video_fxn_register(cmd_fxn_t fxn);
 void mdp4_dsi_video_overlay(struct msm_fb_data_type *mfd);
+void mdp4_overlay_free_base_pipe(struct msm_fb_data_type *mfd);
 void mdp4_lcdc_vsync_ctrl(struct fb_info *info, int enable);
 void mdp4_overlay0_done_dsi_video(int cndx);
 void mdp4_overlay0_done_dsi_cmd(int cndx);
 void mdp4_primary_rdptr(void);
 void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd);
+int mdp4_overlay_commit(struct fb_info *info);
+int mdp4_dsi_video_pipe_commit(int cndx, int wait);
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait);
 int mdp4_lcdc_pipe_commit(int cndx, int wait);
-int mdp4_dtv_pipe_commit(int cndx, int wait);
 int mdp4_dsi_cmd_update_cnt(int cndx);
 void mdp4_dsi_rdptr_init(int cndx);
 void mdp4_dsi_vsync_init(int cndx);
@@ -548,6 +578,8 @@
 	struct device_attribute *attr, char *buf);
 ssize_t mdp4_dsi_video_show_event(struct device *dev,
 	struct device_attribute *attr, char *buf);
+ssize_t mdp4_lcdc_show_event(struct device *dev,
+	struct device_attribute *attr, char *buf);
 ssize_t mdp4_dtv_show_event(struct device *dev,
 	struct device_attribute *attr, char *buf);
 void mdp4_overlay_dsi_state_set(int state);
@@ -555,6 +587,7 @@
 void mdp4_overlay_rgb_setup(struct mdp4_overlay_pipe *pipe);
 void mdp4_overlay_reg_flush(struct mdp4_overlay_pipe *pipe, int all);
 void mdp4_mixer_blend_setup(int mixer);
+void mdp4_mixer_blend_cfg(int);
 struct mdp4_overlay_pipe *mdp4_overlay_stage_pipe(int mixer, int stage);
 void mdp4_mixer_stage_up(struct mdp4_overlay_pipe *pipe, int commit);
 void mdp4_mixer_stage_down(struct mdp4_overlay_pipe *pipe, int commit);
@@ -566,22 +599,20 @@
 int mdp4_overlay_format2pipe(struct mdp4_overlay_pipe *pipe);
 int mdp4_overlay_get(struct fb_info *info, struct mdp_overlay *req);
 int mdp4_overlay_set(struct fb_info *info, struct mdp_overlay *req);
-int mdp4_overlay_wait4vsync(struct fb_info *info, long long *vtime);
+int mdp4_overlay_wait4vsync(struct fb_info *info);
 int mdp4_overlay_vsync_ctrl(struct fb_info *info, int enable);
 int mdp4_overlay_unset(struct fb_info *info, int ndx);
 int mdp4_overlay_unset_mixer(int mixer);
 int mdp4_overlay_play_wait(struct fb_info *info,
 	struct msmfb_overlay_data *req);
 int mdp4_overlay_play(struct fb_info *info, struct msmfb_overlay_data *req);
-int mdp4_overlay_commit(struct fb_info *info);
 struct mdp4_overlay_pipe *mdp4_overlay_pipe_alloc(int ptype, int mixer);
 void mdp4_overlay_dma_commit(int mixer);
 void mdp4_overlay_vsync_commit(struct mdp4_overlay_pipe *pipe);
 void mdp4_mixer_stage_commit(int mixer);
 void mdp4_dsi_cmd_do_update(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_lcdc_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
-void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
-void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe);
+void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe, int all);
 void mdp4_overlay_dmap_cfg(struct msm_fb_data_type *mfd, int lcdc);
 void mdp4_overlay_dmap_xy(struct mdp4_overlay_pipe *pipe);
 void mdp4_overlay_dmae_cfg(struct msm_fb_data_type *mfd, int atv);
@@ -598,10 +629,11 @@
 void mdp4_overlay1_done_atv(void);
 void mdp4_primary_vsync_lcdc(void);
 void mdp4_external_vsync_dtv(void);
-void mdp4_lcdc_wait4vsync(int cndx, long long *vtime);
+void mdp4_lcdc_wait4vsync(int cndx);
 void mdp4_overlay_lcdc_vsync_push(struct msm_fb_data_type *mfd,
 				struct mdp4_overlay_pipe *pipe);
 void mdp4_mddi_overlay_dmas_restore(void);
+void mdp4_overlay_solidfill_init(struct mdp4_overlay_pipe *pipe);
 
 #ifndef CONFIG_FB_MSM_MIPI_DSI
 void mdp4_mddi_dma_busy_wait(struct msm_fb_data_type *mfd);
@@ -665,6 +697,10 @@
 void mdp4_dsi_video_overlay_blt(struct msm_fb_data_type *mfd,
 					struct msmfb_overlay_blt *req);
 void mdp4_dsi_video_base_swap(int cndx, struct mdp4_overlay_pipe *pipe);
+void mdp4_dsi_video_free_base_pipe(struct msm_fb_data_type *mfd);
+void mdp4_dsi_cmd_free_base_pipe(struct msm_fb_data_type *mfd);
+void mdp4_lcdc_free_base_pipe(struct msm_fb_data_type *mfd);
+void mdp4_dtv_free_base_pipe(struct msm_fb_data_type *mfd);
 
 #ifdef CONFIG_FB_MSM_MDP40
 static inline void mdp3_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd)
@@ -718,11 +754,9 @@
 }
 static inline void mdp4_dsi_cmd_blt_start(struct msm_fb_data_type *mfd)
 {
-	
 }
 static inline void mdp4_dsi_cmd_blt_stop(struct msm_fb_data_type *mfd)
 {
-	
 }
 #endif  
 
@@ -751,19 +785,18 @@
 
 
 #ifdef CONFIG_FB_MSM_MIPI_DSI
-void mdp_dsi_cmd_overlay_suspend(struct msm_fb_data_type *mfd);
 int mdp4_dsi_cmd_on(struct platform_device *pdev);
 int mdp4_dsi_cmd_off(struct platform_device *pdev);
 int mdp4_dsi_video_off(struct platform_device *pdev);
 int mdp4_dsi_video_on(struct platform_device *pdev);
+int mdp4_dsi_video_splash_done(void);
 void mdp4_primary_vsync_dsi_video(void);
 void mdp4_dsi_cmd_base_swap(int cndx, struct mdp4_overlay_pipe *pipe);
-void mdp4_dsi_cmd_wait4vsync(int cndx, long long *vtime);
-void mdp4_dsi_video_wait4vsync(int cndx, long long *vtime);
+void mdp4_dsi_cmd_wait4vsync(int cndx);
+void mdp4_dsi_video_wait4vsync(int cndx);
+void mdp4_mixer_reset(int mixer);
 void mdp4_dsi_cmd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_dsi_video_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
-int mdp4_dsi_video_pipe_commit(int cndx, int wait);
-int mdp4_dsi_cmd_pipe_commit(int cndx, int wait);
 void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info, int enable);
 void mdp4_dsi_video_vsync_ctrl(struct fb_info *info, int enable);
 #ifdef CONFIG_FB_MSM_MDP303
@@ -799,10 +832,10 @@
 	struct mdp4_overlay_pipe *pipe)
 {
 }
-static inline void mdp4_dsi_cmd_wait4vsync(int cndx, long long *vtime)
+static inline void mdp4_dsi_cmd_wait4vsync(int cndx)
 {
 }
-static inline void mdp4_dsi_video_wait4vsync(int cndx, long long *vtime)
+static inline void mdp4_dsi_video_wait4vsync(int cndx)
 {
 }
 static inline void mdp4_dsi_cmd_pipe_queue(int cndx,
@@ -813,16 +846,8 @@
 			struct mdp4_overlay_pipe *pipe)
 {
 }
-static inline int mdp4_dsi_video_pipe_commit(int cndx, int wait)
-{
-	return 0;
-}
-static inline int mdp4_dsi_cmd_pipe_commit(int cndx, int wait)
-{
-	return 0;
-}
 static inline void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info,
-					int enable)
+				int enable)
 {
 }
 static inline void mdp4_dsi_video_vsync_ctrl(struct fb_info *info,
@@ -834,12 +859,10 @@
 {
 	
 }
-#ifdef CONFIG_FB_MSM_MDP40
-static inline void mdp_dsi_cmd_overlay_suspend(struct msm_fb_data_type *mfd)
+
+static int mdp4_dsi_video_splash_done(void)
 {
-	
 }
-#endif
 #endif 
 
 void mdp4_dsi_cmd_kickoff_ui(struct msm_fb_data_type *mfd,
@@ -879,10 +902,7 @@
 int mdp4_overlay_writeback_on(struct platform_device *pdev);
 int mdp4_overlay_writeback_off(struct platform_device *pdev);
 void mdp4_writeback_overlay(struct msm_fb_data_type *mfd);
-void mdp4_writeback_kickoff_video(struct msm_fb_data_type *mfd,
-		struct mdp4_overlay_pipe *pipe);
-void mdp4_writeback_dma_busy_wait(struct msm_fb_data_type *mfd);
-void mdp4_overlay1_done_writeback(struct mdp_dma_data *dma);
+void mdp4_overlay2_done_wfd(struct mdp_dma_data *dma);
 
 int mdp4_writeback_start(struct fb_info *info);
 int mdp4_writeback_stop(struct fb_info *info);
@@ -893,12 +913,13 @@
 void mdp4_writeback_dma_stop(struct msm_fb_data_type *mfd);
 int mdp4_writeback_init(struct fb_info *info);
 int mdp4_writeback_terminate(struct fb_info *info);
-void mdp4_set_limit_range(bool set_limit_range);
+int mdp4_writeback_set_mirroring_hint(struct fb_info *info, int hint);
+int mdp4_writeback_play(struct fb_info *info, struct msmfb_overlay_data *req);
+void mdp4_writeback_play_kickoff(struct msm_fb_data_type *mfd, struct mdp4_overlay_pipe *pipe);
 
 uint32_t mdp_block2base(uint32_t block);
 int mdp_hist_lut_config(struct mdp_hist_lut_data *data);
 
-void mdp4_hsic_set(struct mdp4_overlay_pipe *pipe, struct dpp_ctrl *ctrl);
 void mdp4_hsic_update(struct mdp4_overlay_pipe *pipe);
 int mdp4_csc_config(struct mdp_csc_cfg_data *config);
 void mdp4_csc_write(struct mdp_csc_cfg *data, uint32_t base);
@@ -906,6 +927,8 @@
 int mdp4_pcc_cfg(struct mdp_pcc_cfg_data *cfg_ptr);
 int mdp4_argc_cfg(struct mdp_pgc_lut_data *pgc_ptr);
 int mdp4_qseed_cfg(struct mdp_qseed_cfg_data *cfg);
+int mdp4_calib_config(struct mdp_calib_config_data *cfg);
+int mdp4_qseed_access_cfg(struct mdp_qseed_cfg *cfg, uint32_t base);
 u32  mdp4_allocate_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
 void mdp4_init_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
 void mdp4_free_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
@@ -925,9 +948,39 @@
 	unsigned long srcp2_addr);
 int mdp4_overlay_mdp_pipe_req(struct mdp4_overlay_pipe *pipe,
 			      struct msm_fb_data_type *mfd);
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
-			      struct mdp4_overlay_pipe *plist);
+int mdp4_calc_blt_mdp_bw(struct msm_fb_data_type *mfd,
+			 struct mdp4_overlay_pipe *pipe);
+int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd);
 void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd, int flag);
+int mdp4_overlay_reset(void);
+void mdp4_vg_csc_restore(void);
 
-void mdp4_overlay_mdp_perf_dump(void);
+#ifndef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
+static inline void mdp4_wfd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
+{
+	
+}
+static inline void mdp4_wfd_init(int cndx)
+{
+	
+}
+static inline int mdp4_wfd_pipe_commit(struct msm_fb_data_type *mfd,
+					int cndx, int wait)
+{
+	return 0;
+}
+#else
+void mdp4_wfd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
+void mdp4_wfd_init(int cndx);
+int mdp4_wfd_pipe_commit(struct msm_fb_data_type *mfd, int cndx, int wait);
+#endif
+#ifdef CONFIG_FB_MSM_OVERLAY
+int mdp4_unmap_sec_resource(struct msm_fb_data_type *mfd);
+#else
+static inline void mdp4_unmap_sec_resource(struct msm_fb_data_type *mfd);
+{
+	
+	return 0;
+}
+#endif
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_hsic.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_hsic.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_hsic.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_hsic.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,485 +0,0 @@
-/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/msm_mdp.h>
-#include "mdp.h"
-#include "mdp4.h"
-
-#define MDP4_CSC_MV_OFF		0x4400
-#define MDP4_CSC_PRE_BV_OFF	0x4500
-#define MDP4_CSC_POST_BV_OFF	0x4580
-#define MDP4_CSC_PRE_LV_OFF	0x4600
-#define MDP4_CSC_POST_LV_OFF	0x4680
-#define MDP_VG1_BASE	(MDP_BASE + MDP4_VIDEO_BASE)
-
-#define MDP_VG1_CSC_MVn(n)	(MDP_VG1_BASE + MDP4_CSC_MV_OFF + 4 * (n))
-#define MDP_VG1_CSC_PRE_LVn(n)	(MDP_VG1_BASE + MDP4_CSC_PRE_LV_OFF + 4 * (n))
-#define MDP_VG1_CSC_POST_LVn(n)	(MDP_VG1_BASE + MDP4_CSC_POST_LV_OFF + 4 * (n))
-#define MDP_VG1_CSC_PRE_BVn(n)	(MDP_VG1_BASE + MDP4_CSC_PRE_BV_OFF + 4 * (n))
-#define MDP_VG1_CSC_POST_BVn(n)	(MDP_VG1_BASE + MDP4_CSC_POST_BV_OFF + 4 * (n))
-
-#define Q16	(16)
-#define Q16_ONE	(1 << Q16)
-
-#define Q16_VALUE(x)	((int32_t)((uint32_t)x << Q16))
-#define Q16_PERCENT_VALUE(x, n)	((int32_t)( \
-				div_s64(((int64_t)x * (int64_t)Q16_ONE), n)))
-
-#define Q16_WHOLE(x)	((int32_t)(x >> 16))
-#define Q16_FRAC(x)	((int32_t)(x & 0xFFFF))
-#define Q16_S1Q16_MUL(x, y)	(((x >> 1) * (y >> 1)) >> 14)
-
-#define Q16_MUL(x, y)	((int32_t)((((int64_t)x) * ((int64_t)y)) >> Q16))
-#define Q16_NEGATE(x)	(0 - (x))
-
-#define TRIG_MAX	Q16_VALUE(128)
-#define CON_SAT_MAX	Q16_VALUE(128)
-#define INTENSITY_MAX	(Q16_VALUE(2047) >> 12)
-
-#define HUE_MAX	Q16_VALUE(100)
-#define HUE_MIN	Q16_VALUE(-100)
-#define HUE_DEF	Q16_VALUE(0)
-
-#define SAT_MAX	Q16_VALUE(100)
-#define SAT_MIN	Q16_VALUE(-100)
-#define SAT_DEF	CON_SAT_MAX
-
-#define CON_MAX	Q16_VALUE(100)
-#define CON_MIN	Q16_VALUE(-100)
-#define CON_DEF	CON_SAT_MAX
-
-#define INTEN_MAX	Q16_VALUE(100)
-#define INTEN_MIN	Q16_VALUE(-100)
-#define INTEN_DEF	Q16_VALUE(0)
-
-enum {
-	DIRTY,
-	GENERATED,
-	CLEAN
-};
-
-static int32_t csc_matrix_tab[3][3] = {
-	{0x00012a00, 0x00000000, 0x00019880},
-	{0x00012a00, 0xffff9b80, 0xffff3000},
-	{0x00012a00, 0x00020480, 0x00000000}
-};
-
-static int32_t csc_yuv2rgb_conv_tab[3][3] = {
-	{0x00010000, 0x00000000, 0x000123cb},
-	{0x00010000, 0xffff9af9, 0xffff6b5e},
-	{0x00010000, 0x00020838, 0x00000000}
-};
-
-static int32_t csc_rgb2yuv_conv_tab[3][3] = {
-	{0x00004c8b, 0x00009645, 0x00001d2f},
-	{0xffffda56, 0xffffb60e, 0x00006f9d},
-	{0x00009d70, 0xffff7c2a, 0xffffe666}
-};
-
-static uint32_t csc_pre_bv_tab[3]  = {0xfffff800, 0xffffc000, 0xffffc000};
-static uint32_t csc_post_bv_tab[3] = {0x00000000, 0x00000000, 0x00000000};
-
-static uint32_t csc_pre_lv_tab[6] =  {0x00000000, 0x00007f80, 0x00000000,
-					0x00007f80, 0x00000000, 0x00007f80};
-static uint32_t csc_post_lv_tab[6] = {0x00000000, 0x00007f80, 0x00000000,
-					0x00007f80, 0x00000000, 0x00007f80};
-
-static const int32_t  trig_lut[65] = {
-	0x00000000, 
-	0x00000648, 
-	0x00000C90, 
-	0x000012D5,
-	0x00001918,
-	0x00001F56,
-	0x00002590,
-	0x00002BC4,
-	0x000031F1,
-	0x00003817,
-	0x00003E34,
-	0x00004447,
-	0x00004A50,
-	0x0000504D,
-	0x0000563E,
-	0x00005C22,
-	0x000061F8,
-	0x000067BE,
-	0x00006D74,
-	0x0000731A,
-	0x000078AD,
-	0x00007E2F,
-	0x0000839C,
-	0x000088F6,
-	0x00008E3A,
-	0x00009368,
-	0x00009880,
-	0x00009D80,
-	0x0000A268,
-	0x0000A736,
-	0x0000ABEB,
-	0x0000B086,
-	0x0000B505,
-	0x0000B968,
-	0x0000BDAF,
-	0x0000C1D8,
-	0x0000C5E4,
-	0x0000C9D1,
-	0x0000CD9F,
-	0x0000D14D,
-	0x0000D4DB,
-	0x0000D848,
-	0x0000DB94,
-	0x0000DEBE,
-	0x0000E1C6,
-	0x0000E4AA,
-	0x0000E768,
-	0x0000EA0A,
-	0x0000EC83,
-	0x0000EED9,
-	0x0000F109,
-	0x0000F314,
-	0x0000F4FA,
-	0x0000F6BA,
-	0x0000F854,
-	0x0000F9C8,
-	0x0000FB15,
-	0x0000FC3B,
-	0x0000FD3B,
-	0x0000FE13,
-	0x0000FEC4,
-	0x0000FF4E,
-	0x0000FFB1,
-	0x0000FFEC,
-	0x00010000, 
-};
-
-void trig_values_q16(int32_t deg, int32_t *cos, int32_t *sin)
-{
-	int32_t   angle;
-	int32_t   quad, anglei, anglef;
-	int32_t   v0 = 0, v1 = 0;
-	int32_t   t1, t2;
-
-	angle = Q16_MUL(deg, 0xB60B) & 0x00FFFFFF;
-
-	
-	quad   =  angle >> 22;
-	anglei = (angle >> 16) & 0x3F;
-	anglef =  angle & 0xFFFF;
-
-	switch (quad) {
-	case 0x0:
-		v0 += trig_lut[anglei];
-		v1 += trig_lut[0x40-anglei];
-		break;
-
-	case 0x1:
-		v0 += trig_lut[0x40-anglei];
-		v1 -= trig_lut[anglei];
-		break;
-
-	case 0x2:
-		v0 -= trig_lut[anglei];
-		v1 -= trig_lut[0x40-anglei];
-		break;
-
-	case 0x3:
-		v0 -= trig_lut[0x40-anglei];
-		v1 += trig_lut[anglei];
-		break;
-	}
-
-	t1 = Q16_S1Q16_MUL(anglef, 0x0648);
-
-	t2 = Q16_S1Q16_MUL(t1, t1) >> 1;
-
-	*sin = v0 + Q16_S1Q16_MUL(v1, t1) - Q16_S1Q16_MUL(v0, t2);
-
-	*cos = v1 - Q16_S1Q16_MUL(v0, t1) - Q16_S1Q16_MUL(v1, t2);
-}
-
-int16_t convert_q16_s49(int32_t q16Value)
-{	
-	int16_t whole = Q16_WHOLE(q16Value);
-	int32_t fraction  = Q16_FRAC(q16Value);
-
-	
-	if (whole > 7)
-		whole = 7;
-	else if (whole < -7)
-		whole = -7;
-
-	
-	fraction = (fraction<<9)>>Q16;
-
-	return (int16_t) ((int16_t)whole<<9) | ((int16_t)fraction);
-}
-
-int16_t convert_q16_int16(int32_t val)
-{
-	int32_t rounded;
-
-	if (val >= 0) {
-		
-		rounded = val + (Q16_ONE>>1);
-	} else {
-		
-		rounded = val - (Q16_ONE>>1);
-	}
-
-	
-	return (int16_t)(rounded>>Q16);
-}
-
-int32_t norm_q16(int32_t value, int32_t min, int32_t default_val, int32_t max,
-								int32_t range)
-{
-	int32_t diff, perc, mul, result;
-
-	if (0 == value) {
-		result = default_val;
-	} else if (value > 0) {
-		
-		diff = range;
-		perc = Q16_PERCENT_VALUE(value, max);
-		mul = Q16_MUL(perc, diff);
-		result = default_val + mul;
-	} else {
-		
-		diff = -range;
-		perc = Q16_PERCENT_VALUE(-value, -min);
-		mul = Q16_MUL(perc, diff);
-		result = default_val + mul;
-	}
-	return result;
-}
-
-void matrix_mul_3x3(int32_t dest[][3], int32_t a[][3], int32_t b[][3])
-{
-	int32_t i, j, k;
-	int32_t tmp[3][3];
-
-	for (i = 0; i < 3; i++) {
-		for (j = 0; j < 3; j++) {
-			tmp[i][j] = 0;
-			for (k = 0; k < 3; k++)
-				tmp[i][j] += Q16_MUL(a[i][k], b[k][j]);
-		}
-	}
-
-	
-	for (i = 0; i < 3; i++) {
-		for (j = 0; j < 3; j++)
-			dest[i][j] = tmp[i][j];
-	}
-}
-
-#define CONVERT(x)	(x)
-void pr_params(struct mdp4_hsic_regs *regs)
-{
-	int i;
-	if (regs) {
-		for (i = 0; i < NUM_HSIC_PARAM; i++) {
-			pr_info("\t: hsic->params[%d] =	0x%08x [raw = 0x%08x]\n",
-			i, CONVERT(regs->params[i]), regs->params[i]);
-		}
-	}
-}
-
-void pr_3x3_matrix(int32_t in[][3])
-{
-	pr_info("\t[0x%08x\t0x%08x\t0x%08x]\n", CONVERT(in[0][0]),
-	CONVERT(in[0][1]), CONVERT(in[0][2]));
-	pr_info("\t[0x%08x\t0x%08x\t0x%08x]\n", CONVERT(in[1][0]),
-	CONVERT(in[1][1]), CONVERT(in[1][2]));
-	pr_info("\t[0x%08x\t0x%08x\t0x%08x]\n", CONVERT(in[2][0]),
-	CONVERT(in[2][1]), CONVERT(in[2][2]));
-}
-
-void _hsic_get(struct mdp4_hsic_regs *regs, int32_t type, int8_t *val)
-{
-	if (type < 0 || type >= NUM_HSIC_PARAM)
-		BUG_ON(-EINVAL);
-	*val = regs->params[type];
-	pr_info("%s: getting params[%d] = %d\n", __func__, type, *val);
-}
-
-void _hsic_set(struct mdp4_hsic_regs *regs, int32_t type, int8_t val)
-{
-	if (type < 0 || type >= NUM_HSIC_PARAM)
-		BUG_ON(-EINVAL);
-
-	if (regs->params[type] != Q16_VALUE(val)) {
-		regs->params[type] = Q16_VALUE(val);
-		regs->dirty = DIRTY;
-	}
-}
-
-void _hsic_generate_csc_matrix(struct mdp4_overlay_pipe *pipe)
-{
-	int i, j;
-	int32_t sin, cos;
-
-	int32_t hue_matrix[3][3];
-	int32_t con_sat_matrix[3][3];
-	struct mdp4_hsic_regs *regs = &(pipe->hsic_regs);
-
-	memset(con_sat_matrix, 0x0, sizeof(con_sat_matrix));
-	memset(hue_matrix, 0x0, sizeof(hue_matrix));
-
-
-	con_sat_matrix[0][0] = norm_q16(regs->params[HSIC_CON], CON_MIN,
-						CON_DEF, CON_MAX, CON_SAT_MAX);
-	con_sat_matrix[1][1] = norm_q16(regs->params[HSIC_SAT], SAT_MIN,
-						SAT_DEF, SAT_MAX, CON_SAT_MAX);
-	con_sat_matrix[2][2] = con_sat_matrix[1][1];
-
-	hue_matrix[0][0] = TRIG_MAX;
-
-	trig_values_q16(norm_q16(regs->params[HSIC_HUE], HUE_MIN, HUE_DEF,
-					 HUE_MAX, TRIG_MAX), &cos, &sin);
-
-	cos = Q16_MUL(cos, TRIG_MAX);
-	sin = Q16_MUL(sin, TRIG_MAX);
-
-	hue_matrix[1][1] = cos;
-	hue_matrix[2][2] = cos;
-	hue_matrix[2][1] = sin;
-	hue_matrix[1][2] = Q16_NEGATE(sin);
-
-	
-	matrix_mul_3x3(regs->conv_matrix, con_sat_matrix, hue_matrix);
-
-	if (!(pipe->op_mode & MDP4_OP_SRC_DATA_YCBCR)) {
-		
-		pr_info("Pipe %d, has RGB input\n", pipe->pipe_num);
-		matrix_mul_3x3(regs->conv_matrix, regs->conv_matrix,
-							csc_rgb2yuv_conv_tab);
-	}
-
-	
-	for (i = 0; i < 3; i++) {
-		for (j = 0; j < 3; j++)
-			regs->conv_matrix[i][j] = (regs->conv_matrix[i][j]>>14);
-	}
-
-	
-	matrix_mul_3x3(regs->conv_matrix, regs->conv_matrix, csc_matrix_tab);
-
-	if (!(pipe->op_mode & MDP4_OP_SRC_DATA_YCBCR)) {
-		
-		
-		pr_info("Pipe %d, has RGB output\n", pipe->pipe_num);
-		matrix_mul_3x3(regs->conv_matrix, csc_yuv2rgb_conv_tab,
-							regs->conv_matrix);
-	}
-
-	
-	
-	for (i = 0; i < 6; i++) {
-		regs->pre_limit[i] = csc_pre_lv_tab[i];
-		regs->post_limit[i] = csc_post_lv_tab[i];
-	}
-
-	
-	for (i = 0; i < 3; i++) {
-		regs->pre_bias[i] = csc_pre_bv_tab[i];
-		regs->post_bias[i] = csc_post_bv_tab[i] +
-				norm_q16(regs->params[HSIC_INT],
-				INTEN_MIN, INTEN_DEF, INTEN_MAX, INTENSITY_MAX);
-	}
-
-	regs->dirty = GENERATED;
-}
-
-void _hsic_update_mdp(struct mdp4_overlay_pipe *pipe)
-{
-	struct mdp4_hsic_regs *regs = &(pipe->hsic_regs);
-	int i, j, k;
-
-	uint32_t *csc_mv;
-	uint32_t *pre_lv;
-	uint32_t *post_lv;
-	uint32_t *pre_bv;
-	uint32_t *post_bv;
-
-	switch (pipe->pipe_num) {
-	case OVERLAY_PIPE_VG2:
-		csc_mv = (uint32_t *) (MDP_VG1_CSC_MVn(0) +
-					MDP4_VIDEO_OFF);
-		pre_lv = (uint32_t *) (MDP_VG1_CSC_PRE_LVn(0) +
-					MDP4_VIDEO_OFF);
-		post_lv = (uint32_t *) (MDP_VG1_CSC_POST_LVn(0) +
-					MDP4_VIDEO_OFF);
-		pre_bv = (uint32_t *) (MDP_VG1_CSC_PRE_BVn(0) +
-					MDP4_VIDEO_OFF);
-		post_bv = (uint32_t *) (MDP_VG1_CSC_POST_BVn(0) +
-					MDP4_VIDEO_OFF);
-		break;
-	case OVERLAY_PIPE_VG1:
-	default:
-			csc_mv = (uint32_t *) MDP_VG1_CSC_MVn(0);
-			pre_lv = (uint32_t *) MDP_VG1_CSC_PRE_LVn(0);
-			post_lv = (uint32_t *) MDP_VG1_CSC_POST_LVn(0);
-			pre_bv = (uint32_t *) MDP_VG1_CSC_PRE_BVn(0);
-			post_bv = (uint32_t *) MDP_VG1_CSC_POST_BVn(0);
-		break;
-	}
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
-	for (i = 0; i < 3; i++) {
-		for (j = 0; j < 3; j++) {
-			k = (3*i) + j;
-			MDP_OUTP(csc_mv + k, convert_q16_s49(
-						regs->conv_matrix[i][j]));
-		}
-	}
-
-	for (i = 0; i < 6; i++) {
-		MDP_OUTP(pre_lv + i, convert_q16_s49(regs->pre_limit[i]));
-		MDP_OUTP(post_lv + i, convert_q16_s49(regs->post_limit[i]));
-	}
-
-	for (i = 0; i < 3; i++) {
-		MDP_OUTP(pre_bv + i, convert_q16_s49(regs->pre_bias[i]));
-		MDP_OUTP(post_bv + i, convert_q16_s49(regs->post_bias[i]));
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-
-	regs->dirty = CLEAN;
-}
-
-void mdp4_hsic_get(struct mdp4_overlay_pipe *pipe, struct dpp_ctrl *ctrl)
-{
-	int i;
-	for (i = 0; i < NUM_HSIC_PARAM; i++)
-		_hsic_get(&(pipe->hsic_regs), i, &(ctrl->hsic_params[i]));
-}
-
-void mdp4_hsic_set(struct mdp4_overlay_pipe *pipe, struct dpp_ctrl *ctrl)
-{
-	int i;
-	for (i = 0; i < NUM_HSIC_PARAM; i++)
-		_hsic_set(&(pipe->hsic_regs), i, ctrl->hsic_params[i]);
-
-	if (pipe->hsic_regs.dirty == DIRTY)
-		_hsic_generate_csc_matrix(pipe);
-}
-
-void mdp4_hsic_update(struct mdp4_overlay_pipe *pipe)
-{
-	if (pipe->hsic_regs.dirty == GENERATED)
-		_hsic_update_mdp(pipe);
-}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,5 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/*
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -40,6 +41,7 @@
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mdp4.h"
+#include <mach/debug_display.h>
 
 #define VERSION_KEY_MASK	0xFFFFFF00
 
@@ -51,8 +53,9 @@
 	uint32 mixer_cfg[MDP4_MIXER_MAX];
 	uint32 flush[MDP4_MIXER_MAX];
 	struct iommu_free_list iommu_free[MDP4_MIXER_MAX];
+	struct iommu_free_list iommu_free_prev[MDP4_MIXER_MAX];
+	uint32 dmap_cfg[5];
 	uint32 cs_controller;
-	uint32 hw_version;
 	uint32 panel_3d;
 	uint32 panel_mode;
 	uint32 mixer0_played;
@@ -107,35 +110,115 @@
 
 struct mdp4_overlay_perf {
 	u32 mdp_clk_rate;
-	u32 use_ov0_blt;
-	u32 use_ov1_blt;
-	u32 mdp_bw;
-};
+	u32 use_ov_blt[MDP4_MIXER_MAX];
+	u64 mdp_ov_ab_bw[MDP4_MIXER_MAX];
+	u64 mdp_ov_ib_bw[MDP4_MIXER_MAX];
+	u64 mdp_ab_bw;
+	u64 mdp_ib_bw;
+	u64 mdp_ab_port0_bw;
+	u64 mdp_ib_port0_bw;
+	u64 mdp_ab_port1_bw;
+	u64 mdp_ib_port1_bw;
 
-struct mdp4_overlay_perf perf_request = {
-	.mdp_bw = OVERLAY_PERF_LEVEL4,
-};
-struct mdp4_overlay_perf perf_current = {
-	.mdp_bw = OVERLAY_PERF_LEVEL4,
 };
 
+struct mdp4_overlay_perf perf_request;
+struct mdp4_overlay_perf perf_current;
+
+void  mdp4_overlay_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	if (!hdmi_prim_display && mfd->index == 0) {
+		if (ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO)
+			mdp4_dsi_video_free_base_pipe(mfd);
+		else if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD)
+			mdp4_dsi_cmd_free_base_pipe(mfd);
+		else if (ctrl->panel_mode & MDP4_PANEL_LCDC)
+			mdp4_lcdc_free_base_pipe(mfd);
+	} else if (hdmi_prim_display || mfd->index == 1) {
+		mdp4_dtv_free_base_pipe(mfd);
+	}
+}
+
 static struct ion_client *display_iclient;
 
+static int mdp4_map_sec_resource(struct msm_fb_data_type *mfd)
+{
+	int ret = 0;
+
+	if (!mfd) {
+		pr_err("%s: mfd is invalid\n", __func__);
+		return -ENODEV;
+	}
+
+	pr_debug("%s %d mfd->index=%d,mapped=%d,active=%d\n",
+		__func__, __LINE__,
+		 mfd->index, mfd->sec_mapped, mfd->sec_active);
+
+	if (mfd->sec_mapped)
+		return 0;
+
+	ret = mdp_enable_iommu_clocks();
+	if (ret) {
+		pr_err("IOMMU clock enabled failed while open");
+		return ret;
+	}
+	ret = msm_ion_secure_heap(ION_HEAP(ION_CP_MM_HEAP_ID));
+	if (ret)
+		pr_err("ION heap secure failed heap id %d ret %d\n",
+			   ION_CP_MM_HEAP_ID, ret);
+	else
+		mfd->sec_mapped = 1;
+	mdp_disable_iommu_clocks();
+	return ret;
+}
+
+int mdp4_unmap_sec_resource(struct msm_fb_data_type *mfd)
+{
+	int ret = 0;
+
+	if (!mfd) {
+		pr_err("%s: mfd is invalid\n", __func__);
+		return -ENODEV;
+	}
+
+	if ((mfd->sec_mapped == 0) || (mfd->sec_active))
+		return 0;
+
+	pr_debug("%s %d mfd->index=%d,mapped=%d,active=%d\n",
+		__func__, __LINE__,
+		 mfd->index, mfd->sec_mapped, mfd->sec_active);
+
+	ret = mdp_enable_iommu_clocks();
+	if (ret) {
+		pr_err("IOMMU clock enabled failed while close\n");
+		return ret;
+	}
+	msm_ion_unsecure_heap(ION_HEAP(ION_CP_MM_HEAP_ID));
+	mfd->sec_mapped = 0;
+	mdp_disable_iommu_clocks();
+	return ret;
+}
 
 void mdp4_overlay_iommu_unmap_freelist(int mixer)
 {
 	int i;
 	struct ion_handle *ihdl;
-	struct iommu_free_list *flist;
+	struct iommu_free_list *flist, *pflist;
+
+	if (mixer >= MDP4_MIXER_MAX)
+		return;
 
 	mutex_lock(&iommu_mutex);
+
+	pflist = &ctrl->iommu_free_prev[mixer];
 	flist = &ctrl->iommu_free[mixer];
-	if (flist->total == 0) {
-		mutex_unlock(&iommu_mutex);
-		return;
+	pr_debug("%s: mixer=%d fndx=%d %d\n", __func__,
+			mixer, pflist->fndx, flist->fndx);
+	if (pflist->fndx == 0) {
+		goto flist_to_pflist;
 	}
 	for (i = 0; i < IOMMU_FREE_LIST_MAX; i++) {
-		ihdl = flist->ihdl[i];
+		ihdl = pflist->ihdl[i];
 		if (ihdl == NULL)
 			continue;
 		pr_debug("%s: mixer=%d i=%d ihdl=0x%p\n", __func__,
@@ -147,11 +230,12 @@
 			(int)mdp4_stat.iommu_map, (int)mdp4_stat.iommu_unmap,
 				(int)mdp4_stat.iommu_drop);
 		ion_free(display_iclient, ihdl);
-		flist->ihdl[i] = NULL;
 	}
 
-	flist->fndx = 0;
-	flist->total = 0;
+flist_to_pflist:
+	
+	memcpy(pflist, flist, sizeof(*pflist));
+	memset(flist, 0, sizeof(*flist));
 	mutex_unlock(&iommu_mutex);
 }
 
@@ -170,7 +254,6 @@
 	pr_debug("%s: add mixer=%d fndx=%d ihdl=0x%p\n", __func__,
 				mixer, flist->fndx, ihdl);
 
-	flist->total++;
 	flist->ihdl[flist->fndx++] = ihdl;
 }
 
@@ -184,6 +267,27 @@
 	if (pipe == NULL)
 		return;
 
+	if (pipe->flags & MDP_MEMORY_ID_TYPE_FB) {
+		pipe->flags &= ~MDP_MEMORY_ID_TYPE_FB;
+
+		if (pipe->put0_need) {
+			fput_light(pipe->srcp0_file, pipe->put0_need);
+			pipe->put0_need = 0;
+		}
+		if (pipe->put1_need) {
+			fput_light(pipe->srcp1_file, pipe->put1_need);
+			pipe->put1_need = 0;
+		}
+		if (pipe->put2_need) {
+			fput_light(pipe->srcp2_file, pipe->put2_need);
+			pipe->put2_need = 0;
+		}
+
+		pr_debug("%s: ndx=%d flags=%x put=%d\n", __func__,
+			pipe->pipe_ndx, pipe->flags, pipe->put0_need);
+		return;
+	}
+
 	mutex_lock(&iommu_mutex);
 	mixer = pipe->mixer_num;
 	iom = &pipe->iommu;
@@ -218,11 +322,12 @@
 		pr_err("ion_import_dma_buf() failed\n");
 		return PTR_ERR(*srcp_ihdl);
 	}
-	pr_debug("%s(): ion_hdl %p, mixer %u, pipe %u, plane %u\n",
-		 __func__, *srcp_ihdl, pipe->mixer_num, pipe->pipe_ndx, plane);
+	pr_debug("%s(): ion_hdl %p, ion_buf %d\n", __func__, *srcp_ihdl, mem_id);
+	pr_debug("mixer %u, pipe %u, plane %u\n", pipe->mixer_num,
+		pipe->pipe_ndx, plane);
 	if (ion_map_iommu(display_iclient, *srcp_ihdl,
 		DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, 0, start,
-		len, 0, ION_IOMMU_UNMAP_DELAYED)) {
+		len, 0, 0)) {
 		ion_free(display_iclient, *srcp_ihdl);
 		pr_err("ion_map_iommu() failed\n");
 		return -EINVAL;
@@ -323,23 +428,9 @@
 	return ctrl->panel_mode;
 }
 
-void mdp4_overlay_cfg_init(void)
-{
-	if (ctrl->hw_version == 0) {
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-		ctrl->hw_version = inpdw(MDP_BASE + 0x0); 
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-	}
-
-	if (ctrl->hw_version >= 0x0402030b) {
-		
-		outpdw(MDP_BASE + 0x100fc, 0x01);
-	}
-}
-
 int mdp4_overlay_borderfill_supported(void)
 {
-	return (ctrl->hw_version >= 0x0402030b);
+	return (mdp_rev >= MDP_REV_42);
 }
 
 void mdp4_overlay_dmae_cfg(struct msm_fb_data_type *mfd, int atv)
@@ -387,38 +478,34 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
 
-#ifdef CONFIG_FB_MSM_HDMI_3D
-void unfill_black_screen(void) { return; }
-#else
-void unfill_black_screen(void)
+void fill_black_screen(bool on, uint8 pipe_num, uint8 mixer_num)
 {
-	uint32 temp_src_format;
+	uint32 reg_base        = 0x010000;
+	uint32 const_color_reg = reg_base * (pipe_num + 2) + 0x1008;
+	uint32 src_fmt_reg     = reg_base * (pipe_num + 2) + 0x50;
+	uint32 color           = 0x00000000;
+	uint32 temp_src_format = 0x00000000;
+	uint8  bit             = pipe_num + 2;
+
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	temp_src_format = inpdw(MDP_BASE + 0x30050);
-	MDP_OUTP(MDP_BASE + 0x30050, temp_src_format&(~BIT(22)));
-	MDP_OUTP(MDP_BASE + 0x18000, BIT(3));
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-	return;
-}
-#endif
 
-#ifdef CONFIG_FB_MSM_HDMI_3D
-void fill_black_screen(void) { return; }
-#else
-void fill_black_screen(void)
-{
 	
-	uint32 color = 0x00000000;
-	uint32 temp_src_format;
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	MDP_OUTP(MDP_BASE + 0x31008, color);
-	temp_src_format = inpdw(MDP_BASE + 0x30050);
-	MDP_OUTP(MDP_BASE + 0x30050, temp_src_format | BIT(22));
-	MDP_OUTP(MDP_BASE + 0x18000, BIT(3));
+	MDP_OUTP(MDP_BASE + const_color_reg, color);
+
+	
+	temp_src_format = inpdw(MDP_BASE + src_fmt_reg);
+
+	if (on)
+		MDP_OUTP(MDP_BASE + src_fmt_reg, temp_src_format | BIT(22));
+	else
+		MDP_OUTP(MDP_BASE + src_fmt_reg, temp_src_format | (~BIT(22)));
+
+	
+	MDP_OUTP(MDP_BASE + 0x18000, BIT(bit) | BIT(mixer_num));
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+
 	return;
 }
-#endif
 
 void mdp4_overlay_dmae_xy(struct mdp4_overlay_pipe *pipe)
 {
@@ -468,7 +555,11 @@
 		dma2_cfg_reg |= DMA_PACK_PATTERN_RGB;
 
 
-	if (mfd->panel_info.bpp == 18) {
+	if ((mfd->panel_info.type == MIPI_CMD_PANEL) ||
+		(mfd->panel_info.type == MIPI_VIDEO_PANEL)) {
+		dma2_cfg_reg |= DMA_DSTC0G_8BITS |	
+		    DMA_DSTC1B_8BITS | DMA_DSTC2R_8BITS;
+	} else if (mfd->panel_info.bpp == 18) {
 		dma2_cfg_reg |= DMA_DSTC0G_6BITS |	
 		    DMA_DSTC1B_6BITS | DMA_DSTC2R_6BITS;
 	} else if (mfd->panel_info.bpp == 16) {
@@ -491,6 +582,7 @@
 	mask = 0x0FFFFFFF;
 	dma2_cfg_reg = (dma2_cfg_reg & mask) | (curr & ~mask);
 	MDP_OUTP(MDP_BASE + 0x90000, dma2_cfg_reg);
+	ctrl->dmap_cfg[0] = dma2_cfg_reg;
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
@@ -511,24 +603,40 @@
 		off = 0;
 		if (pipe->dmap_cnt & 0x01)
 			off = pipe->src_height * pipe->src_width * bpp;
+		ctrl->dmap_cfg[2] = pipe->dma_blt_addr + off;
 		MDP_OUTP(MDP_BASE + 0x90008, pipe->dma_blt_addr + off);
 		
 		MDP_OUTP(MDP_BASE + 0x9000c, pipe->src_width * bpp);
+                ctrl->dmap_cfg[3] = pipe->src_width * bpp;
 	} else {
 		MDP_OUTP(MDP_BASE + 0x90008, pipe->srcp0_addr);
+		ctrl->dmap_cfg[2] = pipe->srcp0_addr;
 		MDP_OUTP(MDP_BASE + 0x9000c, pipe->srcp0_ystride);
+		ctrl->dmap_cfg[3] = pipe->srcp0_ystride;
 	}
 	
 	MDP_OUTP(MDP_BASE + 0x90004,
 			(pipe->src_height << 16 | pipe->src_width));
+	ctrl->dmap_cfg[1] = (pipe->src_height << 16 | pipe->src_width);
 
 	
 	MDP_OUTP(MDP_BASE + 0x90010, (pipe->dst_y << 16 | pipe->dst_x));
+	ctrl->dmap_cfg[4] = (pipe->dst_y << 16 | pipe->dst_x);
 
 	if (!in_interrupt())
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
 
+static void mdp4_overlay_dmap_reconfig(void)
+{
+        MDP_OUTP(MDP_BASE + 0x90000, ctrl->dmap_cfg[0]);
+        MDP_OUTP(MDP_BASE + 0x90004, ctrl->dmap_cfg[1]);
+        MDP_OUTP(MDP_BASE + 0x90008, ctrl->dmap_cfg[2]);
+        MDP_OUTP(MDP_BASE + 0x9000c, ctrl->dmap_cfg[3]);
+        MDP_OUTP(MDP_BASE + 0x90010, ctrl->dmap_cfg[4]);
+}
+
+
 #define MDP4_VG_PHASE_STEP_DEFAULT	0x20000000
 #define MDP4_VG_PHASE_STEP_SHIFT	29
 
@@ -626,6 +734,37 @@
 	}
 }
 
+void mdp4_overlay_solidfill_init(struct mdp4_overlay_pipe *pipe)
+{
+	char *base;
+	uint32 src_size, src_xy, dst_size, dst_xy;
+	uint32 format;
+	uint32 off;
+	int i;
+
+	src_size = ((pipe->src_h << 16) | pipe->src_w);
+	src_xy = ((pipe->src_y << 16) | pipe->src_x);
+	dst_size = ((pipe->dst_h << 16) | pipe->dst_w);
+	dst_xy = ((pipe->dst_y << 16) | pipe->dst_x);
+
+	base = MDP_BASE + MDP4_VIDEO_BASE;
+	off = MDP4_VIDEO_OFF;	
+	mdp_clk_ctrl(1);
+	for(i = 0; i < 4; i++) {	
+		format = inpdw(base + 0x50);
+		format |= MDP4_FORMAT_SOLID_FILL;
+		outpdw(base + 0x0000, src_size);
+		outpdw(base + 0x0004, src_xy);	
+		outpdw(base + 0x0008, dst_size);
+		outpdw(base + 0x000c, dst_xy);	
+		outpdw(base + 0x0050, format);
+		outpdw(base + 0x1008, 0x0);
+		base += off;
+	}
+	ctrl->flush[MDP4_MIXER0] = 0x3c; 
+	mdp_clk_ctrl(0);
+}
+
 void mdp4_overlay_rgb_setup(struct mdp4_overlay_pipe *pipe)
 {
 	char *rgb_base;
@@ -686,6 +825,7 @@
 		op_mode &= ~(MDP4_OP_FLIP_LR + MDP4_OP_SCALEX_EN);
 		op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
 		outpdw(rgb_base + 0x0058, op_mode);
+		outpdw(rgb_base + 0x1008, 0x0);
 	} else {
 		if (pipe->op_mode & MDP4_OP_FLIP_LR && mdp_rev >= MDP_REV_42) {
 			
@@ -710,36 +850,52 @@
 	*luma_off = 0;
 	*chroma_off = 0;
 
-	if (pipe->src_x && (pipe->frame_format ==
+	if ((pipe->src_x || pipe->src_y) && (pipe->frame_format ==
 		MDP4_FRAME_FORMAT_LINEAR)) {
-		src_xy = (pipe->src_y << 16) | pipe->src_x;
-		src_xy &= 0xffff0000;
+		src_xy = 0;
 		outpdw(vg_base + 0x0004, src_xy);	
 
 		switch (pipe->src_format) {
 		case MDP_Y_CR_CB_H2V2:
 		case MDP_Y_CR_CB_GH2V2:
 		case MDP_Y_CB_CR_H2V2:
-				*luma_off = pipe->src_x;
-				*chroma_off = pipe->src_x/2;
+			*luma_off = pipe->src_x +
+				(pipe->src_y * pipe->srcp0_ystride);
+			*chroma_off = pipe->src_x / 2 +
+				((pipe->src_y / 2) * pipe->srcp1_ystride);
 			break;
 
 		case MDP_Y_CBCR_H2V2_TILE:
 		case MDP_Y_CRCB_H2V2_TILE:
 		case MDP_Y_CBCR_H2V2:
 		case MDP_Y_CRCB_H2V2:
+			*luma_off = pipe->src_x +
+				(pipe->src_y * pipe->srcp0_ystride);
+			*chroma_off = pipe->src_x +
+				((pipe->src_y / 2) * pipe->srcp1_ystride);
+			break;
+
 		case MDP_Y_CRCB_H1V1:
 		case MDP_Y_CBCR_H1V1:
+			*luma_off = pipe->src_x +
+				(pipe->src_y * pipe->srcp0_ystride);
+			*chroma_off = pipe->src_x +
+				((pipe->src_y * 2) * pipe->srcp1_ystride);
+			break;
+
 		case MDP_Y_CRCB_H2V1:
 		case MDP_Y_CBCR_H2V1:
-			*luma_off = pipe->src_x;
-			*chroma_off = pipe->src_x;
+			*luma_off = pipe->src_x +
+				(pipe->src_y * pipe->srcp0_ystride);
+			*chroma_off = pipe->src_x +
+				(pipe->src_y * pipe->srcp1_ystride);
 			break;
 
 		case MDP_YCRYCB_H2V1:
 			if (pipe->src_x & 0x1)
 				pipe->src_x += 1;
-			*luma_off += pipe->src_x * 2;
+			*luma_off += pipe->src_x * 2 +
+				((pipe->src_y * 2) * pipe->srcp0_ystride);
 			break;
 
 		case MDP_ARGB_8888:
@@ -752,7 +908,8 @@
 		case MDP_RGB_888:
 		case MDP_YCBCR_H1V1:
 		case MDP_YCRCB_H1V1:
-			*luma_off = pipe->src_x * pipe->bpp;
+			*luma_off = (pipe->src_x * pipe->bpp) +
+					(pipe->src_y * pipe->srcp0_ystride);
 			break;
 
 		default:
@@ -768,8 +925,9 @@
 	char *vg_base;
 	uint32 frame_size, src_size, src_xy, dst_size, dst_xy;
 	uint32 format, pattern, luma_offset, chroma_offset;
-	uint32 mask, curr, addr;
-	int pnum, ptype;
+	uint32 mask;
+	int pnum, ptype, i;
+	uint32_t block;
 
 	pnum = pipe->pipe_num - OVERLAY_PIPE_VG1; 
 	vg_base = MDP_BASE + MDP4_VIDEO_BASE;
@@ -786,9 +944,42 @@
 	pattern = mdp4_overlay_unpack_pattern(pipe);
 
 	
-	pipe->op_mode |= MDP4_OP_CSC_EN;
+	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN) {
+		if (pipe->pp_cfg.config_ops & MDP_OVERLAY_PP_CSC_CFG) {
+			if (pipe->pp_cfg.csc_cfg.flags & MDP_CSC_FLAG_ENABLE)
+				pipe->op_mode |= MDP4_OP_CSC_EN;
+			if (pipe->pp_cfg.csc_cfg.flags & MDP_CSC_FLAG_YUV_IN)
+				pipe->op_mode |= MDP4_OP_SRC_DATA_YCBCR;
+			if (pipe->pp_cfg.csc_cfg.flags & MDP_CSC_FLAG_YUV_OUT)
+				pipe->op_mode |= MDP4_OP_DST_DATA_YCBCR;
+
+			mdp4_csc_write(&pipe->pp_cfg.csc_cfg,
+				(uint32_t) (vg_base + MDP4_VIDEO_CSC_OFF));
+
+			if (pipe->pipe_num == OVERLAY_PIPE_VG1)
+				block = MDP_BLOCK_VG_1;
+			else
+				block = MDP_BLOCK_VG_2;
+
+			for (i = 0; i < CSC_MAX_BLOCKS; i++) {
+				if (block == csc_cfg_matrix[i].block) {
+					memcpy(&csc_cfg_matrix[i].csc_data,
+					&(pipe->pp_cfg.csc_cfg),
+					sizeof(struct mdp_csc_cfg));
+					break;
+				}
+			}
+		}
+		if (pipe->pp_cfg.config_ops & MDP_OVERLAY_PP_QSEED_CFG) {
+			mdp4_qseed_access_cfg(&pipe->pp_cfg.qseed_cfg[0],
+							(uint32_t) vg_base);
+			mdp4_qseed_access_cfg(&pipe->pp_cfg.qseed_cfg[1],
+							(uint32_t) vg_base);
+		}
+	}
+	
 	if (ptype != OVERLAY_TYPE_RGB)
-		pipe->op_mode |= MDP4_OP_SRC_DATA_YCBCR;
+		pipe->op_mode |= (MDP4_OP_CSC_EN | MDP4_OP_SRC_DATA_YCBCR);
 
 #ifdef MDP4_IGC_LUT_ENABLE
 	pipe->op_mode |= MDP4_OP_IGC_LUT_EN;
@@ -818,8 +1009,21 @@
 	outpdw(vg_base + 0x0008, dst_size);	
 	outpdw(vg_base + 0x000c, dst_xy);	
 
-	if (pipe->frame_format != MDP4_FRAME_FORMAT_LINEAR)
+	if (pipe->frame_format != MDP4_FRAME_FORMAT_LINEAR) {
+		struct mdp4_overlay_pipe *real_pipe;
+		u32 psize, csize;
+
+		real_pipe = mdp4_overlay_ndx2pipe(pipe->pipe_ndx);
+		psize = real_pipe->prev_src_height * real_pipe->prev_src_width;
+		csize = pipe->src_height * pipe->src_width;
+		if (psize && (csize > psize)) {
+			frame_size = (real_pipe->prev_src_height << 16 |
+					real_pipe->prev_src_width);
+		}
 		outpdw(vg_base + 0x0048, frame_size);	
+		real_pipe->prev_src_height = pipe->src_height;
+		real_pipe->prev_src_width = pipe->src_width;
+	}
 
 	
 	if (ptype != OVERLAY_TYPE_RGB) {
@@ -828,24 +1032,6 @@
 	}
 
 	
-	curr = inpdw(vg_base + 0x0058);
-	mask = 0x600;
-
-	if ((curr & mask) != (pipe->op_mode & mask)) {
-		addr = ((uint32_t)vg_base) + 0x4000;
-		if (ptype != OVERLAY_TYPE_RGB)
-			mdp4_csc_write(&(mdp_csc_convert[1]), addr);
-		else
-			mdp4_csc_write(&(mdp_csc_convert[0]), addr);
-
-		mask = 0xFFFCFFFF;
-	} else {
-		
-		mask = 0xFFFCF1FF;
-	}
-	pipe->op_mode = (pipe->op_mode & mask) | (curr & ~mask);
-
-	
 	outpdw(vg_base + 0x0010, pipe->srcp0_addr + luma_offset);
 
 	
@@ -877,15 +1063,6 @@
 			pipe->r_bit << 4 | pipe->b_bit << 2 | pipe->g_bit);
 	}
 
-	if (pipe->flags & MDP_SHARPENING) {
-		outpdw(vg_base + 0x8200,
-			mdp4_ss_table_value(pipe->req_data.dpp.sharp_strength,
-									0));
-		outpdw(vg_base + 0x8204,
-			mdp4_ss_table_value(pipe->req_data.dpp.sharp_strength,
-									1));
-	}
-
 	if (mdp_rev > MDP_REV_41) {
 		
 		mask = 0;
@@ -1424,34 +1601,56 @@
 #endif
 		} else if (pipe->mixer_num == MDP4_MIXER2) {
 			if (ctrl->panel_mode & MDP4_PANEL_WRITEBACK) {
-				off = 0;
-				bpp = 1;
-				if (pipe->ov_cnt & 0x01)
-					off = pipe->src_height *
-							pipe->src_width * bpp;
-
-				outpdw(overlay_base + 0x000c,
-						pipe->ov_blt_addr + off);
-				
-				outpdw(overlay_base + 0x0010,
-					((pipe->src_width << 16) |
-					 pipe->src_width));
-				outpdw(overlay_base + 0x001c,
-						pipe->ov_blt_addr + off);
-				off = pipe->src_height * pipe->src_width;
-				
-				
-				
-				outpdw(overlay_base + 0x0020,
-						pipe->ov_blt_addr + off);
-				
-				outpdw(overlay_base + 0x0004, 0x08);
-				
-				curr = inpdw(overlay_base + 0x0014);
-				curr &= 0x4;
-				outpdw(overlay_base + 0x0014, curr | 0x012);
-				
-				outpdw(overlay_base + 0x0200, 0x05);
+				if (MDP_RGB_565 == pipe->dst_format) {
+					off = 0;
+					bpp = 2;
+					if (pipe->ov_cnt & 0x01)
+						off = pipe->src_height *
+								pipe->src_width * bpp;
+
+					outpdw(overlay_base + 0x000c,
+							pipe->ov_blt_addr + off);
+					
+					outpdw(overlay_base + 0x0010, pipe->src_width * bpp);
+					outpdw(overlay_base + 0x001c, pipe->ov_blt_addr + off);
+					
+					outpdw(overlay_base + 0x0004, 0x08);
+					
+					curr = inpdw(overlay_base + 0x0014);
+					curr &= 0x4;
+					outpdw(overlay_base + 0x0014, curr | 0x1); 
+					
+					outpdw(overlay_base + 0x0200, 0x00);
+				} else {
+					off = 0;
+					bpp = 1;
+					if (pipe->ov_cnt & 0x01)
+						off = pipe->src_height *
+								pipe->src_width * bpp;
+
+					outpdw(overlay_base + 0x000c,
+							pipe->ov_blt_addr + off);
+					
+					outpdw(overlay_base + 0x0010,
+							((pipe->src_width << 16) |
+							 pipe->src_width));
+					outpdw(overlay_base + 0x001c,
+									pipe->ov_blt_addr + off);
+					off = pipe->src_height * pipe->src_width;
+					
+					
+					
+					outpdw(overlay_base + 0x0020,
+									pipe->ov_blt_addr + off);
+					
+					outpdw(overlay_base + 0x0004, 0x08);
+					
+					curr = inpdw(overlay_base + 0x0014);
+					curr &= 0x4;
+					outpdw(overlay_base + 0x0014, curr | 0x012);
+					
+					outpdw(overlay_base + 0x0200, 0x05);
+				}
 			}
 		}
 	} else {
@@ -1505,15 +1704,19 @@
 	int ndx, cnt;
 	struct mdp4_overlay_pipe *pipe;
 
-	if (mixer_num >= MDP4_MIXER_MAX)
+	if (mixer_num > MDP4_MIXER_MAX)
 		return -ENODEV;
 
 	cnt = 0;
 	ndx = MDP4_MIXER_STAGE_BASE;
 	for ( ; ndx < MDP4_MIXER_STAGE_MAX; ndx++) {
-		pipe = ctrl->stage[mixer_num][ndx];
+		pipe = &ctrl->plist[ndx];
 		if (pipe == NULL)
 			continue;
+
+		if (!pipe->pipe_used)
+			continue;
+
 		info->z_order = pipe->mixer_stage - MDP4_MIXER_STAGE0;
 		
 		info->ptype = pipe->pipe_type;
@@ -1526,6 +1729,50 @@
 	return cnt;
 }
 
+void mdp4_mixer_reset(int mixer)
+{
+	uint32 data, data1, mask;
+	int i, ndx, min, max, bit;
+
+	mdp_clk_ctrl(1);
+	
+	data = inpdw(MDP_BASE + 0x10100);
+	data1 = data;
+
+	if (mixer == 0) {
+		min = 1;
+		max = 8;
+		bit = 0x03; 
+	} else {
+		min = 9;
+		max = 0xf;
+		bit = 0x0C; 
+	}
+	mask = 0x0f;
+	for (i = 0 ; i < 8 ; i++) {
+		ndx = data & mask;
+		ndx >>= (i * 4);
+		if (ndx >= min && ndx <= max)
+			data1 &= ~mask;  
+		mask <<= 4;
+	}
+	pr_debug("%s: => MIXER_RESET, data1=%x data=%x bit=%x\n",
+				__func__, data1, data, bit);
+	
+	outpdw(MDP_BASE + 0x10100, data1); 
+	outpdw(MDP_BASE + 0x18000, 0);
+
+	mdp4_sw_reset(bit);    
+
+	
+	outpdw(MDP_BASE + 0x10100, data); 
+	outpdw(MDP_BASE + 0x18000, 0);
+
+	mdp4_vg_csc_restore();
+	mdp4_overlay_dmap_reconfig();
+	mdp_clk_ctrl(0);
+}
+
 void mdp4_mixer_stage_commit(int mixer)
 {
 	struct mdp4_overlay_pipe *pipe;
@@ -1551,7 +1798,8 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	mdp_clk_ctrl(1);
 
-	mdp4_mixer_blend_setup(mixer);
+	if (data)
+		mdp4_mixer_blend_setup(mixer);
 
 	off = 0;
 	if (data != ctrl->mixer_cfg[mixer]) {
@@ -1579,8 +1827,8 @@
 		ctrl->flush[mixer] = 0;
 	}
 	local_irq_restore(flags);
-	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 }
 
 
@@ -1626,6 +1874,7 @@
 	struct mdp4_overlay_pipe *bspipe;
 	int ptype, pnum, pndx, mixer;
 	int format, alpha_enable, alpha;
+	struct mdp4_iommu_pipe_info iom;
 
 	if (pipe->pipe_type != OVERLAY_TYPE_BF)
 		return;
@@ -1637,17 +1886,12 @@
 
 	bspipe = ctrl->stage[mixer][MDP4_MIXER_STAGE_BASE];
 
-	if(bspipe == NULL) {
-		pr_err("%s: no base layer at mixer=%d\n",
-			__func__, mixer);
-		return;
-	}
-
 	bspipe = mdp4_overlay_ndx2pipe(bspipe->pipe_ndx);
 
 	
 	ctrl->baselayer[mixer] = bspipe;
 
+	iom = pipe->iommu;
 	pipe->alpha = 0;	
 	ptype = pipe->pipe_type;
 	pnum = pipe->pipe_num;
@@ -1662,6 +1906,7 @@
 	pipe->src_format = format;
 	pipe->alpha_enable = alpha_enable;
 	pipe->alpha = alpha;
+	pipe->iommu = iom;
 
 	
 	bspipe->pipe_used = 0;
@@ -1672,8 +1917,10 @@
 		mdp4_dsi_cmd_base_swap(0, pipe);
 	else if (ctrl->panel_mode & MDP4_PANEL_LCDC)
 		mdp4_lcdc_base_swap(0, pipe);
+#ifdef CONFIG_FB_MSM_DTV
 	else if (ctrl->panel_mode & MDP4_PANEL_DTV)
 		mdp4_dtv_base_swap(0, pipe);
+#endif
 
 	mdp4_overlay_reg_flush(bspipe, 1);
 	
@@ -1735,7 +1982,7 @@
 	
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_down(pipe, 0); 
-	mdp4_overlay_pipe_free(pipe);
+	mdp4_overlay_pipe_free(pipe, 0);
 
 	
 	mdp4_overlay_reg_flush(bspipe, 1);
@@ -1797,40 +2044,149 @@
 	}
 
 	format = inpdw(base + 0x50);
-	if (blend->solidfill) {
-		format |= MDP4_FORMAT_SOLID_FILL;
-		op_mode = inpdw(base + 0x0058);
-		op_mode &= ~(MDP4_OP_FLIP_LR + MDP4_OP_SCALEX_EN);
-		op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
-		outpdw(base + 0x0058, op_mode);
-		outpdw(base + 0x1008, 0);	
-		outpdw(base + 0x0000, inpdw(base + 0x0008));
-	} else {
-		u32 src_size = ((pipe->src_h << 16) | pipe->src_w);
-		outpdw(base + 0x0000, src_size);
-		format &= ~MDP4_FORMAT_SOLID_FILL;
-		blend->solidfill_pipe = NULL;
-	}
-
+	format |= MDP4_FORMAT_SOLID_FILL;
+	op_mode = inpdw(base + 0x0058);
+	op_mode &= ~(MDP4_OP_FLIP_LR + MDP4_OP_SCALEX_EN);
+	op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
+	outpdw(base + 0x0058, op_mode);
+	outpdw(base + 0x1008, 0);	
+	outpdw(base + 0x0000, inpdw(base + 0x0008));
 	outpdw(base + 0x50, format);
 
 	mdp4_overlay_reg_flush(pipe, 0);
 }
 
+void mdp4_mixer_blend_cfg(int mixer)
+{
+	int i, off;
+	unsigned char *overlay_base;
+	struct blend_cfg *blend;
+
+	if (mixer == MDP4_MIXER2)
+		overlay_base = MDP_BASE + MDP4_OVERLAYPROC2_BASE;
+	else if (mixer == MDP4_MIXER1)
+		overlay_base = MDP_BASE + MDP4_OVERLAYPROC1_BASE;
+	else
+		overlay_base = MDP_BASE + MDP4_OVERLAYPROC0_BASE;
+
+	blend = &ctrl->blend[mixer][MDP4_MIXER_STAGE_BASE];
+	blend++; 
+
+	for (i = MDP4_MIXER_STAGE0; i < MDP4_MIXER_STAGE_MAX; i++) {
+		off = 20 * i;
+		off = 0x20 * (i - MDP4_MIXER_STAGE0);
+		if (i == MDP4_MIXER_STAGE3)
+			off -= 4;
+		outpdw(overlay_base + off + 0x104, blend->op);
+		blend++;
+	}
+}
+
+static void mdp4_set_blend_by_op(struct mdp4_overlay_pipe *s_pipe,
+					struct mdp4_overlay_pipe *d_pipe,
+					int alpha_drop,
+					struct blend_cfg *blend)
+{
+	int d_alpha, s_alpha;
+	u32 op;
+
+	d_alpha = d_pipe->alpha_enable;
+	s_alpha = s_pipe->alpha_enable;
+	
+	blend->fg_alpha = s_pipe->alpha;
+	blend->bg_alpha = 0x0ff - s_pipe->alpha;
+	blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |
+	MDP4_BLEND_BG_ALPHA_BG_CONST;
+	blend->co3_sel = 1; 
+	op = s_pipe->blend_op;
+	if (op == BLEND_OP_OPAQUE) {
+		blend->bg_alpha = 0;
+		blend->fg_alpha = 0xff;
+	} else if ((op == BLEND_OP_PREMULTIPLIED) &&
+			(!alpha_drop) && s_alpha) {
+		blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |
+			MDP4_BLEND_BG_INV_ALPHA |
+			MDP4_BLEND_BG_ALPHA_FG_PIXEL;
+		if (blend->fg_alpha != 0xff) {
+			blend->bg_alpha = blend->fg_alpha;
+			blend->op |= MDP4_BLEND_BG_MOD_ALPHA;
+		}
+	} else if (!alpha_drop && s_alpha) {
+		blend->op = MDP4_BLEND_FG_ALPHA_FG_PIXEL |
+			MDP4_BLEND_BG_INV_ALPHA |
+			MDP4_BLEND_BG_ALPHA_FG_PIXEL;
+		if (blend->fg_alpha != 0xff) {
+			blend->bg_alpha = blend->fg_alpha;
+			blend->op |= MDP4_BLEND_FG_MOD_ALPHA |
+				MDP4_BLEND_BG_MOD_ALPHA;
+		}
+	}
+	if (!s_alpha && d_alpha)
+		blend->co3_sel = 0;
+	pr_debug("%s: op %d bg alpha %d, fg alpha %d blend: %x\n",
+		__func__, op, blend->bg_alpha, blend->fg_alpha, blend->op);
+}
+
+static void mdp4_set_blend_by_fmt(struct mdp4_overlay_pipe *s_pipe,
+					struct mdp4_overlay_pipe *d_pipe,
+					int alpha_drop,
+					struct blend_cfg *blend)
+{
+	int ptype, d_alpha, s_alpha;
+	d_alpha = d_pipe->alpha_enable;
+	s_alpha = s_pipe->alpha_enable;
+	
+	blend->bg_alpha = 0x0ff - s_pipe->alpha;
+	blend->fg_alpha = s_pipe->alpha;
+	blend->co3_sel = 1; 
+
+	if (s_pipe->is_fg) {
+		if (s_pipe->alpha == 0xff) {
+			blend->solidfill = 1;
+			blend->solidfill_pipe = d_pipe;
+		}
+	} else if (s_alpha) {
+		if (!alpha_drop) {
+			blend->op = MDP4_BLEND_BG_ALPHA_FG_PIXEL;
+			if (!(s_pipe->flags & MDP_BLEND_FG_PREMULT))
+				blend->op |=
+					MDP4_BLEND_FG_ALPHA_FG_PIXEL;
+		} else
+			blend->op = MDP4_BLEND_BG_ALPHA_FG_CONST;
+
+		blend->op |= MDP4_BLEND_BG_INV_ALPHA;
+	} else if (d_alpha) {
+		ptype = mdp4_overlay_format2type(s_pipe->src_format);
+		if (ptype == OVERLAY_TYPE_VIDEO &&
+			(!(s_pipe->flags & MDP_BACKEND_COMPOSITION))) {
+			blend->op = (MDP4_BLEND_FG_ALPHA_BG_PIXEL |
+				MDP4_BLEND_FG_INV_ALPHA);
+			if (!(s_pipe->flags & MDP_BLEND_FG_PREMULT))
+				blend->op |=
+					MDP4_BLEND_BG_ALPHA_BG_PIXEL;
+			blend->co3_sel = 0; 
+		} else {
+			
+			blend->op = (MDP4_BLEND_FG_ALPHA_FG_CONST |
+				    MDP4_BLEND_BG_ALPHA_BG_CONST);
+			blend->bg_alpha = 0;
+		}
+	}
+}
+
 void mdp4_mixer_blend_setup(int mixer)
 {
 	struct mdp4_overlay_pipe *d_pipe;
 	struct mdp4_overlay_pipe *s_pipe;
 	struct blend_cfg *blend;
-	int i, off, ptype;
-	int d_alpha, s_alpha;
+	int i, off, alpha_drop;
 	unsigned char *overlay_base;
 	uint32 c0, c1, c2;
 
 
 	d_pipe = ctrl->stage[mixer][MDP4_MIXER_STAGE_BASE];
 	if (d_pipe == NULL) {
-		pr_info("%s:return at mixer=%d\n", __func__, mixer);
+		pr_err("%s: Error: no bg_pipe at mixer=%d\n", __func__, mixer);
 		return;
 	}
 
@@ -1843,44 +2199,30 @@
 		if (s_pipe == NULL) {
 			blend++;
 			d_pipe = NULL;
-			d_alpha = 0;
 			continue;
 		}
+		alpha_drop = 0;	
+		
+		if (s_pipe->pipe_type == OVERLAY_TYPE_VIDEO &&
+			s_pipe->alpha_enable &&
+			((s_pipe->op_mode & MDP4_OP_SCALEY_EN) ||
+			(s_pipe->op_mode & MDP4_OP_SCALEX_EN)) &&
+			!(s_pipe->op_mode & (MDP4_OP_SCALEX_PIXEL_RPT |
+						MDP4_OP_SCALEY_PIXEL_RPT)))
+			alpha_drop = 1;
+
 		d_pipe = mdp4_background_layer(mixer, s_pipe);
-		d_alpha = d_pipe->alpha_enable;
-		s_alpha = s_pipe->alpha_enable;
 		pr_debug("%s: stage=%d: bg: ndx=%d da=%d dalpha=%x "
-			"fg: ndx=%d sa=%d salpha=%x is_fg=%d\n",
-		 __func__, i-2, d_pipe->pipe_ndx, d_alpha, d_pipe->alpha,
-		s_pipe->pipe_ndx, s_alpha, s_pipe->alpha, s_pipe->is_fg);
-
-		
-		blend->bg_alpha = 0x0ff - s_pipe->alpha;
-		blend->fg_alpha = s_pipe->alpha;
-		blend->co3_sel = 1; 
-
-		if (s_pipe->is_fg) {
-			if (s_pipe->alpha == 0xff) {
-				blend->solidfill = 1;
-				blend->solidfill_pipe = d_pipe;
-			}
-		} else if (s_alpha) {
-			blend->op = (MDP4_BLEND_BG_ALPHA_FG_PIXEL |
-				    MDP4_BLEND_BG_INV_ALPHA);
-		} else if (d_alpha) {
-			ptype = mdp4_overlay_format2type(s_pipe->src_format);
-			if (ptype == OVERLAY_TYPE_VIDEO) {
-				blend->op = (MDP4_BLEND_BG_ALPHA_BG_PIXEL |
-				    MDP4_BLEND_FG_ALPHA_BG_PIXEL |
-				    MDP4_BLEND_FG_INV_ALPHA);
-				blend->co3_sel = 0; 
-			} else {
-				
-				blend->op = (MDP4_BLEND_FG_ALPHA_FG_CONST |
-					    MDP4_BLEND_BG_ALPHA_BG_CONST);
-				blend->bg_alpha = 0;
-			}
-		}
+			"fg: ndx=%d sa=%d salpha=%x is_fg=%d alpha_drop=%d\n",
+		__func__, i-2, d_pipe->pipe_ndx, d_pipe->alpha_enable,
+		d_pipe->alpha, s_pipe->pipe_ndx, s_pipe->alpha_enable,
+		s_pipe->alpha, s_pipe->is_fg, alpha_drop);
+		if ((s_pipe->blend_op == BLEND_OP_NOT_DEFINED) ||
+			(s_pipe->blend_op >= BLEND_OP_MAX))
+			mdp4_set_blend_by_fmt(s_pipe, d_pipe,
+				alpha_drop, blend);
+		else
+			mdp4_set_blend_by_op(s_pipe, d_pipe, alpha_drop, blend);
 
 		if (s_pipe->transp != MDP_TRANSP_NOP) {
 			if (s_pipe->is_fg) {
@@ -1935,12 +2277,17 @@
 		if (i == MDP4_MIXER_STAGE3)
 			off -= 4;
 
-		if (blend->solidfill_pipe)
+		if (blend->solidfill_pipe && blend->solidfill)
 			mdp4_overlay_bg_solidfill(blend);
+		else
+			blend->solidfill_pipe = NULL;
 
 		outpdw(overlay_base + off + 0x108, blend->fg_alpha);
 		outpdw(overlay_base + off + 0x10c, blend->bg_alpha);
-		outpdw(overlay_base + off + 0x104, blend->op);
+
+		if (mdp_rev >= MDP_REV_42)
+			outpdw(overlay_base + off + 0x104, blend->op);
+
 		outpdw(overlay_base + (off << 5) + 0x1004, blend->co3_sel);
 		outpdw(overlay_base + off + 0x110, blend->transp_low0);
 		outpdw(overlay_base + off + 0x114, blend->transp_low1);
@@ -2031,16 +2378,26 @@
 		}
 	}
 
-	pr_err("%s: ptype=%d FAILED\n", __func__, ptype);
+	pr_err("%s: ptype=%d mixer:%d FAILED\n", __func__, ptype, mixer);
+
+	PR_DISP_INFO("Dump MDP pipe information\n");
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++) {
+		pipe = &ctrl->plist[i];
+		if (ptype == OVERLAY_TYPE_BF)
+			continue;
+		PR_DISP_INFO("pipe=%x ndx=%d num=%d pipe_used:%d pipe_type:%d mixer_num:%d\n",
+			(int)pipe, pipe->pipe_ndx, pipe->pipe_num, pipe->pipe_used, pipe->pipe_type, pipe->mixer_num);
+	}
 
 	return NULL;
 }
 
 
-void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe)
+void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe, int all)
 {
 	uint32 ptype, num, ndx, mixer;
 	struct mdp4_iommu_pipe_info iom;
+	struct mdp4_overlay_pipe *orgpipe;
 
 	pr_debug("%s: pipe=%x ndx=%d\n", __func__, (int)pipe, pipe->pipe_ndx);
 
@@ -2049,17 +2406,24 @@
 	ndx = pipe->pipe_ndx;
 	mixer = pipe->mixer_num;
 
-	mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+	
+	if (pipe->pipe_type != OVERLAY_TYPE_BF)
+		mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, all);
 
 	iom = pipe->iommu;
 
 	memset(pipe, 0, sizeof(*pipe));
-
 	pipe->pipe_type = ptype;
 	pipe->pipe_num = num;
 	pipe->pipe_ndx = ndx;
 	pipe->mixer_num = mixer;
 	pipe->iommu = iom;
+
+	
+	orgpipe = mdp4_overlay_ndx2pipe(pipe->pipe_ndx);
+	if (orgpipe != NULL)
+		orgpipe->pipe_used = 0;
+
 }
 
 static int mdp4_overlay_req2pipe(struct mdp_overlay *req, int mixer,
@@ -2178,18 +2542,6 @@
 		return -ERANGE;
 	}
 
-	if (mdp_rev <= MDP_REV_41) {
-		if ((mdp4_overlay_format2type(req->src.format) ==
-			OVERLAY_TYPE_RGB) &&
-			!(req->flags & MDP_OV_PIPE_SHARE) &&
-			((req->src_rect.w > req->dst_rect.w) ||
-			 (req->src_rect.h > req->dst_rect.h))) {
-			mdp4_stat.err_size++;
-			pr_err("%s: downscale on RGB pipe!\n", __func__);
-			return -EINVAL;
-		}
-	}
-
 	if (mdp_hw_revision == MDP4_REVISION_V1) {
 		if (req->src_rect.h > (req->dst_rect.h * 4)) {
 			if (req->src_rect.h % req->dst_rect.h) {
@@ -2264,7 +2616,7 @@
 	}
 
 	if (req->id == MSMFB_NEW_REQUEST) {  
-		if ( mixer != pipe->mixer_num && mdp4_overlay_pipe_staged(pipe)) {
+		if (mdp4_overlay_pipe_staged(pipe)) {
 			pr_err("%s: ndx=%d still staged\n", __func__,
 						pipe->pipe_ndx);
 			return -EPERM;
@@ -2308,6 +2660,7 @@
 	pipe->is_fg = req->is_fg;
 
 	pipe->alpha = req->alpha & 0x0ff;
+	pipe->blend_op = req->blend_op;
 
 	pipe->transp = req->transp_mask;
 
@@ -2334,12 +2687,12 @@
 	}
 	if (!mfd) {
 		pr_err("%s: mfd is null!\n", __func__);
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
 		return ret;
 	}
 
-	if (pipe->mixer_num) {
-		pr_debug("%s: force mdp max clk in mixer %d\n", __func__, pipe->mixer_num);
+	if (pipe->flags & MDP_DEINTERLACE) {
+		pr_info("%s deinterlace requires max mdp clk.\n",
+			__func__);
 		pipe->req_clk = mdp_max_clk;
 		return 0;
 	}
@@ -2450,24 +2803,24 @@
 
 	rst >>= shift;
 
+	if ((mfd->panel_info.lcdc.v_back_porch <= 4) &&
+	    (pipe->src_h != pipe->dst_h) &&
+	    (mfd->panel_info.lcdc.v_back_porch)) {
+		u32 clk = 0;
+		clk = 4 * (pclk >> shift) / mfd->panel_info.lcdc.v_back_porch;
+		clk <<= shift;
+		pr_debug("%s: mdp clk rate %d based on low vbp %d\n",
+			 __func__, clk, mfd->panel_info.lcdc.v_back_porch);
+		rst = (rst > clk) ? rst : clk;
+	}
+
 	if (rst < pclk) {
 		rst = ((pclk >> shift) * 23 / 20) << shift;
 		pr_debug("%s calculated mdp clk is less than pclk.\n",
 			__func__);
 	}
 
-	if (pipe->flags & MDP_DEINTERLACE) {
-		rst = (rst > mdp_max_clk) ? rst : mdp_max_clk;
-
-		if (mfd->panel_info.lcdc.v_back_porch < 4) {
-			const int deint_req_clk = 266667000;
-			rst = (rst > deint_req_clk) ? rst : deint_req_clk;
-		}
-		pr_info("%s deinterlace requires max mdp clk.\n",
-			__func__);
-	}
-
-	pipe->req_clk = (u32) rst;
+	pipe->req_clk = (u32) rst;
 
 	pr_debug("%s: required mdp clk %d mixer %d pipe ndx %d\n",
 		 __func__, pipe->req_clk, pipe->mixer_num, pipe->pipe_ndx);
@@ -2475,39 +2828,13 @@
 	return 0;
 }
 
-#define OVERLAY_VGA_SIZE	0x04B000
-#define OVERLAY_720P_TILE_SIZE  0x0E6000
-#define OVERLAY_WSVGA_SIZE 0x98000 
-
-#define OVERLAY_BUS_SCALE_TABLE_BASE	6
-
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-static int cabc_cur_mode = 0;
-static int cabc_mode = 0;
-
-static int mdp4_overlay_is_rgb_type(int format)
-{
-	switch (format) {
-	case MDP_RGB_565:
-	case MDP_RGB_888:
-	case MDP_BGR_565:
-	case MDP_XRGB_8888:
-	case MDP_ARGB_8888:
-	case MDP_RGBA_8888:
-	case MDP_BGRA_8888:
-	case MDP_RGBX_8888:
-		return 1;
-	default:
-		return 0;
-	}
-}
-#endif
-
 static int mdp4_calc_pipe_mdp_bw(struct msm_fb_data_type *mfd,
-			  struct mdp4_overlay_pipe *pipe)
+			 struct mdp4_overlay_pipe *pipe)
 {
-	u32 res;
+	u32 fps;
 	int ret = -EINVAL;
+	u32 quota;
+	u32 shift = 16;
 
 	if (!pipe) {
 		pr_err("%s: pipe is null!\n", __func__);
@@ -2518,106 +2845,148 @@
 		return ret;
 	}
 
-	if (pipe->flags & MDP_DEINTERLACE) {
-		pr_info("%s deinterlace requires max mdp bw.\n",
-			__func__);
-		pipe->req_bw = OVERLAY_PERF_LEVEL1;
-		return 0;
-	}
+	fps = mdp_get_panel_framerate(mfd);
+	quota = pipe->src_w * pipe->src_h * fps * pipe->bpp;
 
-	if (pipe->pipe_type == OVERLAY_TYPE_BF) {
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		return 0;
+	quota >>= shift;
+	
+	quota = quota * mdp_bw_ab_factor / 100;
+	
+	if ((pipe->dst_h) && (pipe->src_h) &&
+	    (pipe->src_h > pipe->dst_h)) {
+		quota = quota * pipe->src_h / pipe->dst_h;
+		pr_debug("%s: src_h=%d dst_h=%d mdp ab %llu\n",
+			__func__, pipe->src_h, pipe->dst_h, ((u64)quota << 16));
 	}
+	pipe->bw_ab_quota = quota;
 
-	res = pipe->src_w * pipe->src_h;
+	
+	pipe->bw_ib_quota = quota * mdp_bw_ib_factor / 100;
 
-	if (res <= OVERLAY_WSVGA_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-	else if (res <= OVERLAY_VGA_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL3;
-	else if (res <= OVERLAY_720P_TILE_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL2;
-	else
-		pipe->req_bw = OVERLAY_PERF_LEVEL1;
+	pipe->bw_ab_quota <<= shift;
+	pipe->bw_ib_quota <<= shift;
+
+	pr_debug("%s: pipe ndx=%d src(h,w)(%d, %d) fps=%d bpp=%d\n",
+		 __func__, pipe->pipe_ndx,  pipe->src_h, pipe->src_w,
+		 fps, pipe->bpp);
+	pr_debug("%s: ab_quota=%llu ib_quota=%llu\n", __func__,
+		 pipe->bw_ab_quota, pipe->bw_ib_quota);
 
 	return 0;
 }
-int mdp4_overlay_blt_check(struct msm_fb_data_type *mfd,
-			   struct mdp4_overlay_pipe *plist)
+
+int mdp4_calc_blt_mdp_bw(struct msm_fb_data_type *mfd,
+			 struct mdp4_overlay_pipe *pipe)
 {
-	int i;
 	struct mdp4_overlay_perf *perf_req = &perf_request;
-	struct mdp4_overlay_pipe *pipe = plist;
+	u32 fps;
+	int bpp;
 	int ret = -EINVAL;
-
+	u32 quota;
+	u32 shift = 16;
+	if (!pipe) {
+		pr_err("%s: pipe is null!\n", __func__);
+		return ret;
+	}
 	if (!mfd) {
 		pr_err("%s: mfd is null!\n", __func__);
 		return ret;
 	}
 
-	if (!plist) {
-		pr_err("%s: plist is null!\n", __func__);
-		return ret;
-	}
+	bpp = BLT_BPP;
+	fps = mdp_get_panel_framerate(mfd);
 
-	perf_req->use_ov0_blt = 0;
-	perf_req->use_ov1_blt = 0;
+	
+	quota = pipe->dst_w * pipe->dst_h * fps * bpp * 2;
+	quota >>= shift;
 
-	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+	perf_req->mdp_ov_ab_bw[pipe->mixer_num] =
+		quota * mdp_bw_ab_factor / 100;
 
-		if (!pipe)
-			return ret;
+	perf_req->mdp_ov_ib_bw[pipe->mixer_num] =
+		quota * mdp_bw_ib_factor / 100;
 
-		if (!pipe->pipe_used)
-			continue;
+	perf_req->mdp_ov_ab_bw[pipe->mixer_num] <<= shift;
+	perf_req->mdp_ov_ib_bw[pipe->mixer_num] <<= shift;
 
-		if (pipe->req_clk > mdp_max_clk) {
-			if (pipe->mixer_num == MDP4_MIXER0)
-				perf_req->use_ov0_blt = 1;
-			if (pipe->mixer_num == MDP4_MIXER1)
-				perf_req->use_ov1_blt = 1;
-		}
+	pr_debug("%s: pipe ndx=%d dst(h,w)(%d, %d) fps=%d bpp=%d\n",
+		 __func__, pipe->pipe_ndx, pipe->dst_h, pipe->dst_w,
+		 fps, bpp);
+	pr_debug("%s: overlay=%d ab_bw=%llu ib_bw=%llu\n", __func__,
+		 pipe->mixer_num,
+		 perf_req->mdp_ov_ab_bw[pipe->mixer_num],
+		 perf_req->mdp_ov_ib_bw[pipe->mixer_num]);
 
-		if (mfd->mdp_rev == MDP_REV_41) {
-			if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
-				if (pipe->dst_x != 0 && (OVERLAY_TYPE_RGB !=
-					mdp4_overlay_format2type(pipe->src_format))) {
-					perf_req->use_ov0_blt = 1;
-				}
-			}
-			if ((mfd->panel_info.xres > 1280) &&
-			    (mfd->panel_info.type != DTV_PANEL)) {
-				perf_req->use_ov0_blt = 1;
-			}
-		}
-	}
 	return 0;
 }
 
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
-			      struct mdp4_overlay_pipe *plist)
+static int mdp4_axi_port_read_client_pipe(struct mdp4_overlay_pipe *pipe)
+{
+	u32 data = inpdw(MDP_BASE + 0x0404);
+	u32 port = 0;
+	if (pipe->pipe_ndx == 1) 
+		port = (data & 0x0010) ? 1 : 0;
+	else if (pipe->pipe_ndx == 2) 
+		port = (data & 0x0080) ? 1 : 0;
+	else if (pipe->pipe_ndx == 3) 
+		port = (data & 0x0001) ? 1 : 0;
+	else if (pipe->pipe_ndx == 4) 
+		port = (data & 0x0004) ? 1 : 0;
+	pr_debug("%s axi_rd=%x pipe_ndx=%d port=%d\n", __func__,
+		data, pipe->pipe_ndx, port);
+	return port;
+}
+
+static int mdp4_axi_port_read_client_mixer(int mixer)
+{
+	u32 data = inpdw(MDP_BASE + 0x0404);
+	u32 port = 0;
+	if (mixer == MDP4_MIXER0) 
+		port = (data & 0x1000) ? 1 : 0;
+	else if (mixer == MDP4_MIXER1) 
+		port = (data & 0x80000) ? 1 : 0;
+	pr_debug("%s axi_rd=%x mixer=%d port=%d\n",
+		 __func__, data, mixer, port);
+	return port;
+}
+
+static int mdp4_axi_port_write_client_mixer(int mixer)
+{
+	u32 data = inpdw(MDP_BASE + 0x0408);
+	u32 port = 0;
+	if (mixer == MDP4_MIXER0) 
+		port = (data & 0x0001) ? 1 : 0;
+	else if (mixer == MDP4_MIXER1) 
+		port = (data & 0x0004) ? 1 : 0;
+	else if (mixer == MDP4_MIXER2)
+		port = (data & 0x0004) ? 1 : 0;
+	pr_debug("%s axi_wr=%x mixer=%d port=%d\n",
+		 __func__, data, mixer, port);
+	return port;
+}
+
+int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd)
 {
 	u32 worst_mdp_clk = 0;
-	u32 worst_mdp_bw = OVERLAY_PERF_LEVEL4;
 	int i;
 	struct mdp4_overlay_perf *perf_req = &perf_request;
-	struct mdp4_overlay_pipe *pipe = plist;
+	struct mdp4_overlay_pipe *pipe;
 	u32 cnt = 0;
 	int ret = -EINVAL;
+	u64 ab_quota_total = 0, ib_quota_total = 0;
+	u64 ab_quota_port0 = 0, ib_quota_port0 = 0;
+	u64 ab_quota_port1 = 0, ib_quota_port1 = 0;
+	u64 ib_quota_min = 0;
 
 	if (!mfd) {
 		pr_err("%s: mfd is null!\n", __func__);
 		return ret;
 	}
 
-	if (!plist) {
-		pr_err("%s: plist is null!\n", __func__);
-		return ret;
-	}
+	pipe = ctrl->plist;
 
-	perf_req->use_ov0_blt = 0;
-	perf_req->use_ov1_blt = 0;
+	for (i = 0; i < MDP4_MIXER_MAX; i++)
+		perf_req->use_ov_blt[i] = 0;
 
 	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
 
@@ -2630,74 +2999,114 @@
 		if (worst_mdp_clk < pipe->req_clk)
 			worst_mdp_clk = pipe->req_clk;
 
-		if (pipe->req_clk > mdp_max_clk) {
-			if (pipe->mixer_num == MDP4_MIXER0)
-				perf_req->use_ov0_blt = 1;
-			if (pipe->mixer_num == MDP4_MIXER1)
-				perf_req->use_ov1_blt = 1;
-		}
-
-		if (!pipe->req_bw) {
-			pr_err("%s mdp pipe bw request should not be zero!\n",
-			       __func__);
-			pr_debug("%s %d pid %d num %d idx %d mix %d bw %d\n",
-				 __func__, __LINE__, current->pid,
-				 pipe->pipe_num, pipe->pipe_ndx,
-				 pipe->mixer_num, pipe->req_bw);
-			pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		}
+		if (pipe->req_clk > mdp_max_clk)
+			perf_req->use_ov_blt[pipe->mixer_num] = 1;
 
-		if (pipe->req_bw < worst_mdp_bw)
-			worst_mdp_bw = pipe->req_bw;
+		if (pipe->mixer_num == MDP4_MIXER2)
+			perf_req->use_ov_blt[MDP4_MIXER2] = 1;
 
-		if (pipe->mixer_num == MDP4_MIXER0) {
-			
-			switch (pipe->src_format) {
-			case MDP_XRGB_8888:
-			case MDP_ARGB_8888:
-			case MDP_RGBA_8888:
-			case MDP_BGRA_8888:
-			case MDP_RGBX_8888:
-				break;
-			default:
-				worst_mdp_bw = OVERLAY_PERF_LEVEL4;
-				break;
+		if (pipe->pipe_type != OVERLAY_TYPE_BF) {
+			ab_quota_total += pipe->bw_ab_quota;
+			ib_quota_total += pipe->bw_ib_quota;
+			if (mdp4_axi_port_read_client_pipe(pipe)) {
+				ab_quota_port1 += pipe->bw_ab_quota;
+				ib_quota_port1 += pipe->bw_ib_quota;
+			} else {
+				ab_quota_port0 += pipe->bw_ab_quota;
+				ib_quota_port0 += pipe->bw_ib_quota;
 			}
+		} else {
+			if (ib_quota_min == 0)
+				ib_quota_min = pipe->bw_ib_quota;
+			else
+				ib_quota_min = min(ib_quota_min,
+						   pipe->bw_ib_quota);
 		}
-
 		if (mfd->mdp_rev == MDP_REV_41) {
 			if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
-				if (pipe->dst_x != 0 && (OVERLAY_TYPE_RGB !=
-					mdp4_overlay_format2type(pipe->src_format))) {
-					perf_req->use_ov0_blt = 1;
-				}
+				if (pipe->dst_x != 0)
+					perf_req->use_ov_blt[MDP4_MIXER0] = 1;
 			}
 			if ((mfd->panel_info.xres > 1280) &&
 			    (mfd->panel_info.type != DTV_PANEL)) {
-				perf_req->use_ov0_blt = 1;
+				perf_req->use_ov_blt[MDP4_MIXER0] = 1;
 			}
 		}
 	}
 
-	perf_req->mdp_clk_rate = worst_mdp_clk;
-	if (perf_req->mdp_clk_rate > mdp_max_clk)
-		perf_req->mdp_clk_rate = mdp_max_clk;
-	else if (perf_req->mdp_clk_rate < mdp_min_clk)
-		perf_req->mdp_clk_rate = mdp_min_clk;
-
+	perf_req->mdp_clk_rate = min(worst_mdp_clk, mdp_max_clk);
 	perf_req->mdp_clk_rate = mdp_clk_round_rate(perf_req->mdp_clk_rate);
 
-	perf_req->mdp_bw = worst_mdp_bw;
+	for (i = 0; i < MDP4_MIXER_MAX; i++) {
+		if (perf_req->use_ov_blt[i]) {
+			ab_quota_total += perf_req->mdp_ov_ab_bw[i];
+			ib_quota_total += perf_req->mdp_ov_ib_bw[i];
+			if (mdp4_axi_port_read_client_mixer(i)) {
+				ab_quota_port1 +=
+					(perf_req->mdp_ov_ab_bw[i] >> 1);
+				ib_quota_port1 +=
+					(perf_req->mdp_ov_ib_bw[i] >> 1);
+			} else {
+				ab_quota_port0 +=
+					(perf_req->mdp_ov_ab_bw[i] >> 1);
+				ib_quota_port0 +=
+					(perf_req->mdp_ov_ib_bw[i] >> 1);
+			}
+			if (mdp4_axi_port_write_client_mixer(i)) {
+				ab_quota_port1 +=
+					(perf_req->mdp_ov_ab_bw[i] >> 1);
+				ib_quota_port1 +=
+					(perf_req->mdp_ov_ib_bw[i] >> 1);
+			} else {
+				ab_quota_port0 +=
+					(perf_req->mdp_ov_ab_bw[i] >> 1);
+				ib_quota_port0 +=
+					(perf_req->mdp_ov_ib_bw[i] >> 1);
+			}
+		}
+	}
+
+	ib_quota_total = max(ib_quota_total, ib_quota_min);
+
+	perf_req->mdp_ab_bw = roundup(ab_quota_total, MDP_BUS_SCALE_AB_STEP);
+	perf_req->mdp_ib_bw = roundup(ib_quota_total, MDP_BUS_SCALE_AB_STEP);
 
-	if (cnt >= 3)
-		perf_req->mdp_bw = OVERLAY_PERF_LEVEL1;
+	perf_req->mdp_ab_port0_bw =
+		roundup(ab_quota_port0, MDP_BUS_SCALE_AB_STEP);
+	perf_req->mdp_ib_port0_bw =
+		roundup(ib_quota_total, MDP_BUS_SCALE_AB_STEP);
+	perf_req->mdp_ab_port1_bw =
+		roundup(ab_quota_port1, MDP_BUS_SCALE_AB_STEP);
+	perf_req->mdp_ib_port1_bw =
+		roundup(ib_quota_total, MDP_BUS_SCALE_AB_STEP);
 
-	pr_debug("%s %d pid %d cnt %d clk %d ov0_blt %d, ov1_blt %d bw %d\n",
+	pr_debug("%s %d: ab_quota_total=(%llu, %llu) ib_quota_total=(%llu, %llu)\n",
+		 __func__, __LINE__,
+		 ab_quota_total, perf_req->mdp_ab_bw,
+		 ib_quota_total, perf_req->mdp_ib_bw);
+
+	pr_debug("%s %d: ab_quota_port0=(%llu, %llu) ib_quota_port0=(%llu, %llu)\n",
+		 __func__, __LINE__,
+		 ab_quota_port0, perf_req->mdp_ab_port0_bw,
+		 ib_quota_port0, perf_req->mdp_ib_port0_bw);
+
+	pr_debug("%s %d: ab_quota_port1=(%llu, %llu) ib_quota_port1=(%llu, %llu)\n",
+		 __func__, __LINE__,
+		 ab_quota_port1, perf_req->mdp_ab_port1_bw,
+		 ib_quota_port1, perf_req->mdp_ib_port1_bw);
+
+	if (ab_quota_total > mdp_max_bw)
+		pr_debug("%s: req ab bw=%llu is larger than max bw=%llu",
+			__func__, ab_quota_total, mdp_max_bw);
+	if (ib_quota_total > mdp_max_bw)
+		pr_debug("%s: req ib bw=%llu is larger than max bw=%llu",
+			__func__, ib_quota_total, mdp_max_bw);
+
+	pr_debug("%s %d: pid %d cnt %d clk %d ov0_blt %d, ov1_blt %d\n",
 		 __func__, __LINE__, current->pid, cnt,
 		 perf_req->mdp_clk_rate,
-		 perf_req->use_ov0_blt,
-		 perf_req->use_ov1_blt,
-		 perf_req->mdp_bw);
+		 perf_req->use_ov_blt[0],
+		 perf_req->use_ov_blt[1]);
 
 	return 0;
 }
@@ -2733,13 +3142,10 @@
 		 flag);
 
 	if (!mdp4_extn_disp)
-		perf_cur->use_ov1_blt = 0;
+		perf_cur->use_ov_blt[1] = 0;
 
 	if (flag) {
 		if (perf_req->mdp_clk_rate > perf_cur->mdp_clk_rate) {
-#ifdef CONFIG_ARCH_MSM8X60
-			perf_req->mdp_clk_rate = 160000000;
-#endif
 			mdp_set_core_clk(perf_req->mdp_clk_rate);
 			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
 				__func__,
@@ -2749,19 +3155,29 @@
 			perf_cur->mdp_clk_rate =
 				perf_req->mdp_clk_rate;
 		}
-		if (perf_req->mdp_bw < perf_cur->mdp_bw) {
+		if ((perf_req->mdp_ab_bw > perf_cur->mdp_ab_bw) ||
+		    (perf_req->mdp_ib_bw > perf_cur->mdp_ib_bw)) {
 			mdp_bus_scale_update_request
-				(OVERLAY_BUS_SCALE_TABLE_BASE -
-				 perf_req->mdp_bw);
-			pr_info("%s mdp bw is changed [%d] from %d to %d\n",
+				(perf_req->mdp_ab_port0_bw,
+				 perf_req->mdp_ib_port0_bw,
+				 perf_req->mdp_ab_port1_bw,
+				 perf_req->mdp_ib_port1_bw);
+			pr_debug("%s mdp ab_bw is changed [%d] from %llu to %llu\n",
+				__func__,
+				flag,
+				perf_cur->mdp_ab_bw,
+				perf_req->mdp_ab_bw);
+			pr_debug("%s mdp ib_bw is changed [%d] from %llu to %llu\n",
 				__func__,
 				flag,
-				perf_cur->mdp_bw,
-				perf_req->mdp_bw);
-			perf_cur->mdp_bw = perf_req->mdp_bw;
+				perf_cur->mdp_ib_bw,
+				perf_req->mdp_ib_bw);
+			perf_cur->mdp_ab_bw = perf_req->mdp_ab_bw;
+			perf_cur->mdp_ib_bw = perf_req->mdp_ib_bw;
 		}
-		if (mfd->panel_info.pdest == DISPLAY_1 &&
-		    perf_req->use_ov0_blt && !perf_cur->use_ov0_blt) {
+
+		if ((mfd->panel_info.pdest == DISPLAY_1 &&
+		     perf_req->use_ov_blt[0] && !perf_cur->use_ov_blt[0])) {
 			if (mfd->panel_info.type == LCDC_PANEL ||
 			    mfd->panel_info.type == LVDS_PANEL)
 				mdp4_lcdc_overlay_blt_start(mfd);
@@ -2772,22 +3188,11 @@
 			pr_info("%s mixer0 start blt [%d] from %d to %d.\n",
 				__func__,
 				flag,
-				perf_cur->use_ov0_blt,
-				perf_req->use_ov0_blt);
-			perf_cur->use_ov0_blt = perf_req->use_ov0_blt;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_2 &&
-		    perf_req->use_ov1_blt && !perf_cur->use_ov1_blt) {
-			mdp4_dtv_overlay_blt_start(mfd);
-			pr_info("%s mixer1 start blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov1_blt,
-				perf_req->use_ov1_blt);
-			perf_cur->use_ov1_blt = perf_req->use_ov1_blt;
+				perf_cur->use_ov_blt[0],
+				perf_req->use_ov_blt[0]);
+			perf_cur->use_ov_blt[0] = perf_req->use_ov_blt[0];
 		}
 	} else {
-#ifndef CONFIG_ARCH_MSM8X60
 		if (perf_req->mdp_clk_rate < perf_cur->mdp_clk_rate) {
 			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
 				__func__,
@@ -2798,20 +3203,29 @@
 			perf_cur->mdp_clk_rate =
 				perf_req->mdp_clk_rate;
 		}
-#endif
-		if (perf_req->mdp_bw > perf_cur->mdp_bw) {
-			pr_info("%s mdp bw is changed [%d] from %d to %d\n",
+		if (perf_req->mdp_ab_bw < perf_cur->mdp_ab_bw ||
+		    perf_req->mdp_ib_bw < perf_cur->mdp_ib_bw) {
+			mdp_bus_scale_update_request
+				(perf_req->mdp_ab_port0_bw,
+				 perf_req->mdp_ib_port0_bw,
+				 perf_req->mdp_ab_port1_bw,
+				 perf_req->mdp_ib_port1_bw);
+			pr_debug("%s mdp ab bw is changed [%d] from %llu to %llu\n",
 				__func__,
 				flag,
-				perf_cur->mdp_bw,
-				perf_req->mdp_bw);
-			mdp_bus_scale_update_request
-				(OVERLAY_BUS_SCALE_TABLE_BASE -
-				 perf_req->mdp_bw);
-			perf_cur->mdp_bw = perf_req->mdp_bw;
+				perf_cur->mdp_ab_bw,
+				perf_req->mdp_ab_bw);
+			pr_debug("%s mdp ib bw is changed [%d] from %llu to %llu\n",
+				__func__,
+				flag,
+				perf_cur->mdp_ib_bw,
+				perf_req->mdp_ib_bw);
+			perf_cur->mdp_ab_bw = perf_req->mdp_ab_bw;
+			perf_cur->mdp_ib_bw = perf_req->mdp_ib_bw;
 		}
-		if (mfd->panel_info.pdest == DISPLAY_1 &&
-		    !perf_req->use_ov0_blt && perf_cur->use_ov0_blt) {
+
+		if ((mfd->panel_info.pdest == DISPLAY_1 &&
+		     !perf_req->use_ov_blt[0] && perf_cur->use_ov_blt[0])) {
 			if (mfd->panel_info.type == LCDC_PANEL ||
 			    mfd->panel_info.type == LVDS_PANEL)
 				mdp4_lcdc_overlay_blt_stop(mfd);
@@ -2822,37 +3236,14 @@
 			pr_info("%s mixer0 stop blt [%d] from %d to %d.\n",
 				__func__,
 				flag,
-				perf_cur->use_ov0_blt,
-				perf_req->use_ov0_blt);
-			perf_cur->use_ov0_blt = perf_req->use_ov0_blt;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_2 &&
-		    !perf_req->use_ov1_blt && perf_cur->use_ov1_blt) {
-			mdp4_dtv_overlay_blt_stop(mfd);
-			pr_info("%s mixer1 stop blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov1_blt,
-				perf_req->use_ov1_blt);
-			perf_cur->use_ov1_blt = perf_req->use_ov1_blt;
+				perf_cur->use_ov_blt[0],
+				perf_req->use_ov_blt[0]);
+			perf_cur->use_ov_blt[0] = perf_req->use_ov_blt[0];
 		}
 	}
 	return;
 }
 
-void mdp4_overlay_mdp_perf_dump()
-{
-	struct mdp4_overlay_perf *req = &perf_request;
-	struct mdp4_overlay_perf *cur = &perf_current;
-
-	pr_info("[DISP] req = {clk=%u, bw=%u, ov0_blt=%d, ov1_blt=%d}\n",
-	   req->mdp_clk_rate, req->mdp_bw, req->use_ov0_blt, req->use_ov1_blt);
-	pr_info("[DISP] cur = {clk=%u, bw=%u, ov0_blt=%d, ov1_blt=%d}\n",
-	   cur->mdp_clk_rate, cur->mdp_bw, cur->use_ov0_blt, cur->use_ov1_blt);
-
-	
-}
-
 static int get_img(struct msmfb_data *img, struct fb_info *info,
 	struct mdp4_overlay_pipe *pipe, unsigned int plane,
 	unsigned long *start, unsigned long *len, struct file **srcp_file,
@@ -2876,6 +3267,7 @@
 		if (file == NULL)
 			return -EINVAL;
 
+		pipe->flags |= MDP_MEMORY_ID_TYPE_FB;
 		if (MAJOR(file->f_dentry->d_inode->i_rdev) == FB_MAJOR) {
 			fb_num = MINOR(file->f_dentry->d_inode->i_rdev);
 			if (get_fb_phys_info(start, len, fb_num,
@@ -2978,9 +3370,6 @@
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	int ret, mixer;
 	struct mdp4_overlay_pipe *pipe;
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	struct msm_fb_panel_data *pdata;
-#endif
 
 	if (mfd == NULL) {
 		pr_err("%s: mfd == NULL, -ENODEV\n", __func__);
@@ -3009,6 +3398,11 @@
 		return ret;
 	}
 
+	if (pipe->flags & MDP_SECURE_OVERLAY_SESSION) {
+		mdp4_map_sec_resource(mfd);
+		mfd->sec_active = TRUE;
+	}
+
 	
 	req->id = pipe->pipe_ndx;	
 	pipe->req_data = *req;		
@@ -3024,40 +3418,24 @@
 		}
 	}
 
-	if (pipe->flags & MDP_SHARPENING) {
-		bool test = ((pipe->req_data.dpp.sharp_strength > 0) &&
-			((req->src_rect.w > req->dst_rect.w) &&
-			 (req->src_rect.h > req->dst_rect.h)));
-		if (test) {
-			pr_debug("%s: No sharpening while downscaling.\n",
+	mdp4_stat.overlay_set[pipe->mixer_num]++;
+
+	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN) {
+		if (pipe->pipe_num <= OVERLAY_PIPE_VG2)
+			memcpy(&pipe->pp_cfg, &req->overlay_pp_cfg,
+					sizeof(struct mdp_overlay_pp_params));
+		else
+			pr_debug("%s: RGB Pipes don't support CSC/QSEED\n",
 								__func__);
-			pipe->flags &= ~MDP_SHARPENING;
-		}
 	}
 
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	if (!mdp4_overlay_is_rgb_type(pipe->src_format)) {
-		cabc_mode = 1;
-	}
-#endif
+	if (hdmi_prim_display)
+		fill_black_screen(FALSE, pipe->pipe_num, pipe->mixer_num);
 
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 
 	mutex_unlock(&mfd->dma->ov_mutex);
 
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	if (cabc_cur_mode != cabc_mode) {
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
-			dev.platform_data;
-		if ((pdata) && (pdata->set_cabc)) {
-			down(&mfd->sem);
-			pdata->set_cabc(mfd, cabc_mode);
-			cabc_cur_mode = cabc_mode;
-			up(&mfd->sem);
-		}
-	}
-#endif
-
 	return 0;
 }
 
@@ -3071,10 +3449,11 @@
 		pipe = ctrl->stage[mixer][i];
 		if (pipe == NULL)
 			continue;
+
 		pipe->flags &= ~MDP_OV_PLAY_NOWAIT;
 		mdp4_overlay_reg_flush(pipe, 1);
 		mdp4_mixer_stage_down(pipe, 1);
-		mdp4_overlay_pipe_free(pipe);
+		mdp4_overlay_pipe_free(pipe, 1);
 		cnt++;
 	}
 
@@ -3085,11 +3464,6 @@
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	struct mdp4_overlay_pipe *pipe;
-	struct dpp_ctrl dpp;
-	int i;
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	struct msm_fb_panel_data *pdata;
-#endif
 
 	if (mfd == NULL)
 		return -ENODEV;
@@ -3123,12 +3497,6 @@
 		}
 	}
 
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	if (!mdp4_overlay_is_rgb_type(pipe->src_format)) {
-		cabc_mode = 0;
-	}
-#endif
-
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_down(pipe, 0);
 
@@ -3137,56 +3505,37 @@
 			if (mfd->panel_power_on)
 				mdp4_mddi_overlay_restore();
 		}
-
 	} else {	
-		if (ctrl->panel_mode & MDP4_PANEL_DTV)
+		if (ctrl->panel_mode & MDP4_PANEL_DTV) {
+			if (hdmi_prim_display)
+				fill_black_screen(TRUE, pipe->pipe_num,
+					pipe->mixer_num);
 			mdp4_overlay_dtv_unset(mfd, pipe);
-	}
-
-	
-	if (pipe->flags & MDP_DPP_HSIC) {
-		for (i = 0; i < NUM_HSIC_PARAM; i++)
-			dpp.hsic_params[i] = 0;
-
-		mdp4_hsic_set(pipe, &dpp);
-		mdp4_hsic_update(pipe);
+		}
 	}
 
 	mdp4_stat.overlay_unset[pipe->mixer_num]++;
 
-	mdp4_overlay_pipe_free(pipe);
-
-	mdp4_overlay_blt_check(mfd, ctrl->plist);
+	if (pipe->flags & MDP_SECURE_OVERLAY_SESSION)
+		mfd->sec_active = FALSE;
+	mdp4_overlay_pipe_free(pipe, 0);
 
 	mutex_unlock(&mfd->dma->ov_mutex);
 
-#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
-	if (cabc_cur_mode != cabc_mode) {
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
-			dev.platform_data;
-		if ((pdata) && (pdata->set_cabc)) {
-			down(&mfd->sem);
-			pdata->set_cabc(mfd, cabc_mode);
-			cabc_cur_mode = cabc_mode;
-			up(&mfd->sem);
-		}
-	}
-#endif
-
 	return 0;
 }
 
-int mdp4_overlay_wait4vsync(struct fb_info *info, long long *vtime)
+int mdp4_overlay_wait4vsync(struct fb_info *info)
 {
 	if (!hdmi_prim_display && info->node == 0) {
 		if (ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO)
-			mdp4_dsi_video_wait4vsync(0, vtime);
+			mdp4_dsi_video_wait4vsync(0);
 		else if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD)
-			mdp4_dsi_cmd_wait4vsync(0, vtime);
+			mdp4_dsi_cmd_wait4vsync(0);
 		else if (ctrl->panel_mode & MDP4_PANEL_LCDC)
-			mdp4_lcdc_wait4vsync(0, vtime);
+			mdp4_lcdc_wait4vsync(0);
 	} else if (hdmi_prim_display || info->node == 1) {
-		mdp4_dtv_wait4vsync(0, vtime);
+		mdp4_dtv_wait4vsync(0);
 	}
 
 	return 0;
@@ -3195,6 +3544,13 @@
 int mdp4_overlay_vsync_ctrl(struct fb_info *info, int enable)
 {
 	int cmd;
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+
+	if (mfd == NULL)
+		return -ENODEV;
+
+	if (!mfd->panel_power_on)
+		return -EINVAL;
 
 	if (enable)
 		cmd = 1;
@@ -3273,20 +3629,14 @@
 	struct mdp4_overlay_pipe *pipe;
 	ulong start, addr;
 	ulong len = 0;
-	struct file *srcp0_file = NULL;
-	struct file *srcp1_file = NULL, *srcp2_file = NULL;
 	struct ion_handle *srcp0_ihdl = NULL;
 	struct ion_handle *srcp1_ihdl = NULL, *srcp2_ihdl = NULL;
-	int ps0_need, p_need;
 	uint32_t overlay_version = 0;
 	int ret = 0;
 
 	if (mfd == NULL)
 		return -ENODEV;
 
-	if (!mfd->panel_power_on) 
-		return -EPERM;
-
 	pipe = mdp4_overlay_ndx2pipe(req->id);
 	if (pipe == NULL) {
 		mdp4_stat.err_play++;
@@ -3302,8 +3652,8 @@
 	mutex_lock(&mfd->dma->ov_mutex);
 
 	img = &req->data;
-	get_img(img, info, pipe, 0, &start, &len, &srcp0_file,
-		&ps0_need, &srcp0_ihdl);
+	get_img(img, info, pipe, 0, &start, &len, &pipe->srcp0_file,
+		&pipe->put0_need, &srcp0_ihdl);
 	if (len == 0) {
 		pr_err("%s: pmem Error\n", __func__);
 		ret = -1;
@@ -3314,6 +3664,7 @@
 	pipe->srcp0_addr = addr;
 	pipe->srcp0_ystride = pipe->src_width * pipe->bpp;
 
+
 	pr_debug("%s: mixer=%d ndx=%x addr=%x flags=%x pid=%d\n", __func__,
 		pipe->mixer_num, pipe->pipe_ndx, (int)addr, pipe->flags,
 							current->pid);
@@ -3324,8 +3675,9 @@
 	if (pipe->fetch_plane == OVERLAY_PLANE_PSEUDO_PLANAR) {
 		if (overlay_version > 0) {
 			img = &req->plane1_data;
-			get_img(img, info, pipe, 1, &start, &len, &srcp1_file,
-				&p_need, &srcp1_ihdl);
+			get_img(img, info, pipe, 1, &start, &len,
+				&pipe->srcp1_file, &pipe->put1_need,
+				&srcp1_ihdl);
 			if (len == 0) {
 				pr_err("%s: Error to get plane1\n", __func__);
 				ret = -EINVAL;
@@ -3355,8 +3707,9 @@
 	} else if (pipe->fetch_plane == OVERLAY_PLANE_PLANAR) {
 		if (overlay_version > 0) {
 			img = &req->plane1_data;
-			get_img(img, info, pipe, 1, &start, &len, &srcp1_file,
-				&p_need, &srcp1_ihdl);
+			get_img(img, info, pipe, 1, &start, &len,
+				&pipe->srcp1_file, &pipe->put1_need,
+				&srcp1_ihdl);
 			if (len == 0) {
 				pr_err("%s: Error to get plane1\n", __func__);
 				ret = -EINVAL;
@@ -3365,8 +3718,9 @@
 			pipe->srcp1_addr = start + img->offset;
 
 			img = &req->plane2_data;
-			get_img(img, info, pipe, 2, &start, &len, &srcp2_file,
-				&p_need, &srcp2_ihdl);
+			get_img(img, info, pipe, 2, &start, &len,
+				&pipe->srcp2_file, &pipe->put2_need,
+				&srcp2_ihdl);
 			if (len == 0) {
 				pr_err("%s: Error to get plane2\n", __func__);
 				ret = -EINVAL;
@@ -3405,10 +3759,7 @@
 		}
 	}
 
-	mdp4_overlay_mdp_perf_req(mfd, ctrl->plist);
-
-	if (pipe->mixer_num == MDP4_MIXER2 || ctrl->panel_mode & MDP4_PANEL_MDDI)
-		goto mddi;
+	mdp4_overlay_mdp_perf_req(mfd);
 
 	if (pipe->mixer_num == MDP4_MIXER0) {
 		if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
@@ -3424,60 +3775,15 @@
 	} else if (pipe->mixer_num == MDP4_MIXER1) {
 		if (ctrl->panel_mode & MDP4_PANEL_DTV)
 			mdp4_dtv_pipe_queue(0, pipe);
-	}
-
-	mutex_unlock(&mfd->dma->ov_mutex);
-	return ret;
-
-mddi:
-	if (pipe->pipe_type == OVERLAY_TYPE_VIDEO) {
-		mdp4_overlay_vg_setup(pipe);    
-	} else {
-		mdp4_overlay_rgb_setup(pipe);	
-	}
-
-	mdp4_mixer_stage_up(pipe, 0);
-
-	if (pipe->mixer_num == MDP4_MIXER2) {
+	} else if (pipe->mixer_num == MDP4_MIXER2) {
 		ctrl->mixer2_played++;
-#ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
-		if (ctrl->panel_mode & MDP4_PANEL_WRITEBACK) {
-			mdp4_writeback_dma_busy_wait(mfd);
-			mdp4_writeback_kickoff_video(mfd, pipe);
-		}
-#endif
-	} else if (ctrl->panel_mode & MDP4_PANEL_MDDI) {
-		if (pipe->flags & MDP_OV_PLAY_NOWAIT) {
-			mdp4_stat.overlay_play[pipe->mixer_num]++;
-			mutex_unlock(&mfd->dma->ov_mutex);
-			goto end;
-		}
-		mdp4_mixer_stage_commit(pipe->mixer_num);
-		mdp4_mddi_dma_busy_wait(mfd);
-		mdp4_mddi_kickoff_video(mfd, pipe);
+		if (ctrl->panel_mode & MDP4_PANEL_WRITEBACK)
+			mdp4_wfd_pipe_queue(0, pipe);
 	}
 
-	
-	if (pipe->flags & MDP_DPP_HSIC)
-		mdp4_hsic_update(pipe);
-	if (!(pipe->flags & MDP_OV_PLAY_NOWAIT))
-		mdp4_iommu_unmap(pipe);
-	mdp4_stat.overlay_play[pipe->mixer_num]++;
-
 end:
 	mutex_unlock(&mfd->dma->ov_mutex);
 
-#ifdef CONFIG_ANDROID_PMEM
-	if (srcp0_file)
-		put_pmem_file(srcp0_file);
-	if (srcp1_file)
-		put_pmem_file(srcp1_file);
-	if (srcp2_file)
-		put_pmem_file(srcp2_file);
-#endif
-	
-	if ((img->flags & MDP_MEMORY_ID_TYPE_FB) && srcp0_file)
-		fput_light(srcp0_file, ps0_need);
 	return ret;
 }
 
@@ -3495,9 +3801,6 @@
 
 	mixer = mfd->panel_info.pdest;	
 
-	if (mixer >= MDP4_MIXER_MAX)
-		return -EPERM;
-
 	mutex_lock(&mfd->dma->ov_mutex);
 
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
@@ -3511,6 +3814,7 @@
 	case MIPI_VIDEO_PANEL:
 		mdp4_dsi_video_pipe_commit(0, 1);
 		break;
+	case LVDS_PANEL:
 	case LCDC_PANEL:
 		mdp4_lcdc_pipe_commit(0, 1);
 		break;
@@ -3518,20 +3822,238 @@
 		mdp4_dtv_pipe_commit(0, 1);
 		break;
 	case WRITEBACK_PANEL:
+		mdp4_wfd_pipe_commit(mfd, 0, 1);
+		break;
 	default:
-		pr_err("Panel Not Supported for Commit (fb%d, type:%d)",
-		    mfd->index, mfd->panel.type);
+		pr_err("Panel Not Supported for Commit");
 		ret = -EINVAL;
 		break;
 	}
 	msm_fb_signal_timeline(mfd);
 
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
+	mdp4_unmap_sec_resource(mfd);
+	mutex_unlock(&mfd->dma->ov_mutex);
+
+	return ret;
+}
+
+#ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
+int mdp4_writeback_play(struct fb_info *info, struct msmfb_overlay_data *req)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msmfb_data *img;
+	struct mdp4_overlay_pipe *pipe;
+	ulong start, addr;
+	ulong len = 0;
+	struct file *srcp0_file = NULL;
+	struct file *srcp1_file = NULL, *srcp2_file = NULL;
+	struct ion_handle *srcp0_ihdl = NULL;
+	struct ion_handle *srcp1_ihdl = NULL, *srcp2_ihdl = NULL;
+	struct ion_handle *dst_ihdl = NULL;
+	int domain = mdp_iommu_split_domain? DISPLAY_WRITE_DOMAIN : DISPLAY_READ_DOMAIN;
+	int ps0_need, p_need;
+	uint32_t overlay_version = 0;
+	int ret = 0;
+
+	if (mfd == NULL)
+		return -ENODEV;
+
+	if (!mfd->panel_power_on) 
+		return -EPERM;
+
+	pipe = mdp4_overlay_ndx2pipe(req->id);
+	if (pipe == NULL || pipe->mixer_num != MDP4_MIXER2 || !(ctrl->panel_mode & MDP4_PANEL_WRITEBACK)) {
+		mdp4_stat.err_play++;
+		return -ENODEV;
+	}
+
+	if (pipe->pipe_type == OVERLAY_TYPE_BF) {
+		mdp4_overlay_borderfill_stage_up(pipe);
+		mdp4_mixer_stage_commit(pipe->mixer_num);
+		return 0;
+	}
+
+	mutex_lock(&mfd->dma->ov_mutex);
+
+	img = &req->data;
+	get_img(img, info, pipe, 0, &start, &len, &srcp0_file,
+		&ps0_need, &srcp0_ihdl);
+	if (len == 0) {
+		pr_err("%s: pmem Error\n", __func__);
+		ret = -1;
+		goto end;
+	}
+
+	addr = start + img->offset;
+	pipe->srcp0_addr = addr;
+	pipe->srcp0_ystride = pipe->src_width * pipe->bpp;
 
+	pr_debug("%s: mixer=%d ndx=%x addr=%x flags=%x pid=%d\n", __func__,
+		pipe->mixer_num, pipe->pipe_ndx, (int)addr, pipe->flags,
+							current->pid);
+
+	if ((req->version_key & VERSION_KEY_MASK) == 0xF9E8D700)
+		overlay_version = (req->version_key & ~VERSION_KEY_MASK);
+
+	if (pipe->fetch_plane == OVERLAY_PLANE_PSEUDO_PLANAR) {
+		if (overlay_version > 0) {
+			img = &req->plane1_data;
+			get_img(img, info, pipe, 1, &start, &len, &srcp1_file,
+				&p_need, &srcp1_ihdl);
+			if (len == 0) {
+				pr_err("%s: Error to get plane1\n", __func__);
+				ret = -EINVAL;
+				goto end;
+			}
+			pipe->srcp1_addr = start + img->offset;
+		} else if (pipe->frame_format ==
+				MDP4_FRAME_FORMAT_VIDEO_SUPERTILE) {
+			struct tile_desc tile;
+
+			tile_samsung(&tile);
+			pipe->srcp1_addr = addr + tile_mem_size(pipe, &tile);
+		} else {
+			pipe->srcp1_addr = addr + (pipe->src_width *
+						pipe->src_height);
+		}
+		pipe->srcp0_ystride = pipe->src_width;
+		if ((pipe->src_format == MDP_Y_CRCB_H1V1) ||
+			(pipe->src_format == MDP_Y_CBCR_H1V1)) {
+			if (pipe->src_width > YUV_444_MAX_WIDTH)
+				pipe->srcp1_ystride = pipe->src_width << 2;
+			else
+				pipe->srcp1_ystride = pipe->src_width << 1;
+		} else
+			pipe->srcp1_ystride = pipe->src_width;
+
+	} else if (pipe->fetch_plane == OVERLAY_PLANE_PLANAR) {
+		if (overlay_version > 0) {
+			img = &req->plane1_data;
+			get_img(img, info, pipe, 1, &start, &len, &srcp1_file,
+				&p_need, &srcp1_ihdl);
+			if (len == 0) {
+				pr_err("%s: Error to get plane1\n", __func__);
+				ret = -EINVAL;
+				goto end;
+			}
+			pipe->srcp1_addr = start + img->offset;
+
+			img = &req->plane2_data;
+			get_img(img, info, pipe, 2, &start, &len, &srcp2_file,
+				&p_need, &srcp2_ihdl);
+			if (len == 0) {
+				pr_err("%s: Error to get plane2\n", __func__);
+				ret = -EINVAL;
+				goto end;
+			}
+			pipe->srcp2_addr = start + img->offset;
+		} else {
+			if (pipe->src_format == MDP_Y_CR_CB_GH2V2) {
+				addr += (ALIGN(pipe->src_width, 16) *
+					pipe->src_height);
+				pipe->srcp1_addr = addr;
+				addr += ((ALIGN((pipe->src_width / 2), 16)) *
+					(pipe->src_height / 2));
+				pipe->srcp2_addr = addr;
+			} else {
+				addr += (pipe->src_width * pipe->src_height);
+				pipe->srcp1_addr = addr;
+				addr += ((pipe->src_width / 2) *
+					(pipe->src_height / 2));
+				pipe->srcp2_addr = addr;
+			}
+		}
+		
+		if ((pipe->src_format == MDP_Y_CR_CB_H2V2) ||
+			(pipe->src_format == MDP_Y_CR_CB_GH2V2))
+			swap(pipe->srcp1_addr, pipe->srcp2_addr);
+
+		if (pipe->src_format == MDP_Y_CR_CB_GH2V2) {
+			pipe->srcp0_ystride = ALIGN(pipe->src_width, 16);
+			pipe->srcp1_ystride = ALIGN(pipe->src_width / 2, 16);
+			pipe->srcp2_ystride = ALIGN(pipe->src_width / 2, 16);
+		} else {
+			pipe->srcp0_ystride = pipe->src_width;
+			pipe->srcp1_ystride = pipe->src_width / 2;
+			pipe->srcp2_ystride = pipe->src_width / 2;
+		}
+	}
+
+	if (!req->dst_data.iova) {
+		if (!mfd->iclient) {
+			pr_err("%s: only support ion memory\n", __func__);
+			goto end;
+		}
+
+		dst_ihdl = ion_import_dma_buf(mfd->iclient, req->dst_data.memory_id);
+
+		if (IS_ERR_OR_NULL(dst_ihdl)) {
+			pr_err("%s: ion import fd failed\n", __func__);
+			goto end;
+		}
+
+		if (ion_map_iommu(mfd->iclient,
+				  dst_ihdl,
+				  domain,
+				  GEN_POOL,
+				  SZ_4K,
+				  0,
+				  (ulong *)&req->dst_data.iova,
+				  (ulong *)&len,
+				  0,
+				  ION_IOMMU_UNMAP_DELAYED)) {
+			ion_free(mfd->iclient, dst_ihdl);
+			pr_err("%s: unable to get ion mapping addr\n",
+			       __func__);
+			goto end;
+		}
+	}
+	pipe->ov_blt_addr = (ulong)(req->dst_data.iova + req->dst_data.offset);
+	pipe->dst_format = req->dst_data.flags; 
+
+	mdp4_overlay_mdp_perf_req(mfd);
+
+	mdp_clk_ctrl(1);
+
+	if (pipe->pipe_type == OVERLAY_TYPE_VIDEO) {
+		mdp4_overlay_vg_setup(pipe);    
+	} else {
+		mdp4_overlay_rgb_setup(pipe);	
+	}
+
+	mdp4_mixer_stage_up(pipe, 0);
+
+	ctrl->mixer2_played++;
+	mdp4_writeback_play_kickoff(mfd, pipe);
+
+end:
 	mutex_unlock(&mfd->dma->ov_mutex);
 
+#ifdef CONFIG_ANDROID_PMEM
+	if (srcp0_file)
+		put_pmem_file(srcp0_file);
+	if (srcp1_file)
+		put_pmem_file(srcp1_file);
+	if (srcp2_file)
+		put_pmem_file(srcp2_file);
+#endif
+	
+	if ((img->flags & MDP_MEMORY_ID_TYPE_FB) && srcp0_file)
+		fput_light(srcp0_file, ps0_need);
+
+	if (dst_ihdl) {
+		ion_unmap_iommu(mfd->iclient,
+				dst_ihdl,
+				domain,
+				GEN_POOL);
+		ion_free(mfd->iclient,
+			 dst_ihdl);
+	}
+
 	return ret;
 }
+#endif 
 
 struct msm_iommu_ctx {
 	char *name;
@@ -3653,7 +4175,7 @@
 {
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_down(pipe, 1);
-	mdp4_overlay_pipe_free(pipe);
+	mdp4_overlay_pipe_free(pipe, 1);
 }
 
 int mdp4_v4l2_overlay_play(struct fb_info *info, struct mdp4_overlay_pipe *pipe,
@@ -3661,7 +4183,7 @@
 	unsigned long srcp2_addr)
 {
 	struct msm_fb_data_type *mfd = info->par;
-	int err = 0;
+	int err;
 
 	if (mutex_lock_interruptible(&mfd->dma->ov_mutex))
 		return -EINTR;
@@ -3731,4 +4253,21 @@
 	mutex_unlock(&mfd->dma->ov_mutex);
 	return err;
 }
+int mdp4_overlay_reset()
+{
+	u32 req_use_ov_blt[MDP4_MIXER_MAX];
+	u32 cur_use_ov_blt[MDP4_MIXER_MAX];
+
+	
+	memcpy(req_use_ov_blt, perf_request.use_ov_blt, sizeof(req_use_ov_blt));
+	memcpy(cur_use_ov_blt, perf_current.use_ov_blt, sizeof(cur_use_ov_blt));
+
+	memset(&perf_request, 0, sizeof(perf_request));
+	memset(&perf_current, 0, sizeof(perf_current));
+
+	
+	memcpy(perf_request.use_ov_blt, req_use_ov_blt, sizeof(req_use_ov_blt));
+	memcpy(perf_current.use_ov_blt, cur_use_ov_blt, sizeof(cur_use_ov_blt));
 
+	return 0;
+}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dsi_cmd.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dsi_cmd.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dsi_cmd.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dsi_cmd.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -25,24 +25,20 @@
 #include <asm/system.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
-#include <mach/debug_display.h>
 
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mdp4.h"
 
-static int dsi_state;
-
-#define TOUT_PERIOD	HZ	
-#define MS_100		(HZ/10)	
-
 static int vsync_start_y_adjust = 4;
 
 #define MAX_CONTROLLER	1
 
 #define VSYNC_EXPIRE_TICK 4
 
+#define VSYNC_MIN_DIFF_MS 4
+
 static struct vsycn_ctrl {
 	struct device *dev;
 	int inited;
@@ -73,12 +69,9 @@
 	int vsync_enabled;
 	int clk_enabled;
 	int clk_control;
-	int watchdog;
 	ktime_t vsync_time;
-	struct work_struct vsync_work;
+	u32 last_vsync_ms;
 	struct work_struct clk_work;
-	
-	int temp_cnt;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 static void vsync_irq_enable(int intr, int term)
@@ -168,7 +161,7 @@
 	mdp4_allocate_writeback_buf(mfd, MDP4_MIXER0);
 
 	if (mfd->ov0_wb_buf->write_addr == 0) {
-		pr_info("%s: no blt_base assigned\n", __func__);
+		pr_err("%s: no blt_base assigned\n", __func__);
 		return;
 	}
 
@@ -210,7 +203,7 @@
 		vctrl->blt_free = 4;	
 	}
 
-	pr_info("%s: changed=%d enable=%d ov_blt_addr=%x\n", __func__,
+	pr_debug("%s: changed=%d enable=%d ov_blt_addr=%x\n", __func__,
 		vctrl->blt_change, enable, (int)pipe->ov_blt_addr);
 
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
@@ -230,8 +223,8 @@
 
 	vctrl = &vsync_ctrl_db[cndx];
 
-	if (atomic_read(&vctrl->suspend) > 0) {
-		pr_warning("[DISP] %s: suspended, no more pipe queue\n", __func__);
+	if (atomic_read(&vctrl->suspend)) {
+		pr_err("%s: suspended, no more pipe queue\n", __func__);
 		return;
 	}
 
@@ -251,7 +244,23 @@
 	mdp4_stat.overlay_play[pipe->mixer_num]++;
 }
 
+static void mdp4_dsi_cmd_pipe_clean(struct vsync_update *vp)
+{
+	struct mdp4_overlay_pipe *pipe;
+	int i;
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+	vp->update_cnt = 0;     
+}
+
 static void mdp4_dsi_cmd_blt_ov_update(struct mdp4_overlay_pipe *pipe);
+static int mdp4_dsi_cmd_clk_check(struct vsycn_ctrl *vctrl);
 
 int mdp4_dsi_cmd_pipe_commit(int cndx, int wait)
 {
@@ -269,19 +278,20 @@
 	vctrl = &vsync_ctrl_db[0];
 
 	mutex_lock(&vctrl->update_lock);
-	if(vctrl->temp_cnt > 0)
-		pr_info("[DISP]%s :update_lock done cnt=%d\n",__func__,vctrl->temp_cnt--);
-
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	mixer = pipe->mixer_num;
-
-	if (vp->update_cnt == 0) {
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
 		mutex_unlock(&vctrl->update_lock);
-		return cnt;
+		return 0;
 	}
 
+	mixer = pipe->mixer_num;
+
+	mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
+
+
 	vctrl->update_ndx++;
 	vctrl->update_ndx &= 0x01;
 	vp->update_cnt = 0;     
@@ -290,6 +300,12 @@
 		if (vctrl->blt_free == 0)
 			mdp4_free_writeback_buf(vctrl->mfd, mixer);
 	}
+
+	if (mdp4_dsi_cmd_clk_check(vctrl) < 0) {
+		mdp4_dsi_cmd_pipe_clean(vp);
+		mutex_unlock(&vctrl->update_lock);
+		return 0;
+	}
 	mutex_unlock(&vctrl->update_lock);
 
 	
@@ -298,8 +314,10 @@
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
 		
-		if (vctrl->blt_wait)
+		if (vctrl->blt_wait) {
+			INIT_COMPLETION(vctrl->dmap_comp);
 			need_dmap_wait = 1;
+		}
 		if (vctrl->ov_koff != vctrl->ov_done) {
 			INIT_COMPLETION(vctrl->ov_comp);
 			need_ov_wait = 1;
@@ -375,17 +393,14 @@
 	pr_debug("%s: kickoff, pid=%d\n", __func__, current->pid);
 	
 	mdp4_stat.kickoff_ov0++;
-	outpdw(MDP_BASE + 0x0004, 0);
-	mb();
+	mdp_pipe_kickoff_simplified(MDP_OVERLAY0_TERM);
+	mb(); 
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
-	if (wait) {
-		long long tick;
-
-		mdp4_dsi_cmd_wait4vsync(cndx, &tick);
-	}
+	if (wait)
+		mdp4_dsi_cmd_wait4vsync(0);
 
 	return cnt;
 }
@@ -396,26 +411,15 @@
 {
 	struct vsycn_ctrl *vctrl;
 	unsigned long flags;
-	int clk_set_on = 0;
 	int cndx = 0;
+	int clk_set_on = 0;
 
 	vctrl = &vsync_ctrl_db[cndx];
-	pr_debug("%s: clk_enabled=%d vsync_enabled=%d req=%d suspend=%d\n",
-	    __func__, vctrl->clk_enabled, vctrl->vsync_enabled, enable,
-	    atomic_read(&vctrl->suspend));
-
-	
-	if (atomic_read(&vctrl->suspend)) {
-		if (vctrl->vsync_enabled)
-			pr_warning("[DISP] %s: suspended, no more vsync event ctrl\n", __func__);
-		enable = 0;
-	}
-	if (enable && (mdp4_overlay_dsi_state_get() <= ST_DSI_SUSPEND)) {
-		pr_info("[DISP] %s: dsi is suspend, req=%d\n", __func__, enable);
-		enable = 0;
-	}
 
 	mutex_lock(&vctrl->update_lock);
+	pr_debug("%s: clk_enabled=%d vsync_enabled=%d req=%d\n", __func__,
+		vctrl->clk_enabled, vctrl->vsync_enabled, enable);
+
 	if (vctrl->vsync_enabled == enable) {
 		mutex_unlock(&vctrl->update_lock);
 		return;
@@ -434,6 +438,8 @@
 			mdp_clk_ctrl(1);
 			vctrl->clk_enabled = 1;
 			clk_set_on = 1;
+			vctrl->last_vsync_ms =
+				ktime_to_ms(ktime_get()) - VSYNC_MIN_DIFF_MS;
 		}
 		if (clk_set_on) {
 			vsync_irq_enable(INTR_PRIMARY_RDPTR,
@@ -447,12 +453,11 @@
 	mutex_unlock(&vctrl->update_lock);
 }
 
-void mdp4_dsi_cmd_wait4vsync(int cndx, long long *vtime)
+void mdp4_dsi_cmd_wait4vsync(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 	unsigned long flags;
-	int timeoutResult = 0;
 
 	if (cndx >= MAX_CONTROLLER) {
 		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
@@ -462,10 +467,8 @@
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	if (atomic_read(&vctrl->suspend) > 0) {
-		*vtime = -1;
+	if (atomic_read(&vctrl->suspend) > 0)
 		return;
-	}
 
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->wait_vsync_cnt == 0)
@@ -473,15 +476,8 @@
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	timeoutResult = wait_for_completion_timeout(&vctrl->vsync_comp, HZ/10);
-	if (!timeoutResult) {
-		PR_DISP_WARN("%s: vsync timeout, clk_enabled %d, expire_tick %d, vctrl->wait_vsync_cnt %d\n",
-		__func__, vctrl->clk_enabled, vctrl->expire_tick, vctrl->wait_vsync_cnt);
-	}
-
+	wait_for_completion(&vctrl->vsync_comp);
 	mdp4_stat.wait4vsync0++;
-
-	*vtime = ktime_to_ns(vctrl->vsync_time);
 }
 
 static void mdp4_dsi_cmd_wait4dmap(int cndx)
@@ -522,14 +518,25 @@
 static void primary_rdptr_isr(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
+	u32 cur_vsync_ms;
+	int vsync_diff;
 
 	vctrl = &vsync_ctrl_db[cndx];
-	pr_debug("%s: ISR, cpu=%d tick=%d\n", __func__,
-	    smp_processor_id(), vctrl->expire_tick);
+	pr_debug("%s: ISR, tick=%d pan=%d cpu=%d\n", __func__,
+		vctrl->expire_tick, vctrl->pan_display, smp_processor_id());
 	vctrl->rdptr_intr_tot++;
-	vctrl->vsync_time = ktime_get();
 
 	spin_lock(&vctrl->spin_lock);
+	vctrl->vsync_time = ktime_get();
+	cur_vsync_ms =  ktime_to_ms(vctrl->vsync_time);
+	vsync_diff = (int)(cur_vsync_ms - vctrl->last_vsync_ms);
+
+	if ((vsync_diff >= 0) && (vsync_diff < VSYNC_MIN_DIFF_MS)) {
+		spin_unlock(&vctrl->spin_lock);
+		return;
+	}
+
+	vctrl->last_vsync_ms = cur_vsync_ms;
 	complete_all(&vctrl->vsync_comp);
 	vctrl->wait_vsync_cnt = 0;
 
@@ -544,17 +551,7 @@
 				vctrl->expire_tick += 1;
 			}
 		}
-	} else if (!vctrl->vsync_enabled) {
-		vctrl->expire_tick = VSYNC_EXPIRE_TICK;
-		vctrl->watchdog++;
-		if ((vctrl->watchdog & 0x0f)==0) {
-			
-			pr_info("\n ### Show Blocked State ### (counter=%d)\n",
-					vctrl->watchdog);
-			show_state_filter(TASK_UNINTERRUPTIBLE);
-		}
 	}
-
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -579,8 +576,7 @@
 	pr_debug("%s: ov_koff=%d ov_done=%d dmap_koff=%d dmap_done=%d cpu=%d\n",
 		__func__, vctrl->ov_koff, vctrl->ov_done, vctrl->dmap_koff,
 		vctrl->dmap_done, smp_processor_id());
-
-	complete_all(&vctrl->dmap_comp);
+	complete(&vctrl->dmap_comp);
 	if (diff <= 0) {
 		if (vctrl->blt_wait)
 			vctrl->blt_wait = 0;
@@ -595,7 +591,7 @@
 	vctrl->dmap_koff++;
 	vsync_irq_enable(INTR_DMA_P_DONE, MDP_DMAP_TERM);
 	outpdw(MDP_BASE + 0x000c, 0); 
-	mb();
+	mb(); 
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -636,7 +632,7 @@
 	vctrl->dmap_koff++;
 	vsync_irq_enable(INTR_DMA_P_DONE, MDP_DMAP_TERM);
 	outpdw(MDP_BASE + 0x000c, 0); 
-	mb();
+	mb(); 
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -648,7 +644,6 @@
 
 	mutex_lock(&vctrl->update_lock);
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
-	vctrl->watchdog = 0;
 	if (vctrl->clk_control && vctrl->clk_enabled) {
 		vsync_irq_disable(INTR_PRIMARY_RDPTR, MDP_PRIM_RDPTR_TERM);
 		vctrl->clk_enabled = 0;
@@ -672,12 +667,11 @@
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
 	unsigned long flags;
+	u64 vsync_tick;
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
 
-	pr_debug("%s:+ VSYNC_EVENT\n", __func__);
-
 	if (atomic_read(&vctrl->suspend) > 0)
 		return 0;
 
@@ -687,16 +681,22 @@
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	wait_for_completion(&vctrl->vsync_comp);
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vsync_tick = ktime_to_ns(vctrl->vsync_time);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu",
-			ktime_to_ns(vctrl->vsync_time));
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
 	buf[strlen(buf) + 1] = '\0';
-	pr_debug("%s:-\n", __func__);
 	return ret;
 }
 
-
 void mdp4_dsi_rdptr_init(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
@@ -710,12 +710,9 @@
 	if (vctrl->inited)
 		return;
 
-	vctrl->temp_cnt = 5;
 	vctrl->inited = 1;
 	vctrl->update_ndx = 0;
-	vctrl->watchdog = 0;
 	mutex_init(&vctrl->update_lock);
-	pr_info("[DISP]%s update_lock init done\n",__func__);
 	init_completion(&vctrl->ov_comp);
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->vsync_comp);
@@ -729,20 +726,6 @@
 	primary_rdptr_isr(0);
 }
 
-void mdp4_overlay_dsi_state_set(int state)
-{
-	unsigned long flag;
-
-	spin_lock_irqsave(&mdp_spin_lock, flag);
-	dsi_state = state;
-	spin_unlock_irqrestore(&mdp_spin_lock, flag);
-}
-
-int mdp4_overlay_dsi_state_get(void)
-{
-	return dsi_state;
-}
-
 static __u32 msm_fb_line_length(__u32 fb_index, __u32 xres, int bpp)
 {
 
@@ -759,9 +742,8 @@
 
 	tear_en = (1 << which);
 
-	if ((mfd->use_mdp_vsync) && (mfd->ibuf.vsync_enable) &&
-		(mfd->panel_info.lcd.vsync_enable)) {
-
+	mdp_clk_ctrl(1);
+	if (mfd->use_mdp_vsync && mfd->panel_info.lcd.vsync_enable) {
 		if (vsync_start_y_adjust <= pipe->dst_y)
 			start_y = pipe->dst_y - vsync_start_y_adjust;
 		else
@@ -780,6 +762,28 @@
 		data &= ~tear_en;
 		MDP_OUTP(MDP_BASE + 0x20c, data);
 	}
+	mdp_clk_ctrl(0);
+}
+
+void mdp4_dsi_cmd_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
+
+	if (pipe == NULL)
+		return ;
+	
+	if (pipe->pipe_type == OVERLAY_TYPE_BF)
+		mdp4_overlay_borderfill_stage_down(pipe);
+
+	
+	pipe = vctrl->base_pipe;
+	mdp4_mixer_stage_down(pipe, 1);
+	mdp4_overlay_pipe_free(pipe, 1);
+	vctrl->base_pipe = NULL;
 }
 
 void mdp4_dsi_cmd_base_swap(int cndx, struct mdp4_overlay_pipe *pipe)
@@ -819,12 +823,12 @@
 						pipe->src_width, bpp);
 	} else {
 		 
-		pipe->src_height = mfd->ovr_dst_height;	
-		pipe->src_width = mfd->ovr_dst_width;	
-		pipe->src_h = mfd->ovr_src_height;	
-		pipe->src_w = mfd->ovr_src_width;	
-		pipe->dst_h = mfd->ovr_dst_height;	
-		pipe->dst_w = mfd->ovr_dst_width;	
+		pipe->src_height = fbi->var.yres;
+		pipe->src_width = fbi->var.xres;
+		pipe->src_h = fbi->var.yres;
+		pipe->src_w = fbi->var.xres;
+		pipe->dst_h = fbi->var.yres;
+		pipe->dst_w = fbi->var.xres;
 		pipe->srcp0_ystride = fbi->fix.line_length;
 	}
 	pipe->src_y = 0;
@@ -874,15 +878,20 @@
 		pipe = vctrl->base_pipe;
 	}
 
-	if (mfd->panel_info.read_pointer)
-		MDP_OUTP(MDP_BASE + 0x021c, mfd->panel_info.read_pointer); 
-	else
-		MDP_OUTP(MDP_BASE + 0x021c, 100); 
+	
+	mdp4_mipi_vsync_enable(mfd, pipe, 0);
+
+	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
+
+	MDP_OUTP(MDP_BASE + 0x021c, 10); 
 
 	MDP_OUTP(MDP_BASE + 0x000a0, 0x10);
 	
 	MDP_OUTP(MDP_BASE + 0x000a4, 0x00);
 
+	mdp4_overlay_solidfill_init(pipe);
+
 	mdp4_overlay_setup_pipe_addr(mfd, pipe);
 
 	mdp4_overlay_rgb_setup(pipe);
@@ -944,12 +953,12 @@
 					pipe->src_width, bpp);
 	} else {
 		 
-		pipe->src_height = mfd->ovr_dst_height;	
-		pipe->src_width = mfd->ovr_dst_width;	
-		pipe->src_h = mfd->ovr_src_height;	
-		pipe->src_w = mfd->ovr_src_width;	
-		pipe->dst_h = mfd->ovr_dst_height;	
-		pipe->dst_w = mfd->ovr_dst_width;	
+		pipe->src_height = fbi->var.yres;
+		pipe->src_width = fbi->var.xres;
+		pipe->src_h = fbi->var.yres;
+		pipe->src_w = fbi->var.xres;
+		pipe->dst_h = fbi->var.yres;
+		pipe->dst_w = fbi->var.xres;
 		pipe->srcp0_ystride = fbi->fix.line_length;
 	}
 	pipe->src_y = 0;
@@ -1007,9 +1016,12 @@
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 	mfd->cont_splash_done = 1;
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl = &vsync_ctrl_db[cndx];
 	vctrl->mfd = mfd;
 	vctrl->dev = mfd->fbi->dev;
+	vctrl->vsync_enabled = 0;
 
 	mdp_clk_ctrl(1);
 	mdp4_overlay_update_dsi_cmd(mfd);
@@ -1019,7 +1031,10 @@
 
 	atomic_set(&vctrl->suspend, 0);
 
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 	pr_debug("%s-:\n", __func__);
+
 	return ret;
 }
 
@@ -1030,130 +1045,119 @@
 	struct msm_fb_data_type *mfd;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
-	int need_wait = 0, cnt;
+	struct vsync_update *vp;
+	int undx;
+	int need_wait, cnt;
 	unsigned long flags;
+	int mixer = 0;
 
 	pr_debug("%s+: pid=%d\n", __func__, current->pid);
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 	if (pipe == NULL) {
 		pr_err("%s: NO base pipe\n", __func__);
+		mutex_unlock(&mfd->dma->ov_mutex);
 		return ret;
 	}
 
+	need_wait = 0;
 	mutex_lock(&vctrl->update_lock);
-	atomic_set(&vctrl->suspend, 1);
+
+	complete_all(&vctrl->vsync_comp);
 
 	pr_debug("%s: clk=%d pan=%d\n", __func__,
 			vctrl->clk_enabled, vctrl->pan_display);
-	if (vctrl->clk_enabled) {
-		pr_info("[DISP] %s: clk is still enabled, need wait for vsync ctrl off\n", __func__);
+	if (vctrl->clk_enabled)
 		need_wait = 1;
-		spin_lock_irqsave(&vctrl->spin_lock, flags);
-		vctrl->vsync_enabled = 0;
-		vctrl->expire_tick = 2 * VSYNC_EXPIRE_TICK;
-		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
-	}
 	mutex_unlock(&vctrl->update_lock);
 
 	cnt = 0;
 	if (need_wait) {
-		while (vctrl->clk_enabled){
+		while (vctrl->clk_enabled) {
 			msleep(20);
 			cnt++;
-			if (0 == (cnt & 0x7f)) { 
-				pr_info("%s: vctrl={pan:%d,clk_ctrl:%d,clk_en:%d,vsync_en:%d, exp_tick=%d}\n", __func__,
-				    vctrl->pan_display, vctrl->clk_control,
-				    vctrl->clk_enabled, vctrl->vsync_enabled, vctrl->expire_tick);
-				pr_info("%s: mdp_intr: %x\n", __func__, mdp_intr_mask);
-			}
+			if (cnt > 10)
+				break;
 		}
 	}
 
-	
-	pr_info("%s: mdp clocks are disabled with cnt=%d\n", __func__, cnt);
-
-	complete_all(&vctrl->vsync_comp);
-	vctrl->wait_vsync_cnt = 0;
-
-	
-	mdp4_overlay_unset_mixer(pipe->mixer_num);
-	mdp4_mixer_stage_down(pipe, 1);
-	mdp4_overlay_pipe_free(pipe);
-	vctrl->base_pipe = NULL;
-
-	pr_debug("%s-:\n", __func__);
+	if (cnt > 10) {
+		spin_lock_irqsave(&vctrl->spin_lock, flags);
+		vctrl->clk_control = 0;
+		vctrl->clk_enabled = 0;
+		vctrl->expire_tick = 0;
+		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+		mipi_dsi_clk_cfg(0);
+		mdp_clk_ctrl(0);
+		pr_err("%s: Error, SET_CLK_OFF by force\n", __func__);
+	}
 
-	return ret;
-}
+	if (vctrl->vsync_enabled) {
+		vsync_irq_disable(INTR_PRIMARY_RDPTR, MDP_PRIM_RDPTR_TERM);
+		vctrl->vsync_enabled = 0;
+	}
 
-void mdp_dsi_cmd_overlay_suspend(struct msm_fb_data_type *mfd)
-{
-	int cndx = 0;
-	struct vsycn_ctrl *vctrl;
-	struct mdp4_overlay_pipe *pipe;
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	if (vp->update_cnt) {
+		pr_warn("%s: update_cnt=%d\n", __func__, vp->update_cnt);
+		mdp4_dsi_cmd_pipe_clean(vp);
+	}
 
-	vctrl = &vsync_ctrl_db[cndx];
-	pipe = vctrl->base_pipe;
-	
 	if (pipe) {
+		
+		mixer = pipe->mixer_num;
+		mdp4_overlay_unset_mixer(mixer);
 		if (mfd->ref_cnt == 0) {
 			
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
 				mdp4_overlay_borderfill_stage_down(pipe);
 
 			
-			mdp4_overlay_unset_mixer(pipe->mixer_num);
+			pipe = vctrl->base_pipe;
+			mdp4_mixer_stage_down(pipe, 1);
+			mdp4_overlay_pipe_free(pipe, 1);
 			vctrl->base_pipe = NULL;
 		} else {
+			
 			mdp4_mixer_stage_down(pipe, 1);
 			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 1);
 		}
 	}
-}
 
-void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd)
-{
-	int cndx = 0;
-	struct vsycn_ctrl *vctrl;
-	struct mdp4_overlay_pipe *pipe;
-	unsigned long flags;
-	int clk_set_on = 0;
+	atomic_set(&vctrl->suspend, 1);
 
-	vctrl = &vsync_ctrl_db[cndx];
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+	mdp4_overlay_iommu_unmap_freelist(mixer);
 
-	if (!mfd->panel_power_on)
-		return;
+	mutex_unlock(&mfd->dma->ov_mutex);
 
-	pipe = vctrl->base_pipe;
-	if (pipe == NULL) {
-		pr_err("%s: NO base pipe\n", __func__);
-		return;
-	}
+	pr_debug("%s-:\n", __func__);
+	return ret;
+}
 
-	mutex_lock(&vctrl->update_lock);
-	if(vctrl->temp_cnt > 0)
-		pr_info("[DISP]%s :update_lock done cnt=%d\n",__func__,vctrl->temp_cnt);
+static int mdp4_dsi_cmd_clk_check(struct vsycn_ctrl *vctrl)
+{
+	int clk_set_on = 0;
+	unsigned long flags;
 
 	if (atomic_read(&vctrl->suspend)) {
-		mutex_unlock(&vctrl->update_lock);
-		pr_warning("[DISP] %s: suspended, no more pan display\n", __func__);
-		return;
+		pr_err("%s: suspended, no more pan display\n", __func__);
+		return -EPERM;
 	}
 
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
-	vctrl->pan_display++;
 	vctrl->clk_control = 0;
-
-	if (vctrl->clk_enabled == 0) {
+	vctrl->pan_display++;
+	if (!vctrl->clk_enabled) {
 		clk_set_on = 1;
 		vctrl->clk_enabled = 1;
 		vctrl->expire_tick = VSYNC_EXPIRE_TICK;
-	} else if (vctrl->expire_tick && vctrl->expire_tick < VSYNC_EXPIRE_TICK) {
-		vctrl->expire_tick = VSYNC_EXPIRE_TICK;
 	}
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
@@ -1164,7 +1168,29 @@
 		vsync_irq_enable(INTR_PRIMARY_RDPTR, MDP_PRIM_RDPTR_TERM);
 	}
 
-	mutex_unlock(&vctrl->update_lock);
+	return 0;
+}
+
+void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd)
+{
+	int cndx = 0;
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	mutex_lock(&mfd->dma->ov_mutex);
+	vctrl = &vsync_ctrl_db[cndx];
+
+	if (!mfd->panel_power_on) {
+		mutex_unlock(&mfd->dma->ov_mutex);
+		return;
+	}
+
+	pipe = vctrl->base_pipe;
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
+		mutex_unlock(&mfd->dma->ov_mutex);
+		return;
+	}
 
 	if (pipe->mixer_stage == MDP4_MIXER_STAGE_BASE) {
 		mdp4_mipi_vsync_enable(mfd, pipe, 0);
@@ -1173,9 +1199,8 @@
 	}
 
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
-
-	mutex_lock(&mfd->dma->ov_mutex);
 	mdp4_dsi_cmd_pipe_commit(cndx, 0);
-	mutex_unlock(&mfd->dma->ov_mutex);
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dsi_video.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dsi_video.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dsi_video.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dsi_video.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -25,7 +25,6 @@
 #include <linux/fb.h>
 #include <linux/msm_mdp.h>
 #include <linux/ktime.h>
-#include <linux/kthread.h>
 #include <linux/wakelock.h>
 #include <linux/time.h>
 #include <asm/system.h>
@@ -37,18 +36,15 @@
 #include "mipi_dsi.h"
 
 #include <mach/iommu_domains.h>
-#include <mach/debug_display.h>
 
 #define DSI_VIDEO_BASE	0xE0000
 
-struct task_struct *vsync_task;
 static int first_pixel_start_x;
 static int first_pixel_start_y;
 static int dsi_video_enabled;
+static int vsync_irq_cnt;
 
 #define MAX_CONTROLLER	1
-#define VSYNC_EXPIRE_TICK 1
-#define CONTINUOUS_SPLASH 1
 
 static struct vsycn_ctrl {
 	struct device *dev;
@@ -57,9 +53,11 @@
 	int ov_koff;
 	int ov_done;
 	atomic_t suspend;
+	atomic_t vsync_resume;
 	int wait_vsync_cnt;
 	int blt_change;
 	int blt_free;
+	int blt_ctrl;
 	int sysfs_created;
 	struct mutex update_lock;
 	struct completion ov_comp;
@@ -71,7 +69,6 @@
 	struct vsync_update vlist[2];
 	int vsync_irq_enabled;
 	ktime_t vsync_time;
-	int send_event;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 static void vsync_irq_enable(int intr, int term)
@@ -123,9 +120,6 @@
 		return;
 	}
 
-	
-	mdp4_overlay_dsi_video_start();
-
 	vctrl = &vsync_ctrl_db[cndx];
 
 	if (atomic_read(&vctrl->suspend) > 0)
@@ -147,6 +141,21 @@
 	mdp4_stat.overlay_play[pipe->mixer_num]++;
 }
 
+static void mdp4_dsi_video_pipe_clean(struct vsync_update *vp)
+{
+	struct mdp4_overlay_pipe *pipe;
+	int i;
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+	vp->update_cnt = 0;     
+}
+
 static void mdp4_dsi_video_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 static void mdp4_dsi_video_wait4dmap(int cndx);
 static void mdp4_dsi_video_wait4ov(int cndx);
@@ -169,13 +178,17 @@
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	mixer = pipe->mixer_num;
-
-	if (vp->update_cnt == 0) {
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
 		mutex_unlock(&vctrl->update_lock);
-		return cnt;
+		return 0;
 	}
 
+	mixer = pipe->mixer_num;
+
+	mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
+
+
 	vctrl->update_ndx++;
 	vctrl->update_ndx &= 0x01;
 	vp->update_cnt = 0;     
@@ -186,9 +199,6 @@
 	}
 	mutex_unlock(&vctrl->update_lock);
 
-	
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->ov_koff != vctrl->ov_done) {
 		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
@@ -217,16 +227,28 @@
 			cnt++;
 			real_pipe = mdp4_overlay_ndx2pipe(pipe->pipe_ndx);
 			if (real_pipe && real_pipe->pipe_used) {
-				
 				mdp4_overlay_vsync_commit(pipe);
 			}
-			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
-			pipe->pipe_used = 0; 
 		}
 	}
 
 	mdp4_mixer_stage_commit(mixer);
 
+	
+	mdp4_overlay_dsi_video_start();
+
+
+	
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+
 	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
@@ -250,14 +272,38 @@
 
 	if (wait) {
 		if (pipe->ov_blt_addr)
-			mdp4_dsi_video_wait4ov(cndx);
+			mdp4_dsi_video_wait4ov(0);
 		else
-			mdp4_dsi_video_wait4dmap(cndx);
+			mdp4_dsi_video_wait4dmap(0);
 	}
 
 	return cnt;
 }
 
+static void mdp4_video_vsync_irq_ctrl(int cndx, int enable)
+{
+	struct vsycn_ctrl *vctrl;
+
+	vctrl = &vsync_ctrl_db[cndx];
+
+	mutex_lock(&vctrl->update_lock);
+	if (enable) {
+		if (vsync_irq_cnt == 0)
+			vsync_irq_enable(INTR_PRIMARY_VSYNC,
+						MDP_PRIM_VSYNC_TERM);
+		vsync_irq_cnt++;
+	} else {
+		if (vsync_irq_cnt) {
+			vsync_irq_cnt--;
+			if (vsync_irq_cnt == 0)
+				vsync_irq_disable(INTR_PRIMARY_VSYNC,
+						MDP_PRIM_VSYNC_TERM);
+		}
+	}
+	pr_debug("%s: enable=%d cnt=%d\n", __func__, enable, vsync_irq_cnt);
+	mutex_unlock(&vctrl->update_lock);
+}
+
 void mdp4_dsi_video_vsync_ctrl(struct fb_info *info, int enable)
 {
 	struct vsycn_ctrl *vctrl;
@@ -272,17 +318,18 @@
 
 	vctrl->vsync_irq_enabled = enable;
 
-	if (enable)
-		vsync_irq_enable(INTR_PRIMARY_VSYNC, MDP_PRIM_VSYNC_TERM);
-	else
-		vsync_irq_disable(INTR_PRIMARY_VSYNC, MDP_PRIM_VSYNC_TERM);
+	mdp4_video_vsync_irq_ctrl(cndx, enable);
+
+	if (vctrl->vsync_irq_enabled &&  atomic_read(&vctrl->suspend) == 0)
+		atomic_set(&vctrl->vsync_resume, 1);
 }
 
-void mdp4_dsi_video_wait4vsync(int cndx, long long *vtime)
+void mdp4_dsi_video_wait4vsync(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 	unsigned long flags;
+	int ret;
 
 	if (cndx >= MAX_CONTROLLER) {
 		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
@@ -292,13 +339,10 @@
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	if (atomic_read(&vctrl->suspend) > 0) {
-		*vtime = -1;
+	if (atomic_read(&vctrl->suspend) > 0)
 		return;
-	}
 
-	
-	mdp4_overlay_dsi_video_start();
+	mdp4_video_vsync_irq_ctrl(cndx, 1);
 
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->wait_vsync_cnt == 0)
@@ -306,11 +350,14 @@
 
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+	
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 8));
+	if (ret <= 0)
+		pr_err("%s timeout ret=%d", __func__, ret);
 
-	wait_for_completion(&vctrl->vsync_comp);
+	mdp4_video_vsync_irq_ctrl(cndx, 0);
 	mdp4_stat.wait4vsync0++;
-
-	*vtime = ktime_to_ns(vctrl->vsync_time);
 }
 
 static void mdp4_dsi_video_wait4dmap(int cndx)
@@ -349,7 +396,6 @@
 	mdp4_dsi_video_wait4dmap(cndx);
 }
 
-
 static void mdp4_dsi_video_wait4ov(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
@@ -374,33 +420,48 @@
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
 	unsigned long flags;
-	int timeout = 0;
-	static int cnt = 0;
+	u64 vsync_tick;
+	ktime_t ctime;
+	u32 ctick, ptick;
+	int diff;
+
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
 
-	if (atomic_read(&vctrl->suspend) > 0)
+	if (atomic_read(&vctrl->suspend) > 0 ||
+		atomic_read(&vctrl->vsync_resume) == 0)
 		return 0;
 
+	ctime = ktime_get();
+	ctick = (u32)ktime_to_us(ctime);
+	ptick = (u32)ktime_to_us(vctrl->vsync_time);
+	ptick += 5000;	
+	diff = ptick - ctick;
+	if (diff > 0) {
+		if (diff > 1000) 
+			diff = 1000;
+		usleep(diff);
+	}
+
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->wait_vsync_cnt == 0)
 		INIT_COMPLETION(vctrl->vsync_comp);
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		complete_all(&vctrl->vsync_comp);
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
 
-	timeout = wait_for_completion_timeout(&vctrl->vsync_comp, HZ/20);
-
-	if (!timeout) {
-		if (cnt > 3)
-			PR_DISP_WARN("WARNING %s: vsync timeout\n", __func__);
-		cnt++;
-	} else
-		cnt = 0;
-
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vsync_tick = ktime_to_ns(vctrl->vsync_time);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu",
-			ktime_to_ns(vctrl->vsync_time));
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
 	buf[strlen(buf) + 1] = '\0';
 	return ret;
 }
@@ -427,9 +488,31 @@
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->ov_comp);
 	atomic_set(&vctrl->suspend, 1);
+	atomic_set(&vctrl->vsync_resume, 1);
 	spin_lock_init(&vctrl->spin_lock);
 }
 
+void mdp4_dsi_video_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
+
+	if (pipe == NULL)
+		return ;
+	
+	if (pipe->pipe_type == OVERLAY_TYPE_BF)
+		mdp4_overlay_borderfill_stage_down(pipe);
+
+	
+	pipe = vctrl->base_pipe;
+	mdp4_mixer_stage_down(pipe, 1);
+	mdp4_overlay_pipe_free(pipe, 1);
+	vctrl->base_pipe = NULL;
+}
+
 void mdp4_dsi_video_base_swap(int cndx, struct mdp4_overlay_pipe *pipe)
 {
 	struct vsycn_ctrl *vctrl;
@@ -443,6 +526,33 @@
 	vctrl->base_pipe = pipe;
 }
 
+static void mdp4_dsi_video_tg_off(struct vsycn_ctrl *vctrl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0); 
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	
+	msleep(20);
+}
+
+int mdp4_dsi_video_splash_done(void)
+{
+	struct vsycn_ctrl *vctrl;
+	int cndx = 0;
+
+	vctrl = &vsync_ctrl_db[cndx];
+
+	mdp4_dsi_video_tg_off(vctrl);
+	mipi_dsi_controller_cfg(0);
+
+	return 0;
+}
+
 int mdp4_dsi_video_on(struct platform_device *pdev)
 {
 	int dsi_width;
@@ -478,7 +588,6 @@
 	uint8 *buf;
 	unsigned int buf_offset;
 	int bpp, ptype;
-	static bool first_video_on = true;
 	struct fb_info *fbi;
 	struct fb_var_screeninfo *var;
 	struct msm_fb_data_type *mfd;
@@ -486,9 +595,11 @@
 	int ret = 0;
 	int cndx = 0;
 	struct vsycn_ctrl *vctrl;
+	struct msm_panel_info *pinfo;
 
 	vctrl = &vsync_ctrl_db[cndx];
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
+	pinfo = &mfd->panel_info;
 
 	if (!mfd)
 		return -ENODEV;
@@ -496,8 +607,13 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl->mfd = mfd;
 	vctrl->dev = mfd->fbi->dev;
+	vctrl->blt_ctrl = pinfo->lcd.blt_ctrl;
+	vctrl->vsync_irq_enabled = 0;
+	vsync_irq_cnt = 0;
 
 	
 	mdp_clk_ctrl(1);
@@ -509,20 +625,6 @@
 	buf = (uint8 *) fbi->fix.smem_start;
 	buf_offset = calc_fb_offset(mfd, fbi, bpp);
 
-	if (first_video_on)
-		first_video_on = false;
-	else {
-		if (mfd->ref_cnt == 0) {
-			
-			int ndx;
-			for (ndx=1; ndx<4; ndx++) {
-				pipe = mdp4_overlay_ndx2pipe(ndx);
-				if (pipe && pipe->pipe_used)
-					mdp4_overlay_unset(mfd->fbi, ndx);
-			}
-		}
-	}
-
 	if (vctrl->base_pipe == NULL) {
 		ptype = mdp4_overlay_format2type(mfd->fb_imgType);
 		if (ptype < 0)
@@ -530,6 +632,7 @@
 		pipe = mdp4_overlay_pipe_alloc(ptype, MDP4_MIXER0);
 		if (pipe == NULL) {
 			printk(KERN_INFO "%s: pipe_alloc failed\n", __func__);
+			mutex_unlock(&mfd->dma->ov_mutex);
 			return -EBUSY;
 		}
 		pipe->pipe_used++;
@@ -550,28 +653,16 @@
 		pipe = vctrl->base_pipe;
 	}
 
-#ifdef CONTINUOUS_SPLASH
-	
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
-	if (!(mfd->cont_splash_done)) {
-		mfd->cont_splash_done = 1;
-		mdp4_dsi_video_wait4dmap_done(0);
-		MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
-		mdelay(20);
-		mipi_dsi_controller_cfg(0);
-		mdp_clk_ctrl(0);
-	}
-#endif
+	atomic_set(&vctrl->suspend, 0);
 
-	pipe->src_height = mfd->ovr_dst_height;	
-	pipe->src_width = mfd->ovr_dst_width;	
-	pipe->src_h = mfd->ovr_src_height;	
-	pipe->src_w = mfd->ovr_src_width;	
+	pipe->src_height = fbi->var.yres;
+	pipe->src_width = fbi->var.xres;
+	pipe->src_h = fbi->var.yres;
+	pipe->src_w = fbi->var.xres;
 	pipe->src_y = 0;
 	pipe->src_x = 0;
-	pipe->dst_h = mfd->ovr_dst_height;	
-	pipe->dst_w = mfd->ovr_dst_width;	
+	pipe->dst_h = fbi->var.yres;
+	pipe->dst_w = fbi->var.xres;
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
@@ -580,12 +671,13 @@
 	else
 		pipe->srcp0_addr = (uint32)(buf + buf_offset);
 
-	pipe->dst_h = mfd->ovr_dst_height;	
-	pipe->dst_w = mfd->ovr_dst_width;	
+	pipe->dst_h = fbi->var.yres;
+	pipe->dst_w = fbi->var.xres;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_overlay_solidfill_init(pipe);
 
-	atomic_set(&vctrl->suspend, 0);
+	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
 
 	mdp4_overlay_dmap_xy(pipe);	
 	mdp4_overlay_dmap_cfg(mfd, 1);
@@ -645,12 +737,6 @@
 		active_v_end = 0;
 	}
 
-#ifdef CONFIG_FB_MSM_RESOLUTION_OVERRIDE
-	active_hctl = 0;
-	active_v_start = 0;
-	active_v_end = 0;
-#endif
-
 	dsi_underflow_clr |= 0x80000000;	
 	hsync_polarity = 0;
 	vsync_polarity = 0;
@@ -677,6 +763,8 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	mdp_histogram_ctrl_all(TRUE);
+	mdp4_overlay_dsi_video_start();
+	mutex_unlock(&mfd->dma->ov_mutex);
 
 	return ret;
 }
@@ -688,32 +776,57 @@
 	struct msm_fb_data_type *mfd;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
+	struct vsync_update *vp;
+	unsigned long flags;
+	int mixer = 0;
+	int undx, need_wait = 0;
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
+
+	mutex_lock(&mfd->dma->ov_mutex);
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	atomic_set(&vctrl->suspend, 1);
+	mdp4_dsi_video_wait4vsync(cndx);
 
-	complete_all(&vctrl->vsync_comp);
+	atomic_set(&vctrl->vsync_resume, 0);
 
+	complete_all(&vctrl->vsync_comp);
 	vctrl->wait_vsync_cnt = 0;
 
-	MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
+	if (pipe->ov_blt_addr) {
+		spin_lock_irqsave(&vctrl->spin_lock, flags);
+		if (vctrl->ov_koff != vctrl->ov_done)
+			need_wait = 1;
+		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+		if (need_wait)
+			mdp4_dsi_video_wait4ov(0);
+	}
 
-	msleep(20);
+	mdp_histogram_ctrl_all(FALSE);
 
 	dsi_video_enabled = 0;
 
-	mdp_histogram_ctrl_all(FALSE);
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	if (vp->update_cnt) {
+		pr_warn("%s: update_cnt=%d\n", __func__, vp->update_cnt);
+		mdp4_dsi_video_pipe_clean(vp);
+	}
 
 	if (pipe) {
 		
-		mdp4_overlay_unset_mixer(pipe->mixer_num);
+		mixer = pipe->mixer_num;
+		mdp4_overlay_unset_mixer(mixer);
 		if (mfd->ref_cnt == 0) {
 			
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
 				mdp4_overlay_borderfill_stage_down(pipe);
+
+			
+			pipe = vctrl->base_pipe;
+			mdp4_mixer_stage_down(pipe, 1);
+			mdp4_overlay_pipe_free(pipe, 1);
 			vctrl->base_pipe = NULL;
 		} else {
 			
@@ -723,10 +836,24 @@
 		}
 	}
 
+	mdp4_dsi_video_tg_off(vctrl);
+
+	atomic_set(&vctrl->suspend, 1);
+
+	if (vctrl->vsync_irq_enabled) {
+		vctrl->vsync_irq_enabled = 0;
+		vsync_irq_disable(INTR_PRIMARY_VSYNC, MDP_PRIM_VSYNC_TERM);
+	}
+
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
 	
 	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_OVERLAY0_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 	return ret;
 }
 
@@ -783,12 +910,12 @@
 					pipe->src_width, bpp);
 	} else {
 		 
-		pipe->src_height = mfd->ovr_dst_height;	
-		pipe->src_width = mfd->ovr_dst_width;	
-		pipe->src_h = mfd->ovr_src_height;	
-		pipe->src_w = mfd->ovr_src_width;	
-		pipe->dst_h = mfd->ovr_dst_height;	
-		pipe->dst_w = mfd->ovr_dst_width;	
+		pipe->src_height = fbi->var.yres;
+		pipe->src_width = fbi->var.xres;
+		pipe->src_h = fbi->var.yres;
+		pipe->src_w = fbi->var.xres;
+		pipe->dst_h = fbi->var.yres;
+		pipe->dst_w = fbi->var.xres;
 		pipe->srcp0_ystride = fbi->fix.line_length;
 	}
 
@@ -872,17 +999,15 @@
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 
-
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[cndx];
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
-	vctrl->vsync_time = ktime_get();
 
 	spin_lock(&vctrl->spin_lock);
-	if (vctrl->wait_vsync_cnt) {
-		complete_all(&vctrl->vsync_comp);
-		vctrl->wait_vsync_cnt = 0;
-	}
+
+	vctrl->vsync_time = ktime_get();
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -900,8 +1025,14 @@
 
 	spin_lock(&vctrl->spin_lock);
 	vsync_irq_disable(INTR_DMA_P_DONE, MDP_DMAP_TERM);
+
+	if (pipe == NULL) {
+		spin_unlock(&vctrl->spin_lock);
+		return;
+	}
+
 	if (vctrl->blt_change &&
-		mdp_ov0_blt_ctl == MDP4_BLT_SWITCH_TG_ON_ISR) {
+		vctrl->blt_ctrl == OVERLAY_BLT_SWITCH_TG_ON) {
 		mdp4_overlayproc_cfg(pipe);
 		mdp4_overlay_dmap_xy(pipe);
 		if (pipe->ov_blt_addr) {
@@ -935,6 +1066,12 @@
 	vsync_irq_disable(INTR_OVERLAY0_DONE, MDP_OVERLAY0_TERM);
 	vctrl->ov_done++;
 	complete_all(&vctrl->ov_comp);
+
+	if (pipe == NULL) {
+		spin_unlock(&vctrl->spin_lock);
+		return;
+	}
+
 	if (pipe->ov_blt_addr == 0) {
 		spin_unlock(&vctrl->spin_lock);
 		return;
@@ -987,17 +1124,18 @@
 		spin_unlock_irqrestore(&vctrl->spin_lock, flag);
 		return;
 	}
-
 	spin_unlock_irqrestore(&vctrl->spin_lock, flag);
 
-	if (mdp_ov0_blt_ctl == MDP4_BLT_SWITCH_TG_OFF) {
+	if (vctrl->blt_ctrl == OVERLAY_BLT_SWITCH_TG_OFF) {
 		int tg_enabled;
-		pr_debug("%s: blt enabled by switching TG off\n", __func__);
+
+		pr_info("%s: blt enabled by switching TG off\n", __func__);
+		vctrl->blt_change = 0;
 		tg_enabled = inpdw(MDP_BASE + DSI_VIDEO_BASE) & 0x01;
 		if (tg_enabled) {
-			mdp4_dsi_video_wait4dmap_done(0);
+			mdp4_dsi_video_wait4vsync(cndx);
 			MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
-			msleep(20);
+			mdp4_dsi_video_wait4dmap_done(0);
 		}
 		mdp4_overlayproc_cfg(pipe);
 		mdp4_overlay_dmap_xy(pipe);
@@ -1017,7 +1155,6 @@
 			mipi_dsi_sw_reset();
 			MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 1);
 		}
-		vctrl->blt_change = 0;
 	}
 }
 
@@ -1043,15 +1180,19 @@
 	uint8 *buf;
 	unsigned int buf_offset;
 	int bpp;
-	int cndx = 0;
+	int cnt, cndx = 0;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	if (!pipe || !mfd->panel_power_on)
+	if (!pipe || !mfd->panel_power_on) {
+		mutex_unlock(&mfd->dma->ov_mutex);
 		return;
+	}
 
 	pr_debug("%s: cpu=%d pid=%d\n", __func__,
 			smp_processor_id(), current->pid);
@@ -1070,15 +1211,14 @@
 
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
-	mutex_lock(&mfd->dma->ov_mutex);
-	mdp4_dsi_video_pipe_commit(cndx, 0);
-
-	if (pipe->ov_blt_addr)
-		mdp4_dsi_video_wait4ov(cndx);
-	else
-		mdp4_dsi_video_wait4dmap(cndx);
+	cnt = mdp4_dsi_video_pipe_commit(cndx, 0);
+	if (cnt >= 0) {
+		if (pipe->ov_blt_addr)
+			mdp4_dsi_video_wait4ov(cndx);
+		else
+			mdp4_dsi_video_wait4dmap(cndx);
+	}
 
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 }
-
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dtv.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dtv.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_dtv.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_dtv.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -26,16 +26,15 @@
 #include <asm/system.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
-#include <mach/debug_display.h>
 
 #include "mdp.h"
 #include "msm_fb.h"
+#include "hdmi_msm.h"
 #include "mdp4.h"
 
 #define DTV_BASE	0xD0000
 
 static int dtv_enabled;
-static int dtv_pipe_ready = 0;
 
 #ifdef DEBUG
 static void __mdp_outp(uint32 port, uint32 value)
@@ -71,6 +70,7 @@
 	int update_ndx;
 	int dmae_intr_cnt;
 	atomic_t suspend;
+	atomic_t vsync_resume;
 	int dmae_wait_cnt;
 	int wait_vsync_cnt;
 	int blt_change;
@@ -80,6 +80,7 @@
 	struct completion dmae_comp;
 	struct completion vsync_comp;
 	spinlock_t spin_lock;
+	struct msm_fb_data_type *mfd;
 	struct mdp4_overlay_pipe *base_pipe;
 	struct vsync_update vlist[2];
 	int vsync_irq_enabled;
@@ -112,6 +113,27 @@
 	pr_debug("%s: IRQ-dis done, term=%x\n", __func__, term);
 }
 
+void mdp4_dtv_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
+
+	if (pipe == NULL)
+		return ;
+
+	if (hdmi_prim_display) {
+		
+		if (pipe->pipe_type == OVERLAY_TYPE_BF)
+			mdp4_overlay_borderfill_stage_down(pipe);
+
+		
+		vctrl->base_pipe = NULL;
+	}
+}
+
 void mdp4_overlay_dtv_start(void)
 {
 	if (!dtv_enabled) {
@@ -157,6 +179,21 @@
 	mdp4_stat.overlay_play[pipe->mixer_num]++;
 }
 
+static void mdp4_dtv_pipe_clean(struct vsync_update *vp)
+{
+	struct mdp4_overlay_pipe *pipe;
+	int i;
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+	vp->update_cnt = 0;     
+}
+
 static void mdp4_dtv_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 static void mdp4_dtv_wait4dmae(int cndx);
 
@@ -177,31 +214,15 @@
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	mixer = pipe->mixer_num;
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-
-	if (vp->update_cnt == 0) {
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
 		mutex_unlock(&vctrl->update_lock);
 		return 0;
 	}
+	mixer = pipe->mixer_num;
 
-	if(!dtv_pipe_ready) {
-		for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
-			real_pipe = mdp4_overlay_ndx2pipe(i);
-			if (real_pipe && real_pipe->pipe_used != 0
-				&& real_pipe->pipe_type != OVERLAY_TYPE_BF
-				&& real_pipe->mixer_num == MDP4_MIXER1) {
-				dtv_pipe_ready = true;
-				break;
-			}
-		}
+	mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
 
-		if(!dtv_pipe_ready && dtv_enabled) {
-			PR_DISP_INFO("Dtv real pipe is not ready, skip this time\n");
-			mutex_unlock(&vctrl->update_lock);
-			return 0;
-		}
-	}
 
 	vctrl->update_ndx++;
 	vctrl->update_ndx &= 0x01;
@@ -217,8 +238,6 @@
 				
 				mdp4_overlay_vsync_commit(pipe);
 			}
-			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
-			pipe->pipe_used = 0; 
 		}
 	}
 	mdp4_mixer_stage_commit(mixer);
@@ -226,6 +245,18 @@
 	 
 	mdp4_overlay_dtv_start();
 
+
+	
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+
 	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
@@ -246,11 +277,36 @@
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
 	if (wait)
-		mdp4_dtv_wait4dmae(cndx);
+		mdp4_dtv_wait4dmae(0);
 
 	return cnt;
 }
 
+static void mdp4_dtv_vsync_irq_ctrl(int cndx, int enable)
+{
+	struct vsycn_ctrl *vctrl;
+	static int vsync_irq_cnt;
+
+	vctrl = &vsync_ctrl_db[cndx];
+
+	mutex_lock(&vctrl->update_lock);
+	if (enable) {
+		if (vsync_irq_cnt == 0)
+			vsync_irq_enable(INTR_EXTERNAL_VSYNC,
+						MDP_EXTER_VSYNC_TERM);
+		vsync_irq_cnt++;
+	} else {
+		if (vsync_irq_cnt) {
+			vsync_irq_cnt--;
+			if (vsync_irq_cnt == 0)
+				vsync_irq_disable(INTR_EXTERNAL_VSYNC,
+						MDP_EXTER_VSYNC_TERM);
+		}
+	}
+	pr_debug("%s: enable=%d cnt=%d\n", __func__, enable, vsync_irq_cnt);
+	mutex_unlock(&vctrl->update_lock);
+}
+
 void mdp4_dtv_vsync_ctrl(struct fb_info *info, int enable)
 {
 	struct vsycn_ctrl *vctrl;
@@ -258,6 +314,8 @@
 
 	vctrl = &vsync_ctrl_db[cndx];
 
+	if (!external_common_state->hpd_state)
+		complete_all(&vctrl->vsync_comp);
 
 	if (vctrl->vsync_irq_enabled == enable)
 		return;
@@ -266,13 +324,13 @@
 
 	vctrl->vsync_irq_enabled = enable;
 
-	if (enable)
-		vsync_irq_enable(INTR_EXTERNAL_VSYNC, MDP_EXTER_VSYNC_TERM);
-	else
-		vsync_irq_disable(INTR_EXTERNAL_VSYNC, MDP_EXTER_VSYNC_TERM);
+	mdp4_dtv_vsync_irq_ctrl(cndx, enable);
+
+	if (vctrl->vsync_irq_enabled &&  atomic_read(&vctrl->suspend) == 0)
+		atomic_set(&vctrl->vsync_resume, 1);
 }
 
-void mdp4_dtv_wait4vsync(int cndx, long long *vtime)
+void mdp4_dtv_wait4vsync(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
@@ -289,6 +347,8 @@
 	if (atomic_read(&vctrl->suspend) > 0)
 		return;
 
+	mdp4_dtv_vsync_irq_ctrl(cndx, 1);
+
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 
 	if (vctrl->wait_vsync_cnt == 0)
@@ -297,9 +357,8 @@
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
 	wait_for_completion(&vctrl->vsync_comp);
+	mdp4_dtv_vsync_irq_ctrl(cndx, 0);
 	mdp4_stat.wait4vsync1++;
-
-	*vtime = ktime_to_ns(vctrl->vsync_time);
 }
 
 static void mdp4_dtv_wait4dmae(int cndx)
@@ -320,33 +379,57 @@
 }
 
 ssize_t mdp4_dtv_show_event(struct device *dev,
-	struct device_attribute *attr, char *buf)
+		struct device_attribute *attr, char *buf)
 {
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
 	unsigned long flags;
+	u64 vsync_tick;
+	ktime_t ctime;
+	u32 ctick, ptick;
+	int diff;
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
 
-	if (atomic_read(&vctrl->suspend) > 0)
+	if (atomic_read(&vctrl->suspend) > 0 ||
+		!external_common_state->hpd_state ||
+		atomic_read(&vctrl->vsync_resume) == 0)
 		return 0;
 
+	ctime = ktime_get();
+	ctick = (u32)ktime_to_us(ctime);
+	ptick = (u32)ktime_to_us(vctrl->vsync_time);
+	ptick += 5000;	
+	diff = ptick - ctick;
+	if (diff > 0) {
+		if (diff > 1000) 
+			diff = 1000;
+		usleep(diff);
+	}
+
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->wait_vsync_cnt == 0)
 		INIT_COMPLETION(vctrl->vsync_comp);
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	wait_for_completion(&vctrl->vsync_comp);
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vsync_tick = ktime_to_ns(vctrl->vsync_time);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu",
-			ktime_to_ns(vctrl->vsync_time));
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
 	buf[strlen(buf) + 1] = '\0';
 	return ret;
 }
-
 void mdp4_dtv_vsync_init(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
@@ -369,6 +452,7 @@
 	init_completion(&vctrl->ov_comp);
 	init_completion(&vctrl->dmae_comp);
 	atomic_set(&vctrl->suspend, 1);
+	atomic_set(&vctrl->vsync_resume, 1);
 	spin_lock_init(&vctrl->spin_lock);
 }
 
@@ -404,8 +488,12 @@
 	int data_en_polarity;
 	int hsync_start_x;
 	int hsync_end_x;
+	uint32_t userformat;
 	struct fb_info *fbi;
 	struct fb_var_screeninfo *var;
+	struct vsycn_ctrl *vctrl;
+
+	vctrl = &vsync_ctrl_db[0];
 
 	if (!mfd)
 		return -ENODEV;
@@ -416,6 +504,8 @@
 	fbi = mfd->fbi;
 	var = &fbi->var;
 
+	vctrl->mfd = mfd;
+
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	if (hdmi_prim_display) {
 		if (is_mdp4_hw_reset()) {
@@ -434,9 +524,10 @@
 	dtv_border_clr = mfd->panel_info.lcdc.border_clr;
 	dtv_underflow_clr = mfd->panel_info.lcdc.underflow_clr;
 	dtv_hsync_skew = mfd->panel_info.lcdc.hsync_skew;
+	userformat = var->reserved[3] >> 16;
 
 	pr_info("%s: <ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>\n", __func__,
-		var->reserved[3], var->xres, var->yres,
+		userformat, var->xres, var->yres,
 		var->right_margin, var->hsync_len, var->left_margin,
 		var->lower_margin, var->vsync_len, var->upper_margin,
 		var->pixclock/1000/1000);
@@ -506,35 +597,11 @@
 	
 
 	
-	if((var->yres == 480) || (var->yres == 576)){
-		if(var->xres == 640 && var->yres == 480)
-			mdp4_set_limit_range(false);
-		else
-			mdp4_set_limit_range(true);
-	}
-	else
-		mdp4_set_limit_range(false);
-
-	
 	MDP_OUTP(MDP_BASE + DTV_BASE, 1);
 
 	return 0;
 }
 
-static int mdp4_dtv_stop(struct msm_fb_data_type *mfd)
-{
-	int cndx = 0;
-	struct vsycn_ctrl *vctrl;
-
-	vctrl = &vsync_ctrl_db[cndx];
-	if (vctrl->base_pipe == NULL)
-		return -EINVAL;
-
-	MDP_OUTP(MDP_BASE + DTV_BASE, 0);
-
-	return 0;
-}
-
 int mdp4_dtv_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
@@ -552,11 +619,12 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl->dev = mfd->fbi->dev;
+	vctrl->vsync_irq_enabled = 0;
 
-#if 0
 	mdp_footswitch_ctrl(TRUE);
-#endif
 	
 	mdp_clk_ctrl(1);
 
@@ -567,6 +635,7 @@
 		if (mdp4_overlay_dtv_set(mfd, NULL)) {
 			pr_warn("%s: dtv_pipe is NULL, dtv_set failed\n",
 				__func__);
+			mutex_unlock(&mfd->dma->ov_mutex);
 			return -EINVAL;
 		}
 	}
@@ -577,38 +646,55 @@
 
 	atomic_set(&vctrl->suspend, 0);
 
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 	pr_info("%s:\n", __func__);
 
 	return ret;
 }
 
+static void mdp4_dtv_tg_off(struct vsycn_ctrl *vctrl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	MDP_OUTP(MDP_BASE + DTV_BASE, 0); 
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	mdp4_dtv_wait4vsync(0);
+}
+
 int mdp4_dtv_off(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
 	int ret = 0;
 	int cndx = 0;
+	int undx;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
+	struct vsync_update *vp;
+	int mixer = 0;
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl = &vsync_ctrl_db[cndx];
 
-	atomic_set(&vctrl->suspend, 1);
+	mdp4_dtv_wait4vsync(cndx);
 
-	if (vctrl->vsync_irq_enabled) {
-		while (vctrl->wait_vsync_cnt)
-			msleep(20);     
-	}
+	atomic_set(&vctrl->vsync_resume, 0);
 
 	complete_all(&vctrl->vsync_comp);
 	vctrl->wait_vsync_cnt = 0;
 
 	pipe = vctrl->base_pipe;
 	if (pipe != NULL) {
-		mdp4_dtv_stop(mfd);
+		mixer = pipe->mixer_num;
 		
-		mdp4_overlay_unset_mixer(pipe->mixer_num);
+		mdp4_overlay_unset_mixer(mixer);
 		if (hdmi_prim_display && mfd->ref_cnt == 0) {
 			
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
@@ -618,22 +704,34 @@
 			vctrl->base_pipe = NULL;
 		} else {
 			mdp4_mixer_stage_down(pipe, 1);
-			mdp4_overlay_pipe_free(pipe);
+			mdp4_overlay_pipe_free(pipe, 1);
 			vctrl->base_pipe = NULL;
-			
-			msleep(20);
 		}
 	}
 
+	mdp4_dtv_tg_off(vctrl);
+
+	atomic_set(&vctrl->suspend, 1);
+
 	mdp4_overlay_panel_mode_unset(MDP4_MIXER1, MDP4_PANEL_DTV);
 
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	if (vp->update_cnt) {
+		pr_warn("%s: update_cnt=%d\n", __func__, vp->update_cnt);
+		mdp4_dtv_pipe_clean(vp);
+	}
+
 	ret = panel_next_off(pdev);
-#if 0
 	mdp_footswitch_ctrl(FALSE);
-#endif
+
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
 	
 	mdp_clk_ctrl(0);
-	dtv_pipe_ready = 0;
+
+	mutex_unlock(&mfd->dma->ov_mutex);
 
 	pr_info("%s:\n", __func__);
 	return ret;
@@ -750,6 +848,9 @@
 	pipe->srcp0_ystride = fbi->fix.line_length;
 
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
+	mdp4_overlay_mdp_perf_req(mfd);
+	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
 	ret = mdp4_overlay_format2pipe(pipe);
 	if (ret < 0)
@@ -812,7 +913,7 @@
 
 	if (pipe->mixer_stage == MDP4_MIXER_STAGE_BASE &&
 			pipe->pipe_type == OVERLAY_TYPE_RGB) {
-		result = mdp4_dtv_stop(mfd);
+		mdp4_dtv_tg_off(vctrl);
 		vctrl->base_pipe = NULL;
 	}
 	return result;
@@ -827,13 +928,12 @@
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[cndx];
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
-	vctrl->vsync_time = ktime_get();
 
 	spin_lock(&vctrl->spin_lock);
-	if (vctrl->wait_vsync_cnt) {
-		complete_all(&vctrl->vsync_comp);
-		vctrl->wait_vsync_cnt = 0;
-	}
+	vctrl->vsync_time = ktime_get();
+
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -851,6 +951,9 @@
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
+	if (pipe == NULL)
+		return;
+
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
 
 	spin_lock(&vctrl->spin_lock);
@@ -870,8 +973,12 @@
 		vctrl->blt_change = 0;
 	}
 
+	if (mdp_rev <= MDP_REV_41)
+		mdp4_mixer_blend_cfg(MDP4_MIXER1);
+
 	complete_all(&vctrl->dmae_comp);
 	mdp4_overlay_dma_commit(MDP4_MIXER1);
+
 	vsync_irq_disable(INTR_DMA_E_DONE, MDP_DMA_E_TERM);
 	spin_unlock(&vctrl->spin_lock);
 }
@@ -884,6 +991,8 @@
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
+	if (pipe == NULL)
+		return;
 
 	spin_lock(&vctrl->spin_lock);
 	if (pipe->ov_blt_addr == 0) {
@@ -1002,8 +1111,11 @@
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 
-	if (!mfd->panel_power_on)
+	mutex_lock(&mfd->dma->ov_mutex);
+	if (!mfd->panel_power_on) {
+		mutex_unlock(&mfd->dma->ov_mutex);
 		return;
+	}
 
 	vctrl = &vsync_ctrl_db[cndx];
 	if (vctrl->base_pipe == NULL)
@@ -1013,6 +1125,7 @@
 
 	if (pipe == NULL) {
 		pr_warn("%s: dtv_pipe == NULL\n", __func__);
+		mutex_unlock(&mfd->dma->ov_mutex);
 		return;
 	}
 
@@ -1028,10 +1141,8 @@
 		mdp4_dtv_pipe_queue(0, pipe);
 	}
 
-	mutex_lock(&mfd->dma->ov_mutex);
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
-	if (mdp4_dtv_pipe_commit(cndx, 0))
-		mdp4_dtv_wait4dmae(0);
+	mdp4_dtv_pipe_commit(0, 1);
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_lcdc.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_lcdc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_lcdc.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_lcdc.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,19 +45,19 @@
 static int lcdc_enabled;
 
 #define MAX_CONTROLLER	1
-#define VSYNC_EXPIRE_TICK 1
 
 static struct vsycn_ctrl {
 	struct device *dev;
 	int inited;
 	int update_ndx;
-	int expire_tick;
 	int ov_koff;
 	int ov_done;
 	atomic_t suspend;
+	atomic_t vsync_resume;
 	int wait_vsync_cnt;
 	int blt_change;
 	int blt_free;
+	int sysfs_created;
 	struct mutex update_lock;
 	struct completion ov_comp;
 	struct completion dmap_comp;
@@ -68,7 +68,6 @@
 	struct vsync_update vlist[2];
 	int vsync_irq_enabled;
 	ktime_t vsync_time;
-	struct work_struct vsync_work;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 
@@ -141,6 +140,21 @@
 	mdp4_stat.overlay_play[pipe->mixer_num]++;
 }
 
+static void mdp4_lcdc_pipe_clean(struct vsync_update *vp)
+{
+	struct mdp4_overlay_pipe *pipe;
+	int i;
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+	vp->update_cnt = 0;     
+}
+
 static void mdp4_lcdc_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 static void mdp4_lcdc_wait4dmap(int cndx);
 static void mdp4_lcdc_wait4ov(int cndx);
@@ -163,12 +177,15 @@
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	mixer = pipe->mixer_num;
-
-	if (vp->update_cnt == 0) {
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
 		mutex_unlock(&vctrl->update_lock);
 		return 0;
 	}
+	mixer = pipe->mixer_num;
+
+	mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
+
 
 	vctrl->update_ndx++;
 	vctrl->update_ndx &= 0x01;
@@ -215,8 +232,6 @@
 				
 				mdp4_overlay_vsync_commit(pipe);
 			}
-			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
-			pipe->pipe_used = 0; 
 		}
 	}
 
@@ -225,6 +240,18 @@
 	
 	mdp4_overlay_lcdc_start();
 
+
+	
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
+	}
+
 	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
@@ -248,14 +275,39 @@
 
 	if (wait) {
 		if (pipe->ov_blt_addr)
-			mdp4_lcdc_wait4ov(cndx);
+			mdp4_lcdc_wait4ov(0);
 		else
-			mdp4_lcdc_wait4dmap(cndx);
+			mdp4_lcdc_wait4dmap(0);
 	}
 
 	return cnt;
 }
 
+static void mdp4_lcdc_vsync_irq_ctrl(int cndx, int enable)
+{
+	struct vsycn_ctrl *vctrl;
+	static int vsync_irq_cnt;
+
+	vctrl = &vsync_ctrl_db[cndx];
+
+	mutex_lock(&vctrl->update_lock);
+	if (enable) {
+		if (vsync_irq_cnt == 0)
+			vsync_irq_enable(INTR_PRIMARY_VSYNC,
+						MDP_PRIM_VSYNC_TERM);
+		vsync_irq_cnt++;
+	} else {
+		if (vsync_irq_cnt) {
+			vsync_irq_cnt--;
+			if (vsync_irq_cnt == 0)
+				vsync_irq_disable(INTR_PRIMARY_VSYNC,
+						MDP_PRIM_VSYNC_TERM);
+		}
+	}
+	pr_debug("%s: enable=%d cnt=%d\n", __func__, enable, vsync_irq_cnt);
+	mutex_unlock(&vctrl->update_lock);
+}
+
 void mdp4_lcdc_vsync_ctrl(struct fb_info *info, int enable)
 {
 	struct vsycn_ctrl *vctrl;
@@ -263,18 +315,20 @@
 
 	vctrl = &vsync_ctrl_db[cndx];
 
+	if (vctrl->vsync_irq_enabled == enable)
+		return;
+
 	pr_debug("%s: vsync enable=%d\n", __func__, enable);
 
-	if (enable && !vctrl->vsync_irq_enabled) {
-		schedule_work(&vctrl->vsync_work);
-		vctrl->vsync_irq_enabled = 1;
-		vctrl->expire_tick = 0;
-		vsync_irq_enable(INTR_PRIMARY_VSYNC, MDP_PRIM_VSYNC_TERM);
-		pr_debug("%s: VSYNC_on\n", __func__);
-	}
+	vctrl->vsync_irq_enabled = enable;
+
+	mdp4_lcdc_vsync_irq_ctrl(cndx, enable);
+
+	if (vctrl->vsync_irq_enabled &&  atomic_read(&vctrl->suspend) == 0)
+		atomic_set(&vctrl->vsync_resume, 1);
 }
 
-void mdp4_lcdc_wait4vsync(int cndx, long long *vtime)
+void mdp4_lcdc_wait4vsync(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
@@ -288,13 +342,10 @@
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	if (atomic_read(&vctrl->suspend) > 0) {
-		*vtime = -1;
+	if (atomic_read(&vctrl->suspend) > 0)
 		return;
-	}
 
-	
-	mdp4_overlay_lcdc_start();
+	mdp4_lcdc_vsync_irq_ctrl(cndx, 1);
 
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 
@@ -304,9 +355,8 @@
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
 	wait_for_completion(&vctrl->vsync_comp);
+	mdp4_lcdc_vsync_irq_ctrl(cndx, 0);
 	mdp4_stat.wait4vsync0++;
-
-	*vtime = vctrl->vsync_time.tv64;
 }
 
 static void mdp4_lcdc_wait4dmap(int cndx)
@@ -343,18 +393,55 @@
 	wait_for_completion(&vctrl->ov_comp);
 }
 
-static void send_vsync_work(struct work_struct *work)
+ssize_t mdp4_lcdc_show_event(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
-	struct vsycn_ctrl *vctrl =
-		container_of(work, typeof(*vctrl), vsync_work);
-	char buf[64];
-	char *envp[2];
-
-	snprintf(buf, sizeof(buf), "VSYNC=%llu",
-				ktime_to_ns(vctrl->vsync_time));
-	envp[0] = buf;
-	envp[1] = NULL;
-	kobject_uevent_env(&vctrl->dev->kobj, KOBJ_CHANGE, envp);
+	int cndx;
+	struct vsycn_ctrl *vctrl;
+	ssize_t ret = 0;
+	unsigned long flags;
+	u64 vsync_tick;
+	ktime_t ctime;
+	u32 ctick, ptick;
+	int diff;
+
+	cndx = 0;
+	vctrl = &vsync_ctrl_db[0];
+
+	if (atomic_read(&vctrl->suspend) > 0 ||
+		atomic_read(&vctrl->vsync_resume) == 0)
+		return 0;
+
+	ctime = ktime_get();
+	ctick = (u32)ktime_to_us(ctime);
+	ptick = (u32)ktime_to_us(vctrl->vsync_time);
+	ptick += 5000;	
+	diff = ptick - ctick;
+	if (diff > 0) {
+		if (diff > 1000) 
+			diff = 1000;
+		usleep(diff);
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	if (vctrl->wait_vsync_cnt == 0)
+		INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vsync_tick = ktime_to_ns(vctrl->vsync_time);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
+	buf[strlen(buf) + 1] = '\0';
+	return ret;
 }
 
 void mdp4_lcdc_vsync_init(int cndx)
@@ -378,9 +465,30 @@
 	init_completion(&vctrl->vsync_comp);
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->ov_comp);
-	atomic_set(&vctrl->suspend, 0);
+	atomic_set(&vctrl->suspend, 1);
+	atomic_set(&vctrl->vsync_resume, 1);
 	spin_lock_init(&vctrl->spin_lock);
-	INIT_WORK(&vctrl->vsync_work, send_vsync_work);
+}
+
+void mdp4_lcdc_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
+
+	if (pipe == NULL)
+		return ;
+	
+	if (pipe->pipe_type == OVERLAY_TYPE_BF)
+		mdp4_overlay_borderfill_stage_down(pipe);
+
+	
+	pipe = vctrl->base_pipe;
+	mdp4_mixer_stage_down(pipe, 1);
+	mdp4_overlay_pipe_free(pipe, 1);
+	vctrl->base_pipe = NULL;
 }
 
 void mdp4_lcdc_base_swap(int cndx, struct mdp4_overlay_pipe *pipe)
@@ -448,8 +556,11 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
+	mutex_lock(&mfd->dma->ov_mutex);
+
 	vctrl->mfd = mfd;
 	vctrl->dev = mfd->fbi->dev;
+	vctrl->vsync_irq_enabled = 0;
 
 	
 	mdp_clk_ctrl(1);
@@ -466,10 +577,8 @@
 		if (ptype < 0)
 			printk(KERN_INFO "%s: format2type failed\n", __func__);
 		pipe = mdp4_overlay_pipe_alloc(ptype, MDP4_MIXER0);
-		if (pipe == NULL) {
+		if (pipe == NULL)
 			printk(KERN_INFO "%s: pipe_alloc failed\n", __func__);
-			return -EBUSY;
-		}
 		pipe->pipe_used++;
 		pipe->mixer_stage  = MDP4_MIXER_STAGE_BASE;
 		pipe->mixer_num  = MDP4_MIXER0;
@@ -506,7 +615,10 @@
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
+	mdp4_overlay_solidfill_init(pipe);
+
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
 
 	atomic_set(&vctrl->suspend, 0);
 
@@ -608,9 +720,24 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	mdp_histogram_ctrl_all(TRUE);
+	mdp4_overlay_lcdc_start();
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 	return ret;
 }
 
+static void mdp4_lcdc_tg_off(struct vsycn_ctrl *vctrl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	MDP_OUTP(MDP_BASE + LCDC_BASE, 0); 
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	mdp4_lcdc_wait4vsync(0);
+}
 int mdp4_lcdc_off(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -618,30 +745,57 @@
 	struct msm_fb_data_type *mfd;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
+	struct vsync_update *vp;
+	unsigned long flags;
+	int undx, need_wait = 0;
+	int mixer = 0;
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
+
+	mutex_lock(&mfd->dma->ov_mutex);
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	atomic_set(&vctrl->suspend, 1);
+	mdp4_lcdc_wait4vsync(cndx);
 
-	if (vctrl->expire_tick)
-		msleep(20 * vctrl->expire_tick);
+	atomic_set(&vctrl->vsync_resume, 0);
 
-	MDP_OUTP(MDP_BASE + LCDC_BASE, 0);
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 
-	lcdc_enabled = 0;
+	if (pipe->ov_blt_addr) {
+		spin_lock_irqsave(&vctrl->spin_lock, flags);
+		if (vctrl->ov_koff != vctrl->ov_done)
+			need_wait = 1;
+		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+		if (need_wait)
+			mdp4_lcdc_wait4ov(0);
+	}
 
 	mdp_histogram_ctrl_all(FALSE);
 
+	lcdc_enabled = 0;
+
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	if (vp->update_cnt) {
+		pr_warn("%s: update_cnt=%d\n", __func__, vp->update_cnt);
+		mdp4_lcdc_pipe_clean(vp);
+	}
 
 	if (pipe) {
 		
-		mdp4_overlay_unset_mixer(pipe->mixer_num);
+		mixer = pipe->mixer_num;
+		mdp4_overlay_unset_mixer(mixer);
 		if (mfd->ref_cnt == 0) {
 			
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
 				mdp4_overlay_borderfill_stage_down(pipe);
+
+			
+			pipe = vctrl->base_pipe;
+			mdp4_mixer_stage_down(pipe, 1);
+			mdp4_overlay_pipe_free(pipe, 1);
 			vctrl->base_pipe = NULL;
 		} else {
 			
@@ -651,12 +805,19 @@
 		}
 	}
 
-	vctrl->vsync_irq_enabled = 0;
+	mdp4_lcdc_tg_off(vctrl);
+
+	atomic_set(&vctrl->suspend, 1);
+
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+	mdp4_overlay_iommu_unmap_freelist(mixer);
 
 	
 	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_OVERLAY0_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
+	mutex_unlock(&mfd->dma->ov_mutex);
+
 	return ret;
 }
 
@@ -715,24 +876,12 @@
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[cndx];
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
-	vctrl->vsync_time = ktime_get();
-	schedule_work(&vctrl->vsync_work);
 
 	spin_lock(&vctrl->spin_lock);
-	if (vctrl->wait_vsync_cnt) {
-		complete_all(&vctrl->vsync_comp);
-		vctrl->wait_vsync_cnt = 0;
-	}
+	vctrl->vsync_time = ktime_get();
 
-	if (vctrl->expire_tick) {
-		vctrl->expire_tick--;
-		if (vctrl->expire_tick == 0) {
-			pr_debug("%s: VSYNC_off\n", __func__);
-			vctrl->vsync_irq_enabled = 0;
-			vsync_irq_disable(INTR_PRIMARY_VSYNC,
-						MDP_PRIM_VSYNC_TERM);
-		}
-	}
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 	spin_unlock(&vctrl->spin_lock);
 }
 
@@ -767,6 +916,10 @@
 	}
 
 	complete_all(&vctrl->dmap_comp);
+
+	if (mdp_rev <= MDP_REV_41)
+		mdp4_mixer_blend_cfg(MDP4_MIXER0);
+
 	mdp4_overlay_dma_commit(cndx);
 	spin_unlock(&vctrl->spin_lock);
 }
@@ -861,17 +1014,19 @@
 	uint8 *buf;
 	unsigned int buf_offset;
 	int bpp;
-	int cndx = 0;
+	int cnt, cndx = 0;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
-	unsigned long flags;
 
+	mutex_lock(&mfd->dma->ov_mutex);
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	if (!pipe || !mfd->panel_power_on)
+	if (!pipe || !mfd->panel_power_on) {
+		mutex_unlock(&mfd->dma->ov_mutex);
 		return;
+	}
 
 	pr_debug("%s: cpu=%d pid=%d\n", __func__,
 			smp_processor_id(), current->pid);
@@ -888,20 +1043,16 @@
 		mdp4_lcdc_pipe_queue(0, pipe);
 	}
 
-	spin_lock_irqsave(&vctrl->spin_lock, flags);
-	vctrl->expire_tick = VSYNC_EXPIRE_TICK;
-	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
-
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
-	mutex_lock(&mfd->dma->ov_mutex);
-	mdp4_lcdc_pipe_commit(cndx, 0);
-	mutex_unlock(&mfd->dma->ov_mutex);
-
-	if (pipe->ov_blt_addr)
-		mdp4_lcdc_wait4ov(cndx);
-	else
-		mdp4_lcdc_wait4dmap(cndx);
+	cnt = mdp4_lcdc_pipe_commit(cndx, 0);
+	if (cnt >= 0) {
+		if (pipe->ov_blt_addr)
+			mdp4_lcdc_wait4ov(cndx);
+		else
+			mdp4_lcdc_wait4dmap(cndx);
+	}
 
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
+	mutex_unlock(&mfd->dma->ov_mutex);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_writeback.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_writeback.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_overlay_writeback.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_overlay_writeback.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,10 +45,54 @@
 	WITH_CLIENT
 };
 
-static struct mdp4_overlay_pipe *writeback_pipe;
-static struct msm_fb_data_type *writeback_mfd;
-static int busy_wait_cnt;
-static bool writeback_init_done = false;
+#define MAX_CONTROLLER	1
+#define VSYNC_EXPIRE_TICK 0
+
+static struct vsycn_ctrl {
+	struct device *dev;
+	int inited;
+	int update_ndx;
+	u32 ov_koff;
+	u32 ov_done;
+	atomic_t suspend;
+	struct mutex update_lock;
+	struct completion ov_comp;
+	spinlock_t spin_lock;
+	struct msm_fb_data_type *mfd;
+	struct mdp4_overlay_pipe *base_pipe;
+	struct vsync_update vlist[2];
+	struct work_struct clk_work;
+} vsync_ctrl_db[MAX_CONTROLLER];
+
+static void vsync_irq_enable(int intr, int term)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	
+	mdp_intr_mask |= intr;
+	outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+	mdp_enable_irq(term);
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
+}
+
+static void vsync_irq_disable(int intr, int term)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	
+	mdp_intr_mask &= ~intr;
+	outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+	mdp_disable_irq_nosync(term);
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
+}
+
+static int mdp4_overlay_writeback_update(struct msm_fb_data_type *mfd);
+static void mdp4_wfd_queue_wakeup(struct msm_fb_data_type *mfd,
+		struct msmfb_writeback_data_list *node);
+static int mdp4_wfd_dequeue_update(struct msm_fb_data_type *mfd,
+		struct msmfb_writeback_data_list **wfdnode);
 
 int mdp4_overlay_writeback_on(struct platform_device *pdev)
 {
@@ -59,6 +103,8 @@
 	int bpp;
 	int ret;
 	uint32 data;
+	struct vsycn_ctrl *vctrl;
+	int cndx = 0;
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
@@ -68,7 +114,9 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	writeback_mfd = mfd;		  
+	vctrl = &vsync_ctrl_db[cndx];
+	vctrl->mfd = mfd;
+	vctrl->dev = mfd->fbi->dev;
 
 	fbi = mfd->fbi;
 
@@ -78,13 +126,15 @@
 		fbi->var.yoffset * fbi->fix.line_length;
 
 	
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
 	mdp_clk_ctrl(1);
-	if (writeback_pipe == NULL) {
+
+	if (vctrl->base_pipe == NULL) {
 		pipe = mdp4_overlay_pipe_alloc(OVERLAY_TYPE_BF, MDP4_MIXER2);
-		if (pipe == NULL)
+		if (pipe == NULL) {
 			pr_info("%s: pipe_alloc failed\n", __func__);
+			mdp_clk_ctrl(0);
+			return -EIO;
+		}
 		pipe->pipe_used++;
 		pipe->mixer_stage  = MDP4_MIXER_STAGE_BASE;
 		pipe->mixer_num  = MDP4_MIXER2;
@@ -94,11 +144,12 @@
 		if (ret < 0)
 			pr_info("%s: format2type failed\n", __func__);
 
-		writeback_pipe = pipe; 
+		vctrl->base_pipe = pipe; 
 
 	} else {
-		pipe = writeback_pipe;
+		pipe = vctrl->base_pipe;
 	}
+
 	ret = panel_next_on(pdev);
 
 	
@@ -115,48 +166,90 @@
 	MDP_OUTP(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x5008,
 		(0x0 & 0xFFF));         
 
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
+
+	atomic_set(&vctrl->suspend, 0);
+
 	return ret;
 }
 
+static void mdp4_wfd_wait4ov(int cndx);
+static void mdp4_writeback_pipe_clean(struct vsync_update *vp);
+
 int mdp4_overlay_writeback_off(struct platform_device *pdev)
 {
-	int ret;
-	struct msm_fb_data_type *mfd =
-			(struct msm_fb_data_type *)platform_get_drvdata(pdev);
-	if (mfd && writeback_pipe) {
-		mdp4_writeback_dma_busy_wait(mfd);
-		mdp4_overlay_pipe_free(writeback_pipe);
-		mdp4_overlay_panel_mode_unset(writeback_pipe->mixer_num,
-						MDP4_PANEL_WRITEBACK);
-		writeback_pipe = NULL;
+	int cndx = 0;
+	struct msm_fb_data_type *mfd;
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+	int ret = 0;
+	int undx;
+	struct vsync_update *vp;
+
+	pr_debug("%s+:\n", __func__);
+
+	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
+
+	vctrl = &vsync_ctrl_db[cndx];
+	pipe = vctrl->base_pipe;
+
+	atomic_set(&vctrl->suspend, 1);
+
+	if (pipe == NULL) {
+		pr_err("%s: NO base pipe\n", __func__);
+		return ret;
 	}
+
+	complete(&vctrl->ov_comp);
+	msleep(20);
+	mdp_clk_ctrl(1);
+	
+	mdp4_overlay_unset_mixer(pipe->mixer_num);
+	mdp4_mixer_stage_down(pipe, 1);
+	mdp4_overlay_pipe_free(pipe, 1);
+	vctrl->base_pipe = NULL;
+	mdp_clk_ctrl(0);
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	if (vp->update_cnt) {
+		pr_warn("%s: update_cnt=%d\n", __func__, vp->update_cnt);
+		mdp4_writeback_pipe_clean(vp);
+	}
+
 	ret = panel_next_off(pdev);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
+	mdp_clk_ctrl(1);
 	
 	outpdw(MDP_BASE + 0x100F4, 0x0);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 	mdp_clk_ctrl(0);
 
+	pr_debug("%s-:\n", __func__);
 	return ret;
 }
-int mdp4_overlay_writeback_update(struct msm_fb_data_type *mfd, struct mdp4_overlay_pipe *ov_pipe)
+
+static int mdp4_overlay_writeback_update(struct msm_fb_data_type *mfd)
 {
 	struct fb_info *fbi;
 	uint8 *buf;
 	unsigned int buf_offset;
 	struct mdp4_overlay_pipe *pipe;
 	int bpp;
+	int cndx = 0;
+	struct vsycn_ctrl *vctrl;
 
 	if (mfd->key != MFD_KEY)
 		return -ENODEV;
 
-	if (!writeback_pipe)
-		return -EINVAL;
 
 	fbi = mfd->fbi;
 
-	pipe = writeback_pipe;
+	vctrl = &vsync_ctrl_db[cndx];
+
+	pipe = vctrl->base_pipe;
+	if (!pipe) {
+		pr_err("%s: no base layer pipe\n", __func__);
+		return -EINVAL;
+	}
 
 	bpp = fbi->var.bits_per_pixel / 8;
 	buf = (uint8 *) fbi->fix.smem_start;
@@ -164,46 +257,22 @@
 		fbi->var.yoffset * fbi->fix.line_length;
 
 	
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
+
+	pipe->src_height = fbi->var.yres;
+	pipe->src_width = fbi->var.xres;
+	pipe->src_h = fbi->var.yres;
+	pipe->src_w = fbi->var.xres;
+	pipe->dst_h = fbi->var.yres;
+	pipe->dst_w = fbi->var.xres;
+	pipe->srcp0_ystride = fbi->fix.line_length;
+	pipe->src_y = 0;
+	pipe->src_x = 0;
+	pipe->dst_y = 0;
+	pipe->dst_x = 0;
 
-	if (ov_pipe && (ov_pipe->flags & MDP_BLIT_NON_CACHED)) {
-		
-		
-		pipe->src_width = ov_pipe->dst_w;
-		pipe->src_height = ov_pipe->dst_h;
-		pipe->src_w = ov_pipe->dst_w;
-		pipe->src_h = ov_pipe->dst_h;
-		
-		
-		
-		if(ov_pipe->src_format == MDP_Y_CBCR_H2V2 ||
-		   ov_pipe->src_format == MDP_Y_CRCB_H2V2) {
-			pipe->src_width = ov_pipe->dst_w;
-			pipe->src_height = ov_pipe->dst_h;
-			pipe->src_w = ov_pipe->dst_w;
-			pipe->src_h = ov_pipe->dst_h;
-		}
-		pipe->dst_w = ov_pipe->dst_w;
-		pipe->dst_h = ov_pipe->dst_h;
-		pipe->srcp0_ystride = ov_pipe->dst_w * 2;
-		pipe->src_x = ov_pipe->src_x;
-		pipe->src_y = ov_pipe->src_y;
-		pipe->dst_x = ov_pipe->dst_x;
-		pipe->dst_y = ov_pipe->dst_y;
-	} else {
-		pipe->src_height = fbi->var.yres;
-		pipe->src_width = fbi->var.xres;
-		pipe->src_h = fbi->var.yres;
-		pipe->src_w = fbi->var.xres;
-		pipe->dst_h = fbi->var.yres;
-		pipe->dst_w = fbi->var.xres;
-		pipe->srcp0_ystride = fbi->fix.line_length;
-		pipe->src_y = 0;
-		pipe->src_x = 0;
-		pipe->dst_y = 0;
-		pipe->dst_x = 0;
-	}
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
 
 	if (mfd->display_iova)
 		pipe->srcp0_addr = mfd->display_iova + buf_offset;
@@ -213,213 +282,241 @@
 	mdp4_mixer_stage_up(pipe, 0);
 
 	mdp4_overlayproc_cfg(pipe);
-	mdp4_mixer_stage_commit(pipe->mixer_num);
+
+	if (hdmi_prim_display)
+		outpdw(MDP_BASE + 0x100F4, 0x01);
+	else
+		outpdw(MDP_BASE + 0x100F4, 0x02);
+
 	
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 
 	wmb();
 	return 0;
 }
-void mdp4_writeback_dma_busy_wait(struct msm_fb_data_type *mfd)
+
+void mdp4_wfd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 {
-	unsigned long flag;
-	int need_wait = 0;
+	struct vsycn_ctrl *vctrl;
+	struct vsync_update *vp;
+	struct mdp4_overlay_pipe *pp;
+	int undx;
 
-	spin_lock_irqsave(&mdp_spin_lock, flag);
-	if (mfd->dma->busy == TRUE) {
-		if (busy_wait_cnt == 0)
-			INIT_COMPLETION(mfd->dma->comp);
-		busy_wait_cnt = 1;
-		need_wait++;
+	if (cndx >= MAX_CONTROLLER) {
+		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
+		return;
 	}
-	spin_unlock_irqrestore(&mdp_spin_lock, flag);
 
-	if (need_wait) {
-		
-		pr_debug("%s: pending pid=%d\n",
-				__func__, current->pid);
-		wait_for_completion(&mfd->dma->comp);
-	}
-}
+	vctrl = &vsync_ctrl_db[cndx];
 
-void mdp4_overlay1_done_writeback(struct mdp_dma_data *dma)
-{
-	spin_lock(&mdp_spin_lock);
-	dma->busy = FALSE;
-	if (busy_wait_cnt)
-		busy_wait_cnt = 0;
-	mdp_disable_irq_nosync(MDP_OVERLAY2_TERM);
-	spin_unlock(&mdp_spin_lock);
-	complete_all(&dma->comp);
-	pr_debug("%s ovdone interrupt\n", __func__);
+	if (atomic_read(&vctrl->suspend) > 0)
+		return;
 
-}
-void mdp4_writeback_overlay_kickoff(struct msm_fb_data_type *mfd,
-				    struct mdp4_overlay_pipe *pipe)
-{
-	unsigned long flag;
-	spin_lock_irqsave(&mdp_spin_lock, flag);
-	mdp_enable_irq(MDP_OVERLAY2_TERM);
+	mutex_lock(&vctrl->update_lock);
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
 
-	mfd->dma->busy = TRUE;
-	outp32(MDP_INTR_CLEAR, INTR_OVERLAY2_DONE);
-	mdp_intr_mask |= INTR_OVERLAY2_DONE;
-	outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+	pp = &vp->plist[pipe->pipe_ndx - 1];	
 
-	wmb();	
-	spin_unlock_irqrestore(&mdp_spin_lock, flag);
-	
-	mdp_pipe_kickoff(MDP_OVERLAY2_TERM, mfd);
-	wmb();
-	pr_debug("%s: before ov done interrupt\n", __func__);
+	pr_debug("%s: vndx=%d pipe_ndx=%d pid=%d\n", __func__,
+		undx, pipe->pipe_ndx, current->pid);
+
+	*pp = *pipe;	
+	vp->update_cnt++;
+
+	mutex_unlock(&vctrl->update_lock);
+	mdp4_stat.overlay_play[pipe->mixer_num]++;
 }
-void mdp4_writeback_dma_stop(struct msm_fb_data_type *mfd)
+
+static void mdp4_writeback_pipe_clean(struct vsync_update *vp)
 {
-	
-	if (mfd && writeback_pipe) {
-		mdp4_writeback_dma_busy_wait(mfd);
-		mdp4_overlay_writeback_update(mfd, NULL);
+	struct mdp4_overlay_pipe *pipe;
+	int i;
 
-		mdp4_writeback_overlay_kickoff(mfd, writeback_pipe);
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
 	}
+	vp->update_cnt = 0;     
 }
 
-void mdp4_writeback_kickoff_video(struct msm_fb_data_type *mfd,
-		struct mdp4_overlay_pipe *pipe)
+int mdp4_wfd_pipe_commit(struct msm_fb_data_type *mfd,
+			int cndx, int wait)
 {
+	int  i, undx;
+	int mixer = 0;
+	struct vsycn_ctrl *vctrl;
+	struct vsync_update *vp;
+	struct mdp4_overlay_pipe *pipe;
+	struct mdp4_overlay_pipe *real_pipe;
+	unsigned long flags;
+	int cnt = 0;
 	struct msmfb_writeback_data_list *node = NULL;
+	int rc = 0;
 
-	if (!writeback_init_done) {
-		printk("[DISP] mdp4_writeback_kickoff_video: writeback_init_done is false!\n");
-		return;
-	}
+	vctrl = &vsync_ctrl_db[cndx];
 
-	mutex_lock(&mfd->unregister_mutex);
-	mutex_lock(&mfd->writeback_mutex);
-	if (!list_empty(&mfd->writeback_free_queue)
-		&& mfd->writeback_state != WB_STOPING
-		&& mfd->writeback_state != WB_STOP) {
-		node = list_first_entry(&mfd->writeback_free_queue,
-				struct msmfb_writeback_data_list, active_entry);
+	mutex_lock(&vctrl->update_lock);
+	undx =  vctrl->update_ndx;
+	vp = &vctrl->vlist[undx];
+	pipe = vctrl->base_pipe;
+	mixer = pipe->mixer_num;
+
+
+	vctrl->update_ndx++;
+	vctrl->update_ndx &= 0x01;
+	vp->update_cnt = 0;     
+	mutex_unlock(&vctrl->update_lock);
+
+	rc = mdp4_wfd_dequeue_update(mfd, &node);
+	if (rc != 0) {
+		pr_err("%s: mdp4_wfd_dequeue_update failed !! mfd=%x\n",
+			__func__, (int)mfd);
+		pipe = vp->plist;
+		for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+			pipe->pipe_used = 0;
+			pr_info("%s: dequeue update failed, unsetting pipes\n",
+				__func__);
+		}
+		return cnt;
 	}
-	if (node) {
-		list_del(&(node->active_entry));
-		node->state = IN_BUSY_QUEUE;
-		mfd->writeback_active_cnt++;
+	
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
+	mdp_clk_ctrl(1);
+	pipe = vp->plist;
+	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+		if (pipe->pipe_used) {
+			cnt++;
+			real_pipe = mdp4_overlay_ndx2pipe(pipe->pipe_ndx);
+			if (real_pipe && real_pipe->pipe_used) {
+				
+				mdp4_overlay_vsync_commit(pipe);
+			}
+			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+			pipe->pipe_used = 0; 
+		}
 	}
-	mutex_unlock(&mfd->writeback_mutex);
 
-	writeback_pipe->ov_blt_addr = (ulong) (node ? node->addr : NULL);
+	mdp4_mixer_stage_commit(mixer);
 
+	pipe = vctrl->base_pipe;
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vctrl->ov_koff++;
+	INIT_COMPLETION(vctrl->ov_comp);
+	vsync_irq_enable(INTR_OVERLAY2_DONE, MDP_OVERLAY2_TERM);
+	pr_debug("%s: kickoff\n", __func__);
 	
-	mdp4_overlay_iommu_unmap_freelist(writeback_pipe->mixer_num);
+	mdp4_stat.kickoff_ov2++;
+	outpdw(MDP_BASE + 0x00D0, 0);
+	mb(); 
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	if (!writeback_pipe->ov_blt_addr) {
-		pr_err("%s: no writeback buffer 0x%x, %p\n", __func__,
-			(unsigned int)writeback_pipe->ov_blt_addr, node);
-		mutex_unlock(&mfd->unregister_mutex);
+	mdp4_stat.overlay_commit[pipe->mixer_num]++;
+
+	if (wait)
+		mdp4_wfd_wait4ov(cndx);
+
+	mdp4_wfd_queue_wakeup(mfd, node);
+
+	return cnt;
+}
+
+static void clk_ctrl_work(struct work_struct *work)
+{
+	struct vsycn_ctrl *vctrl =
+		container_of(work, typeof(*vctrl), clk_work);
+	mdp_clk_ctrl(0);
+}
+
+void mdp4_wfd_init(int cndx)
+{
+	struct vsycn_ctrl *vctrl;
+
+	if (cndx >= MAX_CONTROLLER) {
+		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
 		return;
 	}
 
-	if (writeback_pipe->blt_cnt == 0)
-		mdp4_overlay_writeback_update(mfd, pipe);
+	vctrl = &vsync_ctrl_db[cndx];
+	if (vctrl->inited)
+		return;
 
-	pr_debug("%s: pid=%d\n", __func__, current->pid);
+	vctrl->inited = 1;
+	vctrl->update_ndx = 0;
+	mutex_init(&vctrl->update_lock);
+	init_completion(&vctrl->ov_comp);
+	atomic_set(&vctrl->suspend, 1);
+	spin_lock_init(&vctrl->spin_lock);
+	INIT_WORK(&vctrl->clk_work, clk_ctrl_work);
+}
 
-	mdp4_mixer_stage_commit(pipe->mixer_num);
+static void mdp4_wfd_wait4ov(int cndx)
+{
+	struct vsycn_ctrl *vctrl;
 
-	mdp4_writeback_overlay_kickoff(mfd, pipe);
-	mdp4_writeback_dma_busy_wait(mfd);
+	if (cndx >= MAX_CONTROLLER) {
+		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
+		return;
+	}
 
-	
-	mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+	vctrl = &vsync_ctrl_db[cndx];
 
-	mutex_lock(&mfd->writeback_mutex);
-	list_add_tail(&node->active_entry, &mfd->writeback_busy_queue);
-	mutex_unlock(&mfd->writeback_mutex);
-	mfd->writeback_active_cnt--;
-	mutex_unlock(&mfd->unregister_mutex);
-	wake_up(&mfd->wait_q);
+	if (atomic_read(&vctrl->suspend) > 0)
+		return;
 
-	writeback_init_done = false;
+	wait_for_completion(&vctrl->ov_comp);
 }
 
-void mdp4_writeback_kickoff_ui(struct msm_fb_data_type *mfd,
-		struct mdp4_overlay_pipe *pipe)
+
+void mdp4_overlay2_done_wfd(struct mdp_dma_data *dma)
 {
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+	int cndx = 0;
 
-	mdp4_mixer_stage_commit(pipe->mixer_num);
+	vctrl = &vsync_ctrl_db[cndx];
+	pipe = vctrl->base_pipe;
 
-	pr_debug("%s: pid=%d\n", __func__, current->pid);
-	mdp4_writeback_overlay_kickoff(mfd, pipe);
+	spin_lock(&vctrl->spin_lock);
+	vsync_irq_disable(INTR_OVERLAY2_DONE, MDP_OVERLAY2_TERM);
+	vctrl->ov_done++;
+	complete(&vctrl->ov_comp);
+	schedule_work(&vctrl->clk_work);
+	pr_debug("%s ovdone interrupt\n", __func__);
+	spin_unlock(&vctrl->spin_lock);
 }
 
 void mdp4_writeback_overlay(struct msm_fb_data_type *mfd)
 {
-	int ret = 0;
-	struct msmfb_writeback_data_list *node = NULL;
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
 
-	mutex_lock(&mfd->unregister_mutex);
-	mutex_lock(&mfd->writeback_mutex);
-	if (!list_empty(&mfd->writeback_free_queue)
-		&& mfd->writeback_state != WB_STOPING
-		&& mfd->writeback_state != WB_STOP) {
-		node = list_first_entry(&mfd->writeback_free_queue,
-				struct msmfb_writeback_data_list, active_entry);
-	}
-	if (node) {
-		list_del(&(node->active_entry));
-		node->state = IN_BUSY_QUEUE;
-		mfd->writeback_active_cnt++;
-	}
-	mutex_unlock(&mfd->writeback_mutex);
+	if (mfd && !mfd->panel_power_on)
+		return;
 
-	writeback_pipe->ov_blt_addr = (ulong) (node ? node->addr : NULL);
+	pr_debug("%s:+ mfd=%x\n", __func__, (int)mfd);
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
 
 	mutex_lock(&mfd->dma->ov_mutex);
-	pr_debug("%s in writeback\n", __func__);
-	if (writeback_pipe && !writeback_pipe->ov_blt_addr) {
-		pr_err("%s: no writeback buffer 0x%x\n", __func__,
-				(unsigned int)writeback_pipe->ov_blt_addr);
-		ret = mdp4_overlay_writeback_update(mfd, NULL);
-		if (ret)
-			pr_err("%s: update failed writeback pipe NULL\n",
-					__func__);
-		goto fail_no_blt_addr;
-	}
-
-	if (mfd && mfd->panel_power_on) {
-		pr_debug("%s in before busy wait\n", __func__);
-		mdp4_writeback_dma_busy_wait(mfd);
-
-		pr_debug("%s in before update\n", __func__);
-		ret = mdp4_overlay_writeback_update(mfd, NULL);
-		if (ret) {
-			pr_err("%s: update failed writeback pipe NULL\n",
-					__func__);
-			goto fail_no_blt_addr;
-		}
-
-		pr_debug("%s: in writeback pan display 0x%x\n", __func__,
-				(unsigned int)writeback_pipe->ov_blt_addr);
-		mdp4_writeback_kickoff_ui(mfd, writeback_pipe);
-		mdp4_iommu_unmap(writeback_pipe);
-
-		if (mfd->pan_waiting) {
-			mfd->pan_waiting = FALSE;
-			complete(&mfd->pan_comp);
-		}
-	}
 
-	mutex_lock(&mfd->writeback_mutex);
-	list_add_tail(&node->active_entry, &mfd->writeback_busy_queue);
-	mfd->writeback_active_cnt--;
-	mutex_unlock(&mfd->writeback_mutex);
-	wake_up(&mfd->wait_q);
-fail_no_blt_addr:
+	if (pipe->pipe_type == OVERLAY_TYPE_RGB)
+		mdp4_wfd_pipe_queue(0, pipe);
+
+	mdp4_overlay_mdp_perf_upd(mfd, 1);
+
+	mdp4_wfd_pipe_commit(mfd, 0, 1);
+
+	mdp4_overlay_mdp_perf_upd(mfd, 0);
+
 	mutex_unlock(&mfd->dma->ov_mutex);
-	mutex_unlock(&mfd->unregister_mutex);
 }
+
 static int mdp4_overlay_writeback_register_buffer(
 	struct msm_fb_data_type *mfd, struct msmfb_writeback_data_list *node)
 {
@@ -607,8 +704,6 @@
 int mdp4_writeback_stop(struct fb_info *info)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-	int mixer;
-
 	mutex_lock(&mfd->writeback_mutex);
 	mfd->writeback_state = WB_STOPING;
 	mutex_unlock(&mfd->writeback_mutex);
@@ -617,8 +712,7 @@
 
 	
 	wake_up(&mfd->wait_q);
-	mixer = mfd->panel_info.pdest;
-	mdp4_overlay_iommu_unmap_freelist(mixer);
+
 	return 0;
 }
 int mdp4_writeback_init(struct fb_info *info)
@@ -631,8 +725,6 @@
 	INIT_LIST_HEAD(&mfd->writeback_register_queue);
 	mfd->writeback_state = WB_OPEN;
 	init_waitqueue_head(&mfd->wait_q);
-
-	writeback_init_done = true;
 	return 0;
 }
 int mdp4_writeback_terminate(struct fb_info *info)
@@ -673,3 +765,244 @@
 	mutex_unlock(&mfd->unregister_mutex);
 	return rc;
 }
+
+static int mdp4_wfd_dequeue_update(struct msm_fb_data_type *mfd,
+			struct msmfb_writeback_data_list **wfdnode)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+	struct msmfb_writeback_data_list *node = NULL;
+
+	if (mfd && !mfd->panel_power_on)
+		return -EPERM;
+
+	pr_debug("%s:+ mfd=%x\n", __func__, (int)mfd);
+
+	vctrl = &vsync_ctrl_db[0];
+	pipe = vctrl->base_pipe;
+
+	mutex_lock(&mfd->unregister_mutex);
+	mutex_lock(&mfd->writeback_mutex);
+	if (!list_empty(&mfd->writeback_free_queue)
+		&& mfd->writeback_state != WB_STOPING
+		&& mfd->writeback_state != WB_STOP) {
+		node = list_first_entry(&mfd->writeback_free_queue,
+				struct msmfb_writeback_data_list, active_entry);
+	}
+	if (node) {
+		list_del(&(node->active_entry));
+		node->state = IN_BUSY_QUEUE;
+		mfd->writeback_active_cnt++;
+	}
+	mutex_unlock(&mfd->writeback_mutex);
+
+	pipe->ov_blt_addr = (ulong) (node ? node->addr : NULL);
+
+	if (!pipe->ov_blt_addr) {
+		pr_err("%s: no writeback buffer 0x%x, %p\n", __func__,
+			(unsigned int)pipe->ov_blt_addr, node);
+
+		if (node) {
+			mutex_lock(&mfd->writeback_mutex);
+			list_add_tail(&node->active_entry,
+				&mfd->writeback_free_queue);
+			node->state = IN_FREE_QUEUE;
+			mfd->writeback_active_cnt--;
+			mutex_unlock(&mfd->writeback_mutex);
+		}
+
+		mutex_unlock(&mfd->unregister_mutex);
+		return -EINVAL;
+	}
+
+	mdp4_overlay_writeback_update(mfd);
+
+	*wfdnode = node;
+
+	mutex_unlock(&mfd->unregister_mutex);
+	return 0;
+}
+
+static void mdp4_wfd_queue_wakeup(struct msm_fb_data_type *mfd,
+			struct msmfb_writeback_data_list *node)
+{
+
+	if (mfd && !mfd->panel_power_on)
+		return;
+
+	if (node == NULL)
+		return;
+
+	pr_debug("%s: mfd=%x node: %p", __func__, (int)mfd, node);
+
+	mutex_lock(&mfd->writeback_mutex);
+	list_add_tail(&node->active_entry, &mfd->writeback_busy_queue);
+	mfd->writeback_active_cnt--;
+	mutex_unlock(&mfd->writeback_mutex);
+	wake_up(&mfd->wait_q);
+}
+
+int mdp4_writeback_set_mirroring_hint(struct fb_info *info, int hint)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+
+	if (mfd->panel.type != WRITEBACK_PANEL)
+		return -ENOTSUPP;
+
+	switch (hint) {
+	case MDP_WRITEBACK_MIRROR_ON:
+	case MDP_WRITEBACK_MIRROR_PAUSE:
+	case MDP_WRITEBACK_MIRROR_RESUME:
+	case MDP_WRITEBACK_MIRROR_OFF:
+		pr_info("wfd state switched to %d\n", hint);
+		switch_set_state(&mfd->writeback_sdev, hint);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int
+mdp4_overlay_writeback_pipe_update(
+	struct msm_fb_data_type *mfd,
+	struct mdp4_overlay_pipe *ov_pipe)
+{
+	struct fb_info *fbi;
+	uint8 *buf;
+	unsigned int buf_offset;
+	struct mdp4_overlay_pipe *pipe;
+	int bpp;
+	int cndx = 0;
+	struct vsycn_ctrl *vctrl;
+
+	if (mfd->key != MFD_KEY)
+		return -ENODEV;
+
+
+	fbi = mfd->fbi;
+
+	vctrl = &vsync_ctrl_db[cndx];
+
+	pipe = vctrl->base_pipe;
+	if (!pipe) {
+		pr_err("%s: no base layer pipe\n", __func__);
+		return -EINVAL;
+	}
+	if (!ov_pipe) {
+		pr_err("%s: no ov layer pipe\n", __func__);
+		return -EINVAL;
+	}
+
+	bpp = fbi->var.bits_per_pixel / 8;
+	buf = (uint8 *) fbi->fix.smem_start;
+	buf_offset = fbi->var.xoffset * bpp +
+		fbi->var.yoffset * fbi->fix.line_length;
+
+	
+	mdp_clk_ctrl(1);
+
+	
+	pipe->src_width = ov_pipe->dst_w;
+	pipe->src_height = ov_pipe->dst_h;
+	pipe->src_w = ov_pipe->dst_w;
+	pipe->src_h = ov_pipe->dst_h;
+	
+	
+	
+	if(ov_pipe->src_format == MDP_Y_CBCR_H2V2 ||
+	   ov_pipe->src_format == MDP_Y_CRCB_H2V2) {
+		pipe->src_width = ov_pipe->dst_w;
+		pipe->src_height = ov_pipe->dst_h;
+		pipe->src_w = ov_pipe->dst_w;
+		pipe->src_h = ov_pipe->dst_h;
+	}
+	pipe->dst_w = ov_pipe->dst_w;
+	pipe->dst_h = ov_pipe->dst_h;
+	pipe->srcp0_ystride = ov_pipe->dst_w * 2;
+	pipe->src_x = ov_pipe->src_x;
+	pipe->src_y = ov_pipe->src_y;
+	pipe->dst_x = ov_pipe->dst_x;
+	pipe->dst_y = ov_pipe->dst_y;
+
+	if (ov_pipe->ov_blt_addr) 
+		pipe->dst_format = ov_pipe->dst_format;
+	else 
+		pipe->dst_format = MDP_Y_CBCR_H2V2;
+
+	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	mdp4_calc_blt_mdp_bw(mfd, pipe);
+
+	if (mfd->display_iova)
+		pipe->srcp0_addr = mfd->display_iova + buf_offset;
+	else
+		pipe->srcp0_addr = (uint32)(buf + buf_offset);
+
+	mdp4_mixer_stage_up(pipe, 0);
+
+	mdp4_overlayproc_cfg(pipe);
+
+	if (hdmi_prim_display)
+		outpdw(MDP_BASE + 0x100F4, 0x01);
+	else
+		outpdw(MDP_BASE + 0x100F4, 0x02);
+
+	
+	mdp_clk_ctrl(0);
+
+	wmb();
+	return 0;
+}
+
+void mdp4_writeback_play_kickoff(
+	struct msm_fb_data_type *mfd,
+	struct mdp4_overlay_pipe *ov_pipe)
+{
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *writeback_pipe;
+	unsigned long flags;
+
+	if (mfd && !mfd->panel_power_on) {
+		pr_err("%s: panel power is not on\n", __func__);
+		return;
+	}
+
+	pr_debug("%s:+ mfd=%x\n", __func__, (int)mfd);
+
+	vctrl = &vsync_ctrl_db[0];
+	writeback_pipe = vctrl->base_pipe;
+
+	writeback_pipe->ov_blt_addr = ov_pipe->ov_blt_addr;
+
+	
+	mdp4_overlay_iommu_unmap_freelist(writeback_pipe->mixer_num);
+
+	if (!writeback_pipe->ov_blt_addr) {
+		pr_err("%s: no writeback buffer\n", __func__);
+		return;
+	}
+
+		mdp4_overlay_writeback_pipe_update(mfd, ov_pipe);
+
+
+	pr_debug("%s: pid=%d\n", __func__, current->pid);
+
+	mdp4_mixer_stage_commit(ov_pipe->mixer_num);
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	vctrl->ov_koff++;
+	INIT_COMPLETION(vctrl->ov_comp);
+	vsync_irq_enable(INTR_OVERLAY2_DONE, MDP_OVERLAY2_TERM);
+	pr_debug("%s: kickoff\n", __func__);
+	
+	mdp4_stat.kickoff_ov2++;
+	outpdw(MDP_BASE + 0x00D0, 0);
+	mb(); 
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	mdp4_stat.overlay_commit[writeback_pipe->mixer_num]++;
+
+	mdp4_wfd_wait4ov(0);
+
+	
+	mdp4_overlay_iommu_pipe_free(ov_pipe->pipe_ndx, 0);
+}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_util.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_util.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_util.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_util.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,5 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/*
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,6 +36,149 @@
 
 struct mdp4_statistic mdp4_stat;
 
+struct mdp_csc_cfg_data csc_cfg_matrix[CSC_MAX_BLOCKS] = {
+	{
+	.block = MDP_BLOCK_VG_1,
+	.csc_data = {
+			(MDP_CSC_FLAG_YUV_OUT),
+			{
+				0x0254, 0x0000, 0x0331,
+				0x0254, 0xff37, 0xfe60,
+				0x0254, 0x0409, 0x0000,
+			},
+			{
+				0xfff0, 0xff80, 0xff80,
+			},
+			{
+				0, 0, 0,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+		},
+	},
+	{
+	.block = MDP_BLOCK_VG_2,
+	.csc_data = {
+			(MDP_CSC_FLAG_YUV_OUT),
+			{
+				0x0254, 0x0000, 0x0331,
+				0x0254, 0xff37, 0xfe60,
+				0x0254, 0x0409, 0x0000,
+			},
+			{
+				0xfff0, 0xff80, 0xff80,
+			},
+			{
+				0, 0, 0,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+		},
+	},
+	{
+	.block = MDP_BLOCK_DMA_P,
+	.csc_data = {
+			(0),
+			{
+				0x0200, 0x0000, 0x0000,
+				0x0000, 0x0200, 0x0000,
+				0x0000, 0x0000, 0x0200,
+			},
+			{
+				0x0, 0x0, 0x0,
+			},
+			{
+				0, 0, 0,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+		},
+	},
+	{
+	.block = MDP_BLOCK_OVERLAY_1,
+	.csc_data = {
+			(0),
+			{
+				0x0083, 0x0102, 0x0032,
+				0x1fb5, 0x1f6c, 0x00e1,
+				0x00e1, 0x1f45, 0x1fdc,
+			},
+			{
+				0x0, 0x0, 0x0,
+			},
+			{
+				0x0010, 0x0080, 0x0080,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0x0010, 0x00eb, 0x0010,
+				0x00f0, 0x0010, 0x00f0,
+			},
+		},
+	},
+	{
+	.block = MDP_BLOCK_OVERLAY_2,
+	.csc_data = {
+			(0),
+			{
+				0x0083, 0x0102, 0x0032,
+				0x1fb5, 0x1f6c, 0x00e1,
+				0x00e1, 0x1f45, 0x1fdc,
+			},
+			{
+				0x0, 0x0, 0x0,
+			},
+			{
+				0x0010, 0x0080, 0x0080,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0x0010, 0x00eb, 0x0010,
+				0x00f0, 0x0010, 0x00f0,
+			},
+		},
+	},
+	{
+	.block = MDP_BLOCK_DMA_S,
+	.csc_data = {
+			(0),
+			{
+				0x0200, 0x0000, 0x0000,
+				0x0000, 0x0200, 0x0000,
+				0x0000, 0x0000, 0x0200,
+			},
+			{
+				0x0, 0x0, 0x0,
+			},
+			{
+				0, 0, 0,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+			{
+				0, 0xff, 0, 0xff, 0, 0xff,
+			},
+		},
+	},
+};
+
 unsigned is_mdp4_hw_reset(void)
 {
 	unsigned hw_reset = 0;
@@ -56,13 +200,14 @@
 
 	bits &= 0x1f;	
 	outpdw(MDP_BASE + 0x001c, bits);	
+	wmb();
 
 	while (inpdw(MDP_BASE + 0x001c) & bits) 
 		;
 	
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
-	MSM_FB_DEBUG("mdp4_sw_reset: 0x%x\n", (int)bits);
+	pr_debug("mdp4_sw_reset: 0x%x\n", (int)bits);
 }
 
 void mdp4_overlay_cfg(int overlayer, int blt_mode, int refresh, int direct_out)
@@ -242,11 +387,10 @@
 {
 	ulong bits;
 	uint32 clk_rate;
-
+	int i;
 	
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
-	mdp_bus_scale_update_request(5);
+	mdp_clk_ctrl(1);
 
 #ifdef MDP4_ERROR
 	mdp4_sw_reset(0x17);
@@ -265,11 +409,8 @@
 	mdp4_vg_qseed_init(0);
 	mdp4_vg_qseed_init(1);
 
-	mdp4_vg_csc_setup(0);
-	mdp4_vg_csc_setup(1);
-	mdp4_mixer_csc_setup(1);
-	mdp4_mixer_csc_setup(2);
-	mdp4_dmap_csc_setup();
+	for (i = 0; i < CSC_MAX_BLOCKS; i++)
+		mdp4_csc_config(&csc_cfg_matrix[i]);
 
 	if (mdp_rev <= MDP_REV_41) {
 		mdp4_mixer_gc_lut_setup(0);
@@ -296,6 +437,8 @@
 
 	
 	outpdw(MDP_BASE + 0x004c, 0x02222);	
+	outpdw(MDP_BASE + 0x0400, 0x7FF);
+	outpdw(MDP_BASE + 0x0404, 0x30050);
 
 #ifndef CONFIG_FB_MSM_OVERLAY
 	
@@ -306,13 +449,17 @@
 	clk_rate = mdp_get_core_clk();
 	mdp4_fetch_cfg(clk_rate);
 
-	mdp4_overlay_cfg_init();
+	if (mdp_rev >= MDP_REV_42) {
+		
+		outpdw(MDP_BASE + 0x100fc, 0x01);
+	}
 
 	if (mdp_hw_revision > MDP4_REVISION_V2_1)
 		outpdw(MDP_BASE + 0x003c, 1);
 
 	
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 }
 
 
@@ -351,9 +498,7 @@
 	uint32 isr, mask, panel;
 	struct mdp_dma_data *dma;
 	struct mdp_hist_mgmt *mgmt = NULL;
-	char *base_addr;
 	int i, ret;
-	static unsigned long prev_jiffy = 0; 
 
 	mdp_is_in_isr = TRUE;
 
@@ -373,12 +518,7 @@
 			mgmt = mdp_hist_mgmt_array[i];
 			if (!mgmt)
 				continue;
-			base_addr = MDP_BASE + mgmt->base;
-			MDP_OUTP(base_addr + 0x010, 1);
-			outpdw(base_addr + 0x01c, INTR_HIST_DONE |
-						INTR_HIST_RESET_SEQ_DONE);
 			mgmt->mdp_is_hist_valid = FALSE;
-			__mdp_histogram_reset(mgmt);
 		}
 	}
 
@@ -387,17 +527,6 @@
 		mdp4_stat.intr_underrun_e++;
 	}
 
-	if (isr & (INTR_PRIMARY_INTF_UDERRUN|INTR_EXTERNAL_INTF_UDERRUN)) {
-		if (time_after(jiffies, prev_jiffy + 5 * HZ) || !prev_jiffy) {
-			pr_info("%s: UNDERRUN isr: 0x%x (pri: %lu, ext: %lu)\n",
-			     __func__, isr,
-			     mdp4_stat.intr_underrun_p, mdp4_stat.intr_underrun_e);
-
-			mdp4_overlay_mdp_perf_dump();
-			prev_jiffy = jiffies;
-		}
-	}
-
 	isr &= mask;
 
 	if (isr == 0)
@@ -496,14 +625,8 @@
 	if (isr & INTR_OVERLAY2_DONE) {
 		mdp4_stat.intr_overlay2++;
 		
-		dma = &dma_wb_data;
-		spin_lock(&mdp_spin_lock);
-		mdp_intr_mask &= ~INTR_OVERLAY2_DONE;
-		outp32(MDP_INTR_ENABLE, mdp_intr_mask);
-		dma->waiting = FALSE;
-		spin_unlock(&mdp_spin_lock);
 		if (panel & MDP4_PANEL_WRITEBACK)
-			mdp4_overlay1_done_writeback(dma);
+			mdp4_overlay2_done_wfd(&dma_wb_data);
 	}
 #endif
 #endif	
@@ -1250,422 +1373,54 @@
 	},
 };
 
-struct mdp_csc_cfg csc_matrix[3] = {
-	{
-		(MDP_CSC_FLAG_YUV_OUT),
-		{
-			0x0254, 0x0000, 0x0331,
-			0x0254, 0xff37, 0xfe60,
-			0x0254, 0x0409, 0x0000,
-		},
-		{
-			0xfff0, 0xff80, 0xff80,
-		},
-		{
-			0, 0, 0,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-	},
-	{
-		(MDP_CSC_FLAG_YUV_OUT),
-		{
-			0x0254, 0x0000, 0x0331,
-			0x0254, 0xff37, 0xfe60,
-			0x0254, 0x0409, 0x0000,
-		},
-		{
-			0xfff0, 0xff80, 0xff80,
-		},
-		{
-			0, 0, 0,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-	},
-	{
-		(0),
-		{
-			0x0200, 0x0000, 0x0000,
-			0x0000, 0x0200, 0x0000,
-			0x0000, 0x0000, 0x0200,
-		},
-		{
-			0x0, 0x0, 0x0,
-		},
-		{
-			0, 0, 0,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-		{
-			0, 0xff, 0, 0xff, 0, 0xff,
-		},
-	},
-};
-
-
-
-#define MDP4_CSC_MV_OFF 	0x4400
-#define MDP4_CSC_PRE_BV_OFF 	0x4500
-#define MDP4_CSC_POST_BV_OFF 	0x4580
-#define MDP4_CSC_PRE_LV_OFF 	0x4600
-#define MDP4_CSC_POST_LV_OFF 	0x4680
-
-void mdp4_vg_csc_mv_setup(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-					MDP4_CSC_MV_OFF);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 9; i++) {
-		outpdw(off, csc_matrix[vp_num].csc_mv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_vg_csc_pre_bv_setup(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-					MDP4_CSC_PRE_BV_OFF);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_matrix[vp_num].csc_pre_bv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_vg_csc_post_bv_setup(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-					MDP4_CSC_POST_BV_OFF);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_matrix[vp_num].csc_post_bv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_vg_csc_pre_lv_setup(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-					MDP4_CSC_PRE_LV_OFF);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_matrix[vp_num].csc_pre_lv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_vg_csc_post_lv_setup(int vp_num)
+void mdp4_vg_csc_restore(void)
 {
-	uint32 *off;
-	int i, voff;
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-					MDP4_CSC_POST_LV_OFF);
+        int i;
 
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_matrix[vp_num].csc_post_lv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+        for (i = 0; i < CSC_MAX_BLOCKS; i++)
+                mdp4_csc_config(&csc_cfg_matrix[i]);
 }
 
-void mdp4_vg_csc_convert_setup(int vp_num)
-{
-	struct mdp_csc_cfg_data cfg;
-
-	switch (vp_num) {
-	case 0:
-		cfg.block = MDP_BLOCK_VG_1;
-		break;
-	case 1:
-		cfg.block = MDP_BLOCK_VG_2;
-		break;
-	default:
-		pr_err("%s - invalid vp_num = %d", __func__, vp_num);
-		return;
-	}
-	cfg.csc_data = csc_matrix[vp_num];
-	mdp4_csc_enable(&cfg);
-}
 
-void mdp4_vg_csc_setup(int vp_num)
-{
-		
-		mdp4_vg_csc_mv_setup(vp_num);
-		mdp4_vg_csc_pre_bv_setup(vp_num);
-		mdp4_vg_csc_post_bv_setup(vp_num);
-		mdp4_vg_csc_pre_lv_setup(vp_num);
-		mdp4_vg_csc_post_lv_setup(vp_num);
-		mdp4_vg_csc_convert_setup(vp_num);
-}
 void mdp4_vg_csc_update(struct mdp_csc *p)
 {
 	struct mdp4_overlay_pipe *pipe;
-	int vp_num;
+	uint32_t block = 0;
+	int i = 0;
 
 	pipe = mdp4_overlay_ndx2pipe(p->id);
 	if (pipe == NULL) {
 		pr_err("%s: p->id = %d Error\n", __func__, p->id);
 		return;
 	}
-
-	vp_num = pipe->pipe_num - OVERLAY_PIPE_VG1;
-
-	if (vp_num == 0 || vp_num == 1) {
-		memcpy(csc_matrix[vp_num].csc_mv, p->csc_mv, sizeof(p->csc_mv));
-		memcpy(csc_matrix[vp_num].csc_pre_bv, p->csc_pre_bv,
-			sizeof(p->csc_pre_bv));
-		memcpy(csc_matrix[vp_num].csc_post_bv, p->csc_post_bv,
-			sizeof(p->csc_post_bv));
-		memcpy(csc_matrix[vp_num].csc_pre_lv, p->csc_pre_lv,
-			sizeof(p->csc_pre_lv));
-		memcpy(csc_matrix[vp_num].csc_post_lv, p->csc_post_lv,
-			sizeof(p->csc_post_lv));
-		mdp4_vg_csc_setup(vp_num);
-	}
-}
-static uint32 csc_rgb2yuv_matrix_tab[9] = {
-	0x0083, 0x0102, 0x0032,
-	0x1fb5, 0x1f6c, 0x00e1,
-	0x00e1, 0x1f45, 0x1fdc
-};
-
-static uint32 csc_rgb2yuv_pre_bv_tab[3] = {0, 0, 0};
-
-static uint32 csc_rgb2yuv_post_bv_tab[3] = {0x0010, 0x0080, 0x0080};
-
-static  uint32 csc_rgb2yuv_pre_lv_tab[6] = {
-	0x00, 0xff, 0x00,
-	0xff, 0x00, 0xff
-};
-
-static  uint32 csc_rgb2yuv_post_lv_tab[6] = {
-	0x0010, 0x00eb, 0x0010,
-	0x00f0, 0x0010, 0x00f0
-};
-
-void mdp4_mixer_csc_mv_setup(uint32 mixer)
-{
-	uint32 *off;
-	int i;
-
-	if (mixer == MDP4_MIXER1)
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x2400);
-	else
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC2_BASE + 0x2400);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 9; i++) {
-		outpdw(off, csc_rgb2yuv_matrix_tab[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_mixer_csc_pre_bv_setup(uint32 mixer)
-{
-	uint32 *off;
-	int i;
-
-	if (mixer == MDP4_MIXER1)
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x2500);
-	else
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC2_BASE + 0x2500);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_rgb2yuv_pre_bv_tab[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_mixer_csc_post_bv_setup(uint32 mixer)
-{
-	uint32 *off;
-	int i;
-
-	if (mixer == MDP4_MIXER1)
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x2580);
-	else
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC2_BASE + 0x2580);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_rgb2yuv_post_bv_tab[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_mixer_csc_pre_lv_setup(uint32 mixer)
-{
-	uint32 *off;
-	int i;
-
-	if (mixer == MDP4_MIXER1)
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x2600);
-	else
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC2_BASE + 0x2600);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_rgb2yuv_pre_lv_tab[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_mixer_csc_post_lv_setup(uint32 mixer)
-{
-	uint32 *off;
-	int i;
-
-	if (mixer == MDP4_MIXER1)
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x2680);
+	if (pipe->pipe_num == OVERLAY_PIPE_VG1)
+		block = MDP_BLOCK_VG_1;
+	else if (pipe->pipe_num == OVERLAY_PIPE_VG2)
+		block = MDP_BLOCK_VG_2;
 	else
-		off = (uint32 *)(MDP_BASE + MDP4_OVERLAYPROC2_BASE + 0x2680);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_rgb2yuv_post_lv_tab[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_mixer_csc_setup(uint32 mixer)
-{
-	if (mixer >= MDP4_MIXER1) {
-		
-		mdp4_mixer_csc_mv_setup(mixer);
-		mdp4_mixer_csc_pre_bv_setup(mixer);
-		mdp4_mixer_csc_post_bv_setup(mixer);
-		mdp4_mixer_csc_pre_lv_setup(mixer);
-		mdp4_mixer_csc_post_lv_setup(mixer);
-	}
-}
-
-#define DMA_P_BASE 0x90000
-void mdp4_dmap_csc_mv_setup(void)
-{
-	uint32 *off;
-	int i;
-
-	off = (uint32 *)(MDP_BASE + DMA_P_BASE + 0x3400);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 9; i++) {
-		outpdw(off, csc_matrix[2].csc_mv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_dmap_csc_pre_bv_setup(void)
-{
-	uint32 *off;
-	int i;
-
-	off = (uint32 *)(MDP_BASE + DMA_P_BASE + 0x3500);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_matrix[2].csc_pre_bv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_dmap_csc_post_bv_setup(void)
-{
-	uint32 *off;
-	int i;
-
-	off = (uint32 *)(MDP_BASE + DMA_P_BASE + 0x3580);
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 3; i++) {
-		outpdw(off, csc_matrix[2].csc_post_bv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_dmap_csc_pre_lv_setup(void)
-{
-	uint32 *off;
-	int i;
-
-	off = (uint32 *)(MDP_BASE + DMA_P_BASE + 0x3600);
+		return;
 
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_matrix[2].csc_pre_lv[i]);
-		off++;
+	for (i = 0; i < CSC_MAX_BLOCKS; i++) {
+		if (csc_cfg_matrix[i].block == block)
+			break;
 	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-void mdp4_dmap_csc_post_lv_setup(void)
-{
-	uint32 *off;
-	int i;
+	if (i == CSC_MAX_BLOCKS)
+		return;
 
-	off = (uint32 *)(MDP_BASE + DMA_P_BASE + 0x3680);
+	memcpy(&csc_cfg_matrix[i].csc_data.csc_mv, p->csc_mv,
+			sizeof(p->csc_mv));
+	memcpy(&csc_cfg_matrix[i].csc_data.csc_pre_bv, p->csc_pre_bv,
+		sizeof(p->csc_pre_bv));
+	memcpy(&csc_cfg_matrix[i].csc_data.csc_post_bv, p->csc_post_bv,
+		sizeof(p->csc_post_bv));
+	memcpy(&csc_cfg_matrix[i].csc_data.csc_pre_lv, p->csc_pre_lv,
+		sizeof(p->csc_pre_lv));
+	memcpy(&csc_cfg_matrix[i].csc_data.csc_post_lv, p->csc_post_lv,
+		sizeof(p->csc_post_lv));
+	csc_cfg_matrix[i].csc_data.flags = MDP_CSC_FLAG_YUV_OUT;
 
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < 6; i++) {
-		outpdw(off, csc_matrix[2].csc_post_lv[i]);
-		off++;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
+	mdp4_csc_config(&csc_cfg_matrix[i]);
 
-void mdp4_dmap_csc_setup(void)
-{
-	mdp4_dmap_csc_mv_setup();
-	mdp4_dmap_csc_pre_bv_setup();
-	mdp4_dmap_csc_post_bv_setup();
-	mdp4_dmap_csc_pre_lv_setup();
-	mdp4_dmap_csc_post_lv_setup();
 }
 
 char gc_lut[] = {
@@ -2373,7 +2128,7 @@
 		base = 0x1A000;
 		break;
 	case MDP_BLOCK_OVERLAY_2:
-		base = (mdp_rev >= MDP_REV_44) ? 0x8A000 : 0x0;
+		base = (mdp_rev >= MDP_REV_43) ? 0x8A000 : 0x0;
 		break;
 	case MDP_BLOCK_VG_1:
 		base = 0x24000;
@@ -2641,23 +2396,6 @@
 	buf->read_addr = 0;
 }
 
-void mdp4_set_limit_range(bool set_limit_range)
-{
-	uint32 normal_range =0xFF0000;
-	uint32 limit_range = 0xEB0010;
-
-	printk("%s set_limit_range %d\n", __func__, (set_limit_range)? 1 :0);
-	if(set_limit_range) {
-		outpdw(MDP_BASE + 0xB0070, limit_range);
-		outpdw(MDP_BASE + 0xB0074, limit_range);
-		outpdw(MDP_BASE + 0xB0078, limit_range);
-	} else {
-		outpdw(MDP_BASE + 0xB0070, normal_range);
-		outpdw(MDP_BASE + 0xB0074, normal_range);
-		outpdw(MDP_BASE + 0xB0078, normal_range);
-	}
-}
-
 static int mdp4_update_pcc_regs(uint32_t offset,
 				struct mdp_pcc_cfg_data *cfg_ptr)
 {
@@ -2862,7 +2600,7 @@
 		break;
 
 	default:
-		return ret;
+		break;
 	}
 
 	if (0x8 & cfg_ptr->ops)
@@ -2910,7 +2648,7 @@
 		break;
 
 	case MDP_BLOCK_OVERLAY_2:
-		valid = (mdp_rev >= MDP_REV_44) ? 1 : 0;
+		valid = (mdp_rev >= MDP_REV_43) ? 1 : 0;
 		break;
 
 	default:
@@ -2992,9 +2730,9 @@
 		struct mdp_pgc_lut_data *pgc_ptr)
 {
 	int ret = -1;
-	static struct mdp_ar_gc_lut_data r[MDP_AR_GC_MAX_STAGES];
-	static struct mdp_ar_gc_lut_data g[MDP_AR_GC_MAX_STAGES];
-	static struct mdp_ar_gc_lut_data b[MDP_AR_GC_MAX_STAGES];
+	struct mdp_ar_gc_lut_data r[MDP_AR_GC_MAX_STAGES];
+	struct mdp_ar_gc_lut_data g[MDP_AR_GC_MAX_STAGES];
+	struct mdp_ar_gc_lut_data b[MDP_AR_GC_MAX_STAGES];
 
 	ret = copy_from_user(&r[0], pgc_ptr->r_data,
 		pgc_ptr->num_r_stages * sizeof(struct mdp_ar_gc_lut_data));
@@ -3247,72 +2985,192 @@
 	return valid;
 }
 
-static int mdp4_qseed_write_cfg(struct mdp_qseed_cfg_data *cfg)
+int mdp4_qseed_access_cfg(struct mdp_qseed_cfg *config, uint32_t base)
 {
 	int i, ret = 0;
-	uint32_t base = (uint32_t) (MDP_BASE + mdp_block2base(cfg->block));
 	uint32_t *values;
 
-	if ((cfg->table_num != 1) && (cfg->table_num != 2)) {
+	if ((config->table_num != 1) && (config->table_num != 2)) {
 		ret = -ENOTTY;
 		goto error;
 	}
 
-	if (((cfg->table_num == 1) && (cfg->len != QSEED_TABLE_1_COUNT)) ||
-		((cfg->table_num == 2) && (cfg->len != QSEED_TABLE_2_COUNT))) {
+	if (((config->table_num == 1) && (config->len != QSEED_TABLE_1_COUNT))
+			|| ((config->table_num == 2) &&
+				(config->len != QSEED_TABLE_2_COUNT))) {
 		ret = -EINVAL;
 		goto error;
 	}
 
-	values = kmalloc(cfg->len * sizeof(uint32_t), GFP_KERNEL);
+	values = kmalloc(config->len * sizeof(uint32_t), GFP_KERNEL);
 	if (!values) {
 		ret = -ENOMEM;
 		goto error;
 	}
 
-	ret = copy_from_user(values, cfg->data, sizeof(uint32_t) * cfg->len);
+	base += (config->table_num == 1) ? MDP4_QSEED_TABLE1_OFF :
+							MDP4_QSEED_TABLE2_OFF;
 
-	base += (cfg->table_num == 1) ? MDP4_QSEED_TABLE1_OFF :
-						MDP4_QSEED_TABLE2_OFF;
-	for (i = 0; i < cfg->len; i++) {
-		MDP_OUTP(base , values[i]);
-		base += sizeof(uint32_t);
+	if (config->ops & MDP_PP_OPS_WRITE) {
+		ret = copy_from_user(values, config->data,
+						sizeof(uint32_t) * config->len);
+		if (ret) {
+			pr_warn("%s: Error copying from user, %d", __func__,
+									ret);
+			ret = -EINVAL;
+			goto err_mem;
+		}
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		for (i = 0; i < config->len; i++) {
+			if (!(base & 0x3FF))
+				wmb();
+			MDP_OUTP(base , values[i]);
+			base += sizeof(uint32_t);
+		}
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	} else if (config->ops & MDP_PP_OPS_READ) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		for (i = 0; i < config->len; i++) {
+			values[i] = inpdw(base);
+			if (!(base & 0x3FF))
+				rmb();
+			base += sizeof(uint32_t);
+		}
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+		ret = copy_to_user(config->data, values,
+						sizeof(uint32_t) * config->len);
+		if (ret) {
+			pr_warn("%s: Error copying to user, %d", __func__, ret);
+			ret = -EINVAL;
+			goto err_mem;
+		}
 	}
 
+err_mem:
 	kfree(values);
 error:
 	return ret;
 }
 
-int mdp4_qseed_cfg(struct mdp_qseed_cfg_data *cfg)
+int mdp4_qseed_cfg(struct mdp_qseed_cfg_data *config)
 {
 	int ret = 0;
+	struct mdp_qseed_cfg *cfg = &config->qseed_data;
+	uint32_t base;
 
-	if (!mdp4_pp_block2qseed(cfg->block)) {
+	if (!mdp4_pp_block2qseed(config->block)) {
 		ret = -ENOTTY;
 		goto error;
 	}
 
-	if (cfg->table_num != 1) {
-		ret = -ENOTTY;
-		pr_info("%s: Only QSEED table1 supported.\n", __func__);
+	if ((cfg->ops & MDP_PP_OPS_READ) && (cfg->ops & MDP_PP_OPS_WRITE)) {
+		ret = -EPERM;
+		pr_warn("%s: Cannot read and write on the same request\n",
+								__func__);
 		goto error;
 	}
+	base = (uint32_t) (MDP_BASE + mdp_block2base(config->block));
+	ret = mdp4_qseed_access_cfg(cfg, base);
 
-	switch ((cfg->ops & 0x6) >> 1) {
-	case 0x1:
-		pr_info("%s: QSEED read not supported\n", __func__);
-		ret = -ENOTTY;
-		break;
-	case 0x2:
-		ret = mdp4_qseed_write_cfg(cfg);
-		if (ret)
-			goto error;
-		break;
-	default:
-		break;
+error:
+	return ret;
+}
+
+static int is_valid_calib_addr(void *addr)
+{
+	int ret = 0;
+	unsigned int ptr;
+
+	ptr = (unsigned int) addr;
+
+	if (mdp_rev >= MDP_REV_30 && mdp_rev < MDP_REV_40) {
+		
+		if (ptr == 0x0 || ptr > 0xF0600 || ptr % 0x4)
+			goto end;
+
+		if (ptr >= 0x90000 && ptr < 0x94000) {
+			if (ptr == 0x90000 || ptr == 0x90070)
+				ret = 1;
+			else if (ptr >= 0x93400 && ptr <= 0x93420)
+				ret = 1;
+			else if (ptr >= 0x93500 && ptr <= 0x93508)
+				ret = 1;
+			else if (ptr >= 0x93580 && ptr <= 0x93588)
+				ret = 1;
+			else if (ptr >= 0x93600 && ptr <= 0x93614)
+				ret = 1;
+			else if (ptr >= 0x93680 && ptr <= 0x93694)
+				ret = 1;
+			else if (ptr >= 0x93800 && ptr <= 0x93BFC)
+				ret = 1;
+		}
+	} else if (mdp_rev >= MDP_REV_40 && mdp_rev <= MDP_REV_44) {
+		
+		if (ptr > 0xF0600 || ptr % 0x4)
+			goto end;
+
+		if (ptr < 0x90000) {
+			if (ptr == 0x0 || ptr == 0x4 || ptr == 0x28200 ||
+								ptr == 0x28204)
+				ret = 1;
+		} else if (ptr < 0x95000) {
+			if (ptr == 0x90000 || ptr == 0x90070)
+				ret = 1;
+			else if (ptr >= 0x93400 && ptr <= 0x93420)
+				ret = 1;
+			else if (ptr >= 0x93500 && ptr <= 0x93508)
+				ret = 1;
+			else if (ptr >= 0x93580 && ptr <= 0x93588)
+				ret = 1;
+			else if (ptr >= 0x93600 && ptr <= 0x93614)
+				ret = 1;
+			else if (ptr >= 0x93680 && ptr <= 0x93694)
+				ret = 1;
+			else if (ptr >= 0x94800 && ptr <= 0x94BFC)
+				ret = 1;
+		} else if (ptr < 0x9A000) {
+			if (ptr >= 0x98800 && ptr <= 0x9883C)
+				ret = 1;
+			else if (ptr >= 0x98880 && ptr <= 0x988AC)
+				ret = 1;
+			else if (ptr >= 0x98900 && ptr <= 0x9893C)
+				ret = 1;
+			else if (ptr >= 0x98980 && ptr <= 0x989BC)
+				ret = 1;
+			else if (ptr >= 0x98A00 && ptr <= 0x98A3C)
+				ret = 1;
+			else if (ptr >= 0x98A80 && ptr <= 0x98ABC)
+				ret = 1;
+			else if (ptr >= 0x99000 && ptr <= 0x993FC)
+				ret = 1;
+			else if (ptr >= 0x99800 && ptr <= 0x99BFC)
+				ret = 1;
+		} else if (ptr >= 0x9A000 && ptr <= 0x9a08c) {
+			ret = 1;
+		}
 	}
+end:
+	return ret;
+}
 
-error:
+int mdp4_calib_config(struct mdp_calib_config_data *cfg)
+{
+	int ret = -1;
+	void *ptr = (void *) cfg->addr;
+
+	if (is_valid_calib_addr(ptr))
+		ret = 0;
+	else
+		return ret;
+
+	ptr = (void *)(((unsigned int) ptr) + MDP_BASE);
+	mdp_clk_ctrl(1);
+	if (cfg->ops & MDP_PP_OPS_READ) {
+		cfg->data = inpdw(ptr);
+		ret = 1;
+	} else if (cfg->ops & MDP_PP_OPS_WRITE) {
+		outpdw(ptr, cfg->data);
+	}
+	mdp_clk_ctrl(0);
 	return ret;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -69,6 +69,13 @@
 
 	platform_set_drvdata(mdp_dev, mfd);
 
+	mfd->writeback_sdev.name = "wfd";
+	rc = switch_dev_register(&mfd->writeback_sdev);
+	if (rc) {
+		pr_err("Failed to setup switch dev for writeback panel");
+		return rc;
+	}
+
 	rc = platform_device_add(mdp_dev);
 	if (rc) {
 		WRITEBACK_MSG_ERR("failed to add device");
@@ -78,8 +85,16 @@
 	return rc;
 }
 
+static int writeback_remove(struct platform_device *pdev)
+{
+	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
+	switch_dev_unregister(&mfd->writeback_sdev);
+	return 0;
+}
+
 static struct platform_driver writeback_driver = {
 	.probe = writeback_probe,
+	.remove = writeback_remove,
 	.driver = {
 		.name = "writeback",
 	},
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback_panel.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback_panel.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback_panel.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback_panel.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,6 +45,7 @@
 		.fb_num = 1,
 		
 		.clk_rate = 177780000,
+		
 	},
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback_util.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback_util.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp4_wfd_writeback_util.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp4_wfd_writeback_util.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp.c	2013-08-01 23:38:01.000000000 -0600
@@ -2,7 +2,7 @@
  *
  * MSM MDP Interface (used by framebuffer core)
  *
- * Copyright (c) 2007-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2007-2013, The Linux Foundation. All rights reserved.
  * Copyright (C) 2007 Google Incorporated
  *
  * This software is licensed under the terms of the GNU General Public
@@ -25,7 +25,6 @@
 #include <linux/hrtimer.h>
 #include <linux/clk.h>
 #include <mach/hardware.h>
-#include <mach/debug_display.h>
 #include <linux/io.h>
 #include <linux/debugfs.h>
 #include <linux/delay.h>
@@ -36,6 +35,7 @@
 #include <asm/mach-types.h>
 #include <linux/semaphore.h>
 #include <linux/uaccess.h>
+#include <mach/event_timer.h>
 #include <mach/clk.h>
 #include "mdp.h"
 #include "msm_fb.h"
@@ -49,14 +49,26 @@
 static struct clk *mdp_clk;
 static struct clk *mdp_pclk;
 static struct clk *mdp_lut_clk;
+
+struct res_mmu_clk {
+	char *mmu_clk_name;
+	struct clk *mmu_clk;
+};
+
+static struct res_mmu_clk mdp_sec_mmu_clks[] = {
+	{"mdp_iommu_clk"}, {"rot_iommu_clk"},
+	{"vcodec_iommu0_clk"}, {"vcodec_iommu1_clk"},
+	{"smmu_iface_clk"}
+};
+
 int mdp_rev;
 int mdp_iommu_split_domain;
-u32 mdp_max_clk = 200000000;
-u32 mdp_min_clk = 0;
-u32 mdp_ov0_blt_ctl = MDP4_BLT_SWITCH_TG_OFF;
-
+u32 mdp_max_clk = 266667000;
+u64 mdp_max_bw = 2000000000;
+u32 mdp_bw_ab_factor = MDP4_BW_AB_DEFAULT_FACTOR;
+u32 mdp_bw_ib_factor = MDP4_BW_IB_DEFAULT_FACTOR;
 static struct platform_device *mdp_init_pdev;
-static struct regulator *footswitch, *hdmi_pll_fs;
+static struct regulator *footswitch, *dsi_pll_vdda, *dsi_pll_vddio;
 static unsigned int mdp_footswitch_on;
 
 struct completion mdp_ppp_comp;
@@ -72,6 +84,8 @@
 boolean mdp_current_clk_on = FALSE;
 boolean mdp_is_in_isr = FALSE;
 
+struct vsync vsync_cntrl;
+
 uint32 mdp_in_processing = FALSE;
 
 #ifdef CONFIG_FB_MSM_MDP40
@@ -95,13 +109,13 @@
 static struct delayed_work mdp_pipe_ctrl_worker;
 
 boolean mdp_suspended = FALSE;
+ulong mdp4_display_intf;
 DEFINE_MUTEX(mdp_suspend_mutex);
 
 #ifdef CONFIG_FB_MSM_MDP40
 struct mdp_dma_data dma2_data;
 struct mdp_dma_data dma_s_data;
 struct mdp_dma_data dma_e_data;
-ulong mdp4_display_intf;
 #else
 static struct mdp_dma_data dma2_data;
 static struct mdp_dma_data dma_s_data;
@@ -141,9 +155,6 @@
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static struct early_suspend early_suspend;
-#ifdef CONFIG_HTC_ONMODE_CHARGING
-static struct early_suspend onchg_suspend;
-#endif
 #endif
 
 static u32 mdp_irq;
@@ -183,13 +194,51 @@
 		base = 0x18000;
 		break;
 	case MDP_BLOCK_OVERLAY_2:
-		base = (mdp_rev >= MDP_REV_44) ? 0x88000 : 0;
+		base = (mdp_rev >= MDP_REV_43) ? 0x88000 : 0;
 		break;
 	default:
 		break;
 	}
 	return base;
 }
+int mdp_enable_iommu_clocks(void)
+{
+	int ret = 0, i;
+	for (i = 0; i < ARRAY_SIZE(mdp_sec_mmu_clks); i++) {
+		mdp_sec_mmu_clks[i].mmu_clk = clk_get(&mdp_init_pdev->dev,
+			mdp_sec_mmu_clks[i].mmu_clk_name);
+		if (IS_ERR(mdp_sec_mmu_clks[i].mmu_clk)) {
+			pr_err(" %s: Get failed for clk %s", __func__,
+				   mdp_sec_mmu_clks[i].mmu_clk_name);
+			ret = PTR_ERR(mdp_sec_mmu_clks[i].mmu_clk);
+			break;
+		}
+		ret = clk_prepare_enable(mdp_sec_mmu_clks[i].mmu_clk);
+		if (ret) {
+			clk_put(mdp_sec_mmu_clks[i].mmu_clk);
+			mdp_sec_mmu_clks[i].mmu_clk = NULL;
+		}
+	}
+	if (ret) {
+		for (i--; i >= 0; i--) {
+			clk_disable_unprepare(mdp_sec_mmu_clks[i].mmu_clk);
+			clk_put(mdp_sec_mmu_clks[i].mmu_clk);
+			mdp_sec_mmu_clks[i].mmu_clk = NULL;
+		}
+	}
+	return ret;
+}
+
+int mdp_disable_iommu_clocks(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(mdp_sec_mmu_clks); i++) {
+		clk_disable_unprepare(mdp_sec_mmu_clks[i].mmu_clk);
+		clk_put(mdp_sec_mmu_clks[i].mmu_clk);
+		mdp_sec_mmu_clks[i].mmu_clk = NULL;
+	}
+	return 0;
+}
 
 static uint32_t mdp_pp_block2hist_lut(uint32_t block)
 {
@@ -325,11 +374,13 @@
 		pr_err("%s: Error copying histogram data", __func__);
 		return -ENOMEM;
 	}
+	mdp_clk_ctrl(1);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	for (i = 0; i < MDP_HIST_LUT_SIZE; i++)
 		MDP_OUTP(MDP_BASE + base + offset + (0x400*(sel)) + (4*i),
 				element[i]);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 
 	return 0;
 }
@@ -479,8 +530,9 @@
 	return ret;
 }
 
-DEFINE_MUTEX(mdp_lut_push_sem);
+spinlock_t mdp_lut_push_lock;
 static int mdp_lut_i;
+
 static int mdp_lut_hw_update(struct fb_cmap *cmap)
 {
 	int i;
@@ -516,19 +568,21 @@
 static int mdp_lut_update_nonlcdc(struct fb_info *info, struct fb_cmap *cmap)
 {
 	int ret;
+	unsigned long flags;
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
 	ret = mdp_lut_hw_update(cmap);
+	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	if (ret)
 		return ret;
 
-	mutex_lock(&mdp_lut_push_sem);
+	spin_lock_irqsave(&mdp_lut_push_lock, flags);
 	mdp_lut_push = 1;
 	mdp_lut_push_i = mdp_lut_i;
-	mutex_unlock(&mdp_lut_push_sem);
-
+	spin_unlock_irqrestore(&mdp_lut_push_lock, flags);
 	mdp_lut_i = (mdp_lut_i + 1)%2;
 
 	return 0;
@@ -540,32 +594,74 @@
 	uint32_t out;
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
 	ret = mdp_lut_hw_update(cmap);
 
 	if (ret) {
+		mdp_clk_ctrl(0);
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 		return ret;
 	}
 
 	
+	out = inpdw(MDP_BASE + 0x90070);
+	MDP_OUTP(MDP_BASE + 0x90070, (mdp_lut_i << 10) | 0x7 | out);
+	mdp_clk_ctrl(0);
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_lut_i = (mdp_lut_i + 1)%2;
+
+	return 0;
+}
+
+#ifdef CONFIG_UPDATE_LCDC_LUT
+int mdp_preset_lut_update_lcdc(struct fb_cmap *cmap, uint32_t *internal_lut)
+{
+	uint32_t out;
+	int i;
+	u16 r, g, b;
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
+
+	for (i = 0; i < cmap->len; i++) {
+		r = lut2r(internal_lut[i]);
+		g = lut2g(internal_lut[i]);
+		b = lut2b(internal_lut[i]);
+#ifdef CONFIG_LCD_KCAL
+		r = scaled_by_kcal(r, *(cmap->red));
+		g = scaled_by_kcal(g, *(cmap->green));
+		b = scaled_by_kcal(b, *(cmap->blue));
+#endif
+		MDP_OUTP(MDP_BASE + 0x94800 +
+			(0x400*mdp_lut_i) + cmap->start*4 + i*4,
+				((g & 0xff) |
+				 ((b & 0xff) << 8) |
+				 ((r & 0xff) << 16)));
+	}
+
+	
 	out = inpdw(MDP_BASE + 0x90070) & ~((0x1 << 10) | 0x7);
 	MDP_OUTP(MDP_BASE + 0x90070, (mdp_lut_i << 10) | 0x7 | out);
+	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 	mdp_lut_i = (mdp_lut_i + 1)%2;
 
 	return 0;
 }
+#endif
 
 static void mdp_lut_enable(void)
 {
 	uint32_t out;
+	unsigned long flags;
+
 	if (mdp_lut_push) {
-		mutex_lock(&mdp_lut_push_sem);
+		spin_lock_irqsave(&mdp_lut_push_lock, flags);
 		mdp_lut_push = 0;
 		out = inpdw(MDP_BASE + 0x90070) & ~((0x1 << 10) | 0x7);
 		MDP_OUTP(MDP_BASE + 0x90070,
 				(mdp_lut_push_i << 10) | 0x7 | out);
-		mutex_unlock(&mdp_lut_push_sem);
+		spin_unlock_irqrestore(&mdp_lut_push_lock, flags);
 	}
 }
 
@@ -623,7 +719,7 @@
 	case MDP_BLOCK_DMA_P:
 		term = MDP_HISTOGRAM_TERM_DMA_P;
 		intr = (mdp_rev >= MDP_REV_40) ? INTR_DMA_P_HISTOGRAM :
-			MDP_HIST_DONE;
+								MDP_HIST_DONE;
 		bins = (mdp_rev >= MDP_REV_42) ? MDP_REV42_HIST_MAX_BIN :
 			MDP_REV41_HIST_MAX_BIN;
 		extra = 2;
@@ -657,7 +753,7 @@
 	default:
 		term = MDP_HISTOGRAM_TERM_DMA_P;
 		intr = (mdp_rev >= MDP_REV_40) ? INTR_DMA_P_HISTOGRAM :
-			MDP_HIST_DONE;
+								MDP_HIST_DONE;
 		bins = (mdp_rev >= MDP_REV_42) ? MDP_REV42_HIST_MAX_BIN :
 			MDP_REV41_HIST_MAX_BIN;
 		extra = 2;
@@ -816,6 +912,7 @@
 		return -EINVAL;
 	}
 
+	mdp_clk_ctrl(1);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	base = (uint32_t) (MDP_BASE + mgmt->base);
 	
@@ -838,7 +935,6 @@
 	
 	INIT_COMPLETION(mgmt->mdp_hist_comp);
 
-
 	spin_lock_irqsave(&mdp_spin_lock, flag);
 	MDP_OUTP(base + 0x0018, INTR_HIST_DONE | INTR_HIST_RESET_SEQ_DONE);
 	MDP_OUTP(base + 0x0010, 1);
@@ -858,6 +954,7 @@
 	mgmt->mdp_is_hist_init = FALSE;
 	__mdp_histogram_reset(mgmt);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 	return 0;
 }
 
@@ -876,27 +973,30 @@
 
 	base = (uint32_t) (MDP_BASE + mgmt->base);
 
+	mdp_clk_ctrl(1);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	spin_lock_irqsave(&mdp_spin_lock, flag);
 	outp32(MDP_INTR_CLEAR, mgmt->intr);
 	mdp_intr_mask &= ~mgmt->intr;
 	outp32(MDP_INTR_ENABLE, mdp_intr_mask);
-	mdp_disable_irq(mgmt->irq_term);
+	mdp_disable_irq_nosync(mgmt->irq_term);
 	spin_unlock_irqrestore(&mdp_spin_lock, flag);
 
 	if (mdp_rev >= MDP_REV_42)
-		MDP_OUTP(base + 0x0024, 1);
+		MDP_OUTP(base + 0x0020, 1);
 	status = inpdw(base + 0x001C);
 	status &= ~(INTR_HIST_DONE | INTR_HIST_RESET_SEQ_DONE);
 	MDP_OUTP(base + 0x001C, status);
 
 	MDP_OUTP(base + 0x0018, INTR_HIST_DONE | INTR_HIST_RESET_SEQ_DONE);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 
 	if (mgmt->hist != NULL) {
 		mgmt->hist = NULL;
 		complete(&mgmt->mdp_hist_comp);
 	}
+
 	return 0;
 }
 
@@ -905,14 +1005,10 @@
 	int ret = 0;
 
 	mutex_lock(&mgmt->mdp_hist_mutex);
-	if (mgmt->mdp_is_hist_start == TRUE) {
-		if (en)
-			ret = mdp_histogram_enable(mgmt);
-		else
-			ret = mdp_histogram_disable(mgmt);
-	} else {
-		pr_debug("%s start = false\n", __func__);
-	}
+	if (mgmt->mdp_is_hist_start && !mgmt->mdp_is_hist_data && en)
+		ret = mdp_histogram_enable(mgmt);
+	else if (mgmt->mdp_is_hist_data && !en)
+		ret = mdp_histogram_disable(mgmt);
 	mutex_unlock(&mgmt->mdp_hist_mutex);
 
 	if (en == false)
@@ -1010,7 +1106,6 @@
 	mgmt->mdp_is_hist_start = FALSE;
 
 	if (!mfd->panel_power_on) {
-		mgmt->mdp_is_hist_data = FALSE;
 		if (mgmt->hist != NULL) {
 			mgmt->hist = NULL;
 			complete(&mgmt->mdp_hist_comp);
@@ -1066,6 +1161,7 @@
 	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
 	for (i = 0; i < mgmt->num_bins; i++) {
 		mgmt->c0[i] = inpdw(mdp_hist_base + r_data_offset + (4*i));
 		mgmt->c1[i] = inpdw(mdp_hist_base + g_data_offset + (4*i));
@@ -1081,6 +1177,7 @@
 		} else
 			ret = -ENOMEM;
 	}
+	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	if (!ret)
@@ -1115,6 +1212,7 @@
 	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	mdp_clk_ctrl(1);
 	for (i = 0; i < mgmt->num_bins; i++)
 		mgmt->c0[i] = inpdw(mdp_hist_base + MDP_HIST_DATA_LUMA_OFF +
 									(4*i));
@@ -1126,6 +1224,7 @@
 		} else
 			ret = -ENOMEM;
 	}
+	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	if (!ret)
@@ -1140,7 +1239,8 @@
 {
 	struct mdp_hist_mgmt *mgmt = container_of(data, struct mdp_hist_mgmt,
 							mdp_histogram_worker);
-	int ret = 0, initial = 0;
+	int ret = 0;
+	bool hist_ready;
 	mutex_lock(&mgmt->mdp_hist_mutex);
 	if (mgmt->mdp_is_hist_data == FALSE) {
 		pr_debug("%s, Histogram disabled before read.\n", __func__);
@@ -1148,15 +1248,6 @@
 		goto error;
 	}
 
-	if (mgmt->mdp_is_hist_init == FALSE ||
-					mgmt->mdp_is_hist_valid == FALSE) {
-		pr_warn("%s, histogram not ready: init = %d, valid = %d\n",
-		__func__, mgmt->mdp_is_hist_init, mgmt->mdp_is_hist_valid);
-		ret = -EINVAL;
-		initial = 1;
-		goto error;
-	}
-
 	if (mgmt->hist == NULL) {
 		if ((mgmt->mdp_is_hist_init == TRUE) &&
 			((!completion_done(&mgmt->mdp_hist_comp)) &&
@@ -1164,8 +1255,9 @@
 			pr_err("mgmt->hist invalid NULL\n");
 		ret = -EINVAL;
 	}
+	hist_ready = (mgmt->mdp_is_hist_init && mgmt->mdp_is_hist_valid);
 
-	if (!ret) {
+	if (!ret && hist_ready) {
 		switch (mgmt->block) {
 		case MDP_BLOCK_DMA_P:
 		case MDP_BLOCK_DMA_S:
@@ -1182,7 +1274,7 @@
 			goto error;
 		}
 	}
-	if (!ret && !initial) {
+	if (!ret && hist_ready) {
 		mgmt->hist = NULL;
 		if (waitqueue_active(&mgmt->mdp_hist_comp.wait))
 			complete(&mgmt->mdp_hist_comp);
@@ -1193,12 +1285,14 @@
 	if (mgmt->mdp_is_hist_init == FALSE)
 			mgmt->mdp_is_hist_init = TRUE;
 
+	mdp_clk_ctrl(1);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	if (!ret && !initial)
+	if (!ret && hist_ready)
 		__mdp_histogram_kickoff(mgmt);
 	else
 		__mdp_histogram_reset(mgmt);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
 
 error:
 	mutex_unlock(&mgmt->mdp_hist_mutex);
@@ -1207,7 +1301,7 @@
 static int _mdp_copy_hist_data(struct mdp_histogram_data *hist,
 						struct mdp_hist_mgmt *mgmt)
 {
-	int ret = 0;
+	int ret;
 
 	if (hist->c0) {
 		ret = copy_to_user(hist->c0, mgmt->c0,
@@ -1316,6 +1410,30 @@
 }
 #endif
 
+#ifdef CONFIG_FB_MSM_MDP303
+static void vsync_isr_handler(void)
+{
+	vsync_cntrl.vsync_time = ktime_get();
+}
+#endif
+
+ssize_t mdp_dma_show_event(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	if (atomic_read(&vsync_cntrl.suspend) > 0 ||
+		atomic_read(&vsync_cntrl.vsync_resume) == 0)
+		return 0;
+
+	INIT_COMPLETION(vsync_cntrl.vsync_wait);
+
+	wait_for_completion(&vsync_cntrl.vsync_wait);
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu",
+			ktime_to_ns(vsync_cntrl.vsync_time));
+	buf[strlen(buf) + 1] = '\0';
+	return ret;
+}
 
 int mdp_ppp_pipe_wait(void)
 {
@@ -1330,22 +1448,39 @@
 	if (wait == TRUE) {
 		ret = wait_for_completion_interruptible_timeout(&mdp_ppp_comp,
 								5 * HZ);
-
 		if (!ret)
 			printk(KERN_ERR "%s: Timed out waiting for the MDP.\n",
-					__func__);
+				__func__);
 	}
 
 	return ret;
 }
 
-#define DEFAULT_FRAME_RATE (60)
+#define MAX_VSYNC_GAP		4
+#define DEFAULT_FRAME_RATE	60
 
 u32 mdp_get_panel_framerate(struct msm_fb_data_type *mfd)
 {
 	u32 frame_rate = 0, pixel_rate = 0, total_pixel;
 	struct msm_panel_info *panel_info = &mfd->panel_info;
 
+	if ((panel_info->type == MIPI_VIDEO_PANEL ||
+	     panel_info->type == MIPI_CMD_PANEL) &&
+	    panel_info->mipi.frame_rate)
+		frame_rate = panel_info->mipi.frame_rate;
+
+	if (mfd->dest == DISPLAY_LCD) {
+		if (panel_info->type == MDDI_PANEL && panel_info->mddi.is_type1)
+			frame_rate = panel_info->lcd.refx100 / (100 * 2);
+		else if (panel_info->type != MIPI_CMD_PANEL)
+			frame_rate = panel_info->lcd.refx100 / 100;
+	}
+	pr_debug("%s type=%d frame_rate=%d\n", __func__,
+		 panel_info->type, frame_rate);
+
+	if (frame_rate)
+		return frame_rate;
+
 	pixel_rate =
 		(panel_info->type == MIPI_CMD_PANEL ||
 		 panel_info->type == MIPI_VIDEO_PANEL) ?
@@ -1355,17 +1490,6 @@
 	if (!pixel_rate)
 		pr_warn("%s pixel rate is zero\n", __func__);
 
-#ifdef CONFIG_FB_MSM_RESOLUTION_OVERRIDE
-	total_pixel =
-		(panel_info->lcdc.h_back_porch +
-		  panel_info->lcdc.h_front_porch +
-		  panel_info->lcdc.h_pulse_width +
-		  mfd->ovr_src_width) *
-		(panel_info->lcdc.v_back_porch +
-		  panel_info->lcdc.v_front_porch +
-		  panel_info->lcdc.v_pulse_width +
-		  mfd->ovr_src_height);
-#else
 	total_pixel =
 		(panel_info->lcdc.h_back_porch +
 		 panel_info->lcdc.h_front_porch +
@@ -1375,39 +1499,15 @@
 		 panel_info->lcdc.v_front_porch +
 		 panel_info->lcdc.v_pulse_width +
 		 panel_info->yres);
-#endif
 
 	if (total_pixel)
 		frame_rate = pixel_rate / total_pixel;
 	else
 		pr_warn("%s total pixels are zero\n", __func__);
 
-	if (panel_info->mipi.frame_rate &&
-		(panel_info->mipi.frame_rate != frame_rate)) {
-		pr_info("[DISP] update panel framerate %u -> %u\n",
-			frame_rate, panel_info->mipi.frame_rate);
-		frame_rate = panel_info->mipi.frame_rate;
-	}
-
-	if (mfd->dest == DISPLAY_LCD) {
-		if (panel_info->type == MDDI_PANEL && panel_info->mddi.is_type1)
-			frame_rate = panel_info->lcd.refx100 / (100 * 2);
-		else if (panel_info->type != MIPI_CMD_PANEL)
-			frame_rate = panel_info->lcd.refx100 / 100;
-
-		if (panel_info->type == MIPI_CMD_PANEL && !panel_info->mipi.frame_rate) {
-			if (frame_rate != (panel_info->lcd.refx100 / 100)) {
-				pr_warn("[DISP] rework framerate %u (pixel=%d, pclk=%d) -> %u\n",
-					frame_rate, total_pixel, pixel_rate,
-					panel_info->lcd.refx100 / 100);
-				frame_rate = panel_info->lcd.refx100 / 100;
-			}
-		}
-	}
-
 	if (frame_rate == 0) {
 		frame_rate = DEFAULT_FRAME_RATE;
-		pr_warn("%s frame rate=%d is default\n", __func__, frame_rate);
+		pr_debug("%s frame rate=%d is default\n", __func__, frame_rate);
 	}
 	pr_debug("%s frame rate=%d total_pixel=%d, pixel_rate=%d\n", __func__,
 		frame_rate, total_pixel, pixel_rate);
@@ -1415,6 +1515,50 @@
 	return frame_rate;
 }
 
+static int mdp_diff_to_next_vsync(ktime_t cur_time,
+			ktime_t last_vsync, u32 vsync_period)
+{
+	int diff_from_last, diff_to_next;
+	diff_from_last =
+		(ktime_to_us(ktime_sub(cur_time, last_vsync)));
+	diff_from_last /= USEC_PER_MSEC;
+	if (diff_from_last < (vsync_period * MAX_VSYNC_GAP)) {
+		if (diff_from_last > vsync_period)
+			diff_to_next =
+				(diff_from_last - vsync_period) % vsync_period;
+		else
+			diff_to_next = vsync_period - diff_from_last;
+	} else {
+		
+		diff_to_next = vsync_period + 1;
+	}
+	return diff_to_next;
+}
+
+void mdp_update_pm(struct msm_fb_data_type *mfd, ktime_t pre_vsync)
+{
+	u32 vsync_period;
+	int diff_to_next;
+	ktime_t cur_time, wakeup_time;
+
+	if (!mfd->cpu_pm_hdl)
+		return;
+	vsync_period = mfd->panel_info.frame_interval;
+	cur_time = ktime_get();
+	diff_to_next = mdp_diff_to_next_vsync(cur_time,
+					      pre_vsync,
+					      vsync_period);
+	if (diff_to_next > vsync_period)
+		return;
+	pr_debug("%s cur_time %d, pre_vsync %d, to_next %d\n",
+		 __func__,
+		 (int)ktime_to_ms(cur_time),
+		 (int)ktime_to_ms(pre_vsync),
+		 diff_to_next);
+	wakeup_time = ktime_add_ns(cur_time, diff_to_next * NSEC_PER_MSEC);
+	activate_event_timer(mfd->cpu_pm_hdl, wakeup_time);
+}
+
 static DEFINE_SPINLOCK(mdp_lock);
 static int mdp_irq_mask;
 static int mdp_irq_enabled;
@@ -1471,6 +1615,15 @@
 	spin_unlock(&mdp_lock);
 }
 
+void mdp_pipe_kickoff_simplified(uint32 term)
+{
+	if (term == MDP_OVERLAY0_TERM) {
+		mdp_pipe_ctrl(MDP_OVERLAY0_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		mdp_lut_enable();
+		outpdw(MDP_BASE + 0x0004, 0);
+	}
+}
+
 void mdp_pipe_kickoff(uint32 term, struct msm_fb_data_type *mfd)
 {
 	unsigned long flag;
@@ -1521,6 +1674,15 @@
 		outpdw(MDP_BASE + 0x000c, 0x0);	
 #else
 		outpdw(MDP_BASE + 0x0044, 0x0);	
+
+#ifdef CONFIG_FB_MSM_MDP303
+
+#ifdef CONFIG_FB_MSM_MIPI_DSI
+		mipi_dsi_cmd_mdp_start();
+#endif
+
+#endif
+
 #endif
 #endif
 #ifdef CONFIG_FB_MSM_MDP40
@@ -1536,11 +1698,9 @@
 		outpdw(MDP_BASE + 0x0004, 0);
 	} else if (term == MDP_OVERLAY1_TERM) {
 		mdp_pipe_ctrl(MDP_OVERLAY1_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-		mdp_lut_enable();
 		outpdw(MDP_BASE + 0x0008, 0);
 	} else if (term == MDP_OVERLAY2_TERM) {
 		mdp_pipe_ctrl(MDP_OVERLAY2_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-		mdp_lut_enable();
 		outpdw(MDP_BASE + 0x00D0, 0);
 	}
 #else
@@ -1609,8 +1769,11 @@
 			mdp_clk_cnt--;
 			if (mdp_clk_cnt == 0)
 				mdp_clk_disable_unprepare();
-		}
+		} else
+			pr_err("%s: %d: mdp clk off is invalid\n",
+			       __func__, __LINE__);
 	}
+	pr_debug("%s: on=%d cnt=%d\n", __func__, on, mdp_clk_cnt);
 	mutex_unlock(&mdp_suspend_mutex);
 }
 
@@ -1771,9 +1934,8 @@
 	isr &= mask;
 	if (isr & INTR_HIST_RESET_SEQ_DONE)
 		__mdp_histogram_kickoff(mgmt);
-	else if (isr & INTR_HIST_DONE) {
+	else if (isr & INTR_HIST_DONE)
 		queue_work(mdp_hist_wq, &mgmt->mdp_histogram_worker);
-	}
 }
 
 #ifndef CONFIG_FB_MSM_MDP40
@@ -1783,8 +1945,8 @@
 	struct mdp_dma_data *dma;
 	unsigned long flag;
 	struct mdp_hist_mgmt *mgmt = NULL;
-	char *base_addr;
 	int i, ret;
+	int vsync_isr;
 	
 	mb();
 
@@ -1804,6 +1966,27 @@
 		goto out;
 
 	
+	if (mdp_interrupt & MDP_PRIM_RDPTR) {
+		spin_lock_irqsave(&mdp_spin_lock, flag);
+		vsync_isr = vsync_cntrl.vsync_irq_enabled;
+		if (!vsync_isr) {
+			mdp_intr_mask &= ~MDP_PRIM_RDPTR;
+			outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+			mdp_disable_irq_nosync(MDP_VSYNC_TERM);
+			vsync_cntrl.disabled_clocks = 1;
+		} else {
+			vsync_isr_handler();
+		}
+		spin_unlock_irqrestore(&mdp_spin_lock, flag);
+
+		if (!vsync_isr)
+			mdp_pipe_ctrl(MDP_CMD_BLOCK,
+				MDP_BLOCK_POWER_OFF, TRUE);
+
+		complete_all(&vsync_cntrl.vsync_wait);
+	}
+
+	
 	if (mdp_interrupt & TV_OUT_DMA3_START) {
 		
 		mdp_intr_mask &= ~TV_OUT_DMA3_START;
@@ -1832,13 +2015,7 @@
 				mgmt = mdp_hist_mgmt_array[i];
 				if (!mgmt)
 					continue;
-
-				base_addr = MDP_BASE + mgmt->base;
-				outpdw(base_addr + 0x010, 1);
-				outpdw(base_addr + 0x01C, INTR_HIST_DONE |
-						INTR_HIST_RESET_SEQ_DONE);
 				mgmt->mdp_is_hist_valid = FALSE;
-				__mdp_histogram_reset(mgmt);
 			}
 		}
 
@@ -1846,14 +2023,28 @@
 		if (mdp_interrupt & LCDC_FRAME_START) {
 			dma = &dma2_data;
 			spin_lock_irqsave(&mdp_spin_lock, flag);
+			vsync_isr = vsync_cntrl.vsync_irq_enabled;
 			
-			mdp_intr_mask &= ~LCDC_FRAME_START;
-			outp32(MDP_INTR_ENABLE, mdp_intr_mask);
 			if (dma->waiting) {
 				dma->waiting = FALSE;
 				complete(&dma->comp);
 			}
+
+			if (!vsync_isr) {
+				mdp_intr_mask &= ~LCDC_FRAME_START;
+				outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+				mdp_disable_irq_nosync(MDP_VSYNC_TERM);
+				vsync_cntrl.disabled_clocks = 1;
+			} else {
+				vsync_isr_handler();
+			}
 			spin_unlock_irqrestore(&mdp_spin_lock, flag);
+
+			if (!vsync_isr)
+				mdp_pipe_ctrl(MDP_CMD_BLOCK,
+					MDP_BLOCK_POWER_OFF, TRUE);
+
+			complete_all(&vsync_cntrl.vsync_wait);
 		}
 
 		
@@ -1937,6 +2128,7 @@
 
 	
 	spin_lock_init(&mdp_spin_lock);
+	spin_lock_init(&mdp_lut_push_lock);
 	mdp_dma_wq = create_singlethread_workqueue("mdp_dma_wq");
 	mdp_vsync_wq = create_singlethread_workqueue("mdp_vsync_wq");
 	mdp_pipe_ctrl_wq = create_singlethread_workqueue("mdp_pipe_ctrl_wq");
@@ -1983,7 +2175,9 @@
 	for (i = 0; i < MDP_MAX_BLOCK; i++) {
 		atomic_set(&mdp_block_power_cnt[i], 0);
 	}
-
+	vsync_cntrl.disabled_clocks = 1;
+	init_completion(&vsync_cntrl.vsync_wait);
+	atomic_set(&vsync_cntrl.vsync_resume, 1);
 #ifdef MSM_FB_ENABLE_DBGFS
 	{
 		struct dentry *root;
@@ -2058,14 +2252,27 @@
 	},
 };
 
+static int mdp_fps_level_change(struct platform_device *pdev, u32 fps_level)
+{
+	int ret = 0;
+	ret = panel_next_fps_level_change(pdev, fps_level);
+	return ret;
+}
 static int mdp_off(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
 
+	pr_debug("%s:+\n", __func__);
 	mdp_histogram_ctrl_all(FALSE);
+	atomic_set(&vsync_cntrl.suspend, 1);
+	atomic_set(&vsync_cntrl.vsync_resume, 0);
+	complete_all(&vsync_cntrl.vsync_wait);
 
 	mdp_clk_ctrl(1);
+
+	ret = panel_next_early_off(pdev);
+
 	if (mfd->panel.type == MIPI_CMD_PANEL)
 		mdp4_dsi_cmd_off(pdev);
 	else if (mfd->panel.type == MIPI_VIDEO_PANEL)
@@ -2074,62 +2281,99 @@
 			mfd->panel.type == LCDC_PANEL ||
 			mfd->panel.type == LVDS_PANEL)
 		mdp4_lcdc_off(pdev);
+#ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
+	else if (mfd->panel.type == WRITEBACK_PANEL)
+		mdp4_overlay_writeback_off(pdev);
+#endif
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	ret = panel_next_off(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-	mdp_clk_ctrl(0);
 
-	if (mdp_rev >= MDP_REV_41 && mfd->panel.type == MIPI_CMD_PANEL)
-		mdp_dsi_cmd_overlay_suspend(mfd);
+	mdp_clk_ctrl(0);
+#ifdef CONFIG_MSM_BUS_SCALING
+	mdp_bus_scale_update_request(0, 0, 0, 0);
+#endif
+	pr_debug("%s:-\n", __func__);
 	return ret;
 }
 
-static struct msm_panel_common_pdata *mdp_pdata;
+#ifdef CONFIG_FB_MSM_MDP303
+unsigned is_mdp4_hw_reset(void)
+{
+	return 0;
+}
+void mdp4_hw_init(void)
+{
+	
+}
+
+#endif
+
+static int mdp_bus_scale_restore_request(void);
 
 static int mdp_on(struct platform_device *pdev)
 {
 	int ret = 0;
-#ifdef CONFIG_FB_MSM_MDP40
 	struct msm_fb_data_type *mfd;
-
 	mfd = platform_get_drvdata(pdev);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	mdp_clk_ctrl(1);
-	mdp4_hw_init();
-	outpdw(MDP_BASE + 0x0038, mdp4_display_intf);
-	if (mfd->panel.type == MIPI_CMD_PANEL) {
-		mdp_vsync_cfg_regs(mfd, FALSE);
-		mdp4_dsi_cmd_on(pdev);
-	} else if (mfd->panel.type == MIPI_VIDEO_PANEL)
-		mdp4_dsi_video_on(pdev);
-	else if (mfd->panel.type == HDMI_PANEL ||
-			mfd->panel.type == LCDC_PANEL ||
-			mfd->panel.type == LVDS_PANEL)
-		mdp4_lcdc_on(pdev);
 
-	mdp_clk_ctrl(0);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-#endif
+	pr_debug("%s:+\n", __func__);
+
+	if (!(mfd->cont_splash_done)) {
+		if (mfd->panel.type == MIPI_VIDEO_PANEL)
+			mdp4_dsi_video_splash_done();
+
+		mdp_clk_ctrl(0);
+		mfd->cont_splash_done = 1;
+	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
 	ret = panel_next_on(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
+
+	if (mdp_rev >= MDP_REV_40) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		mdp_clk_ctrl(1);
+		mdp_bus_scale_restore_request();
+		mdp4_hw_init();
+		outpdw(MDP_BASE + 0x0038, mdp4_display_intf);
+		if (mfd->panel.type == MIPI_CMD_PANEL) {
+			mdp_vsync_cfg_regs(mfd, FALSE);
+			mdp4_dsi_cmd_on(pdev);
+		} else if (mfd->panel.type == MIPI_VIDEO_PANEL) {
+			mdp4_dsi_video_on(pdev);
+		} else if (mfd->panel.type == HDMI_PANEL ||
+				mfd->panel.type == LCDC_PANEL ||
+				mfd->panel.type == LVDS_PANEL) {
+			mdp4_lcdc_on(pdev);
+		}
+
+		mdp_clk_ctrl(0);
+		mdp4_overlay_reset();
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	}
+
+	if (mdp_rev == MDP_REV_303 && mfd->panel.type == MIPI_CMD_PANEL) {
+
+		vsync_cntrl.dev = mfd->fbi->dev;
+		atomic_set(&vsync_cntrl.suspend, 1);
+	}
+
 	mdp_histogram_ctrl_all(TRUE);
 
-	if (mdp_pdata->mdp_gamma)
-		mdp_pdata->mdp_gamma();
+	if (ret == 0)
+		ret = panel_next_late_init(pdev);
 
-#ifdef CONFIG_ARCH_MSM8X60
-	if (mfd->panel.type == MIPI_CMD_PANEL)
-		mdp4_dsi_cmd_vsync_ctrl(NULL,1);
-#endif
+	pr_debug("%s:-\n", __func__);
 
 	return ret;
 }
 
 static int mdp_resource_initialized;
+static struct msm_panel_common_pdata *mdp_pdata;
 
 uint32 mdp_hw_revision;
 
@@ -2163,20 +2407,130 @@
 }
 
 #ifdef CONFIG_MSM_BUS_SCALING
+
+#ifndef MDP_BUS_VECTOR_ENTRY_P0
+#define MDP_BUS_VECTOR_ENTRY_P0(ab_val, ib_val)		\
+	{						\
+		.src = MSM_BUS_MASTER_MDP_PORT0,	\
+		.dst = MSM_BUS_SLAVE_EBI_CH0,		\
+		.ab  = (ab_val),			\
+		.ib  = (ib_val),			\
+	}
+#endif
+#ifndef MDP_BUS_VECTOR_ENTRY_P1
+#define MDP_BUS_VECTOR_ENTRY_P1(ab_val, ib_val)		\
+	{						\
+		.src = MSM_BUS_MASTER_MDP_PORT1,	\
+		.dst = MSM_BUS_SLAVE_EBI_CH0,		\
+		.ab  = (ab_val),			\
+		.ib  = (ib_val),			\
+	}
+#endif
+
+static struct msm_bus_vectors mdp_bus_init_vectors[] = {
+	MDP_BUS_VECTOR_ENTRY_P0(0, 0),
+	MDP_BUS_VECTOR_ENTRY_P1(0, 0),
+};
+
+static struct msm_bus_vectors mdp_bus_ping_vectors[] = {
+	MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
+	MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
+};
+
+static struct msm_bus_vectors mdp_bus_pong_vectors[] = {
+	MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
+	MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
+};
+
+static struct msm_bus_paths mdp_bus_usecases[] = {
+	{
+		ARRAY_SIZE(mdp_bus_init_vectors),
+		mdp_bus_init_vectors,
+	},
+	{
+		ARRAY_SIZE(mdp_bus_ping_vectors),
+		mdp_bus_ping_vectors,
+	},
+	{
+		ARRAY_SIZE(mdp_bus_pong_vectors),
+		mdp_bus_pong_vectors,
+	},
+};
+static struct msm_bus_scale_pdata mdp_bus_scale_table = {
+	.usecase = mdp_bus_usecases,
+	.num_usecases = ARRAY_SIZE(mdp_bus_usecases),
+	.name = "mdp",
+};
 static uint32_t mdp_bus_scale_handle;
-int mdp_bus_scale_update_request(uint32_t index)
+static int mdp_bus_scale_register(void)
 {
-	if (!mdp_pdata || !mdp_pdata->mdp_bus_scale_table
-	     || index > (mdp_pdata->mdp_bus_scale_table->num_usecases - 1)) {
-		printk(KERN_ERR "%s invalid table or index\n", __func__);
-		return -EINVAL;
+	struct msm_bus_scale_pdata *bus_pdata = &mdp_bus_scale_table;
+	if (!mdp_bus_scale_handle) {
+		mdp_bus_scale_handle = msm_bus_scale_register_client(bus_pdata);
+		if (!mdp_bus_scale_handle) {
+			pr_err("%s: not able to get bus scale!\n", __func__);
+			return -ENOMEM;
+		}
 	}
+	return 0;
+}
+
+static int bus_index = 1;
+int mdp_bus_scale_update_request(u64 ab_p0, u64 ib_p0, u64 ab_p1, u64 ib_p1)
+{
 	if (mdp_bus_scale_handle < 1) {
-		pr_debug("%s invalid bus handle\n", __func__);
+		pr_err("%s invalid bus handle\n", __func__);
 		return -EINVAL;
 	}
-	return msm_bus_scale_client_update_request(mdp_bus_scale_handle,
-							index);
+
+	if ((!ab_p0) && (!ab_p1))
+		return msm_bus_scale_client_update_request
+			(mdp_bus_scale_handle, 0);
+
+	
+	bus_index++;
+	bus_index = (bus_index > 2) ? 1 : bus_index;
+
+	mdp_bus_usecases[bus_index].vectors[0].ab = min(ab_p0, mdp_max_bw);
+	ib_p0 = max(ib_p0, ab_p0);
+	mdp_bus_usecases[bus_index].vectors[0].ib = min(ib_p0, mdp_max_bw);
+
+	mdp_bus_usecases[bus_index].vectors[1].ab = min(ab_p1, mdp_max_bw);
+	ib_p1 = max(ib_p1, ab_p1);
+	mdp_bus_usecases[bus_index].vectors[1].ib = min(ib_p1, mdp_max_bw);
+
+	pr_debug("%s: handle=%d index=%d ab=%u ib=%u\n", __func__,
+		 (u32)mdp_bus_scale_handle, bus_index,
+		 mdp_bus_usecases[bus_index].vectors[0].ab,
+		 mdp_bus_usecases[bus_index].vectors[0].ib);
+
+	pr_debug("%s: p1 handle=%d index=%d ab=%u ib=%u\n", __func__,
+		 (u32)mdp_bus_scale_handle, bus_index,
+		 mdp_bus_usecases[bus_index].vectors[1].ab,
+		 mdp_bus_usecases[bus_index].vectors[1].ib);
+
+	return msm_bus_scale_client_update_request
+		(mdp_bus_scale_handle, bus_index);
+}
+static int mdp_bus_scale_restore_request(void)
+{
+	pr_debug("%s: index=%d ab_p0=%u ib_p0=%u\n", __func__, bus_index,
+		 mdp_bus_usecases[bus_index].vectors[0].ab,
+		 mdp_bus_usecases[bus_index].vectors[0].ib);
+	pr_debug("%s: index=%d ab_p1=%u ib_p1=%u\n", __func__, bus_index,
+		 mdp_bus_usecases[bus_index].vectors[1].ab,
+		 mdp_bus_usecases[bus_index].vectors[1].ib);
+
+	return mdp_bus_scale_update_request
+		(mdp_bus_usecases[bus_index].vectors[0].ab,
+		 mdp_bus_usecases[bus_index].vectors[0].ib,
+		 mdp_bus_usecases[bus_index].vectors[1].ab,
+		 mdp_bus_usecases[bus_index].vectors[1].ib);
+}
+#else
+static int mdp_bus_scale_restore_request(void)
+{
+	return 0;
 }
 #endif
 DEFINE_MUTEX(mdp_clk_lock);
@@ -2226,15 +2580,29 @@
 	}
 	disable_irq(mdp_irq);
 
-	hdmi_pll_fs = regulator_get(&pdev->dev, "hdmi_pll_fs");
-	if (IS_ERR(hdmi_pll_fs)) {
-		hdmi_pll_fs = NULL;
+	dsi_pll_vdda = regulator_get(&pdev->dev, "dsi_pll_vdda");
+	if (IS_ERR(dsi_pll_vdda)) {
+		dsi_pll_vdda = NULL;
 	} else {
-		if (mdp_rev != MDP_REV_44) {
-			ret = regulator_set_voltage(hdmi_pll_fs, 1800000,
+		if (mdp_rev == MDP_REV_42 || mdp_rev == MDP_REV_44) {
+			ret = regulator_set_voltage(dsi_pll_vdda, 1200000,
+				1200000);
+			if (ret) {
+				pr_err("set_voltage failed for dsi_pll_vdda, ret=%d\n",
+					ret);
+			}
+		}
+	}
+
+	dsi_pll_vddio = regulator_get(&pdev->dev, "dsi_pll_vddio");
+	if (IS_ERR(dsi_pll_vddio)) {
+		dsi_pll_vddio = NULL;
+	} else {
+		if (mdp_rev == MDP_REV_42) {
+			ret = regulator_set_voltage(dsi_pll_vddio, 1800000,
 				1800000);
 			if (ret) {
-				pr_err("set_voltage failed for hdmi_pll_fs, ret=%d\n",
+				pr_err("set_voltage failed for dsi_pll_vddio, ret=%d\n",
 					ret);
 			}
 		}
@@ -2244,21 +2612,8 @@
 	if (IS_ERR(footswitch)) {
 		footswitch = NULL;
 	} else {
-		if (hdmi_pll_fs)
-			regulator_enable(hdmi_pll_fs);
-
 		regulator_enable(footswitch);
 		mdp_footswitch_on = 1;
-
-#ifdef CONFIG_FB_MSM_HDMI_AS_PRIMARY
-		if (mdp_rev == MDP_REV_42 && !cont_splashScreen) {
-			regulator_disable(footswitch);
-			msleep(20);
-			regulator_enable(footswitch);
-		}
-#endif
-		if (hdmi_pll_fs)
-			regulator_disable(hdmi_pll_fs);
 	}
 
 	mdp_clk = clk_get(&pdev->dev, "core_clk");
@@ -2287,7 +2642,8 @@
 	}
 
 #ifdef CONFIG_FB_MSM_MDP40
-	if (mdp_pdata && mdp_pdata->mdp_max_clk)
+
+	if (mdp_pdata)
 		mdp_max_clk = mdp_pdata->mdp_max_clk;
 	else
 		pr_err("%s cannot get mdp max clk!\n", __func__);
@@ -2306,15 +2662,22 @@
 		clk_set_rate(mdp_lut_clk, mdp_clk_rate);
 	mutex_unlock(&mdp_clk_lock);
 
-	if (mdp_pdata && mdp_pdata->mdp_min_clk) {
-		mdp_min_clk = mdp_pdata->mdp_min_clk;
-		PR_DISP_INFO("%s: get mdp min clk = %d\n", __func__, mdp_min_clk);
-	}
-
 	MSM_FB_DEBUG("mdp_clk: mdp_clk=%d\n", (int)clk_get_rate(mdp_clk));
 #endif
+
+	if (mdp_rev == MDP_REV_42 && !cont_splashScreen) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		
+		outpdw(MDP_BASE + 0xE0000, 0x0);
+		
+		outpdw(MDP_BASE + 0x50, 0x0);
+		
+		outpdw(MDP_BASE + 0x10004, 0x3);
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	}
 	return 0;
 }
+
 static int
 mdp_write_reg_mask(uint32_t reg, uint32_t val, uint32_t mask)
 {
@@ -2360,13 +2723,13 @@
 	int rc;
 	resource_size_t  size ;
 	unsigned long flag;
+	u32 frame_rate;
 #ifdef CONFIG_FB_MSM_MDP40
 	int intf, if_no;
 #endif
 #if defined(CONFIG_FB_MSM_MIPI_DSI) && defined(CONFIG_FB_MSM_MDP40)
 	struct mipi_panel_info *mipi;
 #endif
-	static int contSplash_update_done;
 
 	if ((pdev->id == 0) && (pdev->num_resources > 0)) {
 		mdp_init_pdev = pdev;
@@ -2387,7 +2750,15 @@
 			return -ENOMEM;
 		}
 
+		if (mdp_pdata->mdp_max_bw)
+			mdp_max_bw = mdp_pdata->mdp_max_bw;
+		if (mdp_pdata->mdp_bw_ab_factor)
+			mdp_bw_ab_factor = mdp_pdata->mdp_bw_ab_factor;
+		if (mdp_pdata->mdp_bw_ib_factor)
+			mdp_bw_ib_factor = mdp_pdata->mdp_bw_ib_factor;
+
 		mdp_rev = mdp_pdata->mdp_rev;
+
 		mdp_iommu_split_domain = mdp_pdata->mdp_iommu_split_domain;
 
 		rc = mdp_irq_clk_setup(pdev, mdp_pdata->cont_splash_enabled);
@@ -2395,16 +2766,12 @@
 		if (rc)
 			return rc;
 
-		mdp_clk_ctrl(1);
-
 		mdp_hw_version();
 
 		
 #ifdef CONFIG_FB_MSM_MDP40
 		if (!(mdp_pdata->cont_splash_enabled))
 			mdp4_hw_init();
-		else
-			mdp4_overlay_cfg_init();
 #else
 		mdp_hw_init();
 #endif
@@ -2412,12 +2779,7 @@
 #ifdef CONFIG_FB_MSM_OVERLAY
 		mdp_hw_cursor_init();
 #endif
-
-		if (!(mdp_pdata->cont_splash_enabled))
-			mdp_clk_ctrl(0);
-
 		mdp_resource_initialized = 1;
-
 		return 0;
 	}
 
@@ -2444,18 +2806,6 @@
 	mfd->mdp_rev = mdp_rev;
 	mfd->vsync_init = NULL;
 
-	if (mdp_pdata) {
-		if (mdp_pdata->cont_splash_enabled && mfd->panel.type != MIPI_CMD_PANEL) {
-			mfd->cont_splash_done = 0;
-			if (!contSplash_update_done) {
-				mdp_pipe_ctrl(MDP_CMD_BLOCK,
-					MDP_BLOCK_POWER_ON, FALSE);
-				contSplash_update_done = 1;
-			}
-		} else
-			mfd->cont_splash_done = 1;
-	}
-
 	mfd->ov0_wb_buf = MDP_ALLOC(sizeof(struct mdp_buf_type));
 	mfd->ov1_wb_buf = MDP_ALLOC(sizeof(struct mdp_buf_type));
 	memset((void *)mfd->ov0_wb_buf, 0, sizeof(struct mdp_buf_type));
@@ -2488,10 +2838,11 @@
 	pdata = msm_fb_dev->dev.platform_data;
 	pdata->on = mdp_on;
 	pdata->off = mdp_off;
+	pdata->fps_level_change = mdp_fps_level_change;
+	pdata->late_init = NULL;
 	pdata->next = pdev;
 
-	if ((mfd->cont_splash_done))
-		mdp_clk_ctrl(1);
+	mdp_clk_ctrl(1);
 
 	mdp_prim_panel_type = mfd->panel.type;
 	switch (mfd->panel.type) {
@@ -2593,11 +2944,14 @@
 		mfd->do_histogram = mdp_do_histogram;
 		mfd->start_histogram = mdp_histogram_start;
 		mfd->stop_histogram = mdp_histogram_stop;
+		mfd->vsync_ctrl = mdp_dma_video_vsync_ctrl;
+		mfd->vsync_show = mdp_dma_video_show_event;
 		if (mfd->panel_info.pdest == DISPLAY_1)
 			mfd->dma = &dma2_data;
 		else {
 			printk(KERN_ERR "Invalid Selection of destination panel\n");
 			rc = -ENODEV;
+			mdp_clk_ctrl(0);
 			goto mdp_probe_err;
 		}
 
@@ -2626,24 +2980,19 @@
 		mfd->start_histogram = mdp_histogram_start;
 		mfd->stop_histogram = mdp_histogram_stop;
 		mdp4_display_intf_sel(if_no, DSI_CMD_INTF);
-
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-		spin_lock_irqsave(&mdp_spin_lock, flag);
-		mdp_intr_mask |= INTR_OVERLAY0_DONE;
-		outp32(MDP_INTR_ENABLE, mdp_intr_mask);
-		spin_unlock_irqrestore(&mdp_spin_lock, flag);
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 #else
-
 		mfd->dma_fnc = mdp_dma2_update;
 		mfd->do_histogram = mdp_do_histogram;
 		mfd->start_histogram = mdp_histogram_start;
 		mfd->stop_histogram = mdp_histogram_stop;
+		mfd->vsync_ctrl = mdp_dma_vsync_ctrl;
+		mfd->vsync_show = mdp_dma_show_event;
 		if (mfd->panel_info.pdest == DISPLAY_1)
 			mfd->dma = &dma2_data;
 		else {
 			printk(KERN_ERR "Invalid Selection of destination panel\n");
 			rc = -ENODEV;
+			mdp_clk_ctrl(0);
 			goto mdp_probe_err;
 		}
 		INIT_WORK(&mfd->dma_update_worker,
@@ -2663,6 +3012,9 @@
 		mfd->cursor_update = mdp_hw_cursor_update;
 		mfd->dma_fnc = mdp4_dtv_overlay;
 		mfd->dma = &dma_e_data;
+		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 		mdp4_display_intf_sel(EXTERNAL_INTF_SEL, DTV_INTF);
 		break;
 #endif
@@ -2692,7 +3044,8 @@
 #endif
 
 #ifdef CONFIG_FB_MSM_MDP40
-		mdp4_lcdc_vsync_init(0);
+		mfd->vsync_init = mdp4_lcdc_vsync_init;
+		mfd->vsync_show = mdp4_lcdc_show_event;
 		if (mfd->panel.type == HDMI_PANEL) {
 			mfd->dma = &dma_e_data;
 			mdp4_display_intf_sel(EXTERNAL_INTF_SEL, LCDC_RGB_INTF);
@@ -2702,6 +3055,8 @@
 		}
 #else
 		mfd->dma = &dma2_data;
+		mfd->vsync_ctrl = mdp_dma_lcdc_vsync_ctrl;
+		mfd->vsync_show = mdp_dma_lcdc_show_event;
 		spin_lock_irqsave(&mdp_spin_lock, flag);
 		mdp_intr_mask &= ~MDP_DMA_P_DONE;
 		outp32(MDP_INTR_ENABLE, mdp_intr_mask);
@@ -2738,8 +3093,10 @@
 				pr_err("%s: writeback panel not supprted\n",
 					 __func__);
 				platform_device_put(msm_fb_dev);
+				mdp_clk_ctrl(0);
 				return -ENODEV;
 			}
+			mdp4_wfd_init(0);
 			pdata->on = mdp4_overlay_writeback_on;
 			pdata->off = mdp4_overlay_writeback_off;
 			mfd->dma_fnc = mdp4_writeback_overlay;
@@ -2751,36 +3108,32 @@
 	default:
 		printk(KERN_ERR "mdp_probe: unknown device type!\n");
 		rc = -ENODEV;
-		if ((mfd->cont_splash_done))
-			mdp_clk_ctrl(0);
+		mdp_clk_ctrl(0);
 		goto mdp_probe_err;
 	}
-#ifdef CONFIG_FB_MSM_MDP40
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	mdp4_display_intf = inpdw(MDP_BASE + 0x0038);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-#endif
 
-	if ((mfd->cont_splash_done))
-		mdp_clk_ctrl(0);
+	if (mdp_rev >= MDP_REV_40) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		mdp4_display_intf = inpdw(MDP_BASE + 0x0038);
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	}
 
-#ifdef CONFIG_MSM_BUS_SCALING
-	if (!mdp_bus_scale_handle && mdp_pdata &&
-		mdp_pdata->mdp_bus_scale_table) {
-		mdp_bus_scale_handle =
-			msm_bus_scale_register_client(
-					mdp_pdata->mdp_bus_scale_table);
-		if (!mdp_bus_scale_handle) {
-			printk(KERN_ERR "%s not able to get bus scale\n",
-				__func__);
-			return -ENOMEM;
-		}
+	frame_rate = mdp_get_panel_framerate(mfd);
+	if (frame_rate) {
+		mfd->panel_info.frame_interval = 1000 / frame_rate;
+		mfd->cpu_pm_hdl = add_event_timer(NULL, (void *)mfd);
 	}
+	mdp_clk_ctrl(0);
 
-	
-	if (!(mfd->cont_splash_done))
-		mdp_bus_scale_update_request(5);
+#ifdef CONFIG_MSM_BUS_SCALING
+	if (mdp_bus_scale_register())
+		return -ENOMEM;
 
+	
+	mdp_bus_scale_update_request(mdp_max_bw,
+				     mdp_max_bw,
+				     mdp_max_bw,
+				     mdp_max_bw);
 #endif
 
 	
@@ -2819,15 +3172,15 @@
 			mfd->vsync_sysfs_created = 1;
 		}
 	}
-
 	return 0;
 
       mdp_probe_err:
 	platform_device_put(msm_fb_dev);
 #ifdef CONFIG_MSM_BUS_SCALING
-	if (mdp_pdata && mdp_pdata->mdp_bus_scale_table &&
-		mdp_bus_scale_handle > 0)
+	if (mdp_bus_scale_handle > 0) {
 		msm_bus_scale_unregister_client(mdp_bus_scale_handle);
+		mdp_bus_scale_handle = 0;
+	}
 #endif
 	return rc;
 }
@@ -2841,8 +3194,11 @@
 		return;
 	}
 
-	if (hdmi_pll_fs)
-		regulator_enable(hdmi_pll_fs);
+	if (dsi_pll_vddio)
+		regulator_enable(dsi_pll_vddio);
+
+	if (dsi_pll_vdda)
+		regulator_enable(dsi_pll_vdda);
 
 	if (on && !mdp_footswitch_on) {
 		pr_debug("Enable MDP FS\n");
@@ -2854,12 +3210,26 @@
 		mdp_footswitch_on = 0;
 	}
 
-	if (hdmi_pll_fs)
-		regulator_disable(hdmi_pll_fs);
+	if (dsi_pll_vdda)
+		regulator_disable(dsi_pll_vdda);
+
+	if (dsi_pll_vddio)
+		regulator_disable(dsi_pll_vddio);
 
 	mutex_unlock(&mdp_suspend_mutex);
 }
 
+void mdp_free_splash_buffer(struct msm_fb_data_type *mfd)
+{
+	if (mfd->copy_splash_buf) {
+		dma_free_coherent(NULL,	mdp_pdata->splash_screen_size,
+			mfd->copy_splash_buf,
+			(dma_addr_t) mfd->copy_splash_phys);
+
+		mfd->copy_splash_buf = NULL;
+	}
+}
+
 #ifdef CONFIG_PM
 static void mdp_suspend_sub(void)
 {
@@ -2933,9 +3303,10 @@
 	iounmap(msm_mdp_base);
 	pm_runtime_disable(&pdev->dev);
 #ifdef CONFIG_MSM_BUS_SCALING
-	if (mdp_pdata && mdp_pdata->mdp_bus_scale_table &&
-		mdp_bus_scale_handle > 0)
+	if (mdp_bus_scale_handle > 0) {
 		msm_bus_scale_unregister_client(mdp_bus_scale_handle);
+		mdp_bus_scale_handle = 0;
+	}
 #endif
 	return 0;
 }
@@ -2947,12 +3318,6 @@
 	early_suspend.suspend = mdp_early_suspend;
 	early_suspend.resume = mdp_early_resume;
 	register_early_suspend(&early_suspend);
-#ifdef CONFIG_HTC_ONMODE_CHARGING
-	onchg_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1;
-	onchg_suspend.suspend = mdp_early_suspend;
-	onchg_suspend.resume = mdp_early_resume;
-	register_onchg_suspend(&onchg_suspend);
-#endif
 #endif
 
 	return platform_driver_register(&mdp_driver);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_cursor.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_cursor.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_cursor.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_cursor.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2009, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_debugfs.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_debugfs.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_debugfs.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_debugfs.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -418,9 +418,6 @@
 	MDPIBUF *iBuf;
 	uint32 upper_height;
 
-	if (!mfd)
-		return;
-
 	if (mfd->panel.type == EXT_MDDI_PANEL) {
 		mdp_dma2_update_sub(mfd);
 		return;
@@ -486,6 +483,38 @@
 	up(&mfd->dma->mutex);
 }
 
+void mdp_dma_vsync_ctrl(int enable)
+{
+	unsigned long flag;
+	int disabled_clocks;
+	if (vsync_cntrl.vsync_irq_enabled == enable)
+		return;
+
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	if (!enable)
+		INIT_COMPLETION(vsync_cntrl.vsync_wait);
+
+	vsync_cntrl.vsync_irq_enabled = enable;
+	if (!enable)
+		vsync_cntrl.disabled_clocks = 0;
+	disabled_clocks = vsync_cntrl.disabled_clocks;
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
+
+	if (enable && disabled_clocks) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		MDP_OUTP(MDP_BASE + 0x021c, 0x10); 
+		spin_lock_irqsave(&mdp_spin_lock, flag);
+		outp32(MDP_INTR_CLEAR, MDP_PRIM_RDPTR);
+		mdp_intr_mask |= MDP_PRIM_RDPTR;
+		outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+		mdp_enable_irq(MDP_VSYNC_TERM);
+		spin_unlock_irqrestore(&mdp_spin_lock, flag);
+	}
+	if (vsync_cntrl.vsync_irq_enabled &&
+		atomic_read(&vsync_cntrl.suspend) == 0)
+		atomic_set(&vsync_cntrl.vsync_resume, 1);
+}
+
 void mdp_lcd_update_workqueue_handler(struct work_struct *work)
 {
 	struct msm_fb_data_type *mfd = NULL;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma_s.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma_s.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma_s.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma_s.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2009, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -135,9 +135,6 @@
 
 void mdp_dma_s_update(struct msm_fb_data_type *mfd)
 {
-	if (!mfd)
-		return;
-
 	down(&mfd->dma->mutex);
 	if ((mfd) && (!mfd->dma->busy) && (mfd->panel_power_on)) {
 		down(&mfd->sem);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma_tv.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma_tv.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_dma_tv.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_dma_tv.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, 2012 Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2009, 2012 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,7 +24,7 @@
 #include <linux/msm_mdp.h>
 #include <linux/memory_alloc.h>
 #include <mach/hardware.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 
 #ifdef CONFIG_MSM_BUS_SCALING
 #include <mach/msm_bus.h>
@@ -44,15 +44,10 @@
 extern int mdp_rev;
 extern int mdp_iommu_split_domain;
 extern struct mdp_csc_cfg mdp_csc_convert[4];
-
+extern struct mdp_csc_cfg_data csc_cfg_matrix[];
 extern struct workqueue_struct *mdp_hist_wq;
 
-extern u32 mdp_ov0_blt_ctl;
-enum {
-	MDP4_BLT_SWITCH_TG_OFF,
-	MDP4_BLT_SWITCH_TG_ON_ISR
-};
-
+extern uint32 mdp_intr_mask;
 
 #define MDP4_REVISION_V1		0
 #define MDP4_REVISION_V2		1
@@ -95,6 +90,21 @@
 extern struct mdp_ccs mdp_ccs_yuv2rgb ;
 extern struct mdp_ccs mdp_ccs_rgb2yuv ;
 extern unsigned char hdmi_prim_display;
+extern unsigned char hdmi_prim_resolution;
+
+struct vsync {
+	ktime_t vsync_time;
+	struct device *dev;
+	struct work_struct vsync_work;
+	int vsync_irq_enabled;
+	int disabled_clocks;
+	struct completion vsync_wait;
+	atomic_t suspend;
+	atomic_t vsync_resume;
+	int sysfs_created;
+};
+
+extern struct vsync vsync_cntrl;
 
 typedef struct mdpImg_ {
 	uint32 imgType;		
@@ -291,6 +301,7 @@
 #define MDP_HISTOGRAM_TERM_DMA_S 0x20000
 #define MDP_HISTOGRAM_TERM_VG_1 0x40000
 #define MDP_HISTOGRAM_TERM_VG_2 0x80000
+#define MDP_VSYNC_TERM 0x1000
 
 #define ACTIVE_START_X_EN BIT(31)
 #define ACTIVE_START_Y_EN BIT(31)
@@ -310,6 +321,7 @@
 #define MDP_PPP_DONE 				BIT(0)
 #define TV_OUT_DMA3_DONE    BIT(6)
 #define TV_ENC_UNDERRUN     BIT(7)
+#define MDP_PRIM_RDPTR      BIT(8)
 #define TV_OUT_DMA3_START   BIT(13)
 #define MDP_HIST_DONE       BIT(20)
 
@@ -668,6 +680,7 @@
 
 void mdp_hw_init(void);
 int mdp_ppp_pipe_wait(void);
+void mdp_pipe_kickoff_simplified(uint32 term);
 void mdp_pipe_kickoff(uint32 term, struct msm_fb_data_type *mfd);
 void mdp_clk_ctrl(int on);
 void mdp_pipe_ctrl(MDP_BLOCK_TYPE block, MDP_BLOCK_POWER_STATE state,
@@ -711,7 +724,7 @@
 int mdp_lcdc_on(struct platform_device *pdev);
 int mdp_lcdc_off(struct platform_device *pdev);
 void mdp_lcdc_update(struct msm_fb_data_type *mfd);
-
+void mdp_free_splash_buffer(struct msm_fb_data_type *mfd);
 #ifdef CONFIG_FB_MSM_MDP303
 int mdp_dsi_video_on(struct platform_device *pdev);
 int mdp_dsi_video_off(struct platform_device *pdev);
@@ -765,16 +778,27 @@
 int mdp_clk_round_rate(u32 rate);
 
 unsigned long mdp_get_core_clk(void);
-unsigned long mdp_perf_level2clk_rate(uint32 perf_level);
 
 #ifdef CONFIG_MSM_BUS_SCALING
-int mdp_bus_scale_update_request(uint32_t index);
+int mdp_bus_scale_update_request(u64 ab_p0, u64 ib_p0, u64 ab_p1, u64 ib_p1);
 #else
-static inline int mdp_bus_scale_update_request(uint32_t index)
+static inline int mdp_bus_scale_update_request(u64 ab_p0,
+					       u64 ib_p0,
+					       u64 ab_p1,
+					       u64 ib_p1)
 {
 	return 0;
 }
 #endif
+void mdp_dma_vsync_ctrl(int enable);
+void mdp_dma_video_vsync_ctrl(int enable);
+void mdp_dma_lcdc_vsync_ctrl(int enable);
+ssize_t mdp_dma_show_event(struct device *dev,
+		struct device_attribute *attr, char *buf);
+ssize_t mdp_dma_video_show_event(struct device *dev,
+		struct device_attribute *attr, char *buf);
+ssize_t mdp_dma_lcdc_show_event(struct device *dev,
+		struct device_attribute *attr, char *buf);
 
 #ifdef MDP_HW_VSYNC
 void vsync_clk_prepare_enable(void);
@@ -799,6 +823,8 @@
 void __mdp_histogram_kickoff(struct mdp_hist_mgmt *mgmt);
 void __mdp_histogram_reset(struct mdp_hist_mgmt *mgmt);
 void mdp_footswitch_ctrl(boolean on);
+int mdp_enable_iommu_clocks(void);
+int mdp_disable_iommu_clocks(void);
 
 #ifdef CONFIG_FB_MSM_MDP303
 static inline void mdp4_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd)
@@ -825,6 +851,11 @@
 {
 	
 }
+static inline int msmfb_overlay_vsync_ctrl(struct fb_info *info,
+						void __user *argp)
+{
+	return 0;
+}
 #endif
 
 int mdp_ppp_v4l2_overlay_set(struct fb_info *info, struct mdp_overlay *req);
@@ -832,8 +863,10 @@
 int mdp_ppp_v4l2_overlay_play(struct fb_info *info,
 	unsigned long srcp0_addr, unsigned long srcp0_size,
 	unsigned long srcp1_addr, unsigned long srcp1_size);
+void mdp_update_pm(struct msm_fb_data_type *mfd, ktime_t pre_vsync);
 
 u32 mdp_get_panel_framerate(struct msm_fb_data_type *mfd);
+
 #ifdef CONFIG_FB_MSM_DTV
 void mdp_vid_quant_set(void);
 #else
@@ -842,4 +875,25 @@
 	
 }
 #endif
+
+#ifdef CONFIG_UPDATE_LCDC_LUT
+#define R_MASK    0x00ff0000
+#define G_MASK    0x000000ff
+#define B_MASK    0x0000ff00
+#define R_SHIFT   16
+#define G_SHIFT   0
+#define B_SHIFT   8
+#define lut2r(lut) ((lut & R_MASK) >> R_SHIFT)
+#define lut2g(lut) ((lut & G_MASK) >> G_SHIFT)
+#define lut2b(lut) ((lut & B_MASK) >> B_SHIFT)
+
+#ifdef CONFIG_LCD_KCAL
+#define NUM_QLUT  256
+#define MAX_KCAL_V (NUM_QLUT-1)
+#define scaled_by_kcal(rgb, kcal) \
+		(((((unsigned int)(rgb) * (unsigned int)(kcal)) << 16) / \
+		(unsigned int)MAX_KCAL_V) >> 16)
+#endif
+int mdp_preset_lut_update_lcdc(struct fb_cmap *cmap, uint32_t *internal_lut);
+#endif
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_vsync.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_vsync.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mdp_vsync.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mdp_vsync.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, 2012 Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2009, 2012 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -114,20 +114,9 @@
 void mdp_vsync_clk_enable(void)
 {
 	if (vsync_mfd) {
-	#ifdef CONFIG_MACH_DUMMY 
-		unsigned int timeout = (vsync_clk_status == 0)? 18 : 0; 
-	#endif 
 		mdp_hw_vsync_clk_enable(vsync_mfd);
 		if (!vsync_mfd->vsync_resync_timer.function)
 			mdp_set_vsync((unsigned long) vsync_mfd);
-	#ifdef CONFIG_MACH_DUMMY
-	if (timeout) {
-		uint32 count;
-		for (count = inpdw(MDP_BASE + 0x140) >> 16; timeout && count == inpdw(MDP_BASE + 0x140) >> 16; --timeout) {
-			hr_msleep(1);
-		}
-	}
-	#endif 
 	}
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_chimei_wuxga.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_chimei_wuxga.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_chimei_wuxga.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_chimei_wuxga.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_chimei_wxga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_chimei_wxga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_chimei_wxga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_chimei_wxga_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -29,15 +29,12 @@
 #include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/clk.h>
-#include <mach/debug_display.h>
 
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mdp.h"
 #include "mdp4.h"
 
-#include <mach/panel_id.h>
-
 u32 dsi_irq;
 u32 esc_byte_ratio;
 
@@ -48,6 +45,8 @@
 
 static int mipi_dsi_off(struct platform_device *pdev);
 static int mipi_dsi_on(struct platform_device *pdev);
+static int mipi_dsi_fps_level_change(struct platform_device *pdev,
+					u32 fps_level);
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
@@ -66,6 +65,14 @@
 
 struct device dsi_dev;
 
+static int mipi_dsi_fps_level_change(struct platform_device *pdev,
+					u32 fps_level)
+{
+	mipi_dsi_wait4video_done();
+	mipi_dsi_configure_fb_divider(fps_level);
+	return 0;
+}
+
 static int mipi_dsi_off(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -82,15 +89,15 @@
 	else
 		down(&mfd->dma->mutex);
 
-	mdp4_overlay_dsi_state_set(ST_DSI_SUSPEND);
-
-
 	if (mfd->panel_info.type == MIPI_CMD_PANEL) {
-		mipi_dsi_clk_cfg(1);
+		mipi_dsi_prepare_clocks();
+		mipi_dsi_ahb_ctrl(1);
+		mipi_dsi_clk_enable();
 
 		
 		mipi_dsi_cmd_mdp_busy();
 	}
+
 	mipi_dsi_op_mode_config(DSI_CMD_MODE);
 
 	if (mfd->panel_info.type == MIPI_CMD_PANEL) {
@@ -106,12 +113,19 @@
 
 	ret = panel_next_off(pdev);
 
-#ifdef CONFIG_MSM_BUS_SCALING
-	mdp_bus_scale_update_request(0);
-#endif
+	spin_lock_bh(&dsi_clk_lock);
 
-	mipi_dsi_clk_turn_off();
+	mipi_dsi_clk_disable();
 
+	
+	MIPI_OUTP(MIPI_DSI_BASE + 0x0000, 0);
+
+	mipi_dsi_phy_ctrl(0);
+
+	mipi_dsi_ahb_ctrl(0);
+	spin_unlock_bh(&dsi_clk_lock);
+
+	mipi_dsi_unprepare_clocks();
 	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
 		mipi_dsi_pdata->dsi_power_save(0);
 
@@ -125,37 +139,10 @@
 	return ret;
 }
 
-void mipi_exit_ulps(void)
-{
-	uint32 status;
-#if 0
-	status=MIPI_INP(MIPI_DSI_BASE + 0x00a4);
-	if ((status&0x1700)!=0) {
-	PR_DISP_DEBUG("%s: no need to exit ulps\n", __func__);
-	} else
-#endif
-	
-	{
-		status=MIPI_INP(MIPI_DSI_BASE + 0x00a8);
-		status&=0x10000000; 
-		status |= (BIT(8) | BIT(9) | BIT(10) | BIT(12));
-		MIPI_OUTP(MIPI_DSI_BASE + 0x00a8, status);
-		mb();
-		msleep(5);
-		status=MIPI_INP(MIPI_DSI_BASE + 0x00a4);
-		if ((status&0x1700)!=0) {
-			status=MIPI_INP(MIPI_DSI_BASE + 0x00a8);
-			status&=0x10000000; 
-			MIPI_OUTP(MIPI_DSI_BASE + 0x00a8, status);
-		} else {
-			PR_DISP_DEBUG("%s: cannot exit ulps\n", __func__);
-		}
-	}
-}
-
 static int mipi_dsi_on(struct platform_device *pdev)
 {
 	int ret = 0;
+	u32 clk_rate;
 	struct msm_fb_data_type *mfd;
 	struct fb_info *fbi;
 	struct fb_var_screeninfo *var;
@@ -165,29 +152,34 @@
 	u32 ystride, bpp, data;
 	u32 dummy_xres, dummy_yres;
 	int target_type = 0;
-	static bool bfirsttime = true;
 
-	PR_DISP_INFO("%s+:\n", __func__);
+	pr_debug("%s+:\n", __func__);
 
 	mfd = platform_get_drvdata(pdev);
 	fbi = mfd->fbi;
 	var = &fbi->var;
 	pinfo = &mfd->panel_info;
 
-#ifdef CONFIG_MSM_ALT_DSI_ESCAPE_CLOCK
-	esc_byte_ratio = pinfo->mipi.esc_byte_ratio;
-#else
-	esc_byte_ratio = 2;
-#endif
-
 	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
 		mipi_dsi_pdata->dsi_power_save(1);
 
+	cont_splash_clk_ctrl(0);
+	mipi_dsi_prepare_clocks();
+
+	mipi_dsi_ahb_ctrl(1);
+
+	clk_rate = mfd->fbi->var.pixclock;
+	clk_rate = min(clk_rate, mfd->panel_info.clk_max);
+
+	mipi_dsi_phy_ctrl(1);
+
 	if (mdp_rev == MDP_REV_42 && mipi_dsi_pdata)
 		target_type = mipi_dsi_pdata->target_type;
 
-	cont_splash_clk_ctrl(0);
-	mipi_dsi_clk_turn_on(&(mfd->panel_info), target_type);
+	mipi_dsi_phy_init(0, &(mfd->panel_info), target_type);
+
+	mipi_dsi_clk_enable();
+
 	MIPI_OUTP(MIPI_DSI_BASE + 0x114, 1);
 	MIPI_OUTP(MIPI_DSI_BASE + 0x114, 0);
 
@@ -258,15 +250,6 @@
 
 	mipi_dsi_host_init(mipi);
 
-	if (mipi_dsi_pdata && mipi_dsi_pdata->deferred_reset_driver_ic)
-		mipi_dsi_pdata->deferred_reset_driver_ic();
-
-	if (mipi->force_leave_ulps && bfirsttime) {
-		MIPI_OUTP(MIPI_DSI_BASE + 0x00A8, MIPI_INP(MIPI_DSI_BASE + 0x00A8) | (1<<4)); 
-		wmb();
-		MIPI_OUTP(MIPI_DSI_BASE + 0x00A8, MIPI_INP(MIPI_DSI_BASE + 0x00A8) | (1<<12)); 
-	}
-
 	if (mipi->force_clk_lane_hs) {
 		u32 tmp;
 
@@ -283,11 +266,6 @@
 
 	ret = panel_next_on(pdev);
 
-	if (mipi->force_leave_ulps && bfirsttime) {
-		mipi_exit_ulps();
-		bfirsttime = false;
-	}
-
 	mipi_dsi_op_mode_config(mipi->mode);
 
 	if (mfd->panel_info.type == MIPI_CMD_PANEL) {
@@ -333,29 +311,34 @@
 					}
 				}
 			}
-			if (!mfd->panel_info.lcdc.no_set_tear)
-				mipi_dsi_set_tear_on(mfd);
+			mipi_dsi_set_tear_on(mfd);
 		}
-		mipi_dsi_clk_cfg(0);
+		mipi_dsi_clk_disable();
+		mipi_dsi_ahb_ctrl(0);
+		mipi_dsi_unprepare_clocks();
 	}
 
-
-#ifdef CONFIG_MSM_BUS_SCALING
-	mdp_bus_scale_update_request(2);
-#endif
-
-	mdp4_overlay_dsi_state_set(ST_DSI_RESUME);
-
 	if (mdp_rev >= MDP_REV_41)
 		mutex_unlock(&mfd->dma->ov_mutex);
 	else
 		up(&mfd->dma->mutex);
 
-	PR_DISP_INFO("%s-:\n", __func__);
+	pr_debug("%s-:\n", __func__);
 
 	return ret;
 }
 
+static int mipi_dsi_early_off(struct platform_device *pdev)
+{
+	return panel_next_early_off(pdev);
+}
+
+
+static int mipi_dsi_late_init(struct platform_device *pdev)
+{
+	return panel_next_late_init(pdev);
+}
+
 
 static int mipi_dsi_resource_initialized;
 
@@ -443,13 +426,15 @@
 		if (mipi_dsi_clk_init(pdev))
 			return -EPERM;
 
-		if (mipi_dsi_pdata && mipi_dsi_pdata->splash_is_enabled &&
+		if (mipi_dsi_pdata->splash_is_enabled &&
 			!mipi_dsi_pdata->splash_is_enabled()) {
+			mipi_dsi_prepare_clocks();
 			mipi_dsi_ahb_ctrl(1);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x118, 0);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x0, 0);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x200, 0);
 			mipi_dsi_ahb_ctrl(0);
+			mipi_dsi_unprepare_clocks();
 		}
 		mipi_dsi_resource_initialized = 1;
 
@@ -470,9 +455,6 @@
 	if (pdev_list_cnt >= MSM_FB_MAX_DEV_LIST)
 		return -ENOMEM;
 
-	if (!mfd->cont_splash_done)
-		cont_splash_clk_ctrl(1);
-
 	mdp_dev = platform_device_alloc("mdp", pdev->id);
 	if (!mdp_dev)
 		return -ENOMEM;
@@ -489,6 +471,9 @@
 	pdata = mdp_dev->dev.platform_data;
 	pdata->on = mipi_dsi_on;
 	pdata->off = mipi_dsi_off;
+	pdata->fps_level_change = mipi_dsi_fps_level_change;
+	pdata->late_init = mipi_dsi_late_init;
+	pdata->early_off = mipi_dsi_early_off;
 	pdata->next = pdev;
 
 	mfd->panel_info = pdata->panel_info;
@@ -499,7 +484,7 @@
 	else
 		mfd->dest = DISPLAY_LCD;
 
-	if (mdp_rev == MDP_REV_303 && mipi_dsi_pdata &&
+	if (mdp_rev == MDP_REV_303 &&
 		mipi_dsi_pdata->get_lane_config) {
 		if (mipi_dsi_pdata->get_lane_config() != 2) {
 			pr_info("Changing to DSI Single Mode Configuration\n");
@@ -577,8 +562,7 @@
 		goto mipi_dsi_probe_err;
 
 	if ((dsi_pclk_rate < 3300000) || (dsi_pclk_rate > 223000000)) {
-		pr_err("%s: Pixel clock (%d) not supported\n",
-			__func__, dsi_pclk_rate);
+		pr_err("%s: Pixel clock not supported\n", __func__);
 		dsi_pclk_rate = 35000000;
 	}
 	mipi->dsi_pclk_rate = dsi_pclk_rate;
@@ -591,6 +575,11 @@
 
 	pdev_list[pdev_list_cnt++] = pdev;
 
+	esc_byte_ratio = pinfo->mipi.esc_byte_ratio;
+
+	if (!mfd->cont_splash_done)
+		cont_splash_clk_ctrl(1);
+
 return 0;
 
 mipi_dsi_probe_err:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -117,6 +117,7 @@
 #define DSI_INTR_CMD_DMA_DONE_MASK	BIT(1)
 #define DSI_INTR_CMD_DMA_DONE		BIT(0)
 
+#define DSI_VIDEO_TERM	BIT(16)
 #define DSI_MDP_TERM	BIT(8)
 #define DSI_CMD_TERM	BIT(0)
 
@@ -130,7 +131,6 @@
 extern int mipi_dsi_clk_on;
 extern u32 dsi_irq;
 extern u32 esc_byte_ratio;
-extern int panel_type;
 
 extern void  __iomem *periph_base;
 extern char *mmss_cc_base;	
@@ -189,7 +189,7 @@
 #define DSI_HDR_DATA1(data)	((data) & 0x0ff)
 #define DSI_HDR_WC(wc)		((wc) & 0x0ffff)
 
-#define DSI_BUF_SIZE	1024
+#define DSI_BUF_SIZE	64
 #define MIPI_DSI_MRPS	0x04	
 
 #define MIPI_DSI_LEN 8 
@@ -254,13 +254,16 @@
 	void *data;
 };
 
+
 #define CMD_REQ_MAX	4
 
 typedef void (*fxn)(u32 data);
 
 #define CMD_REQ_RX	0x0001
-#define CMD_REQ_COMMIT 0x0002
+#define CMD_REQ_COMMIT	0x0002
+#define CMD_CLK_CTRL	0x0004
 #define CMD_REQ_NO_MAX_PKT_SIZE 0x0008
+#define CMD_REQ_SINGLE_TX 0x0010
 
 struct dcs_cmd_req {
 	struct dsi_cmd_desc *cmds;
@@ -286,6 +289,8 @@
 int mipi_dsi_buf_alloc(struct dsi_buf *, int size);
 int mipi_dsi_cmd_dma_add(struct dsi_buf *dp, struct dsi_cmd_desc *cm);
 int mipi_dsi_cmds_tx(struct dsi_buf *dp, struct dsi_cmd_desc *cmds, int cnt);
+int mipi_dsi_cmds_single_tx(struct dsi_buf *dp, struct dsi_cmd_desc *cmds,
+								int cnt);
 
 int mipi_dsi_cmd_dma_tx(struct dsi_buf *dp);
 int mipi_dsi_cmd_reg_tx(uint32 data);
@@ -305,8 +310,7 @@
 void mipi_dsi_set_tear_on(struct msm_fb_data_type *mfd);
 void mipi_dsi_set_tear_off(struct msm_fb_data_type *mfd);
 void mipi_dsi_set_backlight(struct msm_fb_data_type *mfd, int level);
-void mipi_dsi_clk_enable(void);
-void mipi_dsi_clk_disable(void);
+void mipi_dsi_cmd_backlight_tx(struct dsi_buf *dp);
 void mipi_dsi_pre_kickoff_action(void);
 void mipi_dsi_post_kickoff_action(void);
 void mipi_dsi_pre_kickoff_add(struct dsi_kickoff_action *act);
@@ -320,34 +324,61 @@
 irqreturn_t mipi_dsi_isr(int irq, void *ptr);
 
 void mipi_set_tx_power_mode(int mode);
-void mipi_dsi_phy_ctrl(int on);
 void mipi_dsi_phy_init(int panel_ndx, struct msm_panel_info const *panel_info,
 	int target_type);
 int mipi_dsi_clk_div_config(uint8 bpp, uint8 lanes,
 			    uint32 *expected_dsi_pclk);
 int mipi_dsi_clk_init(struct platform_device *pdev);
 void mipi_dsi_clk_deinit(struct device *dev);
+
+#ifdef CONFIG_FB_MSM_MIPI_DSI
+void mipi_dsi_clk_enable(void);
+void mipi_dsi_clk_disable(void);
 void mipi_dsi_prepare_clocks(void);
 void mipi_dsi_unprepare_clocks(void);
 void mipi_dsi_ahb_ctrl(u32 enable);
+void mipi_dsi_phy_ctrl(int on);
+#else
+static inline void mipi_dsi_clk_enable(void)
+{
+	
+}
+void mipi_dsi_clk_disable(void)
+{
+	
+}
+void mipi_dsi_prepare_clocks(void)
+{
+	
+}
+void mipi_dsi_unprepare_clocks(void)
+{
+	
+}
+void mipi_dsi_ahb_ctrl(u32 enable)
+{
+	
+}
+void mipi_dsi_phy_ctrl(int on)
+{
+	
+}
+#endif
+
 void cont_splash_clk_ctrl(int enable);
 void mipi_dsi_turn_on_clks(void);
 void mipi_dsi_turn_off_clks(void);
 void mipi_dsi_clk_cfg(int on);
-void mipi_dsi_clk_turn_on(struct msm_panel_info const *pinfo, int target_type);
-void mipi_dsi_clk_turn_off(void);
 
 int mipi_dsi_cmdlist_put(struct dcs_cmd_req *cmdreq);
 struct dcs_cmd_req *mipi_dsi_cmdlist_get(void);
 void mipi_dsi_cmdlist_commit(int from_mdp);
 void mipi_dsi_cmd_mdp_busy(void);
+void mipi_dsi_configure_fb_divider(u32 fps_level);
+void mipi_dsi_wait4video_done(void);
 
 #ifdef CONFIG_FB_MSM_MDP303
 void update_lane_config(struct msm_panel_info *pinfo);
 #endif
 
-#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
-uint32 mipi_dsi_cmd_bta_sw_trigger_status(void);
-uint32 mipi_dsi_read_power_mode(void);
-#endif
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi_host.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi_host.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_dsi_host.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_dsi_host.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,5 +1,5 @@
 
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,8 +24,9 @@
 #include <linux/semaphore.h>
 #include <linux/uaccess.h>
 #include <linux/clk.h>
+#include <linux/iopoll.h>
 #include <linux/platform_device.h>
-#include <mach/debug_display.h>
+#include <linux/iopoll.h>
 
 #include <asm/system.h>
 #include <asm/mach-types.h>
@@ -42,6 +43,7 @@
 
 static struct completion dsi_dma_comp;
 static struct completion dsi_mdp_comp;
+static struct completion dsi_video_comp;
 static struct dsi_buf dsi_tx_buf;
 static struct dsi_buf dsi_rx_buf;
 static spinlock_t dsi_irq_lock;
@@ -64,7 +66,6 @@
 
 struct dcs_cmd_list	cmdlist;
 
-void mipi_dsi_error(void);
 #ifdef CONFIG_FB_MSM_MDP40
 void mipi_dsi_mdp_stat_inc(int which)
 {
@@ -95,6 +96,7 @@
 {
 	init_completion(&dsi_dma_comp);
 	init_completion(&dsi_mdp_comp);
+	init_completion(&dsi_video_comp);
 	mipi_dsi_buf_alloc(&dsi_tx_buf, DSI_BUF_SIZE);
 	mipi_dsi_buf_alloc(&dsi_rx_buf, DSI_BUF_SIZE);
 	spin_lock_init(&dsi_irq_lock);
@@ -162,72 +164,27 @@
 	spin_unlock(&dsi_irq_lock);
 }
 
-static int dsi_clk_cnt;
-static int dsi_clk_on_aux;
-
-void mipi_dsi_clk_turn_on(struct msm_panel_info const *pinfo, int target_type)
-{
-	mutex_lock(&clk_mutex);
-
-	if (!dsi_clk_on_aux && !dsi_clk_cnt) {
-		mipi_dsi_prepare_clocks();
-		mipi_dsi_ahb_ctrl(1);
-
-		mipi_dsi_phy_ctrl(1);
-		mipi_dsi_phy_init(0, pinfo, target_type);
-
-		mipi_dsi_clk_enable();
-
-		dsi_clk_on_aux = 1;
-		dsi_clk_cnt = 1;
-	}
-
-	mutex_unlock(&clk_mutex);
-}
-
-void mipi_dsi_clk_turn_off()
-{
-	mutex_lock(&clk_mutex);
-
-	pr_debug("%s: turn off dsi clk and dsi engine, cnt = %d\n",
-	    __func__, dsi_clk_cnt);
-
-	mipi_dsi_clk_disable();
-
-	
-	MIPI_OUTP(MIPI_DSI_BASE + 0x0000, 0);
-
-	mipi_dsi_phy_ctrl(0);
-	mipi_dsi_ahb_ctrl(0);
-	mipi_dsi_unprepare_clocks();
-
-	dsi_clk_on_aux = 0;
-	dsi_clk_cnt = 0;
-
-	mutex_unlock(&clk_mutex);
-}
-
 void mipi_dsi_clk_cfg(int on)
 {
+	static int dsi_clk_cnt;
+
 	mutex_lock(&clk_mutex);
 	if (on) {
-		if (dsi_clk_on_aux) {
-			dsi_clk_on_aux = 0;
-		} else if (dsi_clk_cnt == 0) {
+		if (dsi_clk_cnt == 0) {
 			mipi_dsi_prepare_clocks();
 			mipi_dsi_ahb_ctrl(1);
 			mipi_dsi_clk_enable();
 		}
 		dsi_clk_cnt++;
 	} else {
-		if (dsi_clk_cnt)
+		if (dsi_clk_cnt) {
 			dsi_clk_cnt--;
-		if (dsi_clk_cnt == 0) {
-			mipi_dsi_clk_disable();
-			mipi_dsi_ahb_ctrl(0);
-			mipi_dsi_unprepare_clocks();
+			if (dsi_clk_cnt == 0) {
+				mipi_dsi_clk_disable();
+				mipi_dsi_ahb_ctrl(0);
+				mipi_dsi_unprepare_clocks();
+			}
 		}
-		dsi_clk_on_aux = 0;
 	}
 	pr_debug("%s: on=%d clk_cnt=%d pid=%d\n", __func__,
 				on, dsi_clk_cnt, current->pid);
@@ -917,7 +874,7 @@
 
 
 	
-	MIPI_OUTP(MIPI_DSI_BASE + 0x0108, 0x13ff3fe0); 
+	MIPI_OUTP(MIPI_DSI_BASE + 0x0108, 0x13ff37e0); 
 
 	intr_ctrl |= DSI_INTR_ERROR_MASK;
 	MIPI_OUTP(MIPI_DSI_BASE + 0x010c, intr_ctrl); 
@@ -959,31 +916,30 @@
 
 	uint32 dsi_ctrl;
 	uint32 status;
-	int cnt;
+	u32 sleep_us = 1000;
+	u32 timeout_us = 16000;
 
-	cnt = 16;
-	while (cnt--) {
-		status = MIPI_INP(MIPI_DSI_BASE + 0x0004);
-		status &= 0x02;		
-		if (status == 0)
-			break;
-		usleep(1000);
-	}
-	if (cnt == 0)
+	
+	if (readl_poll_timeout((MIPI_DSI_BASE + 0x0004),
+			   status,
+			   ((status & 0x02) == 0),
+			       sleep_us, timeout_us))
 		pr_info("%s: DSI status=%x failed\n", __func__, status);
 
-	cnt = 16;
-	while (cnt--) {
-		status = MIPI_INP(MIPI_DSI_BASE + 0x0008);
-		status &= 0x11111000;	
-		if (status == 0x11111000)	
-			break;
-		usleep(1000);
-	}
-
-	if (cnt == 0)
+	
+	if (readl_poll_timeout((MIPI_DSI_BASE + 0x0008),
+			   status,
+			   ((status & 0x11111000) == 0x11111000),
+			       sleep_us, timeout_us))
 		pr_info("%s: FIFO status=%x failed\n", __func__, status);
 
+	
+	if (readl_poll_timeout((MIPI_DSI_BASE + 0x0004),
+			   status,
+			   ((status & 0x08) == 0),
+			       sleep_us, timeout_us))
+		pr_info("%s: DSI status=%x failed\n", __func__, status);
+
 	dsi_ctrl = MIPI_INP(MIPI_DSI_BASE + 0x0000);
 	if (enable)
 		dsi_ctrl |= 0x01;
@@ -1003,7 +959,8 @@
 	dsi_ctrl &= ~0x07;
 	if (mode == DSI_VIDEO_MODE) {
 		dsi_ctrl |= 0x03;
-		intr_ctrl = DSI_INTR_CMD_DMA_DONE_MASK;
+		intr_ctrl = (DSI_INTR_CMD_DMA_DONE_MASK |
+					DSI_INTR_VIDEO_DONE_MASK);
 	} else {		
 		dsi_ctrl |= 0x05;
 		intr_ctrl = DSI_INTR_CMD_DMA_DONE_MASK | DSI_INTR_ERROR_MASK |
@@ -1017,6 +974,20 @@
 	wmb();
 }
 
+
+void mipi_dsi_wait4video_done(void)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&dsi_mdp_lock, flag);
+	INIT_COMPLETION(dsi_video_comp);
+	mipi_dsi_enable_irq(DSI_VIDEO_TERM);
+	spin_unlock_irqrestore(&dsi_mdp_lock, flag);
+
+	wait_for_completion_timeout(&dsi_video_comp,
+					msecs_to_jiffies(VSYNC_PERIOD * 4));
+}
+
 void mipi_dsi_mdp_busy_wait(void)
 {
 	mutex_lock(&cmd_mutex);
@@ -1065,10 +1036,9 @@
 static struct dsi_cmd_desc dsi_tear_off_cmd = {
 	DTYPE_DCS_WRITE, 1, 0, 0, 0, sizeof(set_tear_off), set_tear_off};
 
-static struct dcs_cmd_req cmdreq;
-
 void mipi_dsi_set_tear_on(struct msm_fb_data_type *mfd)
 {
+	struct dcs_cmd_req cmdreq;
 
 	cmdreq.cmds = &dsi_tear_on_cmd;
 	cmdreq.cmds_cnt = 1;
@@ -1081,6 +1051,8 @@
 
 void mipi_dsi_set_tear_off(struct msm_fb_data_type *mfd)
 {
+	struct dcs_cmd_req cmdreq;
+
 	cmdreq.cmds = &dsi_tear_off_cmd;
 	cmdreq.cmds_cnt = 1;
 	cmdreq.flags = CMD_REQ_COMMIT;
@@ -1089,56 +1061,7 @@
 
 	mipi_dsi_cmdlist_put(&cmdreq);
 }
-#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
-uint32 mipi_dsi_cmd_bta_sw_trigger_status(void)
-{
-        uint32 data, status;
-        int cnt = 0;
-
-        MIPI_OUTP(MIPI_DSI_BASE + 0x094, 0x01); 
-        wmb();
-
-        while (cnt < 100000) {
-                data = MIPI_INP(MIPI_DSI_BASE + 0x0004);
-                if ((data & 0x0010) == 0)
-                        break;
-                cnt++;
-        }
-
-        status = MIPI_INP(MIPI_DSI_BASE + 0x0064);
-
-        if (status) {
-                pr_err("%s: status=%x\n", __func__, status);
-        }
-
-        pr_info("%s: BTA done, cnt=%d\n", __func__, cnt);
-
-	return status;
-}
-
-static char read_power_mode[2] = {0x0A, 0x00};
-static struct dsi_cmd_desc power_mode_cmd = {
-        DTYPE_DCS_READ, 1, 0, 0, 0, sizeof(read_power_mode), read_power_mode};
-uint32 pwr_mode;
-
-static void mipi_read_power_mode_cb(u32 data)
-{
-	pwr_mode = data & 0xff;
-	pr_info("%s: power_mode=%x\n", __func__, pwr_mode);
-}
-
-uint32 mipi_dsi_read_power_mode(void)
-{
-	cmdreq.cmds = &power_mode_cmd;
-	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_RX | CMD_REQ_COMMIT;
-	cmdreq.rlen = 1;
-	cmdreq.cb = mipi_read_power_mode_cb;
-	mipi_dsi_cmdlist_put(&cmdreq);
 
-	return pwr_mode;
-}
-#endif
 int mipi_dsi_cmd_reg_tx(uint32 data)
 {
 #ifdef DSI_HOST_DEBUG
@@ -1199,6 +1122,53 @@
 	return cnt;
 }
 
+int mipi_dsi_cmds_single_tx(struct dsi_buf *tp, struct dsi_cmd_desc *cmds,
+								int cnt)
+{
+	struct dsi_cmd_desc *cm;
+	uint32 dsi_ctrl, ctrl;
+	int i, j = 0, k = 0, cmd_len = 0, video_mode;
+	char *cmds_tx;
+	char *bp;
+
+	if (tp == NULL || cmds == NULL) {
+		pr_err("%s: Null commands", __func__);
+		return -EINVAL;
+	}
+
+	dsi_ctrl = MIPI_INP(MIPI_DSI_BASE + 0x0000);
+	video_mode = dsi_ctrl & 0x02; 
+	if (video_mode) {
+		ctrl = dsi_ctrl | 0x04; 
+		MIPI_OUTP(MIPI_DSI_BASE + 0x0000, ctrl);
+	}
+
+	cm = cmds;
+	cmds_tx = kmalloc((DSI_BUF_SIZE + DSI_HOST_HDR_SIZE) * cnt, GFP_KERNEL);
+	mipi_dsi_buf_init(tp);
+	mipi_dsi_enable_irq(DSI_CMD_TERM);
+	for (i = 0; i < cnt; i++) {
+		mipi_dsi_buf_init(tp);
+		mipi_dsi_cmd_dma_add(tp, cm);
+		bp = tp->data;
+		for (j = 0; j < tp->len; j++) {
+			*(cmds_tx + k) = *bp++;
+			k++;
+		}
+		cmd_len = cmd_len + tp->len;
+		cm++;
+	}
+	tp->data = cmds_tx;
+	tp->len = cmd_len;
+	mipi_dsi_cmd_dma_tx(tp);
+	kfree(cmds_tx);
+
+	if (video_mode)
+		MIPI_OUTP(MIPI_DSI_BASE + 0x0000, dsi_ctrl); 
+
+	return cnt;
+}
+
 static char max_pktsize[2] = {0x00, 0x00}; 
 
 static struct dsi_cmd_desc pkt_size_cmd[] = {
@@ -1258,7 +1228,6 @@
 	
 	mipi_dsi_cmd_dma_tx(tp);
 
-	mipi_dsi_disable_irq(DSI_CMD_TERM);
 	mipi_dsi_buf_init(rp);
 	if (mfd->panel_info.mipi.no_max_pkt_size) {
 		rp->data += 2;
@@ -1345,7 +1314,6 @@
 	
 	mipi_dsi_cmd_dma_tx(tp);
 
-	mipi_dsi_disable_irq(DSI_CMD_TERM);
 	mipi_dsi_buf_init(rp);
 	if (req->flags & CMD_REQ_NO_MAX_PKT_SIZE) {
 		rp->data += 2;
@@ -1383,12 +1351,9 @@
 	return rp->len;
 }
 
-int dsi_cmd_dma_need_wait;
 int mipi_dsi_cmd_dma_tx(struct dsi_buf *tp)
 {
-
 	unsigned long flags;
-	int ret = 0;
 
 #ifdef DSI_HOST_DEBUG
 	int i;
@@ -1423,19 +1388,11 @@
 	wmb();
 	MIPI_OUTP(MIPI_DSI_BASE + 0x08c, 0x01);	
 	wmb();
-	dsi_cmd_dma_need_wait++;
 	spin_unlock_irqrestore(&dsi_mdp_lock, flags);
 
-	if (dsi_cmd_dma_need_wait) {
-		ret = wait_for_completion_timeout(&dsi_dma_comp, HZ/20);
-		if (ret <= 0) {
-			pr_info("%s: wait for dsi_dma complete timeout (ret=%d, busy=%d, stat=0x%x)\n",
-			    __func__, ret, dsi_cmd_dma_need_wait, MIPI_INP(MIPI_DSI_BASE + 0x0004));
-			if (dsi_cmd_dma_need_wait > 5) {
-				mipi_dsi_error();
-				mipi_dsi_sw_reset();
-			}
-		}
+	if (!wait_for_completion_timeout(&dsi_dma_comp,
+					msecs_to_jiffies(200))) {
+		pr_err("%s: dma timeout error\n", __func__);
 	}
 
 	dma_unmap_single(&dsi_dev, tp->dmap, tp->len, DMA_TO_DEVICE);
@@ -1470,23 +1427,20 @@
 	return rlen;
 }
 
-void mipi_dsi_video_wait_to_mdp_busy(void)
+static void mipi_dsi_wait4video_eng_busy(void)
 {
-	u32 status;
-
-	status = MIPI_INP(MIPI_DSI_BASE + 0x0004);
-	if (!(status & 0x08))	
-		usleep(4000);
+	mipi_dsi_wait4video_done();
+	
+	usleep(4000);
 }
 
 void mipi_dsi_cmd_mdp_busy(void)
 {
 	unsigned long flags;
 	int need_wait = 0;
-	int timeoutResult = 0;
-	static int cnt = 0;
 
-	pr_debug("%s: start pid=%d\n", __func__, current->pid);
+	pr_debug("%s: start pid=%d\n",
+				__func__, current->pid);
 	spin_lock_irqsave(&dsi_mdp_lock, flags);
 	if (dsi_mdp_busy == TRUE)
 		need_wait++;
@@ -1496,15 +1450,7 @@
 		
 		pr_debug("%s: pending pid=%d\n",
 				__func__, current->pid);
-		timeoutResult = wait_for_completion_timeout(&dsi_mdp_comp, HZ/10);
-		if (!timeoutResult) {
-			PR_DISP_WARN("%s:wait_for_completion\n",__func__);
-			if (cnt > 2)
-				PR_DISP_WARN("%s:still timeout\n",__func__);
-			cnt++;
-		} else {
-			cnt = 0;
-		}
+		wait_for_completion(&dsi_mdp_comp);
 	}
 	pr_debug("%s: done pid=%d\n",
 				__func__, current->pid);
@@ -1531,7 +1477,10 @@
 
 	mipi_dsi_buf_init(&dsi_tx_buf);
 	tp = &dsi_tx_buf;
-	ret = mipi_dsi_cmds_tx(tp, req->cmds, req->cmds_cnt);
+	if (req->flags & CMD_REQ_SINGLE_TX)
+		ret = mipi_dsi_cmds_single_tx(tp, req->cmds, req->cmds_cnt);
+	else
+		ret = mipi_dsi_cmds_tx(tp, req->cmds, req->cmds_cnt);
 
 	if (req->cb)
 		req->cb(ret);
@@ -1561,7 +1510,6 @@
 void mipi_dsi_cmdlist_commit(int from_mdp)
 {
 	struct dcs_cmd_req *req;
-	int video;
 	u32 dsi_ctrl;
 
 	mutex_lock(&cmd_mutex);
@@ -1573,17 +1521,11 @@
 	if (req == NULL)
 		goto need_lock;
 
-	video = MIPI_INP(MIPI_DSI_BASE + 0x0000);
-	video &= 0x02; 
-
-	if (!video)
-		mipi_dsi_clk_cfg(1);
-
 	pr_debug("%s:  from_mdp=%d pid=%d\n", __func__, from_mdp, current->pid);
 
 	dsi_ctrl = MIPI_INP(MIPI_DSI_BASE + 0x0000);
 	if (dsi_ctrl & 0x02) {
-		mipi_dsi_video_wait_to_mdp_busy();
+		mipi_dsi_wait4video_eng_busy();
 	} else {
 		
 		if (!from_mdp) { 
@@ -1597,10 +1539,8 @@
 	else
 		mipi_dsi_cmdlist_tx(req);
 
-	if (!video)
-		mipi_dsi_clk_cfg(0);
-
 need_lock:
+
 	if (from_mdp) 
 		mipi_dsi_cmd_mdp_start();
 
@@ -1632,9 +1572,15 @@
 	pr_debug("%s: tot=%d put=%d get=%d\n", __func__,
 		cmdlist.tot, cmdlist.put, cmdlist.get);
 
+	if (req->flags & CMD_CLK_CTRL)
+		mipi_dsi_clk_cfg(1);
+
 	if (req->flags & CMD_REQ_COMMIT)
 		mipi_dsi_cmdlist_commit(0);
 
+	if (req->flags & CMD_CLK_CTRL)
+		mipi_dsi_clk_cfg(0);
+
 	return ret;
 }
 
@@ -1648,6 +1594,7 @@
 	MIPI_OUTP(MIPI_DSI_BASE + 0x010c, data);
 }
 
+
 void mipi_dsi_ack_err_status(void)
 {
 	uint32 status;
@@ -1656,7 +1603,7 @@
 
 	if (status) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0064, status);
-		pr_info("%s: status=%x\n", __func__, status);
+		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1667,7 +1614,7 @@
 	status = MIPI_INP(MIPI_DSI_BASE + 0x00bc);
 	if (status & 0x0111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00bc, status);
-		pr_info("%s: status=%x\n", __func__, status);
+		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1679,7 +1626,7 @@
 
 	if (status & 0x011111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00b0, status);
-		pr_info("%s: status=%x\n", __func__, status);
+		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1691,7 +1638,9 @@
 
 	if (status & 0x44444489) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0008, status);
-		pr_info("%s: status=%x\n", __func__, status);
+		pr_err("%s: Error: status=%x\n", __func__, status);
+		mipi_dsi_sw_reset();
+		mdp4_mixer_reset(0);
 	}
 }
 
@@ -1703,7 +1652,7 @@
 
 	if (status & 0x80000000) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0004, status);
-		pr_info("%s: status=%x\n", __func__, status);
+		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1720,14 +1669,11 @@
 
 irqreturn_t mipi_dsi_isr(int irq, void *ptr)
 {
-	uint32 isr, status;
+	uint32 isr;
 
 	isr = MIPI_INP(MIPI_DSI_BASE + 0x010c);
 	MIPI_OUTP(MIPI_DSI_BASE + 0x010c, isr);
 
-	
-	status = MIPI_INP(MIPI_DSI_BASE + 0x0004);
-
 	pr_debug("%s: isr=%x\n", __func__, (int)isr);
 
 #ifdef CONFIG_FB_MSM_MDP40
@@ -1735,10 +1681,20 @@
 #endif
 	if (isr & DSI_INTR_ERROR) {
 		mipi_dsi_mdp_stat_inc(STAT_DSI_ERROR);
+		spin_lock(&dsi_mdp_lock);
+		dsi_ctrl_lock = FALSE;
+		dsi_mdp_busy = FALSE;
+		mipi_dsi_disable_irq_nosync(DSI_MDP_TERM);
 		mipi_dsi_error();
+		complete(&dsi_mdp_comp);
+		spin_unlock(&dsi_mdp_lock);
 	}
 
 	if (isr & DSI_INTR_VIDEO_DONE) {
+		spin_lock(&dsi_mdp_lock);
+		mipi_dsi_disable_irq_nosync(DSI_VIDEO_TERM);
+		complete(&dsi_video_comp);
+		spin_unlock(&dsi_mdp_lock);
 	}
 
 	if (isr & DSI_INTR_CMD_DMA_DONE) {
@@ -1747,7 +1703,6 @@
 		complete(&dsi_dma_comp);
 		dsi_ctrl_lock = FALSE;
 		mipi_dsi_disable_irq_nosync(DSI_CMD_TERM);
-		dsi_cmd_dma_need_wait = 0;
 		spin_unlock(&dsi_mdp_lock);
 	}
 
@@ -1757,7 +1712,7 @@
 		dsi_ctrl_lock = FALSE;
 		dsi_mdp_busy = FALSE;
 		mipi_dsi_disable_irq_nosync(DSI_MDP_TERM);
-		complete_all(&dsi_mdp_comp);
+		complete(&dsi_mdp_comp);
 		spin_unlock(&dsi_mdp_lock);
 	}
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,12 +20,6 @@
 #include "mipi_novatek.h"
 #include "mdp4.h"
 
-#include <mach/panel_id.h>
-#include <mach/debug_display.h>
-
-#define EVA_CMD_MODE_PANEL
-#undef EVA_VIDEO_MODE_PANEL
-#undef EVA_SWITCH_MODE_PANEL
 
 static struct mipi_dsi_panel_platform_data *mipi_novatek_pdata;
 
@@ -33,20 +27,12 @@
 static struct dsi_buf novatek_rx_buf;
 static int mipi_novatek_lcd_init(void);
 
-struct dsi_cmd_desc *novatek_display_on_cmds = NULL;
-struct dsi_cmd_desc *novatek_display_off_cmds = NULL;
-int novatek_display_on_cmds_size = 0;
-int novatek_display_off_cmds_size = 0;
-char ptype[60] = "Panel Type = ";
-
 static int wled_trigger_initialized;
 
 #define MIPI_DSI_NOVATEK_SPI_DEVICE_NAME	"dsi_novatek_3d_panel_spi"
 #define HPCI_FPGA_READ_CMD	0x84
 #define HPCI_FPGA_WRITE_CMD	0x04
-#ifdef CONFIG_SPI_QUP
-#undef CONFIG_SPI_QUP
-#endif
+
 #ifdef CONFIG_SPI_QUP
 static struct spi_device *panel_3d_spi_client;
 
@@ -227,7 +213,7 @@
 };
 
 #else
-#if 0
+
 static char sw_reset[2] = {0x01, 0x00}; 
 static char enter_sleep[2] = {0x10, 0x00}; 
 static char exit_sleep[2] = {0x11, 0x00}; 
@@ -254,10 +240,10 @@
 static char set_height[5] = { 
 	0x2B, 0x00, 0x00, 0x03, 0xBF}; 
 #endif
-#endif
+
 static char led_pwm2[2] = {0x53, 0x24}; 
+static char led_pwm3[2] = {0x55, 0x00}; 
 
-#if 0
 static struct dsi_cmd_desc novatek_video_on_cmds[] = {
 	{DTYPE_DCS_WRITE, 1, 0, 0, 50,
 		sizeof(sw_reset), sw_reset},
@@ -308,1185 +294,29 @@
 	{DTYPE_DCS_WRITE, 1, 0, 0, 120,
 		sizeof(enter_sleep), enter_sleep}
 };
-#endif
-static char k2_f0_1[] = {
-    0xF0, 0x55, 0xAA, 0x52,
-    0x08, 0x01}; 
-static char k2_b0_1[] = {
-    0xB0, 0x12}; 
-static char k2_b1_1[] = {
-    0xB1, 0x12}; 
-static char k2_b2[] = {
-    0xB2, 0x00}; 
-static char k2_b3[] = {
-    0xB3, 0x07}; 
-static char k2_b6_1[] = {
-    0xB6, 0x14}; 
-static char k2_b7_1[] = {
-    0xB7, 0x15}; 
-static char k2_b8_1[] = {
-    0xB8, 0x24}; 
-static char k2_b9[] = {
-    0xB9, 0x24}; 
-static char k2_ba[] = {
-    0xBA, 0x14}; 
-static char k2_bf[] = {
-    0xBF, 0x01}; 
-static char k2_c3[] = {
-    0xC3, 0x06}; 
-static char k2_c2[] = {
-    0xC2, 0x00}; 
-static char k2_c0[] = {
-    0xC0, 0x00, 0x00}; 
-static char k2_bc_1[] = {
-    0xBC, 0x00, 0x80, 0x00}; 
-static char k2_bd[] = {
-    0xBD, 0x00, 0x80, 0x00}; 
-
-static char k2_d1[] = {
-    0xD1, 0x00, 0x58, 0x00, 0x64, 0x00, 0x76, 0x00, 0x88, 0x00,
-    0x99, 0x00, 0xB8, 0x00, 0xCD, 0x00, 0xFA, 0x01, 0x1A, 0x01,
-    0x4F, 0x01, 0x7D, 0x01, 0xC3, 0x01, 0xFF, 0x02, 0x01, 0x02,
-    0x3A, 0x02, 0x77, 0x02, 0x9E, 0x02, 0XD8, 0X02, 0xF6, 0x03,
-    0x23, 0x03, 0x53, 0x03, 0x79, 0x03, 0x91, 0x03, 0xB7, 0x03,
-    0xC3, 0x03, 0XF9};
-static char k2_d2[] = {
-    0xD2, 0x00, 0xB3, 0x00, 0xBA, 0x00, 0xC7, 0x00, 0xD3, 0x00,
-    0xDF, 0x00, 0xF5, 0x01, 0x01, 0x01, 0x24, 0x01, 0x3F, 0x01,
-    0x6B, 0x01, 0x92, 0x01, 0xD2, 0x02, 0x0B, 0x02, 0x0D, 0x02,
-    0x42, 0x02, 0x7E, 0x02, 0xA5, 0x02, 0xE0, 0x02, 0xFD, 0x03,
-    0x2B, 0x03, 0x58, 0x03, 0x7A, 0x03, 0x90, 0x03, 0xA8, 0x03,
-    0xC2, 0x03, 0xF8};
-static char k2_d3[] = {
-    0xD3, 0x00, 0x58, 0x00, 0x63, 0x00, 0x75, 0x00, 0x87, 0x00,
-    0x98, 0x00, 0xB7, 0x00, 0xCB, 0x00, 0xF8, 0x01, 0x18, 0x01,
-    0x4D, 0x01, 0x7A, 0x01, 0xC0, 0X01, 0xFD, 0x01, 0xFF, 0x02,
-    0x38, 0x02, 0x75, 0x02, 0x9D, 0x02, 0xDB, 0x02, 0xFC, 0x03,
-    0x30, 0x03, 0x63, 0x03, 0x8E, 0x03, 0xA6, 0x03, 0xCC, 0x03,
-    0XD8, 0x03, 0xF9};
-static char k2_d4[] = {
-    0xD4, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x1E, 0x00, 0x30, 0x00,
-    0x41, 0x00, 0x60, 0x00, 0x83, 0x00, 0xB0, 0x00, 0xDA, 0x01,
-    0x21, 0x01, 0x5B, 0x01, 0xB7, 0x01, 0xFF, 0x02, 0x01, 0x02,
-    0x46, 0x02, 0x89, 0x02, 0xB4, 0x02, 0xEE, 0x03, 0x12, 0x03,
-    0x45, 0x03, 0x53, 0x03, 0x79, 0x03, 0x91, 0x03, 0xB7, 0x03,
-    0xC3, 0x03, 0xF9};
-static char k2_d5[] = {
-    0xD5, 0x00, 0x5B, 0x00, 0x62, 0x00, 0x6F, 0x00, 0x78, 0x00,
-    0x87, 0x00, 0x9D, 0x00, 0xB7, 0x00, 0xDA, 0x00, 0xFF, 0x01,
-    0x3D, 0x01, 0x70, 0x01, 0xC6, 0x02, 0x0B, 0x02, 0x0D, 0x02,
-    0x4E, 0x02, 0x90, 0x02, 0xBB, 0x02, 0xF6, 0x03, 0x19, 0x03,
-    0x4D, 0x03, 0x58, 0x03, 0x7A, 0x03, 0x90, 0X03, 0xA9, 0x03,
-    0xC2, 0x03, 0xF8};
-static char k2_d6[] = {
-    0xD6, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x1D, 0x00, 0x2F, 0x00,
-    0x40, 0x00, 0x5F, 0x00, 0x81, 0x00, 0xAE, 0x00, 0xDB, 0x01,
-    0x1F, 0x01, 0x58, 0x01, 0xB4, 0x01, 0xFD, 0x01, 0xFF, 0x02,
-    0x44, 0x02, 0x87, 0x02, 0xB3, 0x02, 0xF1, 0x03, 0x18, 0x03,
-    0x52, 0x03, 0x63, 0x03, 0x8E, 0x03, 0xA6, 0x03, 0xCC, 0x03,
-    0xD8, 0x03, 0xF9};
-
-static char k2_f0_2[] = {
-    0xF0, 0x55, 0xAA, 0x52,
-    0x08, 0x00}; 
-static char k2_b6_2[] = {
-    0xB6, 0x03}; 
-static char k2_b7_2[] = {
-    0xB7, 0x70, 0x70}; 
-static char k2_b8_2[] = {
-    0xB8, 0x01, 0x06, 0x06,
-    0x06}; 
-static char k2_bc_2[] = {
-    0xBC, 0x00}; 
-static char k2_b0_2[] = {
-    0xB0, 0x00, 0x0A, 0x0E,
-    0x09, 0x04}; 
-static char k2_b1_2[] = {
-    0xB1, 0x60, 0x00, 0x01}; 
-static char k2_b4_2[] = {
-    0xB4, 0x10}; 
-
-static char k2_ff_1[] = {
-    0xFF, 0xAA, 0x55, 0xA5,
-    0x80}; 
-static char k2_f7[] = {
-    0xF7, 0x63, 0x40, 0x00,
-    0x00, 0x00, 0x01, 0xC4,
-    0xA2, 0x00, 0x02, 0x64,
-    0x54, 0x48, 0x00, 0xD0}; 
-static char k2_f8[] = {
-    0xF8, 0x00, 0x00, 0x33,
-    0x0F, 0x0F, 0x20, 0x00,
-    0x01, 0x00, 0x00, 0x20,
-    0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00}; 
-static char k2_ff_2[] = {
-    0xFF, 0xAA, 0x55, 0xA5,
-    0x00}; 
-
-static char k2_b7_3[] = {
-    0xB7, 0x02, 0x50}; 
-static char k2_bd_3[] = {
-    0xBD, 0x00, 0x00}; 
-static char k2_bc_3[] = {
-    0xBC, 0x00, 0x00}; 
-
-static char k2_peripheral_on[] = {0x00, 0x00}; 
-static char k2_peripheral_off[] = {0x00, 0x00}; 
-
-static struct dsi_cmd_desc k2_auo_display_on_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_f0_1), k2_f0_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b0_1), k2_b0_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b1_1), k2_b1_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b2), k2_b2},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b3), k2_b3},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b6_1), k2_b6_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b7_1), k2_b7_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b8_1), k2_b8_1},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b9), k2_b9},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_ba), k2_ba},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_bf), k2_bf},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_c3), k2_c3},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_c2), k2_c2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_c0), k2_c0},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_bc_1), k2_bc_1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_bd), k2_bd},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d1), k2_d1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d2), k2_d2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d3), k2_d3},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d4), k2_d4},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d5), k2_d5},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_d6), k2_d6},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_f0_2), k2_f0_2},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b6_2), k2_b6_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_b7_2), k2_b7_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_b8_2), k2_b8_2},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_bc_2), k2_bc_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_b0_2), k2_b0_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_b1_2), k2_b1_2},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(k2_b4_2), k2_b4_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_ff_1), k2_ff_1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_f7), k2_f7},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_f8), k2_f8},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_ff_2), k2_ff_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_b7_3), k2_b7_3},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_bd_3), k2_bd_3},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(k2_bc_3), k2_bc_3},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 1, sizeof(led_pwm2), led_pwm2},
-	{DTYPE_PERIPHERAL_ON, 1, 0, 1, 120, sizeof(k2_peripheral_on), k2_peripheral_on},
-};
-
-static struct dsi_cmd_desc k2_auo_display_off_cmds[] = {
-	{DTYPE_PERIPHERAL_OFF, 1, 0, 1, 70, sizeof(k2_peripheral_off), k2_peripheral_off},
-};
-
-static char set_threelane[2] = {0xBA, 0x02}; 
-
-#ifdef EVA_CMD_MODE_PANEL
-static char display_mode_cmd[2] = {0xC2, 0x08}; 
-#else
-static char display_mode_video[2] = {0xC2, 0x03}; 
-#endif
-
-static char enter_sleep[2] = {0x10, 0x00}; 
-static char exit_sleep[2] = {0x11, 0x00}; 
-static char display_on[2] = {0x29, 0x00}; 
-static char display_off[2] = {0x28, 0x00}; 
-
-static char enable_te[2] = {0x35, 0x00};
-
-static char swr01[2] = {0x01, 0x33};
-static char swr02[2] = {0x02, 0x53};
-
-static struct dsi_cmd_desc sony_display_on_cmds[] = {
-	{DTYPE_DCS_WRITE, 1, 0, 0, 40, sizeof(display_on), display_on},
-};
-
-static struct dsi_cmd_desc sony_panel_video_mode_cmds_id28103_ver008[] = {
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(set_threelane), set_threelane},
-#ifdef EVA_CMD_MODE_PANEL
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(display_mode_cmd), display_mode_cmd},
-#else
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(display_mode_video), display_mode_video},
-#endif
-
-#if 1
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFE, 0x08}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x18, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x19, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1A, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0x26}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x00, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x01, 0x07}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x0B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0x11}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x18}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x06, 0x27}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x07, 0x2A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x08, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x2F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x2C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0B, 0x24}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0C, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0D, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0E, 0x0C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0F, 0x07}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFE, 0x01}},
-#endif
-
-#if 1
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(swr01), swr01},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(swr02), swr02},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x75, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x76, 0xA3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x77, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x78, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x79, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7A, 0xB3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7B, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7C, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7E, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7F, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x80, 0xD5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x81, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x82, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x83, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x84, 0xE9}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x85, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x86, 0xF3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x87, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x88, 0x17}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x89, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8A, 0x36}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8B, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8C, 0x6A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8D, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8E, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8F, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x90, 0xDC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x91, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x92, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x93, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x94, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x95, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x96, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x97, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x98, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x99, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9A, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9B, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9C, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9E, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA0, 0x30}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA2, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA3, 0x41}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA4, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA5, 0x55}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA6, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA7, 0x6B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAA, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAC, 0xA0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAE, 0xC0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB0, 0xE5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB2, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB4, 0xA3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB6, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB8, 0xB3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBA, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBB, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBC, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBD, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBE, 0xD5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC0, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC2, 0xE9}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC4, 0xF3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC5, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC6, 0x17}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC7, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC8, 0x36}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC9, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCA, 0x6A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCC, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCD, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCE, 0xDC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD0, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD1, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD2, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD3, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD4, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD5, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD6, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD7, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD8, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD9, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDA, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDB, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDC, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDE, 0x30}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE0, 0x41}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE2, 0x55}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE3, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE4, 0x6B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE5, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE6, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE7, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE8, 0xA0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEA, 0xC0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEC, 0xE5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xED, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEE, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF0, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF2, 0x7F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF4, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF6, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF8, 0xBA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFA, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x00, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x01, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0xE6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0xF2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x06, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x07, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x08, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x3D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0B, 0x73}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0C, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0D, 0x9F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0E, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0F, 0xE4}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x10, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x11, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x12, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x13, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x14, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x15, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x16, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x17, 0x81}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x18, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x19, 0xA1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1A, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1B, 0xCC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1C, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1D, 0xEA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1E, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1F, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x20, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x21, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x22, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x23, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x24, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0x3E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x26, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x27, 0x4F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x28, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x29, 0x61}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2A, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2B, 0x8F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2F, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x30, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x31, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x32, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x33, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x34, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x35, 0x7F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x36, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x37, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x38, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x39, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3A, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3B, 0xBA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3F, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x40, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x41, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x42, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x43, 0xE6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x44, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x45, 0xF2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x46, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x47, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x48, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x49, 0x3D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4A, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4B, 0x73}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4C, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4D, 0x9F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4E, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4F, 0xE4}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x50, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x51, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x52, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x53, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x54, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x55, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x56, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x58, 0x81}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x59, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5A, 0xA1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5B, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5C, 0xCC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5E, 0xEA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x60, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x61, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x62, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x63, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x64, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x65, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x66, 0x3E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x67, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x68, 0x4F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x69, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6A, 0x61}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6B, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6C, 0x8F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6E, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x70, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x71, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x72, 0xAC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x73, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x74, 0xB2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x75, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x76, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x77, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x78, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x79, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7A, 0xD6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7B, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7C, 0xE1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7E, 0xEB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7F, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x80, 0xF5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x81, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x82, 0xFE}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x83, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x84, 0x1F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x85, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x86, 0x3C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x87, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x88, 0x70}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x89, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8A, 0x9C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8B, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8C, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8E, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8F, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x90, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x91, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x92, 0x52}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x93, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x94, 0x8A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x95, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x96, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x97, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x98, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x99, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9A, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9B, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9C, 0x34}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9E, 0x46}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA0, 0x5B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA2, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA3, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA4, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA5, 0x8C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA6, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA7, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAA, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAC, 0xF0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAE, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB0, 0xAC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB2, 0xB2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB4, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB6, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB8, 0xD6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBA, 0xE1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBB, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBC, 0xEB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBD, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBE, 0xF5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC0, 0xFE}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC1, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC2, 0x1F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC3, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC4, 0x3C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC5, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC6, 0x70}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC7, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC8, 0x9C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC9, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCA, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCB, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCC, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCD, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCE, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD0, 0x52}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD1, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD2, 0x8A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD3, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD4, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD5, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD6, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD7, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD8, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDA, 0x34}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDC, 0x46}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDE, 0x5B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE0, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE2, 0x8C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE3, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE4, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE5, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE6, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE7, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE8, 0xF0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEA, 0xFF}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x04}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x09}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	
-#endif
-
-#if 1
-#ifdef EVA_CMD_MODE_PANEL
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x05} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x8E} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0x8E} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x8E} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01} },
-#endif
-#endif
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-	{DTYPE_DCS_WRITE, 1, 0, 0, 100, sizeof(exit_sleep), exit_sleep},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0xEE} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x12, 0x33} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x13, 0x04} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1B, 0x30} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x39, 0x34} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x46, 0x00} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0xEE} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x12, 0x50} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x13, 0x02} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6A, 0x60} },
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x04} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0x2D} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x21, 0xFF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x22, 0xF7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x23, 0xEF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x24, 0xE7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0xDF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x26, 0xD7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x27, 0xCF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x28, 0xC7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x29, 0xBF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2A, 0xB7} },
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(enable_te), enable_te},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5E, 0x06} },
-
-	
-	
-
-	
-	
-
-	
-	
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x55,0x83}},
-
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x53, 0x24} },
-};
-
-static struct dsi_cmd_desc sony_panel_video_mode_cmds_c2[] = {
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(set_threelane), set_threelane},
-#ifdef EVA_CMD_MODE_PANEL
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(display_mode_cmd), display_mode_cmd},
-#else
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(display_mode_video), display_mode_video},
-#endif
-
-#if 1
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFE, 0x08}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x18, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x19, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1A, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0x26}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x00, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x01, 0x07}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x0B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0x11}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x18}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x06, 0x27}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x07, 0x2A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x08, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x2F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x2C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0B, 0x24}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0C, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0D, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0E, 0x0C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0F, 0x07}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFE, 0x01}},
-#endif
-
-#if 1
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(swr01), swr01},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(swr02), swr02},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x75, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x76, 0xA3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x77, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x78, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x79, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7A, 0xB3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7B, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7C, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7E, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7F, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x80, 0xD5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x81, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x82, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x83, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x84, 0xE9}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x85, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x86, 0xF3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x87, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x88, 0x17}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x89, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8A, 0x36}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8B, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8C, 0x6A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8D, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8E, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8F, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x90, 0xDC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x91, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x92, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x93, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x94, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x95, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x96, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x97, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x98, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x99, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9A, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9B, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9C, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9E, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA0, 0x30}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA2, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA3, 0x41}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA4, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA5, 0x55}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA6, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA7, 0x6B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAA, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAC, 0xA0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAE, 0xC0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB0, 0xE5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB2, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB4, 0xA3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB6, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB8, 0xB3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBA, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBB, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBC, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBD, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBE, 0xD5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC0, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC2, 0xE9}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC4, 0xF3}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC5, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC6, 0x17}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC7, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC8, 0x36}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC9, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCA, 0x6A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCC, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCD, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCE, 0xDC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD0, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD1, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD2, 0x19}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD3, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD4, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD5, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD6, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD7, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD8, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD9, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDA, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDB, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDC, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDE, 0x30}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE0, 0x41}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE2, 0x55}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE3, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE4, 0x6B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE5, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE6, 0x84}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE7, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE8, 0xA0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEA, 0xC0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEC, 0xE5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xED, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEE, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF0, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF2, 0x7F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF4, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF6, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF8, 0xBA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xF9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFA, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x00, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x01, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0xE6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0xF2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x06, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x07, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x08, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x3D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0B, 0x73}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0C, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0D, 0x9F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0E, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0F, 0xE4}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x10, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x11, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x12, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x13, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x14, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x15, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x16, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x17, 0x81}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x18, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x19, 0xA1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1A, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1B, 0xCC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1C, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1D, 0xEA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1E, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x1F, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x20, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x21, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x22, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x23, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x24, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0x3E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x26, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x27, 0x4F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x28, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x29, 0x61}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2A, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2B, 0x8F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2F, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x30, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x31, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x32, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x33, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x34, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x35, 0x7F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x36, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x37, 0x95}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x38, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x39, 0xA8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3A, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3B, 0xBA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x3F, 0xCA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x40, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x41, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x42, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x43, 0xE6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x44, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x45, 0xF2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x46, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x47, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x48, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x49, 0x3D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4A, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4B, 0x73}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4C, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4D, 0x9F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4E, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x4F, 0xE4}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x50, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x51, 0x1C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x52, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x53, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x54, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x55, 0x4E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x56, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x58, 0x81}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x59, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5A, 0xA1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5B, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5C, 0xCC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5E, 0xEA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x60, 0x13}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x61, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x62, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x63, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x64, 0x2E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x65, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x66, 0x3E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x67, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x68, 0x4F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x69, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6A, 0x61}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6B, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6C, 0x8F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6E, 0xDA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x70, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x71, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x72, 0xAC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x73, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x74, 0xB2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x75, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x76, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x77, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x78, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x79, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7A, 0xD6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7B, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7C, 0xE1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7D, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7E, 0xEB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x7F, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x80, 0xF5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x81, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x82, 0xFE}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x83, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x84, 0x1F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x85, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x86, 0x3C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x87, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x88, 0x70}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x89, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8A, 0x9C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8B, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8C, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8D, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8E, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x8F, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x90, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x91, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x92, 0x52}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x93, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x94, 0x8A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x95, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x96, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x97, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x98, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x99, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9A, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9B, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9C, 0x34}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9D, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9E, 0x46}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x9F, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA0, 0x5B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA2, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA3, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA4, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA5, 0x8C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA6, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA7, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xA9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAA, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAC, 0xF0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAE, 0xFF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xAF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB0, 0xAC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB1, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB2, 0xB2}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB3, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB4, 0xBF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB5, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB6, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB7, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB8, 0xD6}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xB9, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBA, 0xE1}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBB, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBC, 0xEB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBD, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBE, 0xF5}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xBF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC0, 0xFE}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC1, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC2, 0x1F}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC3, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC4, 0x3C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC5, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC6, 0x70}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC7, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC8, 0x9C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xC9, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCA, 0xDF}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCB, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCC, 0x1B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCD, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCE, 0x1D}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xCF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD0, 0x52}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD1, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD2, 0x8A}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD3, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD4, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD5, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD6, 0xD8}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD7, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD8, 0xFC}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xD9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDA, 0x34}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDB, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDC, 0x46}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDD, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDE, 0x5B}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xDF, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE0, 0x72}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE1, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE2, 0x8C}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE3, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE4, 0xAA}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE5, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE6, 0xCB}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE7, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE8, 0xF0}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xE9, 0x03}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xEA, 0xFF}},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x02}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x04}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x09, 0x20}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x0A, 0x09}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-	
-#endif
-
-#if 1
-#ifdef EVA_CMD_MODE_PANEL
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x05}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x02, 0x8E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x03, 0x8E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x04, 0x8E}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFB, 0x01}},
-#endif
-#endif
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-	{DTYPE_DCS_WRITE, 1, 0, 0, 100, sizeof(exit_sleep), exit_sleep},
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0xEE} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x12, 0x50} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x13, 0x02} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x6A, 0x60} },
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00} },
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x04} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x05, 0x2D} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x21, 0xFF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x22, 0xF7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x23, 0xEF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x24, 0xE7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x25, 0xDF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x26, 0xD7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x27, 0xCF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x28, 0xC7} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x29, 0xBF} },
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x2A, 0xB7} },
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0xFF, 0x00}},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(enable_te), enable_te},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x5E, 0x06}},
-
-	
-	
-
-	
-	
-
-	
-	
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x55,0x83}},
-
-
-	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, 2, (char[]){0x53, 0x24}},
-};
-
-static struct dsi_cmd_desc sony_display_off_cmds[] = {
-	{DTYPE_DCS_WRITE, 1, 0, 0, 0,
-		sizeof(display_off), display_off},
-	{DTYPE_DCS_WRITE, 1, 0, 0, 100,
-		sizeof(enter_sleep), enter_sleep}
-};
-
 
 static char manufacture_id[2] = {0x04, 0x00}; 
 
 static struct dsi_cmd_desc novatek_manufacture_id_cmd = {
 	DTYPE_DCS_READ, 1, 0, 1, 5, sizeof(manufacture_id), manufacture_id};
 
-static struct dcs_cmd_req cmdreq;
 static u32 manu_id;
 
-static void mipi_novatek_manufature_cb(u32 data)
+static void mipi_novatek_manufacture_cb(u32 data)
 {
 	manu_id = data;
-	pr_info("%s: manufature_id=%x\n", __func__, manu_id);
+	pr_info("%s: manufacture_id=%x\n", __func__, manu_id);
 }
 
 static uint32 mipi_novatek_manufacture_id(struct msm_fb_data_type *mfd)
 {
+	struct dcs_cmd_req cmdreq;
+
 	cmdreq.cmds = &novatek_manufacture_id_cmd;
 	cmdreq.cmds_cnt = 1;
 	cmdreq.flags = CMD_REQ_RX | CMD_REQ_COMMIT;
 	cmdreq.rlen = 3;
-	cmdreq.cb = mipi_novatek_manufature_cb;
+	cmdreq.cb = mipi_novatek_manufacture_cb; 
 	mipi_dsi_cmdlist_put(&cmdreq);
 
 	return manu_id;
@@ -1550,39 +380,12 @@
 					__func__);
 }
 
-static void mipi_novatek_panel_type_detect(struct mipi_panel_info *mipi)
-{
-	if (panel_type == PANEL_ID_K2_WL_AUO) {
-		PR_DISP_INFO("%s: panel_type=PANEL_ID_K2_WL_AUO\n", __func__);
-		strcat(ptype, "PANEL_ID_K2_WL_AUO");
-		if (mipi->mode == DSI_VIDEO_MODE) {
-			novatek_display_on_cmds = k2_auo_display_on_cmds;
-			novatek_display_on_cmds_size = ARRAY_SIZE(k2_auo_display_on_cmds);
-			novatek_display_off_cmds = k2_auo_display_off_cmds;
-			novatek_display_off_cmds_size = ARRAY_SIZE(k2_auo_display_off_cmds);
-		}
-	} else if (panel_type == PANEL_ID_ELITE_SONY_NT_C2) {
-		strcat(ptype, "PANEL_ID_ELITE_SONY_NT_C2");
-		PR_DISP_INFO("%s: assign initial setting for SONY_NT Cut2, %s\n", __func__, ptype);
-		novatek_display_on_cmds = sony_panel_video_mode_cmds_c2;
-		novatek_display_on_cmds_size = ARRAY_SIZE(sony_panel_video_mode_cmds_c2);
-		novatek_display_off_cmds = sony_display_off_cmds;
-		novatek_display_off_cmds_size = ARRAY_SIZE(sony_display_off_cmds);
-	} else if (panel_type == PANEL_ID_ELITE_SONY_NT_C1) {
-		strcat(ptype, "PANEL_ID_ELITE_SONY_NT_C1");
-		PR_DISP_INFO("%s: assign initial setting for SONY_NT id 0x28103 Cut1, %s\n", __func__, ptype);
-		novatek_display_on_cmds = sony_panel_video_mode_cmds_id28103_ver008;
-		novatek_display_on_cmds_size = ARRAY_SIZE(sony_panel_video_mode_cmds_id28103_ver008);
-		novatek_display_off_cmds = sony_display_off_cmds;
-		novatek_display_off_cmds_size = ARRAY_SIZE(sony_display_off_cmds);
-	}
-}
-
 static int mipi_novatek_lcd_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
 	struct mipi_panel_info *mipi;
 	struct msm_panel_info *pinfo;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 	if (!mfd)
@@ -1596,39 +399,32 @@
 
 	mipi  = &mfd->panel_info.mipi;
 
-	if (mfd->init_mipi_lcd == 0) {
-		PR_DISP_DEBUG("Display On - 1st time\n");
-
-		mipi_novatek_panel_type_detect(mipi);
-
-		mfd->init_mipi_lcd = 1;
-		return 0;
-	}
-
-	PR_DISP_INFO("Display On. (%s)\n", ptype);
-
 	if (mipi->mode == DSI_VIDEO_MODE) {
+		cmdreq.cmds = novatek_video_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(novatek_video_on_cmds);
+		cmdreq.flags = CMD_REQ_COMMIT;
+		cmdreq.rlen = 0;
+		cmdreq.cb = NULL;
+		mipi_dsi_cmdlist_put(&cmdreq);
 	} else {
-		cmdreq.cmds = novatek_display_on_cmds;
-		cmdreq.cmds_cnt = novatek_display_on_cmds_size;
+		cmdreq.cmds = novatek_cmd_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(novatek_cmd_on_cmds);
 		cmdreq.flags = CMD_REQ_COMMIT;
 		cmdreq.rlen = 0;
 		cmdreq.cb = NULL;
 		mipi_dsi_cmdlist_put(&cmdreq);
 
-		mipi_dsi_cmd_bta_sw_trigger(); 
-
+		
+		mipi_dsi_cmd_bta_sw_trigger();
 		mipi_novatek_manufacture_id(mfd);
 	}
-
-	PR_DISP_DEBUG("Init done!\n");
-
 	return 0;
 }
 
 static int mipi_novatek_lcd_off(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 
@@ -1638,7 +434,7 @@
 		return -EINVAL;
 
 	cmdreq.cmds = novatek_display_off_cmds;
-	cmdreq.cmds_cnt = novatek_display_off_cmds_size;
+	cmdreq.cmds_cnt = ARRAY_SIZE(novatek_display_off_cmds);
 	cmdreq.flags = CMD_REQ_COMMIT;
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
@@ -1648,42 +444,39 @@
 	return 0;
 }
 
-static void mipi_novatek_display_on(struct msm_fb_data_type *mfd)
+static int mipi_novatek_lcd_late_init(struct platform_device *pdev)
 {
-	mutex_lock(&mfd->dma->ov_mutex);
-
-	if (panel_type == PANEL_ID_ELITE_SONY_NT_C1
-			|| panel_type == PANEL_ID_ELITE_SONY_NT_C2)
-		mipi_dsi_cmds_tx(&novatek_tx_buf, sony_display_on_cmds,
-			ARRAY_SIZE(sony_display_on_cmds));
-
-	mutex_unlock(&mfd->dma->ov_mutex);
+	return 0;
 }
 
 DEFINE_LED_TRIGGER(bkl_led_trigger);
 
-static char led_pwm1[2] = {0x51, 0xF0};	
-static struct dsi_cmd_desc backlight_cmd[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 1, sizeof(led_pwm1), led_pwm1},
-};
+static char led_pwm1[2] = {0x51, 0x0};	
+static struct dsi_cmd_desc backlight_cmd = {
+	DTYPE_DCS_LWRITE, 1, 0, 0, 1, sizeof(led_pwm1), led_pwm1};
+
 
 static void mipi_novatek_set_backlight(struct msm_fb_data_type *mfd)
 {
-	if ((mipi_novatek_pdata && mipi_novatek_pdata->enable_wled_bl_ctrl)
+	struct dcs_cmd_req cmdreq;
+
+	if (mipi_novatek_pdata &&
+	    mipi_novatek_pdata->gpio_set_backlight) {
+		mipi_novatek_pdata->gpio_set_backlight(mfd->bl_level);
+		return;
+	}
+
+	if ((mipi_novatek_pdata->enable_wled_bl_ctrl)
 	    && (wled_trigger_initialized)) {
 		led_trigger_event(bkl_led_trigger, mfd->bl_level);
 		return;
 	}
 
-	
-	if (mipi_novatek_pdata && mipi_novatek_pdata->shrink_pwm)
-		led_pwm1[1] = mipi_novatek_pdata->shrink_pwm(mfd->bl_level);
-	else
-		led_pwm1[1] = (unsigned char)(mfd->bl_level);
+	led_pwm1[1] = (unsigned char)mfd->bl_level;
 
-	cmdreq.cmds = (struct dsi_cmd_desc*)&backlight_cmd;
+	cmdreq.cmds = &backlight_cmd;
 	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
@@ -1760,7 +553,7 @@
 static struct msm_fb_panel_data novatek_panel_data = {
 	.on		= mipi_novatek_lcd_on,
 	.off		= mipi_novatek_lcd_off,
-	.display_on = mipi_novatek_display_on,
+	.late_init	= mipi_novatek_lcd_late_init,
 	.set_backlight = mipi_novatek_set_backlight,
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -63,7 +63,7 @@
 	pinfo.is_3d_panel = FB_TYPE_3D_PANEL;
 	pinfo.lcd.vsync_enable = TRUE;
 	pinfo.lcd.hw_vsync_mode = TRUE;
-	pinfo.lcd.refx100 = 6000; 
+	pinfo.lcd.refx100 = 6200; 
 	pinfo.lcd.v_back_porch = 11;
 	pinfo.lcd.v_front_porch = 10;
 	pinfo.lcd.v_pulse_width = 5;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek_video_qhd_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek_video_qhd_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_novatek_video_qhd_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_novatek_video_qhd_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -481,6 +481,11 @@
 
 	mipi  = &mfd->panel_info.mipi;
 
+	if (!mfd->cont_splash_done) {
+		mfd->cont_splash_done = 1;
+		return 0;
+	}
+
 	if (mipi_nt35510_pdata && mipi_nt35510_pdata->rotate_panel)
 		rotate = mipi_nt35510_pdata->rotate_panel();
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510_cmd_wvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510_cmd_wvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510_cmd_wvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510_cmd_wvga_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510_video_wvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510_video_wvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_NT35510_video_wvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_NT35510_video_wvga_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise_cmd_720p_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise_cmd_720p_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise_cmd_720p_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise_cmd_720p_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise.h	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise_video_720p_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise_video_720p_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_orise_video_720p_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_orise_video_720p_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,328 +13,1140 @@
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mipi_renesas.h"
-#include "mdp4.h"
-#include <linux/i2c.h>
-#include <mach/debug_display.h>
-#include <mach/panel_id.h>
+#include <mach/socinfo.h>
 
-static struct mipi_dsi_panel_platform_data *mipi_renesas_pdata;
+#define RENESAS_CMD_DELAY 0 
+#define RENESAS_SLEEP_OFF_DELAY 50
+static struct msm_panel_common_pdata *mipi_renesas_pdata;
 
 static struct dsi_buf renesas_tx_buf;
 static struct dsi_buf renesas_rx_buf;
 
-static struct dsi_cmd_desc *renesas_video_on_cmds = NULL;
-static struct dsi_cmd_desc *renesas_display_off_cmds = NULL;
-int renesas_video_on_cmds_count = 0;
-int renesas_display_off_cmds_count = 0;
-
 static int mipi_renesas_lcd_init(void);
 
-static char enter_sleep[2] = {0x10, 0x00}; 
-static char exit_sleep[2] = {0x11, 0x00}; 
-static char display_off[2] = {0x28, 0x00}; 
-static char display_on[2] = {0x29, 0x00}; 
-
-static char write_display_brightnes[3]= {0x51, 0x0F, 0xFF};
-static char write_control_display[2] = {0x53, 0x24}; 
-static struct dsi_cmd_desc renesas_display_on_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(display_on), display_on},
-};
-static struct dsi_cmd_desc renesas_cmd_backlight_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(write_display_brightnes), write_display_brightnes},
+static char config_sleep_out[2] = {0x11, 0x00};
+static char config_CMD_MODE[2] = {0x40, 0x01};
+static char config_WRTXHT[7] = {0x92, 0x16, 0x08, 0x08, 0x00, 0x01, 0xe0};
+static char config_WRTXVT[7] = {0x8b, 0x02, 0x02, 0x02, 0x00, 0x03, 0x60};
+static char config_PLL2NR[2] = {0xa0, 0x24};
+static char config_PLL2NF1[2] = {0xa2, 0xd0};
+static char config_PLL2NF2[2] = {0xa4, 0x00};
+static char config_PLL2BWADJ1[2] = {0xa6, 0xd0};
+static char config_PLL2BWADJ2[2] = {0xa8, 0x00};
+static char config_PLL2CTL[2] = {0xaa, 0x00};
+static char config_DBICBR[2] = {0x48, 0x03};
+static char config_DBICTYPE[2] = {0x49, 0x00};
+static char config_DBICSET1[2] = {0x4a, 0x1c};
+static char config_DBICADD[2] = {0x4b, 0x00};
+static char config_DBICCTL[2] = {0x4e, 0x01};
+static char config_COLMOD_888[2] = {0x3a, 0x07};
+static char config_MADCTL[2] = {0x36, 0x00};
+static char config_DBIOC[2] = {0x82, 0x40};
+static char config_CASET[7] = {0x2a, 0x00, 0x00, 0x00, 0x00, 0x01, 0xdf };
+static char config_PASET[7] = {0x2b, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5f };
+static char config_TXON[2] = {0x81, 0x00};
+static char config_BLSET_TM[2] = {0xff, 0x6c};
+static char config_DSIRXCTL[2] = {0x41, 0x01};
+static char config_TEON[2] = {0x35, 0x00};
+static char config_TEOFF[1] = {0x34};
+
+static char config_AGCPSCTL_TM[2] = {0x56, 0x08};
+
+static char config_DBICADD70[2] = {0x4b, 0x70};
+static char config_DBICSET_15[2] = {0x4a, 0x15};
+static char config_DBICADD72[2] = {0x4b, 0x72};
+
+static char config_Power_Ctrl_2a_cmd[3] = {0x4c, 0x40, 0x10};
+static char config_Auto_Sequencer_Setting_a_cmd[3] = {0x4c, 0x00, 0x00};
+static char Driver_Output_Ctrl_indx[3] = {0x4c, 0x00, 0x01};
+static char Driver_Output_Ctrl_cmd[3] = {0x4c, 0x03, 0x10};
+static char config_LCD_drive_AC_Ctrl_indx[3] = {0x4c, 0x00, 0x02};
+static char config_LCD_drive_AC_Ctrl_cmd[3] = {0x4c, 0x01, 0x00};
+static char config_Entry_Mode_indx[3] = {0x4c, 0x00, 0x03};
+static char config_Entry_Mode_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_Display_Ctrl_1_indx[3] = {0x4c, 0x00, 0x07};
+static char config_Display_Ctrl_1_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_Display_Ctrl_2_indx[3] = {0x4c, 0x00, 0x08};
+static char config_Display_Ctrl_2_cmd[3] = {0x4c, 0x00, 0x04};
+static char config_Display_Ctrl_3_indx[3] = {0x4c, 0x00, 0x09};
+static char config_Display_Ctrl_3_cmd[3] = {0x4c, 0x00, 0x0c};
+static char config_Display_IF_Ctrl_1_indx[3] = {0x4c, 0x00, 0x0c};
+static char config_Display_IF_Ctrl_1_cmd[3] = {0x4c, 0x40, 0x10};
+static char config_Display_IF_Ctrl_2_indx[3] = {0x4c, 0x00, 0x0e};
+static char config_Display_IF_Ctrl_2_cmd[3] = {0x4c, 0x00, 0x00};
+
+static char config_Panel_IF_Ctrl_1_indx[3] = {0x4c, 0x00, 0x20};
+static char config_Panel_IF_Ctrl_1_cmd[3] = {0x4c, 0x01, 0x3f};
+static char config_Panel_IF_Ctrl_3_indx[3] = {0x4c, 0x00, 0x22};
+static char config_Panel_IF_Ctrl_3_cmd[3] = {0x4c, 0x76, 0x00};
+static char config_Panel_IF_Ctrl_4_indx[3] = {0x4c, 0x00, 0x23};
+static char config_Panel_IF_Ctrl_4_cmd[3] = {0x4c, 0x1c, 0x0a};
+static char config_Panel_IF_Ctrl_5_indx[3] = {0x4c, 0x00, 0x24};
+static char config_Panel_IF_Ctrl_5_cmd[3] = {0x4c, 0x1c, 0x2c};
+static char config_Panel_IF_Ctrl_6_indx[3] = {0x4c, 0x00, 0x25};
+static char config_Panel_IF_Ctrl_6_cmd[3] = {0x4c, 0x1c, 0x4e};
+static char config_Panel_IF_Ctrl_8_indx[3] = {0x4c, 0x00, 0x27};
+static char config_Panel_IF_Ctrl_8_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_Panel_IF_Ctrl_9_indx[3] = {0x4c, 0x00, 0x28};
+static char config_Panel_IF_Ctrl_9_cmd[3] = {0x4c, 0x76, 0x0c};
+
+
+static char config_gam_adjust_00_indx[3] = {0x4c, 0x03, 0x00};
+static char config_gam_adjust_00_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_gam_adjust_01_indx[3] = {0x4c, 0x03, 0x01};
+static char config_gam_adjust_01_cmd[3] = {0x4c, 0x05, 0x02};
+static char config_gam_adjust_02_indx[3] = {0x4c, 0x03, 0x02};
+static char config_gam_adjust_02_cmd[3] = {0x4c, 0x07, 0x05};
+static char config_gam_adjust_03_indx[3] = {0x4c, 0x03, 0x03};
+static char config_gam_adjust_03_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_gam_adjust_04_indx[3] = {0x4c, 0x03, 0x04};
+static char config_gam_adjust_04_cmd[3] = {0x4c, 0x02, 0x00};
+static char config_gam_adjust_05_indx[3] = {0x4c, 0x03, 0x05};
+static char config_gam_adjust_05_cmd[3] = {0x4c, 0x07, 0x07};
+static char config_gam_adjust_06_indx[3] = {0x4c, 0x03, 0x06};
+static char config_gam_adjust_06_cmd[3] = {0x4c, 0x10, 0x10};
+static char config_gam_adjust_07_indx[3] = {0x4c, 0x03, 0x07};
+static char config_gam_adjust_07_cmd[3] = {0x4c, 0x02, 0x02};
+static char config_gam_adjust_08_indx[3] = {0x4c, 0x03, 0x08};
+static char config_gam_adjust_08_cmd[3] = {0x4c, 0x07, 0x04};
+static char config_gam_adjust_09_indx[3] = {0x4c, 0x03, 0x09};
+static char config_gam_adjust_09_cmd[3] = {0x4c, 0x07, 0x07};
+static char config_gam_adjust_0A_indx[3] = {0x4c, 0x03, 0x0a};
+static char config_gam_adjust_0A_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_gam_adjust_0B_indx[3] = {0x4c, 0x03, 0x0b};
+static char config_gam_adjust_0B_cmd[3] = {0x4c, 0x00, 0x00};
+static char config_gam_adjust_0C_indx[3] = {0x4c, 0x03, 0x0c};
+static char config_gam_adjust_0C_cmd[3] = {0x4c, 0x07, 0x07};
+static char config_gam_adjust_0D_indx[3] = {0x4c, 0x03, 0x0d};
+static char config_gam_adjust_0D_cmd[3] = {0x4c, 0x10, 0x10};
+static char config_gam_adjust_10_indx[3] = {0x4c, 0x03, 0x10};
+static char config_gam_adjust_10_cmd[3] = {0x4c, 0x01, 0x04};
+static char config_gam_adjust_11_indx[3] = {0x4c, 0x03, 0x11};
+static char config_gam_adjust_11_cmd[3] = {0x4c, 0x05, 0x03};
+static char config_gam_adjust_12_indx[3] = {0x4c, 0x03, 0x12};
+static char config_gam_adjust_12_cmd[3] = {0x4c, 0x03, 0x04};
+static char config_gam_adjust_15_indx[3] = {0x4c, 0x03, 0x15};
+static char config_gam_adjust_15_cmd[3] = {0x4c, 0x03, 0x04};
+static char config_gam_adjust_16_indx[3] = {0x4c, 0x03, 0x16};
+static char config_gam_adjust_16_cmd[3] = {0x4c, 0x03, 0x1c};
+static char config_gam_adjust_17_indx[3] = {0x4c, 0x03, 0x17};
+static char config_gam_adjust_17_cmd[3] = {0x4c, 0x02, 0x04};
+static char config_gam_adjust_18_indx[3] = {0x4c, 0x03, 0x18};
+static char config_gam_adjust_18_cmd[3] = {0x4c, 0x04, 0x02};
+static char config_gam_adjust_19_indx[3] = {0x4c, 0x03, 0x19};
+static char config_gam_adjust_19_cmd[3] = {0x4c, 0x03, 0x05};
+static char config_gam_adjust_1C_indx[3] = {0x4c, 0x03, 0x1c};
+static char config_gam_adjust_1C_cmd[3] = {0x4c, 0x07, 0x07};
+static char config_gam_adjust_1D_indx[3] = {0x4c, 0x03, 0x1D};
+static char config_gam_adjust_1D_cmd[3] = {0x4c, 0x02, 0x1f};
+static char config_gam_adjust_20_indx[3] = {0x4c, 0x03, 0x20};
+static char config_gam_adjust_20_cmd[3] = {0x4c, 0x05, 0x07};
+static char config_gam_adjust_21_indx[3] = {0x4c, 0x03, 0x21};
+static char config_gam_adjust_21_cmd[3] = {0x4c, 0x06, 0x04};
+static char config_gam_adjust_22_indx[3] = {0x4c, 0x03, 0x22};
+static char config_gam_adjust_22_cmd[3] = {0x4c, 0x04, 0x05};
+static char config_gam_adjust_27_indx[3] = {0x4c, 0x03, 0x27};
+static char config_gam_adjust_27_cmd[3] = {0x4c, 0x02, 0x03};
+static char config_gam_adjust_28_indx[3] = {0x4c, 0x03, 0x28};
+static char config_gam_adjust_28_cmd[3] = {0x4c, 0x03, 0x00};
+static char config_gam_adjust_29_indx[3] = {0x4c, 0x03, 0x29};
+static char config_gam_adjust_29_cmd[3] = {0x4c, 0x00, 0x02};
+
+static char config_Power_Ctrl_1_indx[3] = {0x4c, 0x01, 0x00};
+static char config_Power_Ctrl_1b_cmd[3] = {0x4c, 0x36, 0x3c};
+static char config_Power_Ctrl_2_indx[3] = {0x4c, 0x01, 0x01};
+static char config_Power_Ctrl_2b_cmd[3] = {0x4c, 0x40, 0x03};
+static char config_Power_Ctrl_3_indx[3] = {0x4c, 0x01, 0x02};
+static char config_Power_Ctrl_3a_cmd[3] = {0x4c, 0x00, 0x01};
+static char config_Power_Ctrl_4_indx[3] = {0x4c, 0x01, 0x03};
+static char config_Power_Ctrl_4a_cmd[3] = {0x4c, 0x3c, 0x58};
+static char config_Power_Ctrl_6_indx[3] = {0x4c, 0x01, 0x0c};
+static char config_Power_Ctrl_6a_cmd[3] = {0x4c, 0x01, 0x35};
+
+static char config_Auto_Sequencer_Setting_b_cmd[3] = {0x4c, 0x00, 0x02};
+
+static char config_Panel_IF_Ctrl_10_indx[3] = {0x4c, 0x00, 0x29};
+static char config_Panel_IF_Ctrl_10a_cmd[3] = {0x4c, 0x03, 0xbf};
+static char config_Auto_Sequencer_Setting_indx[3] = {0x4c, 0x01, 0x06};
+static char config_Auto_Sequencer_Setting_c_cmd[3] = {0x4c, 0x00, 0x03};
+static char config_Power_Ctrl_2c_cmd[3] = {0x4c, 0x40, 0x10};
+
+static char config_VIDEO[2] = {0x40, 0x00};
+
+static char config_Panel_IF_Ctrl_10_indx_off[3] = {0x4C, 0x00, 0x29};
+
+static char config_Panel_IF_Ctrl_10b_cmd_off[3] = {0x4C, 0x00, 0x02};
+
+static char config_Power_Ctrl_1a_cmd[3] = {0x4C, 0x30, 0x00};
+
+static struct dsi_cmd_desc renesas_sleep_off_cmds[] = {
+	{DTYPE_DCS_WRITE, 1, 0, 0, RENESAS_SLEEP_OFF_DELAY,
+		sizeof(config_sleep_out), config_sleep_out }
 };
 
+static struct dsi_cmd_desc renesas_display_off_cmds[] = {
+	
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_CMD_MODE), config_CMD_MODE },
 
-static char interface_setting_0[2] = {0xB0, 0x04};
-#if 0
-static char interface_setting_1[7] = {
-	0xB3, 0x14, 0x00, 0x00,
-	0x00, 0x00, 0x00};
-static char interface_id_setting[3] = {
-	0xB4, 0x0C, 0x00};
-static char DSI_Control[3] = {
-	0xB6, 0x3A, 0xD3};
-static char External_Clock_Setting[3] = {
-	0xBB, 0x00, 0x10};
-static char Slew_rate_adjustment[3] = {
-	0xC0, 0x00, 0x00};
-static char Display_Setting1common[35] = {
-	0xC1, 0x04, 0x60, 0x40,
-	0x40, 0x0C, 0x00, 0x50,
-	0x02, 0x00, 0x00, 0x00,
-	0x5C, 0x63, 0xAC, 0x39,
-	0x00, 0x00, 0x50, 0x00,
-	0x00, 0x00, 0x86, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x40, 0x00, 0x02,
-	0x02, 0x02, 0x00};
-static char Display_Setting2[8]= {
-	0xC2, 0x32, 0xF7, 0x00,
-	0x00, 0x08, 0x00, 0x00};
-static char TPC_Sync_Control[4]= {
-	0xC3, 0x00, 0x00, 0x00};
-static char Source_Timing_Setting[23]= {
-	0xC4, 0x70, 0x00, 0x00,
-	0x05, 0x00, 0x05, 0x00,
-	0x00, 0x00, 0x05, 0x05,
-	0x00, 0x00, 0x00, 0x05,
-	0x00, 0x05, 0x00, 0x00,
-	0x00, 0x05, 0x05};
-static char LTPS_Timing_Setting[41]= {
-	0xC6, 0x01, 0x71, 0x07,
-	0x65, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x09, 0x19, 0x09,
-	0x01, 0xE0, 0x01, 0x71,
-	0x07, 0x65, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x09, 0x19,
-	0x09};
-static char Panal_PIN_Control[10]= {
-	0xCB, 0x66, 0xE0, 0x87,
-	0x61, 0x00, 0x00, 0x00,
-	0x00, 0xC0};
-static char Panel_Interface_Control[2] = {
-	0xCC, 0x03};
-static char GPO_Control[6]= {
-	0xCF, 0x00, 0x00, 0xC1,
-	0x05, 0x3F};
-static char Power_Setting_0[15]= {
-	0xD0, 0x00, 0x00, 0x19,
-	0x18, 0x99, 0x9C, 0x1C,
-	0x01, 0x81, 0x00, 0xBB,
-	0x56, 0x49, 0x01};
-static char Power_Setting_1[30]= {
-	0xD1, 0x20, 0x00, 0x00,
-	0x04, 0x08, 0x0C, 0x10,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x3C, 0x04, 0x20,
-	0x00, 0x00, 0x04, 0x08,
-	0x0C, 0x10, 0x00, 0x00,
-	0x3C, 0x06, 0x40, 0x00,
-	0x32, 0x31};
-static char Power_Setting_for_Internal_Power [35]= {
-	0xD3, 0x1B, 0x33, 0xBB,
-	0xBB, 0xB3, 0x33, 0x33,
-	0x33, 0x00, 0x01, 0x00,
-	0xA0, 0xD8, 0xA0, 0x00,
-	0x3F, 0x33, 0x33, 0x22,
-	0x70, 0x02, 0x37, 0x53,
-	0x3D, 0xBF, 0x99};
-static char VCOM_Setting[8]= {
-	0xD5, 0x06, 0x00, 0x00,
-	0x01, 0x2D, 0x01, 0x2D};
-static char Sequencer_Control[3]= {
-	0xD9, 0x20 ,0x00};
-static char Panel_syncronous_output_1[3]= {
-	0xEC, 0x40, 0x10};
-static char Panel_syncronous_output_2[4]= {
-	0xED, 0x00, 0x00, 0x00};
-static char Panel_syncronous_output_3[3]= {
-	0xEE, 0x00, 0x32};
-static char Panel_syncronous_output_4[13]= {
-	0xEF, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00};
-static char Backlght_Control_2[8]= {
-	0xB9, 0x0F, 0x18, 0x04,
-	0x40, 0x9F, 0x1F, 0x80};
-static char BackLight_Control_4[8]= {
-	0xBA, 0x0F, 0x18, 0x04,
-	0x40, 0x9F, 0x1F, 0xD7};
-static char Color_enhancement[33]= {
-	0xCA, 0x01, 0x80, 0xDC,
-	0xF0, 0xDC, 0xF0, 0xDC,
-	0xF0, 0x18, 0x3F, 0x14,
-	0x8A, 0x0A, 0x4A, 0x37,
-	0xA0, 0x55, 0xF8, 0x0C,
-	0x0C, 0x20, 0x10, 0x3F,
-	0x3F, 0x00, 0x00, 0x10,
-	0x10, 0x3F, 0x3F, 0x3F,
-	0x3F};
-static char BackLight_Control_6[8]= {
-	0xCE, 0x00, 0x07, 0x00,
-	0xC1, 0x24, 0xB2, 0x02};
-static char ContrastOptimize[7]= {
-	0xD8, 0x01, 0x80, 0x80,
-	0x40, 0x42, 0x21};
-static char Outline_Sharpening_Control[3]= {
-	0xDD, 0x31, 0xB3};
-static char Test_Image_Generator[7]= {
-	0xDE, 0x00, 0xFF, 0x07,
-	0x10, 0x00, 0x77};
-static char gamma_setting_red[25]= {
-	0xC7, 0x01, 0x0A, 0x11,
-	0x1A, 0x29, 0x45, 0x3B,
-	0x4E, 0x5B, 0x64, 0x6C,
-	0x75, 0x01, 0x0A, 0x11,
-	0x1A, 0x28, 0x41, 0x38,
-	0x4C, 0x59, 0x63, 0x6B,
-	0x74};
-static char gamma_setting_green[25]= {
-	0xC8, 0x01, 0x0A, 0x11,
-	0x1A, 0x29, 0x45, 0x3B,
-	0x4E, 0x5B, 0x64, 0x6C,
-	0x75, 0x01, 0x0A, 0x11,
-	0x1A, 0x28, 0x41, 0x38,
-	0x4C, 0x59, 0x63, 0x6B,
-	0x74};
-static char gamma_setting_blue[25]= {
-	0xC9, 0x01, 0x0A, 0x11,
-	0x1A, 0x29, 0x45, 0x3B,
-	0x4E, 0x5B, 0x64, 0x6C,
-	0x75, 0x01, 0x0A, 0x11,
-	0x1A, 0x28, 0x41, 0x38,
-	0x4C, 0x59, 0x63, 0x6B,
-	0x74};
-#endif
-static char BackLight_Control_6[8]= {
-	0xCE, 0x00, 0x07, 0x00,
-	0xC1, 0x24, 0xB2, 0x02};
-static char Manufacture_Command_setting[4] = {0xD6, 0x01};
-static char nop[4] = {0x00, 0x00};
-static char CABC[2] = {0x55, 0x00};
-static char hsync_output[4] = {0xC3, 0x01, 0x00, 0x10};
-static char protect_off[4] = {0xB0, 0x03};
-static char TE_OUT[4] = {0x35, 0x00};
-static char deep_standby_off[2] = {0xB1, 0x01};
-
-static struct dsi_cmd_desc sharp_video_on_cmds[] = {
-#if 0
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(interface_setting_0), interface_setting_0},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(interface_setting_1), interface_setting_1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(interface_id_setting), interface_id_setting},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(DSI_Control), DSI_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(External_Clock_Setting), External_Clock_Setting},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Slew_rate_adjustment), Slew_rate_adjustment},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Display_Setting1common), Display_Setting1common},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Display_Setting2), Display_Setting2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(TPC_Sync_Control), TPC_Sync_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Source_Timing_Setting), Source_Timing_Setting},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(LTPS_Timing_Setting), LTPS_Timing_Setting},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Panal_PIN_Control), Panal_PIN_Control},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(Panel_Interface_Control), Panel_Interface_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(GPO_Control), GPO_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Power_Setting_0), Power_Setting_0},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Power_Setting_1), Power_Setting_1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Power_Setting_for_Internal_Power), Power_Setting_for_Internal_Power},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(VCOM_Setting), VCOM_Setting},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Sequencer_Control), Sequencer_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Panel_syncronous_output_1), Panel_syncronous_output_1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Panel_syncronous_output_2), Panel_syncronous_output_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Panel_syncronous_output_3), Panel_syncronous_output_3},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Panel_syncronous_output_4), Panel_syncronous_output_4},
-
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Backlght_Control_2), Backlght_Control_2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(BackLight_Control_4), BackLight_Control_4},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Color_enhancement), Color_enhancement},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(BackLight_Control_6), BackLight_Control_6},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(ContrastOptimize), ContrastOptimize},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Outline_Sharpening_Control), Outline_Sharpening_Control},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(Test_Image_Generator), Test_Image_Generator},
-
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(gamma_setting_red), gamma_setting_red},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(gamma_setting_green), gamma_setting_green},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(gamma_setting_blue), gamma_setting_blue},
-
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(Manufacture_Command_setting), Manufacture_Command_setting},
-
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(write_display_brightnes), write_display_brightnes},
-#endif
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(interface_setting_0), interface_setting_0},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(BackLight_Control_6), BackLight_Control_6},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(Manufacture_Command_setting), Manufacture_Command_setting},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_indx),
+			config_Auto_Sequencer_Setting_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_b_cmd),
+			config_Auto_Sequencer_Setting_b_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY * 2,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_indx),
+			config_Auto_Sequencer_Setting_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_a_cmd),
+			config_Auto_Sequencer_Setting_a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_10_indx_off),
+			config_Panel_IF_Ctrl_10_indx_off},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_10b_cmd_off),
+				config_Panel_IF_Ctrl_10b_cmd_off},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1_indx),
+				config_Power_Ctrl_1_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1a_cmd),
+				config_Power_Ctrl_1a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_TEOFF), config_TEOFF},
+};
+
+static struct dsi_cmd_desc renesas_display_on_cmds[] = {
+	
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_CMD_MODE), config_CMD_MODE },
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_WRTXHT), config_WRTXHT },
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_WRTXVT), config_WRTXVT },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2NR), config_PLL2NR },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2NF1), config_PLL2NF1 },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2NF2), config_PLL2NF2 },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2BWADJ1), config_PLL2BWADJ1},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2BWADJ2), config_PLL2BWADJ2},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PLL2CTL), config_PLL2CTL},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICBR), config_DBICBR},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICTYPE), config_DBICTYPE},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET1), config_DBICSET1},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD), config_DBICADD},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICCTL), config_DBICCTL},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_COLMOD_888), config_COLMOD_888},
 	
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(write_control_display), write_control_display},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(CABC), CABC},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_MADCTL), config_MADCTL},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBIOC), config_DBIOC},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_CASET), config_CASET},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_PASET), config_PASET},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DSIRXCTL), config_DSIRXCTL},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_TEON), config_TEON},
+	{DTYPE_DCS_WRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_TXON), config_TXON},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_BLSET_TM), config_BLSET_TM},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_AGCPSCTL_TM), config_AGCPSCTL_TM},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1_indx), config_Power_Ctrl_1_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1a_cmd), config_Power_Ctrl_1a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2_indx), config_Power_Ctrl_2_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2a_cmd), config_Power_Ctrl_2a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_indx),
+			config_Auto_Sequencer_Setting_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_a_cmd),
+			config_Auto_Sequencer_Setting_a_cmd },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(Driver_Output_Ctrl_indx), Driver_Output_Ctrl_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(Driver_Output_Ctrl_cmd),
+			Driver_Output_Ctrl_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_LCD_drive_AC_Ctrl_indx),
+			config_LCD_drive_AC_Ctrl_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_LCD_drive_AC_Ctrl_cmd),
+			config_LCD_drive_AC_Ctrl_cmd },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Entry_Mode_indx),
+			config_Entry_Mode_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Entry_Mode_cmd),
+			config_Entry_Mode_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_1_indx),
+			config_Display_Ctrl_1_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_1_cmd),
+			config_Display_Ctrl_1_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_2_indx),
+			config_Display_Ctrl_2_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_2_cmd),
+			config_Display_Ctrl_2_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_3_indx),
+			config_Display_Ctrl_3_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_Ctrl_3_cmd),
+			config_Display_Ctrl_3_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_IF_Ctrl_1_indx),
+			config_Display_IF_Ctrl_1_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_IF_Ctrl_1_cmd),
+			config_Display_IF_Ctrl_1_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_IF_Ctrl_2_indx),
+			config_Display_IF_Ctrl_2_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Display_IF_Ctrl_2_cmd),
+			config_Display_IF_Ctrl_2_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_1_indx),
+			config_Panel_IF_Ctrl_1_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_1_cmd),
+			config_Panel_IF_Ctrl_1_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_3_indx),
+			config_Panel_IF_Ctrl_3_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_3_cmd),
+			config_Panel_IF_Ctrl_3_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_4_indx),
+			config_Panel_IF_Ctrl_4_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_4_cmd),
+			config_Panel_IF_Ctrl_4_cmd },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_5_indx),
+			config_Panel_IF_Ctrl_5_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_5_cmd),
+			config_Panel_IF_Ctrl_5_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_6_indx),
+			config_Panel_IF_Ctrl_6_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_6_cmd),
+			config_Panel_IF_Ctrl_6_cmd },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_8_indx),
+			config_Panel_IF_Ctrl_8_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_8_cmd),
+			config_Panel_IF_Ctrl_8_cmd },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_9_indx),
+			config_Panel_IF_Ctrl_9_indx },
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_9_cmd),
+			config_Panel_IF_Ctrl_9_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_00_indx),
+			config_gam_adjust_00_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_00_cmd),
+			config_gam_adjust_00_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_01_indx),
+			config_gam_adjust_01_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_01_cmd),
+			config_gam_adjust_01_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_02_indx),
+			config_gam_adjust_02_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_02_cmd),
+			config_gam_adjust_02_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_03_indx),
+			config_gam_adjust_03_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_03_cmd),
+			config_gam_adjust_03_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_04_indx), config_gam_adjust_04_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_04_cmd), config_gam_adjust_04_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_05_indx), config_gam_adjust_05_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_05_cmd), config_gam_adjust_05_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_06_indx), config_gam_adjust_06_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_06_cmd), config_gam_adjust_06_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_07_indx), config_gam_adjust_07_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_07_cmd), config_gam_adjust_07_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_08_indx), config_gam_adjust_08_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_08_cmd), config_gam_adjust_08_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_09_indx), config_gam_adjust_09_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_09_cmd), config_gam_adjust_09_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0A_indx), config_gam_adjust_0A_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0A_cmd), config_gam_adjust_0A_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0B_indx), config_gam_adjust_0B_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0B_cmd), config_gam_adjust_0B_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0C_indx), config_gam_adjust_0C_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0C_cmd), config_gam_adjust_0C_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0D_indx), config_gam_adjust_0D_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_0D_cmd), config_gam_adjust_0D_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_10_indx), config_gam_adjust_10_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_10_cmd), config_gam_adjust_10_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_11_indx), config_gam_adjust_11_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_11_cmd), config_gam_adjust_11_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_12_indx), config_gam_adjust_12_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_12_cmd), config_gam_adjust_12_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_15_indx), config_gam_adjust_15_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_15_cmd), config_gam_adjust_15_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_16_indx), config_gam_adjust_16_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_16_cmd), config_gam_adjust_16_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_17_indx), config_gam_adjust_17_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_17_cmd), config_gam_adjust_17_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_18_indx), config_gam_adjust_18_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_18_cmd), config_gam_adjust_18_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_19_indx), config_gam_adjust_19_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_19_cmd), config_gam_adjust_19_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_1C_indx), config_gam_adjust_1C_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_1C_cmd), config_gam_adjust_1C_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_1D_indx), config_gam_adjust_1D_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_1D_cmd), config_gam_adjust_1D_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_20_indx), config_gam_adjust_20_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_20_cmd), config_gam_adjust_20_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_21_indx), config_gam_adjust_21_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_21_cmd), config_gam_adjust_21_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_22_indx), config_gam_adjust_22_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_22_cmd), config_gam_adjust_22_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_27_indx), config_gam_adjust_27_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_27_cmd), config_gam_adjust_27_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_28_indx), config_gam_adjust_28_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_28_cmd), config_gam_adjust_28_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_29_indx), config_gam_adjust_29_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_gam_adjust_29_cmd), config_gam_adjust_29_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1_indx), config_Power_Ctrl_1_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_1b_cmd), config_Power_Ctrl_1b_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2_indx), config_Power_Ctrl_2_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2b_cmd), config_Power_Ctrl_2b_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_3_indx), config_Power_Ctrl_3_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_3a_cmd), config_Power_Ctrl_3a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_4_indx), config_Power_Ctrl_4_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_4a_cmd), config_Power_Ctrl_4a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_6_indx), config_Power_Ctrl_6_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_6a_cmd), config_Power_Ctrl_6a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_indx),
+			config_Auto_Sequencer_Setting_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_b_cmd),
+			config_Auto_Sequencer_Setting_b_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_10_indx),
+			config_Panel_IF_Ctrl_10_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Panel_IF_Ctrl_10a_cmd),
+			config_Panel_IF_Ctrl_10a_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_indx),
+			config_Auto_Sequencer_Setting_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Auto_Sequencer_Setting_c_cmd),
+			config_Auto_Sequencer_Setting_c_cmd},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD70), config_DBICADD70},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2_indx),
+			config_Power_Ctrl_2_indx},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_DBICADD72), config_DBICADD72},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_Power_Ctrl_2c_cmd),
+			config_Power_Ctrl_2c_cmd},
 
-        
-        {DTYPE_DCS_WRITE, 1, 0, 0, 0, sizeof(exit_sleep), exit_sleep},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 0,
+		sizeof(config_DBICSET_15), config_DBICSET_15},
 
 };
-static struct dsi_cmd_desc sony_video_on_cmds[] = {
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(interface_setting_0), interface_setting_0},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(hsync_output), hsync_output},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(BackLight_Control_6), BackLight_Control_6},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(Manufacture_Command_setting), Manufacture_Command_setting},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(protect_off), protect_off},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(CABC), CABC},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(write_control_display), write_control_display},
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(TE_OUT), TE_OUT},
-	{DTYPE_DCS_WRITE, 1, 0, 0, 0, sizeof(exit_sleep), exit_sleep},
-};
 
-static struct dsi_cmd_desc sharp_display_off_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 16,
-		sizeof(display_off), display_off},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 64,
-		sizeof(enter_sleep), enter_sleep}
+static char config_WRTXHT2[7] = {0x92, 0x15, 0x05, 0x0F, 0x00, 0x01, 0xe0};
+static char config_WRTXVT2[7] = {0x8b, 0x14, 0x01, 0x14, 0x00, 0x03, 0x60};
+
+static struct dsi_cmd_desc renesas_hvga_on_cmds[] = {
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_WRTXHT2), config_WRTXHT2},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_WRTXVT2), config_WRTXVT2},
 };
-static struct dsi_cmd_desc sony_display_off_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(display_off), display_off},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 48, sizeof(enter_sleep), enter_sleep},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(interface_setting_0), interface_setting_0},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(nop), nop},
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0, sizeof(deep_standby_off), deep_standby_off},
+
+static struct dsi_cmd_desc renesas_video_on_cmds[] = {
+{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_VIDEO), config_VIDEO}
 };
-#if 0
-static char manufacture_id[2] = {0x04, 0x00}; 
 
-static struct dsi_cmd_desc renesas_manufacture_id_cmd = {
-	DTYPE_DCS_READ, 1, 0, 1, 5, sizeof(manufacture_id), manufacture_id};
+static struct dsi_cmd_desc renesas_cmd_on_cmds[] = {
+{DTYPE_DCS_WRITE1, 1, 0, 0, RENESAS_CMD_DELAY,
+		sizeof(config_CMD_MODE), config_CMD_MODE},
+};
 
-static uint32 mipi_renesas_manufacture_id(struct msm_fb_data_type *mfd)
-{
-	struct dsi_buf *rp, *tp;
-	struct dsi_cmd_desc *cmd;
-	uint32 *lp;
-
-	tp = &renesas_tx_buf;
-	rp = &renesas_rx_buf;
-	cmd = &renesas_manufacture_id_cmd;
-	mipi_dsi_cmds_rx(mfd, tp, rp, cmd, 3);
-	lp = (uint32 *)rp->data;
-	pr_info("%s: manufacture_id=%x", __func__, *lp);
-	return *lp;
-}
-#endif
-static int resume_blk = 1;
-static int first_init = 1;
-struct i2c_client *pwm_client;
 static int mipi_renesas_lcd_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
 	struct mipi_panel_info *mipi;
 
 	mfd = platform_get_drvdata(pdev);
+	mipi  = &mfd->panel_info.mipi;
+
 	if (!mfd)
 		return -ENODEV;
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	mipi  = &mfd->panel_info.mipi;
+	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_sleep_off_cmds,
+			ARRAY_SIZE(renesas_sleep_off_cmds));
 
-	if (first_init)
-		first_init = 0;
-	else {
-		if (mipi->mode == DSI_VIDEO_MODE) {
-			mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_video_on_cmds,
-				renesas_video_on_cmds_count);
-		}
+	mipi_set_tx_power_mode(1);
+	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_display_on_cmds,
+			ARRAY_SIZE(renesas_display_on_cmds));
+
+	if (cpu_is_msmonarudox25a() || cpu_is_msmonarudox25aa() || cpu_is_msmonarudox25ab()) {
+		mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_hvga_on_cmds,
+			ARRAY_SIZE(renesas_hvga_on_cmds));
 	}
 
-	
-	PR_DISP_INFO("mipi_renesas_lcd_on\n");
+	if (mipi->mode == DSI_VIDEO_MODE)
+		mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_video_on_cmds,
+			ARRAY_SIZE(renesas_video_on_cmds));
+	else
+		mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_cmd_on_cmds,
+			ARRAY_SIZE(renesas_cmd_on_cmds));
+	mipi_set_tx_power_mode(0);
+
 	return 0;
 }
 
@@ -349,8 +1161,9 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	resume_blk = 1;
-	PR_DISP_INFO("mipi_renesas_lcd_off\n");
+	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_display_off_cmds,
+			ARRAY_SIZE(renesas_display_off_cmds));
+
 	return 0;
 }
 
@@ -366,98 +1179,19 @@
 	return 0;
 }
 
-static void renesas_display_on(struct msm_fb_data_type *mfd)
-{
-	
-	msleep(120);
-
-	mutex_lock(&mfd->dma->ov_mutex);
-	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_display_on_cmds,
-			ARRAY_SIZE(renesas_display_on_cmds));
-	mutex_unlock(&mfd->dma->ov_mutex);
-	PR_DISP_INFO("renesas_display_on\n");
-}
-
-static void renesas_display_off(struct msm_fb_data_type *mfd)
-{
-	mutex_lock(&mfd->dma->ov_mutex);
-	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_display_off_cmds,
-			renesas_display_off_cmds_count);
-
-	mutex_unlock(&mfd->dma->ov_mutex);
-	PR_DISP_INFO("renesas_display_off");
-}
-
-#define PWM_MIN                   6
-#define PWM_DEFAULT               102
-#define PWM_MAX                   255
-
-#define BRI_SETTING_MIN                 30
-#define BRI_SETTING_DEF                 143
-#define BRI_SETTING_MAX                 255
-
-static unsigned char renesas_shrink_pwm(int val)
-{
-        unsigned char shrink_br = BRI_SETTING_MAX;
-
-        if (val <= 0) {
-                shrink_br = 0;
-        } else if (val > 0 && (val < BRI_SETTING_MIN)) {
-                        shrink_br = PWM_MIN;
-        } else if ((val >= BRI_SETTING_MIN) && (val <= BRI_SETTING_DEF)) {
-                        shrink_br = (val - BRI_SETTING_MIN) * (PWM_DEFAULT - PWM_MIN) /
-                (BRI_SETTING_DEF - BRI_SETTING_MIN) + PWM_MIN;
-        } else if (val > BRI_SETTING_DEF && val <= BRI_SETTING_MAX) {
-                        shrink_br = (val - BRI_SETTING_DEF) * (PWM_MAX - PWM_DEFAULT) /
-                (BRI_SETTING_MAX - BRI_SETTING_DEF) + PWM_DEFAULT;
-        } else if (val > BRI_SETTING_MAX)
-                        shrink_br = PWM_MAX;
-
-        PR_DISP_INFO("brightness orig=%d, transformed=%d\n", val, shrink_br);
-
-        return shrink_br;
-}
-
 static void mipi_renesas_set_backlight(struct msm_fb_data_type *mfd)
 {
-	struct mipi_panel_info *mipi;
-	int rc;
-
-	mipi  = &mfd->panel_info.mipi;
-
-	mutex_lock(&mfd->dma->ov_mutex);
-	if (mdp4_overlay_dsi_state_get() <= ST_DSI_SUSPEND) {
-		mutex_unlock(&mfd->dma->ov_mutex);
-		return;
-	 }
-
-	write_display_brightnes[2] = renesas_shrink_pwm(mfd->bl_level);
-
-	if (resume_blk) {
-		resume_blk = 0;
-		rc = i2c_smbus_write_byte_data(pwm_client, 0x10, 0xC5);
-		if (rc)
-			pr_err("i2c write fail\n");
-		rc = i2c_smbus_write_byte_data(pwm_client, 0x19, 0x13);
-		if (rc)
-			pr_err("i2c write fail\n");
-		rc = i2c_smbus_write_byte_data(pwm_client, 0x14, 0xC2);
-		if (rc)
-			pr_err("i2c write fail\n");
-		rc = i2c_smbus_write_byte_data(pwm_client, 0x79, 0xFF);
-		if (rc)
-			pr_err("i2c write fail\n");
-		rc = i2c_smbus_write_byte_data(pwm_client, 0x1D, 0xFA);
-		if (rc)
-			pr_err("i2c write fail\n");
-	}
+	int ret = -EPERM;
+	int bl_level;
 
-	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_cmd_backlight_cmds,
-			ARRAY_SIZE(renesas_cmd_backlight_cmds));
+	bl_level = mfd->bl_level;
 
-	mutex_unlock(&mfd->dma->ov_mutex);
-	return;
+	if (mipi_renesas_pdata && mipi_renesas_pdata->pmic_backlight)
+		ret = mipi_renesas_pdata->pmic_backlight(bl_level);
+	else
+		pr_err("%s(): Backlight level set failed", __func__);
 }
+
 static struct platform_driver this_driver = {
 	.probe  = mipi_renesas_lcd_probe,
 	.driver = {
@@ -469,11 +1203,8 @@
 	.on		= mipi_renesas_lcd_on,
 	.off	= mipi_renesas_lcd_off,
 	.set_backlight = mipi_renesas_set_backlight,
-	.display_on = renesas_display_on,
-	.display_off = renesas_display_off,
 };
 
-
 static int ch_used[3];
 
 int mipi_renesas_device_register(struct msm_panel_info *pinfo,
@@ -481,7 +1212,6 @@
 {
 	struct platform_device *pdev = NULL;
 	int ret;
-
 	if ((channel >= 3) || ch_used[channel])
 		return -ENODEV;
 
@@ -518,67 +1248,11 @@
 	platform_device_put(pdev);
 	return ret;
 }
-static const struct i2c_device_id pwm_i2c_id[] = {
-	{ "pwm_i2c", 0 },
-	{ }
-};
-
-static int pwm_i2c_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	int rc;
-
-	if (!i2c_check_functionality(client->adapter,
-				     I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))
-		return -ENODEV;
-	pwm_client = client;
 
-	return rc;
-}
-
-static struct i2c_driver pwm_i2c_driver = {
-	.driver = {
-		.name = "pwm_i2c",
-		.owner = THIS_MODULE,
-	},
-	.probe = pwm_i2c_probe,
-	.remove =  __exit_p( pwm_i2c_remove),
-	.id_table =  pwm_i2c_id,
-};
-static void __exit pwm_i2c_remove(void)
-{
-	i2c_del_driver(&pwm_i2c_driver);
-}
 static int mipi_renesas_lcd_init(void)
 {
-	int ret;
-
 	mipi_dsi_buf_alloc(&renesas_tx_buf, DSI_BUF_SIZE);
 	mipi_dsi_buf_alloc(&renesas_rx_buf, DSI_BUF_SIZE);
-	ret = i2c_add_driver(&pwm_i2c_driver);
-
-	if (ret)
-		pr_err(KERN_ERR "%s: failed to add i2c driver\n", __func__);
-
-	if (panel_type == PANEL_ID_DLX_SHARP_RENESAS ) {
-		renesas_video_on_cmds = sharp_video_on_cmds;
-		renesas_display_off_cmds = sharp_display_off_cmds;
-		renesas_video_on_cmds_count = ARRAY_SIZE(sharp_video_on_cmds);
-		renesas_display_off_cmds_count =ARRAY_SIZE(sharp_display_off_cmds);
-		PR_DISP_INFO("panel_type = PANEL_ID_DLX_SHARP_RENESAS");
-	} else if (panel_type == PANEL_ID_DLX_SONY_RENESAS ) {
-		renesas_video_on_cmds = sony_video_on_cmds;
-		renesas_display_off_cmds = sony_display_off_cmds;
-		renesas_video_on_cmds_count = ARRAY_SIZE(sony_video_on_cmds);
-		renesas_display_off_cmds_count =ARRAY_SIZE(sony_display_off_cmds);
-		PR_DISP_INFO("panel_type = PANEL_ID_DLX_SONY_RENESAS");
-	} else {
-		renesas_video_on_cmds = sharp_video_on_cmds;
-		renesas_display_off_cmds = sharp_display_off_cmds;
-		renesas_video_on_cmds_count = ARRAY_SIZE(sharp_video_on_cmds);
-		renesas_display_off_cmds_count =ARRAY_SIZE(sharp_display_off_cmds);
-		PR_DISP_INFO("Default panel_type = PANEL_ID_DLX_SHARP_RENESAS");
-	}
 
 	return platform_driver_register(&this_driver);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas_video_fwvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas_video_fwvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_renesas_video_fwvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_renesas_video_fwvga_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,25 +13,46 @@
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mipi_renesas.h"
-#include <mach/panel_id.h>
 
 static struct msm_panel_info pinfo;
 
 static struct mipi_dsi_phy_ctrl dsi_video_mode_phy_db = {
+#ifdef CONFIG_FB_MSM_MDP303
 	
 	
-	{0x03, 0x08, 0x05, 0x00, 0x20},
+	{0x03, 0x01, 0x01, 0x00},
 	
-	{0xDD, 0x51, 0x27, 0x00, 0x6E, 0x74, 0x2C,
-	0x55, 0x3E, 0x3, 0x4, 0xA0},
+	{0xb9, 0x8e, 0x1f, 0x00, 0x98, 0x9c, 0x22, 0x90,
+	0x18, 0x03, 0x04},
 	
-	{0x5F, 0x00, 0x00, 0x10},
+	{0x7f, 0x00, 0x00, 0x00},
 	
-	{0xFF, 0x00, 0x06, 0x00},
+	{0xbb, 0x02, 0x06, 0x00},
 	
-	{0x00, 0x38, 0x32, 0xDA, 0x00, 0x10, 0x0F, 0x61,
-	0x41, 0x0F, 0x01,
-	0x00, 0x1A, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x02 },
+	{0x00, 0xec, 0x31, 0xd2, 0x00, 0x40, 0x37, 0x62,
+	0x01, 0x0f, 0x07,
+	0x05, 0x14, 0x03, 0x0, 0x0, 0x0, 0x20, 0x0, 0x02, 0x0},
+#else
+	
+	
+	{0x03, 0x01, 0x01, 0x00},
+	
+	{0xaa, 0x3b, 0x1b, 0x00, 0x52, 0x58, 0x20, 0x3f,
+	0x2e, 0x03, 0x04},
+	
+	{0x7f, 0x00, 0x00, 0x00},
+	
+	{0xee, 0x00, 0x86, 0x00},
+	
+	{0x40, 0xc7, 0xb0, 0xda, 0x00, 0x50, 0x48, 0x63,
+#if defined(RENESAS_FWVGA_TWO_LANE)
+	0x30, 0x07, 0x03,
+#else
+	
+	0x30, 0x07, 0x07,
+#endif
+	0x05, 0x14, 0x03, 0x0, 0x0, 0x54, 0x06, 0x10, 0x04, 0x0},
+#endif
 };
 
 static int __init mipi_video_renesas_fwvga_pt_init(void)
@@ -41,64 +62,95 @@
 	if (msm_fb_detect_client("mipi_video_renesas_fwvga"))
 		return 0;
 
-	pinfo.xres = 1080;
-	pinfo.yres = 1920;
+	pinfo.xres = 480;
+	pinfo.yres = 864;
 	pinfo.type = MIPI_VIDEO_PANEL;
 	pinfo.pdest = DISPLAY_1;
 	pinfo.wait_cycle = 0;
 	pinfo.bpp = 24;
-	pinfo.lcdc.h_back_porch = 58;
+#ifdef CONFIG_FB_MSM_MDP303
+	pinfo.lcdc.h_back_porch = 100;
 	pinfo.lcdc.h_front_porch = 100;
-	pinfo.lcdc.h_pulse_width = 10;
-        if (panel_type == PANEL_ID_DLX_SHARP_RENESAS ) {
-		pinfo.lcdc.v_back_porch = 4;
-		pinfo.lcdc.v_front_porch = 4;
-		pinfo.lcdc.v_pulse_width = 2;
-
-		pinfo.lcd.v_back_porch = 4;
-		pinfo.lcd.v_front_porch = 4;
-		pinfo.lcd.v_pulse_width = 2;
-	} else {
-                pinfo.lcdc.v_back_porch = 3;
-                pinfo.lcdc.v_front_porch = 3;
-                pinfo.lcdc.v_pulse_width = 2;
-
-                pinfo.lcd.v_back_porch = 3;
-                pinfo.lcd.v_front_porch = 3;
-	        pinfo.lcd.v_pulse_width = 2;
-	}
+	pinfo.lcdc.h_pulse_width = 8;
+	pinfo.lcdc.v_back_porch = 20;
+	pinfo.lcdc.v_front_porch = 20;
+	pinfo.lcdc.v_pulse_width = 1;
+	pinfo.clk_rate = 499000000;
+#else
+
+#if defined(RENESAS_FWVGA_TWO_LANE)
+	pinfo.lcdc.h_back_porch = 400;
+#else
+	pinfo.lcdc.h_back_porch = 50;
+#endif
+	pinfo.lcdc.h_front_porch = 50;
+
+#if defined(RENESAS_FWVGA_TWO_LANE)
+	pinfo.lcdc.h_pulse_width = 5;
+#else
+	pinfo.lcdc.h_pulse_width = 20;
+#endif
+
+#if defined(RENESAS_FWVGA_TWO_LANE)
+	pinfo.lcdc.v_back_porch = 75;
+	pinfo.lcdc.v_front_porch = 5;
+	pinfo.lcdc.v_pulse_width = 1;
+#else
+	pinfo.lcdc.v_back_porch = 10;
+	pinfo.lcdc.v_front_porch = 10;
+	pinfo.lcdc.v_pulse_width = 5;
+#endif
+
+#endif
 	pinfo.lcdc.border_clr = 0;	
 	pinfo.lcdc.underflow_clr = 0xff;	
 	pinfo.lcdc.hsync_skew = 0;
 	pinfo.bl_max = 255;
 	pinfo.bl_min = 1;
 	pinfo.fb_num = 2;
-	pinfo.clk_rate = 860000000;
 
 	pinfo.mipi.mode = DSI_VIDEO_MODE;
 	pinfo.mipi.pulse_mode_hsa_he = TRUE;
-	pinfo.mipi.hfp_power_stop = FALSE;
-	pinfo.mipi.hbp_power_stop = FALSE;
+	pinfo.mipi.hfp_power_stop = TRUE;
+	pinfo.mipi.hbp_power_stop = TRUE;
 	pinfo.mipi.hsa_power_stop = TRUE;
 	pinfo.mipi.eof_bllp_power_stop = TRUE;
 	pinfo.mipi.bllp_power_stop = TRUE;
-	pinfo.mipi.traffic_mode = DSI_NON_BURST_SYNCH_EVENT;
-	pinfo.mipi.dst_format = DSI_VIDEO_DST_FORMAT_RGB888;
+#ifdef CONFIG_FB_MSM_MDP303
+	pinfo.mipi.traffic_mode = DSI_BURST_MODE;
+	pinfo.mipi.dst_format =  DSI_VIDEO_DST_FORMAT_RGB888;
 	pinfo.mipi.vc = 0;
 	pinfo.mipi.rgb_swap = DSI_RGB_SWAP_RGB;
 	pinfo.mipi.data_lane0 = TRUE;
 	pinfo.mipi.data_lane1 = TRUE;
-	pinfo.mipi.data_lane2 = TRUE;
-	pinfo.mipi.data_lane3 = TRUE;
-
-	pinfo.mipi.tx_eot_append = TRUE;
-	pinfo.mipi.t_clk_post = 0x05;
-	pinfo.mipi.t_clk_pre = 0x2D;
+	pinfo.mipi.t_clk_post = 0x20;
+	pinfo.mipi.t_clk_pre = 0x2F;
+	pinfo.mipi.stream = 0; 
+	pinfo.mipi.mdp_trigger = DSI_CMD_TRIGGER_NONE;
+	pinfo.mipi.dma_trigger = DSI_CMD_TRIGGER_SW;
+	pinfo.mipi.frame_rate = 60;
+	pinfo.mipi.dsi_phy_db = &dsi_video_mode_phy_db;
+	pinfo.mipi.dlane_swap = 0x01;
+	pinfo.mipi.tx_eot_append = 0x01;
+#else
+	pinfo.mipi.traffic_mode = DSI_NON_BURST_SYNCH_PULSE;
+	pinfo.mipi.dst_format = DSI_VIDEO_DST_FORMAT_RGB888;
+	pinfo.mipi.vc = 0;
+	pinfo.mipi.rgb_swap = DSI_RGB_SWAP_BGR;
+	pinfo.mipi.data_lane0 = TRUE;
+#if defined(RENESAS_FWVGA_TWO_LANE)
+	pinfo.mipi.data_lane1 = TRUE;
+#else
+	pinfo.mipi.data_lane1 = FALSE;
+#endif
+	pinfo.mipi.t_clk_post = 0x03;
+	pinfo.mipi.t_clk_pre = 0x24;
 	pinfo.mipi.stream = 0; 
 	pinfo.mipi.mdp_trigger = DSI_CMD_TRIGGER_SW;
 	pinfo.mipi.dma_trigger = DSI_CMD_TRIGGER_SW;
 	pinfo.mipi.frame_rate = 60;
 	pinfo.mipi.dsi_phy_db = &dsi_video_mode_phy_db;
+#endif
 
 	ret = mipi_renesas_device_register(&pinfo, MIPI_DSI_PRIM,
 						MIPI_DSI_PANEL_FWVGA_PT);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator_video.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator_video.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_simulator_video.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_simulator_video.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_tc358764_dsi2lvds.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_tc358764_dsi2lvds.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_tc358764_dsi2lvds.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_tc358764_dsi2lvds.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_tc358764_dsi2lvds.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_tc358764_dsi2lvds.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_tc358764_dsi2lvds.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_tc358764_dsi2lvds.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -184,6 +184,7 @@
 static int mipi_toshiba_lcd_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 
@@ -192,24 +193,36 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WVGA_PT)
-		mipi_dsi_cmds_tx(&toshiba_tx_buf,
-			toshiba_wvga_display_on_cmds,
-			ARRAY_SIZE(toshiba_wvga_display_on_cmds));
-	else if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WSVGA_PT ||
-		TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WUXGA)
-		mipi_dsi_cmds_tx(&toshiba_tx_buf,
-			toshiba_wsvga_display_on_cmds,
-			ARRAY_SIZE(toshiba_wsvga_display_on_cmds));
-	else
+	if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WVGA_PT) {
+		cmdreq.cmds = toshiba_wvga_display_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_wvga_display_on_cmds);
+		cmdreq.flags = CMD_REQ_COMMIT;
+		cmdreq.rlen = 0;
+		cmdreq.cb = NULL;
+		mipi_dsi_cmdlist_put(&cmdreq);
+	} else if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WSVGA_PT ||
+		TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WUXGA) {
+		cmdreq.cmds = toshiba_wsvga_display_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_wsvga_display_on_cmds);
+		cmdreq.flags = CMD_REQ_COMMIT;
+		cmdreq.rlen = 0;
+		cmdreq.cb = NULL;
+		mipi_dsi_cmdlist_put(&cmdreq);
+	} else
 		return -EINVAL;
 
 	return 0;
 }
 
+static int mipi_toshiba_early_off(struct platform_device *pdev)
+{
+	return 0;
+}
+
 static int mipi_toshiba_lcd_off(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 
@@ -218,9 +231,18 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	mipi_dsi_cmds_tx(&toshiba_tx_buf, toshiba_display_off_cmds,
-			ARRAY_SIZE(toshiba_display_off_cmds));
+	cmdreq.cmds = toshiba_display_off_cmds;
+	cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_display_off_cmds);
+	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
 
+	mipi_dsi_cmdlist_put(&cmdreq);
+	return 0;
+}
+
+static int mipi_toshiba_lcd_late_init(struct platform_device *pdev)
+{
 	return 0;
 }
 
@@ -296,6 +318,8 @@
 static struct msm_fb_panel_data toshiba_panel_data = {
 	.on		= mipi_toshiba_lcd_on,
 	.off		= mipi_toshiba_lcd_off,
+	.late_init	= mipi_toshiba_lcd_late_init,
+	.early_off	= mipi_toshiba_early_off,
 	.set_backlight  = mipi_toshiba_set_backlight,
 };
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,5 +1,5 @@
 
-/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wsvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wsvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wsvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wsvga_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wuxga.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wuxga.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wuxga.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wuxga.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_toshiba_video_wvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_toshiba_video_wvga_pt.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly.h	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly_video_wvga_pt.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly_video_wvga_pt.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/mipi_truly_video_wvga_pt.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/mipi_truly_video_wvga_pt.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_dss_io_8960.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_dss_io_8960.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_dss_io_8960.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_dss_io_8960.c	2013-08-01 23:38:02.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -322,7 +322,10 @@
 }
 
 #define PREF_DIV_RATIO 27
+#define VCO_MINIMUM 600
 struct dsiphy_pll_divider_config pll_divider_config;
+u32 vco_level_100;
+u32 vco_min_allowed;
 
 int mipi_dsi_phy_pll_config(u32 clk_rate)
 {
@@ -364,10 +367,35 @@
 	return 0;
 }
 
+void mipi_dsi_configure_fb_divider(u32 fps_level)
+{
+	u32 fb_div_req, fb_div_req_by_2;
+	u32 vco_required;
+
+	vco_required = vco_level_100 * fps_level/100;
+	if (vco_required < vco_min_allowed) {
+		printk(KERN_WARNING "Can not change fps. Min level allowed is \
+	%d \n", (vco_min_allowed * 100 / vco_level_100) + 1);
+		return;
+	}
+
+	fb_div_req = vco_required * PREF_DIV_RATIO / 27;
+	fb_div_req_by_2 = (fb_div_req / 2) - 1;
+
+	pll_divider_config.fb_divider = fb_div_req;
+
+	
+	MIPI_OUTP(MIPI_DSI_BASE + 0x204, fb_div_req_by_2 & 0xff);
+	wmb();
+}
+
 int mipi_dsi_clk_div_config(uint8 bpp, uint8 lanes,
 			    uint32 *expected_dsi_pclk)
 {
 	u32 fb_divider, rate, vco;
+	u32 fb_div_min, fb_div_by_2_min,
+			 fb_div_by_2;
+	u32 vco_level_75;
 	u32 div_ratio = 0;
 	struct dsi_clk_mnd_table const *mnd_entry = mnd_table;
 	if (pll_divider_config.clk_rate == 0)
@@ -410,6 +438,17 @@
 	pll_divider_config.dsi_clk_divider =
 			(mnd_entry->dsiclk_div) * div_ratio;
 
+	vco_level_100 = vco;
+	fb_div_by_2 = (fb_divider / 2) - 1;
+	fb_div_by_2_min = (fb_div_by_2 / 256) * 256;
+	fb_div_min = (fb_div_by_2_min + 1) * 2;
+	vco_min_allowed = (fb_div_min * 27 / PREF_DIV_RATIO);
+	vco_level_75 = vco_level_100 * 75 / 100;
+	if (vco_min_allowed < VCO_MINIMUM)
+		vco_min_allowed = VCO_MINIMUM;
+	if (vco_min_allowed < vco_level_75)
+		vco_min_allowed = vco_level_75;
+
 	if (mnd_entry->dsiclk_d == 0) {
 		dsicore_clk.mnd_mode = 0;
 		dsicore_clk.src = 0x3;
@@ -605,6 +644,12 @@
 {
 	static int cont_splash_clks_enabled;
 	if (enable && !cont_splash_clks_enabled) {
+		if (clk_set_rate(dsi_byte_div_clk, 1) < 0)      
+			pr_err("%s: dsi_byte_div_clk - "
+				"clk_set_rate failed\n", __func__);
+		if (clk_set_rate(dsi_esc_clk, esc_byte_ratio) < 0) 
+			pr_err("%s: dsi_esc_clk - "                      
+				"clk_set_rate failed\n", __func__);
 			clk_prepare_enable(dsi_byte_div_clk);
 			clk_prepare_enable(dsi_esc_clk);
 			cont_splash_clks_enabled = 1;
@@ -620,8 +665,6 @@
 	clk_prepare(amp_pclk);
 	clk_prepare(dsi_m_pclk);
 	clk_prepare(dsi_s_pclk);
-	clk_prepare(dsi_byte_div_clk);
-	clk_prepare(dsi_esc_clk);
 }
 
 void mipi_dsi_unprepare_clocks(void)
@@ -669,16 +712,16 @@
 	MIPI_OUTP(MIPI_DSI_BASE + 0x0200, pll_ctrl | 0x01);
 	mipi_dsi_phy_rdy_poll();
 
-	if (clk_set_rate(dsi_byte_div_clk, 1) < 0)	
+	if (clk_set_rate(dsi_byte_div_clk, 1) < 0)      
 		pr_err("%s: dsi_byte_div_clk - "
 			"clk_set_rate failed\n", __func__);
 	if (clk_set_rate(dsi_esc_clk, esc_byte_ratio) < 0) 
-		pr_err("%s: dsi_esc_clk - "			 
+		pr_err("%s: dsi_esc_clk - "                      
 			"clk_set_rate failed\n", __func__);
 	mipi_dsi_pclk_ctrl(&dsi_pclk, 1);
 	mipi_dsi_clk_ctrl(&dsicore_clk, 1);
-	clk_enable(dsi_byte_div_clk);
-	clk_enable(dsi_esc_clk);
+	clk_prepare_enable(dsi_byte_div_clk);
+	clk_prepare_enable(dsi_esc_clk);
 	mipi_dsi_clk_on = 1;
 	mdp4_stat.dsi_clk_on++;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,5 @@
-/* drivers/video/msm/msm_fb.c
+/*
+ * drivers/video/msm/msm_fb.c
  *
  * Core MSM framebuffer driver.
  *
@@ -45,10 +46,6 @@
 #include <linux/sw_sync.h>
 #include <linux/file.h>
 
-#include <linux/cm3629.h>
-#include <linux/pm_qos.h>
-#include <mach/perflock.h>
-
 #define MSM_FB_C
 #include "msm_fb.h"
 #include "mddihosti.h"
@@ -70,12 +67,11 @@
 static struct delayed_work esd_dw;
 void esd_wq_routine(struct work_struct *work);
 #endif
-extern int get_lightsensoradc(void);
+int get_lightsensoradc(void);
 static unsigned char *fbram;
 static unsigned char *fbram_phys;
 static int fbram_size;
 static boolean bf_supported;
-static struct mutex msm_fb_blank_mutex;
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
@@ -105,21 +101,6 @@
 
 u32 mddi_msg_level = 5;
 
-#define PERF_EXPIRE_TICK 2
-static const unsigned long perf_qos_duration = 300;
-
-struct display_perflock {
-	unsigned int expire_tick;
-
-	struct pm_qos_request qos_req;
-	struct perf_lock lock_0; 
-	struct perf_lock lock_more; 
-	struct delayed_work worker;
-
-	int lock_stat;
-	struct perf_lock *activelock;
-} perflock_pan;
-
 extern int32 mdp_block_power_cnt[MDP_MAX_BLOCK];
 extern unsigned long mdp_timer_duration;
 extern boolean mdp_suspended;
@@ -140,7 +121,6 @@
 static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg);
 static int msm_fb_mmap(struct fb_info *info, struct vm_area_struct * vma);
-void msm_fb_shutdown(struct platform_device *pdev);
 static int mdp_bl_scale_config(struct msm_fb_data_type *mfd,
 						struct mdp_bl_scale_data *data);
 static void msm_fb_commit_wq_handler(struct work_struct *work);
@@ -184,15 +164,17 @@
 #define MSM_FB_MAX_DBGFS 1024
 #define MAX_BACKLIGHT_BRIGHTNESS 255
 
-#define WAIT_FENCE_TIMEOUT 800
-#define WAIT_DISP_OP_TIMEOUT 900
+#define WAIT_FENCE_FIRST_TIMEOUT MSEC_PER_SEC
+#define WAIT_FENCE_FINAL_TIMEOUT 10 * MSEC_PER_SEC
+#define WAIT_DISP_OP_TIMEOUT (WAIT_FENCE_FIRST_TIMEOUT +\
+        WAIT_FENCE_FINAL_TIMEOUT) * MDP_MAX_FENCE_FD
 #define MAX_TIMELINE_NAME_LEN 16
 
 int msm_fb_debugfs_file_index;
 struct dentry *msm_fb_debugfs_root;
 struct dentry *msm_fb_debugfs_file[MSM_FB_MAX_DBGFS];
 static int bl_scale, bl_min_lvl;
-DEFINE_SEMAPHORE(msm_fb_pan_sem);
+
 DEFINE_MUTEX(msm_fb_notify_update_sem);
 void msmfb_no_update_notify_timer_cb(unsigned long data)
 {
@@ -406,16 +388,19 @@
 	struct msm_fb_data_type *mfd = dev_get_drvdata(led_cdev->dev->parent);
 	int bl_lvl;
 
-	if (value > MAX_BACKLIGHT_BRIGHTNESS)
-		value = MAX_BACKLIGHT_BRIGHTNESS;
-
-	bl_lvl = (2 * value * mfd->panel_info.bl_max + MAX_BACKLIGHT_BRIGHTNESS)
-		/(2 * MAX_BACKLIGHT_BRIGHTNESS);
-
-	if (!bl_lvl && value)
-		bl_lvl = 1;
+	if (value <= 0)
+		bl_lvl = 0;
+	else if (value >= MAX_BACKLIGHT_BRIGHTNESS)
+		bl_lvl = mfd->panel_info.bl_max;
+	else
+		bl_lvl = mfd->panel_info.bl_min + ((value - 1) * 2 *
+			(mfd->panel_info.bl_max - mfd->panel_info.bl_min) +
+			MAX_BACKLIGHT_BRIGHTNESS - 1) /
+			(MAX_BACKLIGHT_BRIGHTNESS - 1) / 2;
 
+        down(&mfd->sem);
 	msm_fb_set_backlight(mfd, bl_lvl);
+	up(&mfd->sem);
 }
 
 static struct led_classdev backlight_led = {
@@ -504,6 +489,7 @@
 
 static struct msm_fb_platform_data *msm_fb_pdata;
 unsigned char hdmi_prim_display;
+unsigned char hdmi_prim_resolution;
 
 int msm_fb_detect_client(const char *name)
 {
@@ -524,6 +510,8 @@
 			if (!strncmp((char *)msm_fb_pdata->prim_panel_name,
 				"hdmi_msm", len))
 				hdmi_prim_display = 1;
+				hdmi_prim_resolution =
+					msm_fb_pdata->ext_resolution;
 			return 0;
 		} else {
 			ret = -EPERM;
@@ -556,6 +544,28 @@
 	return ret;
 }
 
+static ssize_t msm_fb_fps_level_change(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
+	struct msm_fb_panel_data *pdata =
+		(struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+	unsigned long val;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	if ((val <= 0) || (val > 100))
+		return -EINVAL;
+	if (pdata->fps_level_change)
+		pdata->fps_level_change(mfd->pdev, (u32)val);
+	return count;
+}
+
 static ssize_t msm_fb_msm_fb_type(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -609,44 +619,13 @@
 
 	return ret;
 }
-static ssize_t perfhint_show(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	int ret = 0;
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-
-	ret = snprintf(buf, PAGE_SIZE,
-		    "PerfHint: %d, Lock Stat: %d\n",
-		    mfd->perfhint, perflock_pan.lock_stat);
-	return ret;
-}
-
-static ssize_t perfhint_set(struct device *dev,
-			  struct device_attribute *attr, const char *buf,
-			  size_t count)
-{
-	ssize_t ret = count;
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	int new_val = 0;
-
-	if (mfd->index == 0) { 
-		new_val = simple_strtol(buf, NULL, 10);
-	}
-	pr_debug("%s: fb[%d] set from %d to %d\n",
-	    __func__, mfd->index, mfd->perfhint, new_val);
-	mfd->perfhint = new_val;
-
-	return ret;
-}
 
 static DEVICE_ATTR(msm_fb_type, S_IRUGO, msm_fb_msm_fb_type, NULL);
-static DEVICE_ATTR(perfhint, S_IRUGO | S_IWUSR, perfhint_show, perfhint_set);
-
+static DEVICE_ATTR(msm_fb_fps_level, S_IRUGO | S_IWUSR, NULL, \
+				msm_fb_fps_level_change);
 static struct attribute *msm_fb_attrs[] = {
 	&dev_attr_msm_fb_type.attr,
-	&dev_attr_perfhint.attr,
+	&dev_attr_msm_fb_fps_level.attr,
 	NULL,
 };
 static struct attribute_group msm_fb_attr_group = {
@@ -704,49 +683,13 @@
 static void sre_update(unsigned long data)
 {
    struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)data;
-   queue_work(mfd->sre_wq, &mfd->sre_work);
-}
-
-static int msm_fb_update_perflock_locked(int newlock)
-{
-	if (perflock_pan.lock_stat == newlock)
-		return 0; 
-
-	
-	if (perflock_pan.activelock)
-		perf_unlock(perflock_pan.activelock);
-
-	perflock_pan.activelock = NULL;
-	if (newlock == MSM_FB_PERFORMANCE_NORMAL) {
-		perflock_pan.activelock = &perflock_pan.lock_0;
-	} else if (newlock == MSM_FB_PERFORMANCE_MORE) {
-		perflock_pan.activelock = &perflock_pan.lock_more;
-	}
-
-	
-	if (perflock_pan.activelock) {
-		perf_lock(perflock_pan.activelock);
 
-		if (perflock_pan.lock_stat == MSM_FB_PERFORMANCE_NONE) {
-			schedule_delayed_work(&perflock_pan.worker,
-					msecs_to_jiffies(perf_qos_duration));
-		}
-	}
-
-	perflock_pan.lock_stat = newlock;
-	return 1;
-}
+   if (!mfd->panel_power_on) {
+	PR_DISP_INFO("%s: skip sre_work\n", __func__);
+	return;
+   }
 
-static void msm_fb_perflock_reaper(struct work_struct *work)
-{
-	down(&msm_fb_pan_sem);
-	if (--perflock_pan.expire_tick) {
-		schedule_delayed_work(&perflock_pan.worker,
-					msecs_to_jiffies(perf_qos_duration));
-	} else {
-		msm_fb_update_perflock_locked(MSM_FB_PERFORMANCE_NONE);
-	}
-	up(&msm_fb_pan_sem);
+   queue_work(mfd->sre_wq, &mfd->sre_work);
 }
 
 static int msm_fb_probe(struct platform_device *pdev)
@@ -760,32 +703,31 @@
 
 	if ((pdev->id == 0) && (pdev->num_resources > 0)) {
 		msm_fb_pdata = pdev->dev.platform_data;
-		fbram_size =
-			pdev->resource[0].end - pdev->resource[0].start + 1;
-		fbram_phys = (char *)pdev->resource[0].start;
-		fbram = __va(fbram_phys);
-
-		if (!fbram) {
-			printk(KERN_ERR "fbram ioremap failed!\n");
-			return -ENOMEM;
+		if (pdev->resource[0].start) {
+			fbram_size =
+				pdev->resource[0].end -
+				pdev->resource[0].start + 1;
+			fbram_phys = (char *)pdev->resource[0].start;
+			fbram = __va(fbram_phys);
+
+			if (!fbram) {
+				printk(KERN_ERR "fbram ioremap failed!\n");
+				return -ENOMEM;
+			}
+		} else {
+			fbram_size = 0;
+			fbram_phys = NULL;
+			fbram = NULL;
 		}
 		MSM_FB_DEBUG("msm_fb_probe:  phy_Addr = 0x%x virt = 0x%x\n",
 			     (int)fbram_phys, (int)fbram);
 
-#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION
 		iclient = msm_ion_client_create(-1, pdev->name);
 		if (IS_ERR_OR_NULL(iclient)) {
 			pr_err("msm_ion_client_create() return"
 				" error, val %p\n", iclient);
 			iclient = NULL;
 		}
-#endif
-
-		pm_qos_add_request(&perflock_pan.qos_req, PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
-		perf_lock_init(&perflock_pan.lock_0, TYPE_PERF_LOCK, PERF_LOCK_LOWEST, "perflock_0");
-		perf_lock_init(&perflock_pan.lock_more, TYPE_PERF_LOCK, PERF_LOCK_MEDIUM, "perflock_more");
-		INIT_DELAYED_WORK(&perflock_pan.worker, msm_fb_perflock_reaper);
-		perflock_pan.lock_stat = MSM_FB_PERFORMANCE_NONE;
 
 		msm_fb_resource_initialized = 1;
 		return 0;
@@ -810,10 +752,8 @@
 			backlightvalue = mfd->panel_info.camera_backlight;
 	}
 
+	vsync_cntrl.dev = mfd->fbi->dev;
 	mfd->panel_info.frame_count = 0;
-	
-	mfd->width = mfd->panel_info.width;
-	mfd->height = mfd->panel_info.height;
 
 	mfd->bl_level = 0;
 	bl_scale = 1024;
@@ -884,7 +824,6 @@
 
 	pdev_list[pdev_list_cnt++] = pdev;
 	msm_fb_create_sysfs(pdev);
-#ifdef CONFIG_SW_SYNC
 	if (mfd->timeline == NULL) {
 		char timeline_name[MAX_TIMELINE_NAME_LEN];
 		snprintf(timeline_name, sizeof(timeline_name),
@@ -897,9 +836,6 @@
 			mfd->timeline_value = 0;
 		}
 	}
-#endif
-
-	mutex_init(&msm_fb_blank_mutex);
 
 #ifdef CONFIG_FB_MSM_ESD_WORKAROUND
 	if((pdata) && (pdata->esd_workaround) && (pdata->panel_info.type == MIPI_CMD_PANEL)) {
@@ -925,13 +861,15 @@
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
+	msm_fb_pan_idle(mfd);
+
 	msm_fb_remove_sysfs(pdev);
 
+	pm_runtime_disable(mfd->fbi->dev);
+
 	if (!mfd)
 		return -ENODEV;
 
-	pm_runtime_disable(mfd->fbi->dev);
-
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
@@ -976,13 +914,6 @@
 		debugfs_remove(mfd->sub_dir);
 #endif
 
-	if (pdev->id == 0) {
-		
-		cancel_delayed_work(&perflock_pan.worker);
-		msm_fb_update_perflock_locked(MSM_FB_PERFORMANCE_NONE);
-		pm_qos_remove_request(&perflock_pan.qos_req);
-	}
-
 	return 0;
 }
 
@@ -999,6 +930,8 @@
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
 
+	msm_fb_pan_idle(mfd);
+
 	console_lock();
 	fb_set_suspend(mfd->fbi, FBINFO_STATE_SUSPENDED);
 
@@ -1015,29 +948,6 @@
 }
 #else
 #define msm_fb_suspend NULL
-void msm_fb_shutdown(struct platform_device *pdev)
-{
-	struct msm_fb_data_type *mfd;
-	int ret;
-
-	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
-
-	if ((!mfd) || (mfd->key != MFD_KEY))
-		return;
-
-	console_lock();
-	fb_set_suspend(mfd->fbi, FBINFO_STATE_SUSPENDED);
-
-	ret = msm_fb_suspend_sub(mfd);
-	if (ret != 0) {
-		printk(KERN_ERR "msm_fb: failed to suspend! %d\n", ret);
-		fb_set_suspend(mfd->fbi, FBINFO_STATE_RUNNING);
-	} else {
-		pdev->dev.power.power_state = PMSG_SUSPEND;
-	}
-
-	console_unlock();
-}
 #endif
 
 static int msm_fb_suspend_sub(struct msm_fb_data_type *mfd)
@@ -1047,13 +957,15 @@
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
 
-	if (mfd->msmfb_no_update_notify_timer.function)
-		del_timer(&mfd->msmfb_no_update_notify_timer);
-	complete(&mfd->msmfb_no_update_notify);
-
 	mfd->suspend.sw_refreshing_enable = mfd->sw_refreshing_enable;
 	mfd->suspend.op_enable = mfd->op_enable;
-	mfd->suspend.panel_power_on = mfd->panel_power_on;
+
+	if (mfd->panel_info.type == HDMI_PANEL ||
+	    mfd->panel_info.type == DTV_PANEL)
+		mfd->suspend.panel_power_on = false;
+	else
+		mfd->suspend.panel_power_on = mfd->panel_power_on;
+
 	mfd->suspend.op_suspend = true;
 
 	if (mfd->op_enable) {
@@ -1106,12 +1018,16 @@
 	mfd->op_enable = mfd->suspend.op_enable;
 
 	if (mfd->suspend.panel_power_on) {
+		if (mfd->panel_driver_on == FALSE)
+			msm_fb_blank_sub(FB_BLANK_POWERDOWN, mfd->fbi,
+				      mfd->op_enable);
 		ret =
 		     msm_fb_blank_sub(FB_BLANK_UNBLANK, mfd->fbi,
 				      mfd->op_enable);
 		if (ret)
 			MSM_FB_INFO("msm_fb_resume: can't turn on display!\n");
 	}
+
 	mfd->suspend.op_suspend = false;
 
 	return ret;
@@ -1131,6 +1047,8 @@
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
 
+	msm_fb_pan_idle(mfd);
+
 	console_lock();
 	ret = msm_fb_resume_sub(mfd);
 	pdev->dev.power.power_state = PMSG_ON;
@@ -1168,8 +1086,15 @@
 	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
+	if (hdmi_prim_display) {
+		MSM_FB_INFO("%s: hdmi primary handles early suspend only\n",
+			__func__);
+		return 0;
+	}
+
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
+	msm_fb_pan_idle(mfd);
 
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if (mfd->panel_info.type == HDMI_PANEL ||
@@ -1193,9 +1118,15 @@
 	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
-	if ((!mfd) || (mfd->key != MFD_KEY))
+	if (hdmi_prim_display) {
+		MSM_FB_INFO("%s: hdmi primary handles early resume only\n",
+			__func__);
 		return 0;
+	}
 
+	if ((!mfd) || (mfd->key != MFD_KEY))
+		return 0;
+	msm_fb_pan_idle(mfd);
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if (mfd->panel_info.type == HDMI_PANEL ||
 		mfd->panel_info.type == DTV_PANEL) {
@@ -1217,7 +1148,8 @@
 	.runtime_suspend = msm_fb_runtime_suspend,
 	.runtime_resume = msm_fb_runtime_resume,
 	.runtime_idle = msm_fb_runtime_idle,
-#if (defined(CONFIG_SUSPEND) && defined(CONFIG_FB_MSM_HDMI_MSM_PANEL))
+#if (defined(CONFIG_SUSPEND) && defined(CONFIG_FB_MSM_HDMI_MSM_PANEL) && \
+	!defined(CONFIG_FB_MSM_HDMI_AS_PRIMARY))
 	.suspend = msm_fb_ext_suspend,
 	.resume = msm_fb_ext_resume,
 #endif
@@ -1230,7 +1162,7 @@
 	.suspend = msm_fb_suspend,
 	.resume = msm_fb_resume,
 #endif
-	.shutdown = msm_fb_shutdown,
+	.shutdown = NULL,
 	.driver = {
 		   
 		   .name = "msm_fb",
@@ -1251,21 +1183,23 @@
 static void msmfb_early_suspend(struct early_suspend *h)
 {
 	struct msm_fb_data_type *mfd = container_of(h, struct msm_fb_data_type,
-						    early_suspend);
-#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
+						early_suspend);
 	struct msm_fb_panel_data *pdata = (struct msm_fb_panel_data *)mfd->pdev->
 						dev.platform_data;
-#endif
 
+	msm_fb_pan_idle(mfd);
 #if defined(CONFIG_FB_MSM_MDP303)
 	struct fb_info *fbi = mfd->fbi;
 	switch (mfd->fbi->var.bits_per_pixel) {
 	case 32:
-		memset32_io((void *)fbi->screen_base, 0xFF000000,
-							fbi->fix.smem_len);
+		if (fbi->screen_base)
+			memset32_io((void *)fbi->screen_base, 0xFF000000,
+				    fbi->fix.smem_len);
 		break;
 	default:
-		memset32_io((void *)fbi->screen_base, 0x00, fbi->fix.smem_len);
+		if (fbi->screen_base)
+			memset32_io((void *)fbi->screen_base, 0x00,
+				    fbi->fix.smem_len);
 		break;
 	}
 #endif
@@ -1276,27 +1210,44 @@
 #endif
 
 	msm_fb_suspend_sub(mfd);
+
+	if (hdmi_prim_display &&
+		(mfd->panel_info.type == HDMI_PANEL ||
+		 mfd->panel_info.type == DTV_PANEL)) {
+		
+		if (pdata->power_ctrl) {
+			MSM_FB_INFO("%s: Turning off HPD circuitry\n",
+				__func__);
+			pdata->power_ctrl(FALSE);
+		}
+	}
 }
 
 static void msmfb_early_resume(struct early_suspend *h)
 {
 	struct msm_fb_data_type *mfd = container_of(h, struct msm_fb_data_type,
-						    early_suspend);
-#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
+						early_suspend);
 	struct msm_fb_panel_data *pdata = NULL;
 
-	if (mfd && mfd->key == MFD_KEY)
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
-						dev.platform_data;
-#endif
+	msm_fb_pan_idle(mfd);
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+	if (hdmi_prim_display &&
+		(mfd->panel_info.type == HDMI_PANEL ||
+		 mfd->panel_info.type == DTV_PANEL)) {
+		
+		if (pdata->power_ctrl) {
+			MSM_FB_INFO("%s: Turning on HPD circuitry\n", __func__);
+			pdata->power_ctrl(TRUE);
+		}
+	}
+
 	msm_fb_resume_sub(mfd);
 
 #ifdef CONFIG_FB_MSM_ESD_WORKAROUND
-	if(pdata && pdata->esd_workaround)
+	if(mfd->key == MFD_KEY && pdata && pdata->esd_workaround)
 		queue_delayed_work(esd_wq, &esd_dw, msecs_to_jiffies(5000));
 #endif
 }
-
 #ifdef CONFIG_HTC_ONMODE_CHARGING
 static void msmfb_onchg_suspend(struct early_suspend *h)
 {
@@ -1363,7 +1314,9 @@
 						struct mdp_bl_scale_data *data)
 {
 	int ret = 0;
-	int curr_bl = mfd->bl_level;
+	int curr_bl;
+	down(&mfd->sem);
+	curr_bl = mfd->bl_level;
 	bl_scale = data->scale;
 	bl_min_lvl = data->min_lvl;
 	pr_debug("%s: update scale = %d, min_lvl = %d\n", __func__, bl_scale,
@@ -1371,6 +1324,7 @@
 
 	
 	msm_fb_set_backlight(mfd, curr_bl);
+	up(&mfd->sem);
 
 	return ret;
 }
@@ -1378,6 +1332,7 @@
 static void msm_fb_scale_bl(__u32 *bl_lvl)
 {
 	__u32 temp = *bl_lvl;
+	pr_debug("%s: input = %d, scale = %d", __func__, temp, bl_scale);
 	if (temp >= bl_min_lvl) {
 		
 		temp = ((*bl_lvl) * bl_scale) / 1024;
@@ -1386,6 +1341,7 @@
 		if (temp < bl_min_lvl)
 			temp = bl_min_lvl;
 	}
+	pr_debug("%s: output = %d", __func__, temp);
 
 	(*bl_lvl) = temp;
 }
@@ -1395,7 +1351,6 @@
 	struct msm_fb_panel_data *pdata;
 	__u32 temp = bkl_lvl;
 
-	down(&mfd->sem);
 	if (mfd->panel_power_on && !bl_updated && !mfd->request_display_on) {
 		PR_DISP_INFO("%s: bl_level_old = %d bkl_lvl = %d\n", __func__, bl_level_old, bkl_lvl);
 		unset_bl_level = 0;
@@ -1403,40 +1358,35 @@
 		bl_level_old = 0;	
 	} else if (!mfd->panel_power_on || !bl_updated) {
 		unset_bl_level = bkl_lvl;
-		up(&mfd->sem);
 		return;
 	} else {
 		unset_bl_level = 0;
 	}
-	up(&mfd->sem);
 
-	msm_fb_scale_bl(&temp);
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 
 	if ((pdata) && (pdata->set_backlight)) {
-		down(&mfd->sem);
+		msm_fb_scale_bl(&temp);
 		if (bl_level_old == temp) {
-			up(&mfd->sem);
 			return;
 		}
 		mfd->bl_level = temp;
 		pdata->set_backlight(mfd);
 		mfd->bl_level = bkl_lvl;
 		bl_level_old = temp;
-		up(&mfd->sem);
 	}
 }
 
 void msm_fb_display_on(struct msm_fb_data_type *mfd)
 {
-        struct msm_fb_panel_data *pdata;
-        pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+	struct msm_fb_panel_data *pdata;
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 
-        if ((pdata) && (pdata->display_on)) {
-                down(&mfd->sem);
-                pdata->display_on(mfd);
-                up(&mfd->sem);
-        }
+	if ((pdata) && (pdata->display_on)) {
+		down(&mfd->sem);
+		pdata->display_on(mfd);
+		up(&mfd->sem);
+	}
 	if ((pdata) && (pdata->sre_ctrl)) {
 		mod_timer(&mfd->sre_update_timer, jiffies + msecs_to_jiffies(50));
 	}
@@ -1464,9 +1414,6 @@
 	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
-	if (!op_enable)
-		return -EPERM;
-
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if ((!pdata) || (!pdata->on) || (!pdata->off)) {
 		printk(KERN_ERR "msm_fb_blank_sub: no panel operation detected!\n");
@@ -1476,11 +1423,11 @@
 	switch (blank_mode) {
 	case FB_BLANK_UNBLANK:
 		if (!mfd->panel_power_on) {
-			msleep(16);
 			ret = pdata->on(mfd->pdev);
 			if (ret == 0) {
 				mfd->panel_power_on = TRUE;
 				mfd->request_display_on = TRUE;
+				mfd->panel_driver_on = mfd->op_enable;
 #ifdef CONFIG_FB_MSM_ESD_WORKAROUND
 				if(pdata && pdata->esd_workaround)
 					queue_delayed_work(esd_wq, &esd_dw, msecs_to_jiffies(10000));
@@ -1497,8 +1444,6 @@
 		if (mfd->panel_power_on) {
 			int curr_pwr_state;
 
-			mutex_lock(&msm_fb_blank_mutex);
-
 			
 			if ((pdata) && (pdata->dimming_on))
 				del_timer_sync(&mfd->dimming_update_timer);
@@ -1509,16 +1454,18 @@
 			mfd->op_enable = FALSE;
 			curr_pwr_state = mfd->panel_power_on;
 			mfd->panel_power_on = FALSE;
-			down(&mfd->sem);
+
+			if (mfd->msmfb_no_update_notify_timer.function)
+				del_timer(&mfd->msmfb_no_update_notify_timer);
+			complete(&mfd->msmfb_no_update_notify);
+
 			bl_updated = 0;
-			up(&mfd->sem);
 
-			down(&msm_fb_pan_sem);
-			cancel_delayed_work(&perflock_pan.worker);
-			msm_fb_update_perflock_locked(MSM_FB_PERFORMANCE_NONE);
-			up(&msm_fb_pan_sem);
+			
+			if (info->screen_base)
+				memset((void *)info->screen_base, 0,
+				       info->fix.smem_len);
 
-			msleep(16);
 			msm_fb_display_off(mfd);
 			ret = pdata->off(mfd->pdev);
 			if (ret)
@@ -1526,7 +1473,6 @@
 
 			msm_fb_release_timeline(mfd);
 			mfd->op_enable = TRUE;
-			mutex_unlock(&msm_fb_blank_mutex);
 		}
 		break;
 	}
@@ -1540,10 +1486,10 @@
 	int remainder, yres, offset;
 
 	if (panel_info->mode2_yres != 0) {
-		yres = mfd->ovr_src_height;	
+		yres = panel_info->mode2_yres;
 		remainder = (fbi->fix.line_length*yres) & (PAGE_SIZE - 1);
 	} else {
-		yres = mfd->ovr_src_height;	
+		yres = panel_info->yres;
 		remainder = (fbi->fix.line_length*yres) & (PAGE_SIZE - 1);
 	}
 
@@ -1566,7 +1512,6 @@
 			    const struct fb_fillrect *rect)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-
 	msm_fb_pan_idle(mfd);
 	cfb_fillrect(info, rect);
 	if (!mfd->hw_refresh && (info->var.yoffset == 0) &&
@@ -1627,7 +1572,25 @@
 static int msm_fb_blank(int blank_mode, struct fb_info *info)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+
+	if (blank_mode == FB_BLANK_POWERDOWN) {
+		struct fb_event event;
+		event.info = info;
+		event.data = &blank_mode;
+		fb_notifier_call_chain(FB_EVENT_BLANK, &event);
+	}
 	msm_fb_pan_idle(mfd);
+	if (mfd->op_enable == 0) {
+		if (blank_mode == FB_BLANK_UNBLANK) {
+			mfd->suspend.panel_power_on = TRUE;
+			while (mfd->suspend.op_suspend) {
+				pr_debug("waiting for system to resume\n");
+				msleep(20);
+			}
+		}
+		else
+			mfd->suspend.panel_power_on = FALSE;
+	}
 	return msm_fb_blank_sub(blank_mode, info, mfd->op_enable);
 }
 
@@ -1650,6 +1613,9 @@
 	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
+	if (!start)
+		return -EINVAL;
+
 	if ((vma->vm_end <= vma->vm_start) ||
 		(off >= len) ||
 		((vma->vm_end - vma->vm_start) > (len - off)))
@@ -1721,36 +1687,6 @@
 		return xres * bpp;
 }
 
-static void msm_fb_resolution_override(struct msm_fb_data_type *mfd)
-{
-	struct msm_panel_info *panel_info = &mfd->panel_info;
-
-	
-	if (mfd->index == 0) {
-#ifdef CONFIG_FB_MSM_RESOLUTION_OVERRIDE
-		mfd->ovr_src_height = CONFIG_FB_MSM_RESOLUTION_OVERRIDE_SRC_HEIGHT;
-		mfd->ovr_src_width = CONFIG_FB_MSM_RESOLUTION_OVERRIDE_SRC_WIDTH;
-		mfd->ovr_dst_height = CONFIG_FB_MSM_RESOLUTION_OVERRIDE_DST_HEIGHT;
-		mfd->ovr_dst_width = CONFIG_FB_MSM_RESOLUTION_OVERRIDE_DST_WIDTH;
-#else
-		mfd->ovr_src_height = panel_info->yres;
-		mfd->ovr_src_width = panel_info->xres;
-		mfd->ovr_dst_height = panel_info->yres;
-		mfd->ovr_dst_width = panel_info->xres;
-#endif
-	} else {
-		mfd->ovr_src_height = panel_info->yres;
-		mfd->ovr_src_width = panel_info->xres;
-		mfd->ovr_dst_height = panel_info->yres;
-		mfd->ovr_dst_width = panel_info->xres;
-	}
-
-	MSM_FB_INFO("%s : ovr_src_height : %d, ovr_src_width : %d, ovr_dst_height : %d, ovr_dst_width : %d\n",
-		__func__, mfd->ovr_src_height, mfd->ovr_src_width, mfd->ovr_dst_height, mfd->ovr_dst_width);
-
-	return;
-}
-
 static int msm_fb_register(struct msm_fb_data_type *mfd)
 {
 	int ret = -ENODEV;
@@ -1766,9 +1702,6 @@
 	fix = &fbi->fix;
 	var = &fbi->var;
 
-	
-	msm_fb_resolution_override(mfd);
-
 	fix->type_aux = 0;	
 	fix->visual = FB_VISUAL_TRUECOLOR;	
 	fix->ywrapstep = 0;	
@@ -1781,13 +1714,10 @@
 	var->grayscale = 0,	
 	var->nonstd = 0,	
 	var->activate = FB_ACTIVATE_VBL,	
-#if 1 
-	var->height = mfd->height,      
-	var->width = mfd->width,        
-#else
-	var->height = -1,       
-	var->width = -1,        
-#endif 
+	
+	var->width = mfd->panel_info.width,        
+	var->height = mfd->panel_info.height,      
+	
 	var->accel_flags = 0,	
 	var->sync = 0,	
 	var->rotate = 0,	
@@ -1901,11 +1831,11 @@
 
 	fix->type = panel_info->is_3d_panel;
 
-	fix->line_length = msm_fb_line_length(mfd->index, mfd->ovr_src_width,
+	fix->line_length = msm_fb_line_length(mfd->index, panel_info->xres,
 					      bpp);
 
 
-	remainder = (fix->line_length * mfd->ovr_src_height) & (PAGE_SIZE - 1);
+	remainder = (fix->line_length * panel_info->yres) & (PAGE_SIZE - 1);
 					
 	if (!remainder)
 		remainder = PAGE_SIZE;
@@ -1916,9 +1846,9 @@
 
 	if (!bf_supported || mfd->index == 0)
 		fix->smem_len = MAX((msm_fb_line_length(mfd->index,
-							mfd->ovr_src_width,
+							panel_info->xres,
 							bpp) *
-				     mfd->ovr_src_height + PAGE_SIZE -
+				     panel_info->yres + PAGE_SIZE -
 				     remainder) * mfd->fb_page,
 				    (msm_fb_line_length(mfd->index,
 							panel_info->mode2_xres,
@@ -1931,48 +1861,20 @@
 		fix->smem_len = 0;
 	}
 
-	mfd->var_xres = mfd->ovr_src_width;	
-	mfd->var_yres = mfd->ovr_src_height;	
+	mfd->var_xres = panel_info->xres;
+	mfd->var_yres = panel_info->yres;
 	mfd->var_frame_rate = panel_info->frame_rate;
 
 	var->pixclock = mfd->panel_info.clk_rate;
 	mfd->var_pixclock = var->pixclock;
 
-	var->xres = mfd->ovr_src_width;	
-	var->yres = mfd->ovr_src_height;	
-	var->xres_virtual = ALIGN( mfd->ovr_src_width, 32);	
-	var->yres_virtual = mfd->ovr_src_height * mfd->fb_page +
+	var->xres = panel_info->xres;
+	var->yres = panel_info->yres;
+	var->xres_virtual = ALIGN(panel_info->xres, 32);	
+	var->yres_virtual = panel_info->yres * mfd->fb_page +
 		((PAGE_SIZE - remainder)/fix->line_length) * mfd->fb_page;
 	var->bits_per_pixel = bpp * 8;	
-	var->reserved[3] =  mdp_get_panel_framerate(mfd);
-#if 0
-	if (mfd->dest == DISPLAY_LCD) {
-		if (panel_info->type == MDDI_PANEL && panel_info->mddi.is_type1) {
-			var->reserved[3] = panel_info->lcd.refx100 / (100 * 2);
-		} else {
-			if (panel_info->mipi.frame_rate) {
-				var->reserved[3] = panel_info->mipi.frame_rate;
-			} else {
-				var->reserved[3] = panel_info->lcd.refx100 / 100;
-			}
-		}
-	} else {
-		if (panel_info->type == MIPI_VIDEO_PANEL) {
-			var->reserved[3] = panel_info->mipi.frame_rate;
-		} else {
-			var->reserved[3] = panel_info->clk_rate /
-				((panel_info->lcdc.h_back_porch +
-				  panel_info->lcdc.h_front_porch +
-				  panel_info->lcdc.h_pulse_width +
-				  mfd->ovr_src_width) *
-				 (panel_info->lcdc.v_back_porch +
-				  panel_info->lcdc.v_front_porch +
-				  panel_info->lcdc.v_pulse_width +
-				  mfd->ovr_src_height));
-		}
-	}
-#endif
-	pr_debug("reserved[3] %u\n", var->reserved[3]);
+	var->reserved[3] = mdp_get_panel_framerate(mfd);
 
 	id = (int *)&mfd->panel;
 
@@ -2032,13 +1934,25 @@
 	mfd->msmfb_no_update_notify_timer.data = (unsigned long)mfd;
 	init_completion(&mfd->msmfb_update_notify);
 	init_completion(&mfd->msmfb_no_update_notify);
+	init_completion(&mfd->commit_comp);
+	mutex_init(&mfd->sync_mutex);
+	INIT_WORK(&mfd->commit_work, msm_fb_commit_wq_handler);
+	mfd->msm_fb_backup = kzalloc(sizeof(struct msm_fb_backup_type),
+		GFP_KERNEL);
+	if (mfd->msm_fb_backup == 0) {
+		pr_err("error: not enough memory!\n");
+		return -ENOMEM;
+	}
 
-	fbram_offset = PAGE_ALIGN((int)fbram)-(int)fbram;
-	fbram += fbram_offset;
-	fbram_phys += fbram_offset;
-	fbram_size -= fbram_offset;
+	if (fbram) {
+		fbram_offset = PAGE_ALIGN((int)fbram)-(int)fbram;
+		fbram += fbram_offset;
+		fbram_phys += fbram_offset;
+		fbram_size -= fbram_offset;
+	} else
+		fbram_offset = 0;
 
-	if (!bf_supported || mfd->index == 0)
+	if ((!bf_supported || mfd->index == 0) && fbram)
 		if (fbram_size < fix->smem_len) {
 			pr_err("error: no more framebuffer memory!\n");
 			return -ENOMEM;
@@ -2047,23 +1961,33 @@
 	fbi->screen_base = fbram;
 	fbi->fix.smem_start = (unsigned long)fbram_phys;
 
-	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					DISPLAY_READ_DOMAIN,
-					GEN_POOL,
-					fbi->fix.smem_len,
-					SZ_4K,
-					0,
-					&(mfd->display_iova));
-
-	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					ROTATOR_SRC_DOMAIN,
-					GEN_POOL,
-					fbi->fix.smem_len,
-					SZ_4K,
-					0,
-					&(mfd->rotator_iova));
+	if (fbi->fix.smem_start) {
+		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					    DISPLAY_WRITE_DOMAIN,
+					    GEN_POOL,
+					    fbi->fix.smem_len,
+					    SZ_4K,
+					    0,
+					    &(mfd->display_iova));
+
+		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					    DISPLAY_READ_DOMAIN,
+					    GEN_POOL,
+					    fbi->fix.smem_len,
+					    SZ_4K,
+					    0,
+					    &(mfd->display_iova));
+
+		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					    ROTATOR_SRC_DOMAIN,
+					    GEN_POOL,
+					    fbi->fix.smem_len,
+					    SZ_4K,
+					    0,
+					    &(mfd->rotator_iova));
+	}
 
-	if (!bf_supported || mfd->index == 0)
+	if ((!bf_supported || mfd->index == 0) && fbi->screen_base)
 		memset(fbi->screen_base, 0x0, fix->smem_len);
 
 	mfd->op_enable = TRUE;
@@ -2071,10 +1995,22 @@
 
 	
 	if (mfd->cursor_update) {
+		unsigned long cursor_buf_iommu = 0;
 		mfd->cursor_buf = dma_alloc_coherent(NULL,
 					MDP_CURSOR_SIZE,
 					(dma_addr_t *) &mfd->cursor_buf_phys,
 					GFP_KERNEL);
+
+		msm_iommu_map_contig_buffer((unsigned long)mfd->cursor_buf_phys,
+					    DISPLAY_READ_DOMAIN,
+					    GEN_POOL,
+					    MDP_CURSOR_SIZE,
+					    SZ_4K,
+					    0,
+					    &cursor_buf_iommu);
+		if (cursor_buf_iommu)
+			mfd->cursor_buf_phys = (void *)cursor_buf_iommu;
+
 		if (!mfd->cursor_buf)
 			mfd->cursor_update = 0;
 	}
@@ -2100,20 +2036,12 @@
 		return -EPERM;
 	}
 
-	init_completion(&mfd->commit_comp);
-	mutex_init(&mfd->sync_mutex);
-	INIT_WORK(&mfd->commit_work, msm_fb_commit_wq_handler);
-	mfd->msm_fb_backup = kzalloc(sizeof(struct msm_fb_backup_type),
-		GFP_KERNEL);
-	if (mfd->msm_fb_backup == 0) {
-		pr_err("error: not enough memory!\n");
-		return -ENOMEM;
+	if (fbram) {
+		fbram += fix->smem_len;
+		fbram_phys += fix->smem_len;
+		fbram_size -= fix->smem_len;
 	}
 
-	fbram += fix->smem_len;
-	fbram_phys += fix->smem_len;
-	fbram_size -= fix->smem_len;
-
 	MSM_FB_INFO
 	    ("FrameBuffer[%d] %dx%d size=%d bytes is registered successfully!\n",
 	     mfd->index, fbi->var.xres, fbi->var.yres, fbi->fix.smem_len);
@@ -2126,7 +2054,9 @@
 	ret = 0;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
-	if (mfd->panel_info.type != DTV_PANEL) {
+
+	if (hdmi_prim_display ||
+	    (mfd->panel_info.type != DTV_PANEL)) {
 		mfd->early_suspend.suspend = msmfb_early_suspend;
 		mfd->early_suspend.resume = msmfb_early_resume;
 		mfd->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 2;
@@ -2277,6 +2207,7 @@
 static int msm_fb_open(struct fb_info *info, int user)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	bool unblank = true;
 	int result;
 
 	result = pm_runtime_get_sync(info->dev);
@@ -2290,6 +2221,14 @@
 			return 0;
 	}
 
+	if (mfd->op_enable == 0) {
+		if (info->node == 2)
+			return -EPERM;
+		
+		mfd->ref_cnt++;
+		return 0;
+	}
+
 	if (!mfd->ref_cnt) {
 		if (!bf_supported ||
 			(info->node != 1 && info->node != 2))
@@ -2297,10 +2236,14 @@
 		else
 			pr_debug("%s:%d no mdp_set_dma_pan_info %d\n",
 				__func__, __LINE__, info->node);
-		if (mfd->panel_info.type != DTV_PANEL) {
-			if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable)) {
-				printk(KERN_ERR "msm_fb_open: can't turn on display!\n");
-				return -1;
+
+		if (mfd->is_panel_ready && !mfd->is_panel_ready())
+			unblank = false;
+
+		if (unblank && (mfd->panel_info.type != DTV_PANEL)) {
+			if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, TRUE)) {
+				pr_err("msm_fb_open: can't turn on display\n");
+				return -EINVAL;
 			}
 		}
 	}
@@ -2309,6 +2252,11 @@
 	return 0;
 }
 
+static void msm_fb_free_base_pipe(struct msm_fb_data_type *mfd)
+{
+	return 	mdp4_overlay_free_base_pipe(mfd);
+}
+
 static int msm_fb_release(struct fb_info *info, int user)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
@@ -2319,22 +2267,19 @@
 			    mfd->index);
 		return -EINVAL;
 	}
-
+	msm_fb_pan_idle(mfd);
 	mfd->ref_cnt--;
 
 	if (!mfd->ref_cnt) {
-		if (mfd->suspend.op_suspend) {
-			
-			mfd->sw_refreshing_enable = mfd->suspend.sw_refreshing_enable;
-			mfd->op_enable = mfd->suspend.op_enable;
-			mfd->panel_power_on = mfd->suspend.panel_power_on;
-			mfd->suspend.op_suspend = false;
-		}
-		if ((ret =
-		     msm_fb_blank_sub(FB_BLANK_POWERDOWN, info,
-				      mfd->op_enable)) != 0) {
-			printk(KERN_ERR "msm_fb_release: can't turn off display!\n");
-			return ret;
+		if (mfd->op_enable) {
+			ret = msm_fb_blank_sub(FB_BLANK_POWERDOWN, info,
+							mfd->op_enable);
+			if (ret != 0) {
+				printk(KERN_ERR "msm_fb_release: can't turn off display!\n");
+				return ret;
+			}
+		} else {
+			msm_fb_free_base_pipe(mfd);
 		}
 	}
 
@@ -2344,49 +2289,60 @@
 
 void msm_fb_wait_for_fence(struct msm_fb_data_type *mfd)
 {
-#ifdef CONFIG_SW_SYNC
 	int i, ret = 0;
 	
 	for (i = 0; i < mfd->acq_fen_cnt; i++) {
-		ret = sync_fence_wait(mfd->acq_fen[i], WAIT_FENCE_TIMEOUT);
-		sync_fence_put(mfd->acq_fen[i]);
+		ret = sync_fence_wait(mfd->acq_fen[i],
+				WAIT_FENCE_FIRST_TIMEOUT);
+		if (ret == -ETIME) {
+			pr_warn("%s: sync_fence_wait timed out!"
+				"Waiting %ld more seconds\n",
+				__func__,WAIT_FENCE_FINAL_TIMEOUT/MSEC_PER_SEC);
+			ret = sync_fence_wait(mfd->acq_fen[i],
+					WAIT_FENCE_FINAL_TIMEOUT);
+		}
 		if (ret < 0) {
 			pr_err("%s: sync_fence_wait failed! ret = %x\n",
 				__func__, ret);
 			break;
 		}
+		sync_fence_put(mfd->acq_fen[i]);
+	}
+	if (ret < 0) {
+		while (i < mfd->acq_fen_cnt) {
+			sync_fence_put(mfd->acq_fen[i]);
+			i++;
+		}
 	}
 	mfd->acq_fen_cnt = 0;
-#endif
 }
-
 int msm_fb_signal_timeline(struct msm_fb_data_type *mfd)
 {
-#ifdef CONFIG_SW_SYNC
 	mutex_lock(&mfd->sync_mutex);
-	if (mfd->timeline) {
+	if (mfd->timeline && !list_empty((const struct list_head *)
+				(&(mfd->timeline->obj.active_list_head)))) {
 		sw_sync_timeline_inc(mfd->timeline, 1);
 		mfd->timeline_value++;
 	}
 	mfd->last_rel_fence = mfd->cur_rel_fence;
 	mfd->cur_rel_fence = 0;
 	mutex_unlock(&mfd->sync_mutex);
-#endif
 	return 0;
 }
 
 void msm_fb_release_timeline(struct msm_fb_data_type *mfd)
 {
-#ifdef CONFIG_SW_SYNC
+	mutex_lock(&mfd->sync_mutex);
 	if (mfd->timeline) {
 		sw_sync_timeline_inc(mfd->timeline, 2);
 		mfd->timeline_value += 2;
 	}
 	mfd->last_rel_fence = 0;
 	mfd->cur_rel_fence = 0;
-#endif
+	mutex_unlock(&mfd->sync_mutex);
 }
 
+DEFINE_SEMAPHORE(msm_fb_pan_sem);
 static int msm_fb_pan_idle(struct msm_fb_data_type *mfd)
 {
 	int ret = 0;
@@ -2394,52 +2350,75 @@
 	mutex_lock(&mfd->sync_mutex);
 	if (mfd->is_committing) {
 		mutex_unlock(&mfd->sync_mutex);
-		ret = wait_for_completion_timeout(&mfd->commit_comp,
-			msecs_to_jiffies(WAIT_FENCE_TIMEOUT));
-		if (ret <= 0)
+		ret = wait_for_completion_interruptible_timeout(
+				&mfd->commit_comp,
+			msecs_to_jiffies(WAIT_DISP_OP_TIMEOUT));
+		if (ret < 0)
+			ret = -ERESTARTSYS;
+		else if (!ret)
 			pr_err("%s wait for commit_comp timeout %d %d",
 				__func__, ret, mfd->is_committing);
+		if (ret <= 0) {
+			mutex_lock(&mfd->sync_mutex);
+			mfd->is_committing = 0;
+			complete_all(&mfd->commit_comp);
+			mutex_unlock(&mfd->sync_mutex);
+		}
 	} else {
 		mutex_unlock(&mfd->sync_mutex);
 	}
 	return ret;
 }
-static int msm_fb_pan_display_ex(struct fb_var_screeninfo *var,
-			      struct fb_info *info, u32 wait_for_finish)
+static int msm_fb_pan_display_ex(struct fb_info *info,
+		struct mdp_display_commit *disp_commit)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	struct msm_fb_backup_type *fb_backup;
+	struct fb_var_screeninfo *var = &disp_commit->var;
+	u32 wait_for_finish = disp_commit->wait_for_finish;
 	int ret = 0;
-	if (bf_supported && info->node == 2) {
-		pr_err("%s: no pan display for fb%d!",
-		       __func__, info->node);
-		return -EPERM;
-	}
 
-	if (info->node != 0 || mfd->cont_splash_done)	
-		if ((!mfd->op_enable) || (!mfd->panel_power_on))
+	if (disp_commit->flags &
+		MDP_DISPLAY_COMMIT_OVERLAY) {
+		if (!mfd->panel_power_on) 
+			return -EPERM;
+	} else {
+		if (bf_supported && info->node == 2) {
+			pr_err("%s: no pan display for fb%d!",
+				   __func__, info->node);
 			return -EPERM;
+		}
 
-	if (var->xoffset > (info->var.xres_virtual - info->var.xres))
-		return -EINVAL;
+		if (info->node != 0 || mfd->cont_splash_done)	
+			if ((!mfd->op_enable) || (!mfd->panel_power_on))
+				return -EPERM;
 
-	if (var->yoffset > (info->var.yres_virtual - info->var.yres))
-		return -EINVAL;
+		if (var->xoffset > (info->var.xres_virtual - info->var.xres))
+			return -EINVAL;
+
+		if (var->yoffset > (info->var.yres_virtual - info->var.yres))
+			return -EINVAL;
+	}
 	msm_fb_pan_idle(mfd);
 
 	mutex_lock(&mfd->sync_mutex);
 
-	if (info->fix.xpanstep)
-		info->var.xoffset =
-		    (var->xoffset / info->fix.xpanstep) * info->fix.xpanstep;
-
-	if (info->fix.ypanstep)
-		info->var.yoffset =
-		    (var->yoffset / info->fix.ypanstep) * info->fix.ypanstep;
-
+	if (!(disp_commit->flags &
+		MDP_DISPLAY_COMMIT_OVERLAY)) {
+		if (info->fix.xpanstep)
+			info->var.xoffset =
+				(var->xoffset / info->fix.xpanstep) *
+					info->fix.xpanstep;
+
+		if (info->fix.ypanstep)
+			info->var.yoffset =
+				(var->yoffset / info->fix.ypanstep) *
+					info->fix.ypanstep;
+	}
 	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
 	memcpy(&fb_backup->info, info, sizeof(struct fb_info));
-	memcpy(&fb_backup->var, var, sizeof(struct fb_var_screeninfo));
+	memcpy(&fb_backup->disp_commit, disp_commit,
+		sizeof(struct mdp_display_commit));
 	mfd->is_committing = 1;
 	INIT_COMPLETION(mfd->commit_comp);
 	schedule_work(&mfd->commit_work);
@@ -2452,7 +2431,11 @@
 static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 			      struct fb_info *info)
 {
-	return msm_fb_pan_display_ex(var, info, FALSE);
+	struct mdp_display_commit disp_commit;
+	memset(&disp_commit, 0, sizeof(disp_commit));
+	disp_commit.var = *var;
+	disp_commit.wait_for_finish = TRUE;
+	return msm_fb_pan_display_ex(info, &disp_commit);
 }
 
 static int msm_fb_pan_display_sub(struct fb_var_screeninfo *var,
@@ -2462,34 +2445,22 @@
 	struct mdp_dirty_region *dirtyPtr = NULL;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	struct msm_fb_panel_data *pdata;
-	static bool ignore_bkl_zero = false;
-	int ret = -EINVAL;
 
-
-	mutex_lock(&msm_fb_blank_mutex);
 	if (bf_supported && info->node == 2) {
-		static unsigned int panfb2cnt = 0; 
-		if ((panfb2cnt & 0x3f)==0) { 
-			pr_info("%s: skip pan display for fb%d! (cnt: %u)\n",
-				__func__, info->node, panfb2cnt);
-		}
-		panfb2cnt++;
-		ret = -EPERM;
-		goto done;
+		pr_err("%s: no pan display for fb%d!",
+		       __func__, info->node);
+		return -EPERM;
 	}
 
-	if (info->node != 0 || mfd->cont_splash_done) {	
-		if ((!mfd->op_enable) || (!mfd->panel_power_on)) {
-			ret = -EPERM;
-			goto done;
-		}
-	}
+	if (info->node != 0 || mfd->cont_splash_done)	
+		if ((!mfd->op_enable) || (!mfd->panel_power_on))
+			return -EPERM;
 
 	if (var->xoffset > (info->var.xres_virtual - info->var.xres))
-		goto done;
+		return -EINVAL;
 
 	if (var->yoffset > (info->var.yres_virtual - info->var.yres))
-		goto done;
+		return -EINVAL;
 
 	if (info->fix.xpanstep)
 		info->var.xoffset =
@@ -2506,10 +2477,9 @@
 		dirty.yoffset = (var->reserved[1] >> 16) & 0xffff;
 
 		if ((var->reserved[2] & 0xffff) <= dirty.xoffset)
-			goto done;
-
+			return -EINVAL;
 		if (((var->reserved[2] >> 16) & 0xffff) <= dirty.yoffset)
-			goto done;
+			return -EINVAL;
 
 		dirty.width = (var->reserved[2] & 0xffff) - dirty.xoffset;
 		dirty.height =
@@ -2517,19 +2487,19 @@
 		info->var.yoffset = var->yoffset;
 
 		if (dirty.xoffset < 0)
-			goto done;
+			return -EINVAL;
 
 		if (dirty.yoffset < 0)
-			goto done;
+			return -EINVAL;
 
 		if ((dirty.xoffset + dirty.width) > info->var.xres)
-			goto done;
+			return -EINVAL;
 
 		if ((dirty.yoffset + dirty.height) > info->var.yres)
-			goto done;
+			return -EINVAL;
 
 		if ((dirty.width <= 0) || (dirty.height <= 0))
-			goto done;
+			return -EINVAL;
 
 		dirtyPtr = &dirty;
 	}
@@ -2553,8 +2523,7 @@
 	if (mfd->msmfb_no_update_notify_timer.function)
 		del_timer(&mfd->msmfb_no_update_notify_timer);
 
-	mfd->msmfb_no_update_notify_timer.expires =
-				jiffies + ((1000 * HZ) / 1000);
+	mfd->msmfb_no_update_notify_timer.expires = jiffies + (2 * HZ);
 	add_timer(&mfd->msmfb_no_update_notify_timer);
 	mutex_unlock(&msm_fb_notify_update_sem);
 
@@ -2566,29 +2535,51 @@
 			pr_err("%s: can't turn on display!\n", __func__);
 			up(&msm_fb_pan_sem);
 			msm_fb_release_timeline(mfd);
-
-			ret = -EINVAL;
-			goto done;
+			return -EINVAL;
 		}
 	}
 
 	mdp_set_dma_pan_info(info, dirtyPtr,
-			     (var->activate == FB_ACTIVATE_VBL));
+			     (var->activate & FB_ACTIVATE_VBL));
+	
 
-	if (mfd->perfhint) {
-		
-		perflock_pan.expire_tick = PERF_EXPIRE_TICK;
-		pm_qos_update_request(&perflock_pan.qos_req, 100);
-		msm_fb_update_perflock_locked(mfd->perfhint);
+	mdp_dma_pan_update(info);
+	msm_fb_signal_timeline(mfd);
+	if (mdp4_unmap_sec_resource(mfd))
+		pr_err("%s: unmap secure res failed\n", __func__);
 
-		mdp_dma_pan_update(info);
-		pm_qos_update_request(&perflock_pan.qos_req, PM_QOS_DEFAULT_VALUE);
-	} else {
-		mdp_dma_pan_update(info);
+	up(&msm_fb_pan_sem);
+
+	if (info->node == 0 && (mfd->cont_splash_done)) 
+		mdp_free_splash_buffer(mfd);
+
+	++mfd->panel_info.frame_count;
+	return 0;
+}
+
+static void msm_fb_commit_wq_handler(struct work_struct *work)
+{
+	struct msm_fb_data_type *mfd;
+	struct fb_var_screeninfo *var;
+	struct fb_info *info;
+	struct msm_fb_backup_type *fb_backup;
+	static bool ignore_bkl_zero = false;
+
+	mfd = container_of(work, struct msm_fb_data_type, commit_work);
+	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
+	info = &fb_backup->info;
+
+#if 0
+	if (fb_backup->disp_commit.flags &
+		MDP_DISPLAY_COMMIT_OVERLAY) {
+			mdp4_overlay_commit(info);
+	} else
+#endif
+	{
+		var = &fb_backup->disp_commit.var;
+		msm_fb_pan_display_sub(var, info);
 	}
 
-	msm_fb_signal_timeline(mfd);
-	up(&msm_fb_pan_sem);
 	if (mfd->request_display_on) {
 		msm_fb_display_on(mfd);
 		if (!ignore_bkl_zero) {
@@ -2599,77 +2590,24 @@
 			ignore_bkl_zero = true;
 		}
 		down(&mfd->sem);
-		mfd->request_display_on = 0;
+		mfd->request_display_on = FALSE;
 		bl_updated = 0;
 		up(&mfd->sem);
 	}
 	if (unset_bl_level && !bl_updated) {
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
+		struct msm_fb_panel_data
+		*pdata = (struct msm_fb_panel_data *)mfd->pdev->
 			dev.platform_data;
 		if ((pdata) && (pdata->set_backlight)) {
 			down(&mfd->sem);
 			mfd->bl_level = unset_bl_level;
 			pdata->set_backlight(mfd);
 			bl_level_old = unset_bl_level;
-			bl_updated = 1;
-			up(&mfd->sem);
-		}
-	}
-	mutex_unlock(&msm_fb_blank_mutex);
-
-#ifdef CONFIG_MSM_ACL_ENABLE
-	if (!cabc_updated) {
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
-			dev.platform_data;
-		if ((pdata) && (pdata->acl_enable)) {
-			down(&mfd->sem);
-			pdata->acl_enable(auto_bkl_status, mfd);
-			cabc_updated = 1;
-			up(&mfd->sem);
-		}
-	}
-#endif
-
-#ifdef CONFIG_FB_MSM_CABC_LEVEL_CONTROL
-	if (cabc_level_ctl_status_old != cabc_level_ctl_status) {
-		pdata = (struct msm_fb_panel_data *)mfd->pdev->
-			dev.platform_data;
-		if ((pdata) && (pdata->set_cabc)) {
-			down(&mfd->sem);
-			pdata->set_cabc(mfd, cabc_level_ctl_status);
-			cabc_level_ctl_status_old = cabc_level_ctl_status;
 			up(&mfd->sem);
+			bl_updated = 1;
 		}
 	}
 
-#endif
-
-	++mfd->panel_info.frame_count;
-	return 0;
-
-done:
-	if (ret) {
-		pr_info("%s: timeline=%d, ret=%d, do release timeline\n",
-		    __func__, mfd->timeline_value, ret);
-		msm_fb_release_timeline(mfd);
-	}
-	mutex_unlock(&msm_fb_blank_mutex);
-
-	return ret;
-}
-
-static void msm_fb_commit_wq_handler(struct work_struct *work)
-{
-	struct msm_fb_data_type *mfd;
-	struct fb_var_screeninfo *var;
-	struct fb_info *info;
-	struct msm_fb_backup_type *fb_backup;
-
-	mfd = container_of(work, struct msm_fb_data_type, commit_work);
-	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
-	var = &fb_backup->var;
-	info = &fb_backup->info;
-	msm_fb_pan_display_sub(var, info);
 	mutex_lock(&mfd->sync_mutex);
 	mfd->is_committing = 0;
 	complete_all(&mfd->commit_comp);
@@ -2768,12 +2706,6 @@
 	if ((var->xres == 0) || (var->yres == 0))
 		return -EINVAL;
 
-	if ((var->xres > MAX(mfd->panel_info.xres,
-			     mfd->panel_info.mode2_xres)) ||
-		(var->yres > MAX(mfd->panel_info.yres,
-				 mfd->panel_info.mode2_yres)))
-		return -EINVAL;
-
 	if (var->xoffset > (var->xres_virtual - var->xres))
 		return -EINVAL;
 
@@ -2783,24 +2715,28 @@
 	return 0;
 }
 
-int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd
-						, struct fb_info *info)
+int msm_fb_get_frame_rate(struct fb_var_screeninfo *var)
 {
-	int panel_height, panel_width, var_frame_rate, fps_mod;
-	struct fb_var_screeninfo *var = &info->var;
-	fps_mod = 0;
-	if ((mfd->panel_info.type == DTV_PANEL) ||
-		(mfd->panel_info.type == HDMI_PANEL)) {
-		panel_height = var->yres + var->upper_margin +
+	int panel_height, panel_width;
+
+	panel_height = var->yres + var->upper_margin +
 			var->vsync_len + var->lower_margin;
-		panel_width = var->xres + var->right_margin +
+	panel_width  = var->xres + var->right_margin +
 			var->hsync_len + var->left_margin;
-		var_frame_rate = ((var->pixclock)/(panel_height * panel_width));
-		if (mfd->var_frame_rate != var_frame_rate) {
+	return (var->pixclock)/(panel_height * panel_width);
+}
+
+int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd, struct fb_info *info)
+{
+	int fps_mod = 0;
+	struct fb_var_screeninfo *var = &info->var;
+
+	if ((mfd->panel_info.type == DTV_PANEL) ||
+	    (mfd->panel_info.type == HDMI_PANEL)) {
+		if (mfd->var_frame_rate != msm_fb_get_frame_rate(var))
 			fps_mod = 1;
-			mfd->var_frame_rate = var_frame_rate;
-		}
 	}
+
 	return fps_mod;
 }
 
@@ -2810,7 +2746,6 @@
 	struct fb_var_screeninfo *var = &info->var;
 	int old_imgType;
 	int blank = 0;
-
 	msm_fb_pan_idle(mfd);
 	old_imgType = mfd->fb_imgType;
 	switch (var->bits_per_pixel) {
@@ -2843,20 +2778,27 @@
 	}
 
 	if ((mfd->var_pixclock != var->pixclock) ||
-		(mfd->hw_refresh && ((mfd->fb_imgType != old_imgType) ||
-				(mfd->var_pixclock != var->pixclock) ||
-				(mfd->var_xres != var->xres) ||
-				(mfd->var_yres != var->yres) ||
-				(msm_fb_check_frame_rate(mfd, info))))) {
+		(mfd->hw_refresh &&
+			((mfd->fb_imgType != old_imgType) ||
+			 (mfd->var_xres   != var->xres) ||
+			 (mfd->var_yres   != var->yres) ||
+			 (msm_fb_check_frame_rate(mfd, info))))) {
 		mfd->var_xres = var->xres;
 		mfd->var_yres = var->yres;
-		mfd->var_pixclock = var->pixclock;
+		mfd->var_pixclock   = var->pixclock;
+		mfd->var_frame_rate = msm_fb_get_frame_rate(var);
+
+		if (mfd->update_panel_info)
+			mfd->update_panel_info(mfd);
+
 		blank = 1;
 	}
-	mfd->fbi->fix.line_length = msm_fb_line_length(mfd->index, mfd->ovr_src_width,
+	mfd->fbi->fix.line_length = msm_fb_line_length(mfd->index, var->xres,
 						       var->bits_per_pixel/8);
 
-	if (blank) {
+	if ((mfd->panel_info.type == DTV_PANEL) && !mfd->panel_power_on) {
+		msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable);
+	} else if (blank) {
 		msm_fb_blank_sub(FB_BLANK_POWERDOWN, info, mfd->op_enable);
 		msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable);
 	}
@@ -3560,7 +3502,7 @@
 	int count, i, req_list_count;
 	if (bf_supported &&
 		(info->node == 1 || info->node == 2)) {
-		pr_err("%s: no pan display for fb%d.\n",
+		pr_err("%s: no pan display for fb%d.",
 		       __func__, info->node);
 		return -EPERM;
 	}
@@ -3608,6 +3550,27 @@
 	return 0;
 }
 
+static int msmfb_vsync_ctrl(struct fb_info *info, void __user *argp)
+{
+	int enable, ret;
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+
+	ret = copy_from_user(&enable, argp, sizeof(enable));
+	if (ret) {
+		pr_err("%s:msmfb_overlay_vsync ioctl failed", __func__);
+		return ret;
+	}
+
+	if (mfd->vsync_ctrl)
+		mfd->vsync_ctrl(enable);
+	else {
+		pr_err("%s: Vsync IOCTL not supported", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 #ifdef CONFIG_FB_MSM_OVERLAY
 static int msmfb_overlay_get(struct fb_info *info, void __user *p)
 {
@@ -3670,25 +3633,6 @@
 	return mdp4_overlay_unset(info, ndx);
 }
 
-static int msmfb_overlay_wait4vsync(struct fb_info *info, void __user *argp)
-{
-	int ret;
-	long long vtime;
-
-	ret = mdp4_overlay_wait4vsync(info, &vtime);
-	if (ret) {
-		pr_err("%s: ioctl failed\n", __func__);
-		return ret;
-	}
-
-	if (copy_to_user(argp, &vtime, sizeof(vtime))) {
-		pr_err("%s: copy2user failed\n", __func__);
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
 static int msmfb_overlay_vsync_ctrl(struct fb_info *info, void __user *argp)
 {
 	int ret;
@@ -3730,9 +3674,8 @@
 	int	ret;
 	struct msmfb_overlay_data req;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-#ifdef CONFIG_MSM_ACL_ENABLE
 	struct msm_fb_panel_data *pdata;
-#endif
+
 	if (mfd->overlay_play_enable == 0)	
 		return 0;
 
@@ -3743,16 +3686,6 @@
 		return ret;
 	}
 
-	complete(&mfd->msmfb_update_notify);
-	mutex_lock(&msm_fb_notify_update_sem);
-	if (mfd->msmfb_no_update_notify_timer.function)
-		del_timer(&mfd->msmfb_no_update_notify_timer);
-
-	mfd->msmfb_no_update_notify_timer.expires =
-				jiffies + ((1000 * HZ) / 1000);
-	add_timer(&mfd->msmfb_no_update_notify_timer);
-	mutex_unlock(&msm_fb_notify_update_sem);
-
 	if (info->node == 0 && !(mfd->cont_splash_done)) { 
 		mdp_set_dma_pan_info(info, NULL, TRUE);
 		if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable)) {
@@ -3761,20 +3694,35 @@
 		}
 	}
 
+	if (!mfd->panel_power_on) 
+		return -EPERM;
+
+	complete(&mfd->msmfb_update_notify);
+	mutex_lock(&msm_fb_notify_update_sem);
+	if (mfd->msmfb_no_update_notify_timer.function)
+		del_timer(&mfd->msmfb_no_update_notify_timer);
+
+	mfd->msmfb_no_update_notify_timer.expires = jiffies + (2 * HZ);
+	add_timer(&mfd->msmfb_no_update_notify_timer);
+	mutex_unlock(&msm_fb_notify_update_sem);
+
 	ret = mdp4_overlay_play(info, &req);
 
-#ifdef CONFIG_MSM_ACL_ENABLE
-	if (!cabc_updated) {
+	if (unset_bl_level && !bl_updated) {
 		pdata = (struct msm_fb_panel_data *)mfd->pdev->
 			dev.platform_data;
-		if ((pdata) && (pdata->acl_enable)) {
+		if ((pdata) && (pdata->set_backlight)) {
 			down(&mfd->sem);
-			pdata->acl_enable(auto_bkl_status, mfd);
-			cabc_updated = 1;
+			mfd->bl_level = unset_bl_level;
+			pdata->set_backlight(mfd);
+			bl_level_old = unset_bl_level;
 			up(&mfd->sem);
+			bl_updated = 1;
 		}
 	}
-#endif
+
+	if (info->node == 0 && (mfd->cont_splash_done)) 
+		mdp_free_splash_buffer(mfd);
 
 	return ret;
 }
@@ -3896,6 +3844,49 @@
 	return mdp4_writeback_terminate(info);
 }
 
+static int msmfb_overlay_ioctl_writeback_set_mirr_hint(struct fb_info *
+		info, void *argp)
+{
+	int ret = 0, hint;
+
+	if (!info) {
+		ret = -EINVAL;
+		goto error;
+	}
+
+	ret = copy_from_user(&hint, argp, sizeof(hint));
+	if (ret)
+		goto error;
+
+	ret = mdp4_writeback_set_mirroring_hint(info, hint);
+	if (ret)
+		goto error;
+error:
+	if (ret)
+		pr_err("%s: ioctl failed\n", __func__);
+	return ret;
+}
+
+static int msmfb_overlay_ioctl_writeback_play(
+	struct fb_info *info, unsigned long *argp)
+{
+	int ret;
+	struct msmfb_overlay_data req;
+
+	ret = copy_from_user(&req, argp, sizeof(req));
+	if (ret)
+		goto error;
+
+	ret = mdp4_writeback_play(info, &req);
+
+error:
+	if (ret) {
+		pr_err("%s:msmfb_overlay_writeback_play ioctl failed\n",
+				__func__);
+	}
+	return ret;
+}
+
 #else
 static int msmfb_overlay_ioctl_writeback_init(struct fb_info *info)
 {
@@ -3928,6 +3919,17 @@
 {
 	return -ENOTSUPP;
 }
+
+static int msmfb_overlay_ioctl_writeback_set_mirr_hint(struct fb_info *
+		info, void *argp)
+{
+	return -ENOTSUPP;
+}
+
+static int msmfb_overlay_ioctl_writeback_play(struct fb_info *info, unsigned long *argp)
+{
+	return -ENOTSUPP;
+}
 #endif
 
 static int msmfb_overlay_3d_sbys(struct fb_info *info, unsigned long *argp)
@@ -3962,7 +3964,8 @@
 	req.cnt = cnt;
 	ret = copy_to_user(argp, &req, sizeof(req));
 	if (ret)
-		pr_err("%s:ioctl failed\n", __func__);
+		pr_err("%s:msmfb_overlay_blt_off ioctl failed\n",
+		__func__);
 
 	return cnt;
 }
@@ -4030,19 +4033,25 @@
 
 	if (notify == NOTIFY_UPDATE_START) {
 		INIT_COMPLETION(mfd->msmfb_update_notify);
-		wait_for_completion_interruptible(&mfd->msmfb_update_notify);
+		ret = wait_for_completion_interruptible_timeout(
+		&mfd->msmfb_update_notify, 4*HZ);
 	} else {
 		INIT_COMPLETION(mfd->msmfb_no_update_notify);
-		wait_for_completion_interruptible(&mfd->msmfb_no_update_notify);
+		ret = wait_for_completion_interruptible_timeout(
+		&mfd->msmfb_no_update_notify, 4*HZ);
 	}
-	return 0;
+	if (ret == 0)
+		ret = -ETIMEDOUT;
+	return (ret > 0) ? 0 : ret;
 }
 
 static int msmfb_handle_pp_ioctl(struct msm_fb_data_type *mfd,
 						struct msmfb_mdp_pp *pp_ptr)
 {
 	int ret = -1;
-
+#ifdef CONFIG_FB_MSM_MDP40
+	int i = 0;
+#endif
 	if (!pp_ptr)
 		return ret;
 
@@ -4050,6 +4059,15 @@
 #ifdef CONFIG_FB_MSM_MDP40
 	case mdp_op_csc_cfg:
 		ret = mdp4_csc_config(&(pp_ptr->data.csc_cfg_data));
+		for (i = 0; i < CSC_MAX_BLOCKS; i++) {
+			if (pp_ptr->data.csc_cfg_data.block ==
+					csc_cfg_matrix[i].block) {
+				memcpy(&csc_cfg_matrix[i].csc_data,
+				&(pp_ptr->data.csc_cfg_data.csc_data),
+				sizeof(struct mdp_csc_cfg));
+				break;
+			}
+		}
 		break;
 
 	case mdp_op_pcc_cfg:
@@ -4083,6 +4101,10 @@
 		ret = mdp4_qseed_cfg((struct mdp_qseed_cfg_data *)
 						&pp_ptr->data.qseed_cfg_data);
 		break;
+	case mdp_op_calib_cfg:
+		ret = mdp4_calib_config((struct mdp_calib_config_data *)
+						&pp_ptr->data.calib_cfg);
+		break;
 #endif
 	case mdp_bl_scale_cfg:
 		ret = mdp_bl_scale_config(mfd, (struct mdp_bl_scale_data *)
@@ -4101,9 +4123,8 @@
 static int msmfb_handle_buf_sync_ioctl(struct msm_fb_data_type *mfd,
 						struct mdp_buf_sync *buf_sync)
 {
-	int ret = 0;
-#ifdef CONFIG_SW_SYNC
-	int i, fence_cnt = 0;
+	int i, ret = 0;
+	u32 threshold;
 	int acq_fen_fd[MDP_MAX_FENCE_FD];
 	struct sync_fence *fence;
 
@@ -4111,6 +4132,9 @@
 		(mfd->timeline == NULL))
 		return -EINVAL;
 
+	if ((!mfd->op_enable) || (!mfd->panel_power_on))
+		return -EPERM;
+
 	if (buf_sync->acq_fen_fd_cnt)
 		ret = copy_from_user(acq_fen_fd, buf_sync->acq_fen_fd,
 				buf_sync->acq_fen_fd_cnt * sizeof(int));
@@ -4129,15 +4153,18 @@
 		}
 		mfd->acq_fen[i] = fence;
 	}
-	fence_cnt = i;
+	mfd->acq_fen_cnt = i;
 	if (ret)
 		goto buf_sync_err_1;
-	mfd->acq_fen_cnt = fence_cnt;
 	if (buf_sync->flags & MDP_BUF_SYNC_FLAG_WAIT) {
 		msm_fb_wait_for_fence(mfd);
 	}
+	if (mfd->panel.type == WRITEBACK_PANEL)
+		threshold = 1;
+	else
+		threshold = 2;
 	mfd->cur_rel_sync_pt = sw_sync_pt_create(mfd->timeline,
-			mfd->timeline_value + 2);
+			mfd->timeline_value + threshold);
 	if (mfd->cur_rel_sync_pt == NULL) {
 		pr_err("%s: cannot create sync point", __func__);
 		ret = -ENOMEM;
@@ -4155,29 +4182,31 @@
 	}
 	
 	mfd->cur_rel_fen_fd = get_unused_fd_flags(0);
+	if (mfd->cur_rel_fen_fd < 0) {
+		pr_err("%s: get_unused_fd_flags failed", __func__);
+		ret  = -EIO;
+		goto buf_sync_err_2;
+	}
 	sync_fence_install(mfd->cur_rel_fence, mfd->cur_rel_fen_fd);
 	ret = copy_to_user(buf_sync->rel_fen_fd,
 		&mfd->cur_rel_fen_fd, sizeof(int));
 	if (ret) {
 		pr_err("%s:copy_to_user failed", __func__);
-		goto buf_sync_err_2;
+		goto buf_sync_err_3;
 	}
-
 	mutex_unlock(&mfd->sync_mutex);
 	return ret;
-
+buf_sync_err_3:
+	put_unused_fd(mfd->cur_rel_fen_fd);
 buf_sync_err_2:
 	sync_fence_put(mfd->cur_rel_fence);
-	put_unused_fd(mfd->cur_rel_fen_fd);
 	mfd->cur_rel_fence = NULL;
 	mfd->cur_rel_fen_fd = 0;
 buf_sync_err_1:
-	for (i = 0; i < fence_cnt; i++)
+	for (i = 0; i < mfd->acq_fen_cnt; i++)
 		sync_fence_put(mfd->acq_fen[i]);
 	mfd->acq_fen_cnt = 0;
 	mutex_unlock(&mfd->sync_mutex);
-#endif 
-
 	return ret;
 }
 
@@ -4193,7 +4222,7 @@
 		return ret;
 	}
 
-	ret = msm_fb_pan_display_ex(&disp_commit.var, info, disp_commit.wait_for_finish);
+	ret = msm_fb_pan_display_ex(info, &disp_commit);
 
 	return ret;
 }
@@ -4212,34 +4241,9 @@
 		ret = -EINVAL;
 		break;
 	}
-
 	return ret;
 }
 
-static int do_sched_setscheduler(pid_t pid, int val)
-{
-	struct sched_param lparam;
-	struct task_struct *p;
-	int retval;
-
-	if (pid < 0)
-		return -EINVAL;
-
-	lparam.sched_priority = val;
-
-	rcu_read_lock();
-	retval = -ESRCH;
-	p = find_task_by_vpid(pid);
-
-	if (p != NULL)
-		retval = sched_setscheduler_nocheck(p, SCHED_RR, &lparam);
-
-	rcu_read_unlock();
-
-	return retval;
-}
-
-
 static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg)
 {
@@ -4259,21 +4263,13 @@
 	struct msmfb_mdp_pp mdp_pp;
 	struct mdp_buf_sync buf_sync;
 	struct msmfb_metadata mdp_metadata;
-	struct msmfb_sched_priority sched_priority_data;
 	int ret = 0;
-
-
 	struct msmfb_usb_projector_info tmp_info;
 
 	msm_fb_pan_idle(mfd);
+
 	switch (cmd) {
 #ifdef CONFIG_FB_MSM_OVERLAY
-	case FBIO_WAITFORVSYNC:
-		ret = msmfb_overlay_wait4vsync(info, argp);
-		break;
-	case MSMFB_OVERLAY_VSYNC_CTRL:
-		ret = msmfb_overlay_vsync_ctrl(info, argp);
-		break;
 	case MSMFB_OVERLAY_GET:
 		ret = msmfb_overlay_get(info, argp);
 		break;
@@ -4325,7 +4321,23 @@
 	case MSMFB_WRITEBACK_TERMINATE:
 		ret = msmfb_overlay_ioctl_writeback_terminate(info);
 		break;
+	case MSMFB_WRITEBACK_SET_MIRRORING_HINT:
+		ret = msmfb_overlay_ioctl_writeback_set_mirr_hint(
+				info, argp);
+		break;
+	case MSMFB_WRITEBACK_PLAY:
+		ret = msmfb_overlay_ioctl_writeback_play(info, argp);
+		break;
 #endif
+	case MSMFB_VSYNC_CTRL:
+	case MSMFB_OVERLAY_VSYNC_CTRL:
+		down(&msm_fb_ioctl_ppp_sem);
+		if (mdp_rev >= MDP_REV_40)
+			ret = msmfb_overlay_vsync_ctrl(info, argp);
+		else
+			ret = msmfb_vsync_ctrl(info, argp);
+		up(&msm_fb_ioctl_ppp_sem);
+		break;
 	case MSMFB_BLIT:
 		down(&msm_fb_ioctl_ppp_sem);
 		ret = msmfb_blit(info, argp);
@@ -4538,6 +4550,8 @@
 			return ret;
 
 		ret = msmfb_handle_pp_ioctl(mfd, &mdp_pp);
+		if (ret == 1)
+			ret = copy_to_user(argp, &mdp_pp, sizeof(mdp_pp));
 		break;
 	case MSMFB_BUFFER_SYNC:
 		ret = copy_from_user(&buf_sync, argp, sizeof(buf_sync));
@@ -4549,8 +4563,10 @@
 		if (!ret)
 			ret = copy_to_user(argp, &buf_sync, sizeof(buf_sync));
 		break;
+
 	case MSMFB_DISPLAY_COMMIT:
 		ret = msmfb_display_commit(info, argp);
+		break;
 
 	case MSMFB_METADATA_GET:
 		ret = copy_from_user(&mdp_metadata, argp, sizeof(mdp_metadata));
@@ -4653,13 +4669,6 @@
 			return ret;
 		break;
 
-	case MSMFB_SET_SCHED_PRIORITY:
-		ret = copy_from_user(&sched_priority_data, argp, sizeof(sched_priority_data));
-		if(ret)
-			return ret;
-		do_sched_setscheduler(sched_priority_data.pid, sched_priority_data.priority);
-		break;
-
 	default:
 		MSM_FB_INFO("MDP: unknown ioctl (cmd=%x, type=0x%x, nr=0x%x) received!\n",
 			cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_def.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_def.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_def.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_def.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2013, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -37,8 +37,9 @@
 #include <linux/fb.h>
 #include <linux/list.h>
 #include <linux/types.h>
-
+#include <linux/switch.h>
 #include <linux/msm_mdp.h>
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 #endif
@@ -77,16 +78,19 @@
 
 	panel_id_type panel;
 	struct msm_panel_info panel_info;
-	int init_mipi_lcd;
 
 	DISP_TARGET dest;
 	struct fb_info *fbi;
 
+	struct device *dev;
 	boolean op_enable;
 	uint32 fb_imgType;
 	boolean sw_currently_refreshing;
 	boolean sw_refreshing_enable;
 	boolean hw_refresh;
+	
+	boolean init_mipi_lcd;
+	
 #ifdef CONFIG_FB_MSM_OVERLAY
 	int overlay_play_enable;
 #endif
@@ -138,7 +142,10 @@
 			      struct mdp_histogram_data *hist);
 	int (*start_histogram) (struct mdp_histogram_start_req *req);
 	int (*stop_histogram) (struct fb_info *info, uint32_t block);
+	void (*vsync_ctrl) (int enable);
 	void (*vsync_init) (int cndx);
+	void (*update_panel_info)(struct msm_fb_data_type *mfd);
+	bool (*is_panel_ready)(void);
 	void *vsync_show;
 	void *cursor_buf;
 	void *cursor_buf_phys;
@@ -154,19 +161,8 @@
 	__u32 var_xres;
 	__u32 var_yres;
 	__u32 var_pixclock;
-#if 1 
-	uint32_t width;
-	uint32_t height;
-	int perfhint;
-#endif 
 	__u32 var_frame_rate;
 
-	
-	int ovr_src_height;
-	int ovr_src_width;
-	int ovr_dst_height;
-	int ovr_dst_width;
-
 #ifdef MSM_FB_ENABLE_DBGFS
 	struct dentry *sub_dir;
 #endif
@@ -193,6 +189,7 @@
 	struct list_head writeback_busy_queue;
 	struct list_head writeback_free_queue;
 	struct list_head writeback_register_queue;
+	struct switch_dev writeback_sdev;
 	wait_queue_head_t wait_q;
 	struct ion_client *iclient;
 	unsigned long display_iova;
@@ -205,7 +202,7 @@
 	u32 writeback_state;
 	bool writeback_active_cnt;
 	int cont_splash_done;
-
+	void *cpu_pm_hdl;
 	u32 acq_fen_cnt;
 	struct sync_fence *acq_fen[MDP_MAX_FENCE_FD];
 	int cur_rel_fen_fd;
@@ -214,7 +211,6 @@
 	struct sync_fence *last_rel_fence;
 	struct sw_sync_timeline *timeline;
 	int timeline_value;
-	int vsync_sysfs_created;
 	u32 last_acq_fen_cnt;
 	struct sync_fence *last_acq_fen[MDP_MAX_FENCE_FD];
 	struct mutex sync_mutex;
@@ -222,6 +218,12 @@
 	u32 is_committing;
 	struct work_struct commit_work;
 	void *msm_fb_backup;
+	boolean panel_driver_on;
+	int vsync_sysfs_created;
+	void *copy_splash_buf;
+	unsigned char *copy_splash_phys;
+	uint32 sec_mapped;
+	uint32 sec_active;
 	
 	struct workqueue_struct *dimming_wq;
 	struct work_struct dimming_work;
@@ -230,14 +232,11 @@
 	struct work_struct sre_work;
 	struct timer_list sre_update_timer;
 };
-
 struct msm_fb_backup_type {
 	struct fb_info info;
-	struct fb_var_screeninfo var;
-	struct msm_fb_data_type mfd;
+	struct mdp_display_commit disp_commit;
 };
 
-
 struct dentry *msm_fb_get_debugfs_root(void);
 void msm_fb_debugfs_file_create(struct dentry *root, const char *name,
 				u32 *var);
@@ -258,14 +257,13 @@
 void msm_fb_wait_for_fence(struct msm_fb_data_type *mfd);
 int msm_fb_signal_timeline(struct msm_fb_data_type *mfd);
 void msm_fb_release_timeline(struct msm_fb_data_type *mfd);
-
 void mdp_color_enhancement(const struct mdp_reg *reg_seq, int size);
+
 #ifdef CONFIG_FB_BACKLIGHT
 void msm_fb_config_backlight(struct msm_fb_data_type *mfd);
 #endif
 
-void fill_black_screen(void);
-void unfill_black_screen(void);
+void fill_black_screen(bool on, uint8 pipe_num, uint8 mixer_num);
 int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd,
 				struct fb_info *info);
 
@@ -273,11 +271,6 @@
 #define INIT_IMAGE_FILE "/initlogo.rle"
 int load_565rle_image(char *filename, bool bf_supported);
 #endif
-enum {
-	MSM_FB_PERFORMANCE_NONE,
-	MSM_FB_PERFORMANCE_NORMAL,
-	MSM_FB_PERFORMANCE_MORE,
-};
 
 #define DEFAULT_BRIGHTNESS 143
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_panel.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_panel.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_panel.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_panel.c	2013-08-01 23:38:01.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -75,6 +75,75 @@
 		}
 	}
 
+	return ret;
+}
+
+int panel_next_fps_level_change(struct platform_device *pdev,
+					 u32 fps_level)
+{
+	int ret = 0;
+	struct msm_fb_panel_data *pdata;
+	struct msm_fb_panel_data *next_pdata;
+	struct platform_device *next_pdev;
+
+	pdata = (struct msm_fb_panel_data *)pdev->dev.platform_data;
+
+	if (pdata) {
+		next_pdev = pdata->next;
+		if (next_pdev) {
+			next_pdata =
+			    (struct msm_fb_panel_data *)next_pdev->dev.
+			    platform_data;
+			if ((next_pdata) && (next_pdata->fps_level_change))
+				ret = next_pdata->fps_level_change(next_pdev,
+							 fps_level);
+		}
+	}
+
+	return ret;
+}
+
+int panel_next_late_init(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct msm_fb_panel_data *pdata;
+	struct msm_fb_panel_data *next_pdata;
+	struct platform_device *next_pdev;
+
+	pdata = (struct msm_fb_panel_data *)pdev->dev.platform_data;
+
+	if (pdata) {
+		next_pdev = pdata->next;
+		if (next_pdev) {
+			next_pdata = (struct msm_fb_panel_data *)
+					next_pdev->dev.platform_data;
+			if ((next_pdata) && (next_pdata->late_init))
+				ret = next_pdata->late_init(next_pdev);
+		}
+	}
+
+	return ret;
+}
+
+int panel_next_early_off(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct msm_fb_panel_data *pdata;
+	struct msm_fb_panel_data *next_pdata;
+	struct platform_device *next_pdev;
+
+	pdata = (struct msm_fb_panel_data *)pdev->dev.platform_data;
+
+	if (pdata) {
+		next_pdev = pdata->next;
+		if (next_pdev) {
+			next_pdata = (struct msm_fb_panel_data *)
+					next_pdev->dev.platform_data;
+			if ((next_pdata) && (next_pdata->early_off))
+				ret = next_pdata->early_off(next_pdev);
+		}
+	}
+
 	return ret;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_panel.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_panel.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/msm_fb_panel.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/msm_fb_panel.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -60,6 +60,7 @@
 	__u32 v_pulse_width;
 	__u32 hw_vsync_mode;
 	__u32 vsync_notifier_period;
+	__u32 blt_ctrl;
 	__u32 rev;
 };
 
@@ -80,7 +81,6 @@
 	boolean is_sync_active_high;
 	
 	__u32 no_set_tear;
-
 };
 
 struct mddi_panel_info {
@@ -137,8 +137,6 @@
 	
 	struct mipi_dsi_reg_set *dsi_reg_db;
 	uint32 dsi_reg_db_size;
-	
-	char force_leave_ulps;
 };
 
 enum lvds_mode {
@@ -171,6 +169,7 @@
 	__u32 frame_count;
 	__u32 is_3d_panel;
 	__u32 frame_rate;
+	__u32 frame_interval;
 	__u32 width;
 	__u32 height;
 	__u32 camera_backlight;
@@ -195,15 +194,20 @@
 	void (*set_rect) (int x, int y, int xres, int yres);
 	void (*set_vsync_notifier) (msm_fb_vsync_handler_type, void *arg);
 	void (*set_backlight) (struct msm_fb_data_type *);
+	int (*get_backlight_on_status) (void);
 
 	
 	void (*display_on) (struct msm_fb_data_type *);
 	void (*display_off) (struct msm_fb_data_type *);
 	int (*on) (struct platform_device *pdev);
 	int (*off) (struct platform_device *pdev);
+	int (*late_init) (struct platform_device *pdev);
+	int (*early_off) (struct platform_device *pdev);
 	int (*power_ctrl) (boolean enable);
 	struct platform_device *next;
 	int (*clk_func) (int enable);
+	int (*fps_level_change) (struct platform_device *pdev,
+					u32 fps_level);
 #ifdef CONFIG_FB_MSM_CABC
 	int (*autobl_enable) (int on, struct msm_fb_data_type *);
 	void (*enable_cabc) (int, bool, struct msm_fb_data_type *);
@@ -222,6 +226,10 @@
 						u32 type, u32 id);
 int panel_next_on(struct platform_device *pdev);
 int panel_next_off(struct platform_device *pdev);
+int panel_next_fps_level_change(struct platform_device *pdev,
+					u32 fps_level);
+int panel_next_late_init(struct platform_device *pdev);
+int panel_next_early_off(struct platform_device *pdev);
 
 int lcdc_device_register(struct msm_panel_info *pinfo);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/sii9234/sii9234.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/sii9234/sii9234.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/sii9234/sii9234.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/sii9234/sii9234.c	2013-08-01 23:38:01.000000000 -0600
@@ -349,20 +349,19 @@
 	T_MHL_SII9234_INFO *pInfo = sii9234_info_ptr;
 	if (!pInfo)
 		return;
+
 	mutex_lock(&mhl_early_suspend_sem);
-	if (!g_bEnterEarlySuspend) {
+	if(time_after(jiffies, irq_jiffies + HZ/20))
+	{
 		uint8_t		event;
 		uint8_t		eventParameter;
-		if(time_after(jiffies, irq_jiffies + HZ/20))
-		{
-			irq_jiffies = jiffies;
-			
-			need_simulate_cable_out = false;
-			if(!dbg_con_test_on)
-				cancel_delayed_work(&pInfo->irq_timeout_work);
-			SiiMhlTxGetEvents(&event, &eventParameter);
-			ProcessRcp(event, eventParameter);
-		}
+		irq_jiffies = jiffies;
+		
+		need_simulate_cable_out = false;
+		if(!dbg_con_test_on)
+			cancel_delayed_work(&pInfo->irq_timeout_work);
+		SiiMhlTxGetEvents(&event, &eventParameter);
+		ProcessRcp(event, eventParameter);
 	}
 	mutex_unlock(&mhl_early_suspend_sem);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h	2013-08-01 23:38:01.000000000 -0600
@@ -294,6 +294,7 @@
 	struct ddl_batch_frame_data batch_frame;
 	u32 avc_delimiter_enable;
 	u32 vui_timinginfo_enable;
+	u32 bitstream_restrict_enable;
 };
 struct ddl_decoder_data {
 	struct ddl_codec_data_hdr  hdr;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c	2013-08-01 23:38:01.000000000 -0600
@@ -403,8 +403,6 @@
 		encoder->dynamic_prop_change = 0;
 		ddl_free_enc_hw_buffers(ddl);
 	}
-	ddl_pmem_free(&ddl->shared_mem[0]);
-	ddl_pmem_free(&ddl->shared_mem[1]);
 }
 
 u32 ddl_codec_type_transact(struct ddl_client_context *ddl,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c	2013-08-01 23:38:01.000000000 -0600
@@ -1080,10 +1080,24 @@
 		}
 		break;
 	}
+	case VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG:
+	{
+		struct vcd_property_bitstream_restrict_enable *restrict_enable =
+			(struct vcd_property_bitstream_restrict_enable *)
+				property_value;
+		if (sizeof(struct vcd_property_bitstream_restrict_enable) ==
+			property_hdr->sz &&
+			encoder->codec.codec == VCD_CODEC_H264) {
+			encoder->bitstream_restrict_enable =
+			restrict_enable->bitstream_restrict_enable_flag;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	}
 	default:
 		DDL_MSG_ERROR("INVALID ID %d\n", (int)property_hdr->prop_id);
 		vcd_status = VCD_ERR_ILLEGAL_OP;
-	break;
+		break;
 	}
 	return vcd_status;
 }
@@ -1581,6 +1595,15 @@
 			vcd_status = VCD_S_SUCCESS;
 		}
 		break;
+	case VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG:
+		if (sizeof(struct vcd_property_bitstream_restrict_enable) ==
+			property_hdr->sz) {
+			((struct vcd_property_bitstream_restrict_enable *)
+				property_value)->bitstream_restrict_enable_flag
+					= encoder->bitstream_restrict_enable;
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
 	default:
 		vcd_status = VCD_ERR_ILLEGAL_OP;
 		break;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2013-08-01 23:38:01.000000000 -0600
@@ -85,6 +85,8 @@
 #define VIDC_SM_ENC_EXT_CTRL_VBV_BUFFER_SIZE_SHFT    16
 #define VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_BMSK     0x00004000
 #define VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_SHFT     14
+#define VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_BMSK 0x2000
+#define VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_SHFT 13
 #define VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_BMSK    0x00000800
 #define VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_SHFT    11
 #define VIDC_SM_ENC_EXT_CTRL_H263_CPCFC_ENABLE_BMSK  0x80
@@ -457,8 +459,8 @@
 	enum VIDC_SM_frame_skip frame_skip_mode,
 	u32 seq_hdr_in_band, u32 vbv_buffer_size, u32 cpcfc_enable,
 	u32 sps_pps_control, u32 closed_gop_enable,
-	u32 au_delim_enable,
-	u32 vui_timing_info_enable)
+	u32 au_delim_enable, u32 vui_timing_info_enable,
+	u32 restrict_bitstream_enable)
 {
 	u32 enc_ctrl;
 	enc_ctrl = VIDC_SETFIELD((hec_enable) ? 1 : 0,
@@ -487,7 +489,10 @@
 			VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_BMSK) |
 			VIDC_SETFIELD((vui_timing_info_enable) ? 1 : 0,
 			VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_SHFT,
-			VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_BMSK);
+			VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_BMSK) |
+			VIDC_SETFIELD((restrict_bitstream_enable) ? 1 : 0,
+			VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_SHFT,
+			VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_BMSK);
 
 	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_ENC_EXT_CTRL_ADDR, enc_ctrl);
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2013-08-01 23:38:01.000000000 -0600
@@ -106,7 +106,8 @@
 	struct ddl_buf_addr *shared_mem, u32 hec_enable,
 	enum VIDC_SM_frame_skip  frame_skip_mode, u32 seq_hdr_in_band,
 	u32 vbv_buffer_size, u32 cpcfc_enable, u32 sps_pps_control,
-	u32 closed_gop_enable, u32 au_delim_enable, u32 vui_timing_info_enable);
+	u32 closed_gop_enable, u32 au_delim_enable, u32 vui_timing_info_enable,
+	u32 restrict_bitstream_enable);
 void vidc_sm_set_encoder_param_change(struct ddl_buf_addr *shared_mem,
 	u32 bit_rate_chg, u32 frame_rate_chg, u32 i_period_chg);
 void vidc_sm_set_encoder_vop_time(struct ddl_buf_addr *shared_mem,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2013-08-01 23:38:01.000000000 -0600
@@ -614,7 +614,8 @@
 		r_cframe_skip, false, 0,
 		h263_cpfc_enable, encoder->sps_pps.sps_pps_for_idr_enable_flag,
 		encoder->closed_gop, encoder->avc_delimiter_enable,
-		encoder->vui_timinginfo_enable);
+		encoder->vui_timinginfo_enable,
+		encoder->bitstream_restrict_enable);
 	if (encoder->vui_timinginfo_enable) {
 		vidc_sm_set_h264_encoder_timing_info(
 			&ddl->shared_mem[ddl->command_channel],
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/dec/vdec.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/dec/vdec.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/dec/vdec.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/dec/vdec.c	2013-08-01 23:38:01.000000000 -0600
@@ -1233,6 +1233,8 @@
 				return false;
 			}
 		}
+
+		client_ctx->stop_called = false;
 	} else {
 		DBG("%s(): Calling vcd_stop()", __func__);
 		mutex_lock(&vid_dec_device_p->lock);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/enc/venc.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/enc/venc.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/enc/venc.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/enc/venc.c	2013-08-01 23:38:01.000000000 -0600
@@ -1692,6 +1692,28 @@
 		break;
 	}
 
+       case VEN_IOCTL_SET_VUI_BITSTREAM_RESTRICT_FLAG:
+       {
+               struct vcd_property_hdr vcd_property_hdr;
+               struct vcd_property_bitstream_restrict_enable vcd_property_val;
+               u32 vcd_status = VCD_ERR_FAIL;
+
+               vcd_property_hdr.prop_id =
+                       VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG;
+               vcd_property_hdr.sz = sizeof(struct
+                               vcd_property_bitstream_restrict_enable);
+
+               vcd_property_val.bitstream_restrict_enable_flag = true;
+
+               vcd_status = vcd_set_property(client_ctx->vcd_handle,
+                               &vcd_property_hdr, &vcd_property_val);
+               if (vcd_status) {
+                       pr_err("Setting bitstream restrict flag failed");
+                       return -EIO;
+               }
+               break;
+       }
+
 	case VEN_IOCTL_SET_AC_PREDICTION:
 	case VEN_IOCTL_GET_AC_PREDICTION:
 	case VEN_IOCTL_SET_RVLC:
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/vcd/vcd.h monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/vcd/vcd.h
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/vcd/vcd.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/vcd/vcd.h	2013-08-01 23:38:01.000000000 -0600
@@ -399,4 +399,8 @@
 u32 vcd_update_decoder_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl);
 
 u32 vcd_set_perf_turbo_level(struct vcd_clnt_ctxt *cctxt);
+
+struct vcd_transc *vcd_get_first_in_use_trans_for_clnt(
+	struct vcd_clnt_ctxt *cctxt);
+
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/vcd/vcd_sub.c monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/vcd/vcd_sub.c
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm/vidc/common/vcd/vcd_sub.c	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm/vidc/common/vcd/vcd_sub.c	2013-08-01 23:38:01.000000000 -0600
@@ -1693,7 +1693,7 @@
 void vcd_send_frame_done_in_eos(struct vcd_clnt_ctxt *cctxt,
 	 struct vcd_frame_data *input_frame, u32 valid_opbuf)
 {
-	VCD_MSG_LOW("vcd_send_frame_done_in_eos:");
+	VCD_MSG_HIGH("vcd_send_frame_done_in_eos:");
 
 	if (!input_frame->virtual && !valid_opbuf) {
 		VCD_MSG_MED("Sending NULL output with EOS");
@@ -1813,12 +1813,41 @@
 	}
 }
 
+struct vcd_transc *vcd_get_first_in_use_trans_for_clnt(
+	struct vcd_clnt_ctxt *cctxt)
+{
+	u32 i;
+	struct vcd_dev_ctxt *dev_ctxt;
+	VCD_MSG_HIGH("%s: ", __func__);
+	dev_ctxt = cctxt->dev_ctxt;
+	if (!dev_ctxt->trans_tbl) {
+		VCD_MSG_ERROR("%s: Null trans_tbl", __func__);
+		return NULL;
+	}
+	i = 0;
+	while (i < dev_ctxt->trans_tbl_size) {
+		if ((cctxt == dev_ctxt->trans_tbl[i].cctxt) &&
+			(dev_ctxt->trans_tbl[i].in_use)) {
+			VCD_MSG_MED("%s: found transc = 0x%p",
+				__func__, &dev_ctxt->trans_tbl[i]);
+			break;
+		}
+		i++;
+	}
+	if (i == dev_ctxt->trans_tbl_size) {
+		VCD_MSG_ERROR("%s: in_use transction not found",
+			__func__);
+		return NULL;
+	} else
+		return &dev_ctxt->trans_tbl[i];
+}
+
 u32 vcd_handle_recvd_eos(
 	struct vcd_clnt_ctxt *cctxt,
 	 struct vcd_frame_data *input_frame, u32 *pb_eos_handled)
 {
 	u32 rc;
-
+	struct vcd_transc *transc;
 	VCD_MSG_LOW("vcd_handle_recvd_eos:");
 
 	*pb_eos_handled = false;
@@ -1834,15 +1863,24 @@
 
 	if (rc == VCD_S_SUCCESS)
 		*pb_eos_handled = true;
-	else if (cctxt->decoding && !input_frame->virtual)
+	else if (cctxt->decoding && !input_frame->virtual) {
 		cctxt->sched_clnt_hdl->tkns++;
-	else if (!cctxt->decoding) {
-		vcd_send_frame_done_in_eos(cctxt, input_frame, false);
-		if (cctxt->status.mask & VCD_EOS_WAIT_OP_BUF) {
-			vcd_do_client_state_transition(cctxt,
-				VCD_CLIENT_STATE_EOS,
-				CLIENT_STATE_EVENT_NUMBER
-				(encode_frame));
+		VCD_MSG_LOW("%s: decoding & virtual addr is NULL", __func__);
+	} else if (!cctxt->decoding && !cctxt->status.frame_delayed) {
+		if (!cctxt->status.frame_submitted) {
+			vcd_send_frame_done_in_eos(cctxt, input_frame, false);
+			if (cctxt->status.mask & VCD_EOS_WAIT_OP_BUF)
+				vcd_do_client_state_transition(cctxt,
+					VCD_CLIENT_STATE_EOS,
+					CLIENT_STATE_EVENT_NUMBER
+					(encode_frame));
+		} else {
+			transc = vcd_get_first_in_use_trans_for_clnt(cctxt);
+			if (transc) {
+				transc->flags |= VCD_FRAME_FLAG_EOS;
+				VCD_MSG_HIGH("%s: Add EOS flag to transc",
+				       __func__);
+			}
 		}
 		*pb_eos_handled = true;
 	}
@@ -2319,8 +2357,16 @@
 
 	if (cctxt->decoding)
 		op_frm->vcd_frm.frame = transc->frame;
-	else
+	else {
 		transc->frame = op_frm->vcd_frm.frame;
+		if ((transc->flags & VCD_FRAME_FLAG_EOS) &&
+			!(op_frm->vcd_frm.flags & VCD_FRAME_FLAG_EOS)) {
+			op_frm->vcd_frm.flags |= VCD_FRAME_FLAG_EOS;
+			VCD_MSG_HIGH("%s: add EOS flag to the output "\
+				"from transc(0x%x)",
+				__func__, (u32)transc);
+		}
+	}
 	transc->frame_done = true;
 
 	if (transc->input_done && transc->frame_done) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/Makefile monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/Makefile	2013-08-01 23:38:09.000000000 -0600
@@ -0,0 +1,194 @@
+ifeq ($(CONFIG_FB_MSM_MDSS),y)
+obj-y += mdss/
+else
+obj-y := msm_fb.o
+
+obj-$(CONFIG_FB_MSM_LOGO) += logo.o
+obj-$(CONFIG_FB_BACKLIGHT) += msm_fb_bl.o
+
+ifeq ($(CONFIG_FB_MSM_MDP_HW),y)
+# MDP
+obj-y += mdp.o
+
+obj-$(CONFIG_DEBUG_FS) += mdp_debugfs.o
+
+ifeq ($(CONFIG_FB_MSM_MDP40),y)
+obj-y += mdp4_util.o
+obj-y += mdp4_hsic.o
+else
+obj-y += mdp_hw_init.o
+obj-y += mdp_ppp.o
+ifeq ($(CONFIG_FB_MSM_MDP31),y)
+obj-y += mdp_ppp_v31.o
+else
+obj-y += mdp_ppp_v20.o
+endif
+endif
+
+ifeq ($(CONFIG_FB_MSM_OVERLAY),y)
+obj-y += mdp4_overlay.o
+obj-y += mdp4_overlay_lcdc.o
+ifeq ($(CONFIG_FB_MSM_MIPI_DSI),y)
+obj-y += mdp4_overlay_dsi_video.o
+obj-y += mdp4_overlay_dsi_cmd.o
+else
+obj-y += mdp4_overlay_mddi.o
+endif
+else
+obj-y += mdp_dma_lcdc.o
+endif
+
+obj-$(CONFIG_FB_MSM_MDP303) += mdp_dma_dsi_video.o
+
+ifeq ($(CONFIG_FB_MSM_DTV),y)
+obj-y += mdp4_dtv.o
+obj-y += mdp4_overlay_dtv.o
+endif
+
+obj-y += mdp_dma.o
+obj-y += mdp_dma_s.o
+obj-y += mdp_vsync.o
+obj-y += mdp_cursor.o
+obj-y += mdp_dma_tv.o
+obj-$(CONFIG_ARCH_MSmonarudoX27A) += msm_dss_io_7x27a.o
+obj-$(CONFIG_ARCH_MSM8X60) += msm_dss_io_8x60.o
+obj-$(CONFIG_ARCH_MSM8960) += msm_dss_io_8960.o
+
+# EBI2
+obj-$(CONFIG_FB_MSM_EBI2) += ebi2_lcd.o
+
+# LCDC
+obj-$(CONFIG_FB_MSM_LCDC) += lcdc.o
+
+# LVDS
+obj-$(CONFIG_FB_MSM_LVDS) += lvds.o
+
+# MDDI
+msm_mddi-objs := mddi.o mddihost.o mddihosti.o
+obj-$(CONFIG_FB_MSM_MDDI) += msm_mddi.o
+
+# External MDDI
+msm_mddi_ext-objs := mddihost_e.o mddi_ext.o
+obj-$(CONFIG_FB_MSM_EXTMDDI) += msm_mddi_ext.o
+
+# MIPI gereric
+msm_mipi-objs := mipi_dsi.o mipi_dsi_host.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI) += msm_mipi.o
+
+# MIPI manufacture
+obj-$(CONFIG_FB_MSM_MIPI_DSI_TOSHIBA) += mipi_toshiba.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NOVATEK) += mipi_novatek.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_ORISE) += mipi_orise.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_RENESAS) += mipi_renesas.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_TRULY) += mipi_truly.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35510) += mipi_NT35510.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35516) += mipi_truly_tft540960_1_e.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_SIMULATOR) += mipi_simulator.o
+
+# MIPI Bridge
+obj-$(CONFIG_FB_MSM_MIPI_DSI_TC358764_DSI2LVDS) += mipi_tc358764_dsi2lvds.o
+
+# TVEnc
+obj-$(CONFIG_FB_MSM_TVOUT) += tvenc.o
+ifeq ($(CONFIG_FB_MSM_OVERLAY),y)
+obj-$(CONFIG_FB_MSM_TVOUT) += mdp4_overlay_atv.o
+endif
+
+# MSM FB Panel
+obj-y += msm_fb_panel.o
+obj-$(CONFIG_FB_MSM_EBI2_TMD_QVGA_EPSON_QCIF) += ebi2_tmd20.o
+obj-$(CONFIG_FB_MSM_EBI2_TMD_QVGA_EPSON_QCIF) += ebi2_l2f.o
+
+ifeq ($(CONFIG_FB_MSM_MDDI_AUTO_DETECT),y)
+obj-y += mddi_prism.o
+obj-y += mddi_toshiba.o
+obj-y += mddi_toshiba_vga.o
+obj-y += mddi_toshiba_wvga_pt.o
+obj-y += mddi_toshiba_wvga.o
+obj-y += mddi_sharp.o
+obj-y += mddi_orise.o
+obj-y += mddi_quickvx.o
+else
+obj-$(CONFIG_FB_MSM_MDDI_PRISM_WVGA) += mddi_prism.o
+obj-$(CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON) += mddi_toshiba.o
+obj-$(CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON_VGA) += mddi_toshiba_vga.o
+obj-$(CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA_PORTRAIT) += mddi_toshiba_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA) += mddi_toshiba_wvga.o
+obj-$(CONFIG_FB_MSM_MDDI_SHARP_QVGA_128x128) += mddi_sharp.o
+obj-$(CONFIG_FB_MSM_MDDI_ORISE) += mddi_orise.o
+obj-$(CONFIG_FB_MSM_MDDI_QUICKVX) += mddi_quickvx.o
+endif
+
+ifeq ($(CONFIG_FB_MSM_MIPI_PANEL_DETECT),y)
+obj-y += mipi_toshiba_video_wvga_pt.o mipi_toshiba_video_wsvga_pt.o mipi_toshiba_video_wuxga.o
+obj-y += mipi_novatek_video_qhd_pt.o mipi_novatek_cmd_qhd_pt.o mipi_novatek_cmd_720p.o
+obj-y += mipi_orise_video_720p_pt.o mipi_orise_cmd_720p_pt.o
+obj-y += mipi_renesas_video_fwvga_pt.o mipi_renesas_cmd_fwvga_pt.o
+obj-y += mipi_NT35510_video_wvga_pt.o mipi_NT35510_cmd_wvga_pt.o
+obj-y += mipi_truly_tft540960_1_e_video_qhd_pt.o mipi_truly_tft540960_1_e_cmd_qhd_pt.o
+obj-y += mipi_chimei_wxga_pt.o
+obj-y += mipi_chimei_wuxga.o
+obj-y += mipi_truly_video_wvga_pt.o
+else
+obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT) += mipi_toshiba_video_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT) += mipi_toshiba_video_wsvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA) += mipi_toshiba_video_wuxga.o
+obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT) += mipi_novatek_video_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_ORISE_VIDEO_720P_PT) += mipi_orise_video_720p_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_ORISE_CMD_720P_PT) += mipi_orise_cmd_720p_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT) += mipi_novatek_cmd_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT) += mipi_renesas_video_fwvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT) += mipi_renesas_cmd_fwvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT) += mipi_renesas_video_fwvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT) += mipi_truly_video_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35510_CMD_WVGA_PT) += mipi_NT35510_cmd_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT) += mipi_NT35510_video_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35516_CMD_QHD_PT) += mipi_truly_tft540960_1_e_cmd_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35516_VIDEO_QHD_PT) += mipi_truly_tft540960_1_e_video_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO) += mipi_simulator_video.o
+obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WXGA) += mipi_chimei_wxga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA) += mipi_chimei_wuxga.o
+endif
+
+obj-$(CONFIG_FB_MSM_LCDC_PANEL) += lcdc_panel.o
+obj-$(CONFIG_FB_MSM_LCDC_PRISM_WVGA) += lcdc_prism.o
+obj-$(CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA) += lcdc_samsung_wsvga.o
+obj-$(CONFIG_FB_MSM_LCDC_CHIMEI_WXGA) += lcdc_chimei_wxga.o
+obj-$(CONFIG_FB_MSM_LCDC_NT35582_WVGA) += lcdc_nt35582_wvga.o
+obj-$(CONFIG_FB_MSM_LCDC_EXTERNAL_WXGA) += lcdc_external.o
+obj-$(CONFIG_FB_MSM_HDMI_SII_EXTERNAL_720P) += hdmi_sii9022.o
+obj-$(CONFIG_FB_MSM_LCDC_GORDON_VGA) += lcdc_gordon.o
+obj-$(CONFIG_FB_MSM_LCDC_WXGA) += lcdc_wxga.o
+obj-$(CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT) += lcdc_toshiba_wvga_pt.o
+obj-$(CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT) += lcdc_toshiba_fwvga_pt.o
+obj-$(CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT) += lcdc_sharp_wvga_pt.o
+obj-$(CONFIG_FB_MSM_LCDC_AUO_WVGA) += lcdc_auo_wvga.o
+obj-$(CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT) += lcdc_samsung_oled_pt.o
+obj-$(CONFIG_FB_MSM_HDMI_ADV7520_PANEL) += adv7520.o
+obj-$(CONFIG_FB_MSM_LCDC_ST15_WXGA) += lcdc_st15.o
+obj-$(CONFIG_FB_MSM_LVDS_CHIMEI_WXGA) += lvds_chimei_wxga.o
+obj-$(CONFIG_FB_MSM_LVDS_FRC_FHD) += lvds_frc_fhd.o
+obj-$(CONFIG_FB_MSM_HDMI_MSM_PANEL) += hdmi_msm.o
+obj-$(CONFIG_FB_MSM_EXT_INTERFACE_COMMON) += external_common.o
+obj-$(CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335) += lcdc_truly_ips3p2335.o
+
+obj-$(CONFIG_FB_MSM_TVOUT) += tvout_msm.o
+
+obj-$(CONFIG_FB_MSM_EXTMDDI_SVGA) += mddi_ext_lcd.o
+
+obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback_panel.o
+obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback.o
+obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_overlay_writeback.o
+else
+obj-$(CONFIG_FB_MSM_EBI2) += ebi2_host.o
+obj-$(CONFIG_FB_MSM_EBI2) += ebi2_lcd.o
+obj-y += msm_fb_panel.o
+obj-$(CONFIG_FB_MSM_EBI2_EPSON_S1D_QVGA_PANEL) += ebi2_epson_s1d_qvga.o
+endif
+endif
+
+obj-$(CONFIG_MSM_VIDC_1080P) += vidc/
+obj-$(CONFIG_MSM_VIDC_720P) += vidc/
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234)  += sii9234/
+clean:
+	rm *.o .*cmd
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/sii9234/Makefile monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/sii9234/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/sii9234/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/sii9234/Makefile	2013-08-01 23:38:09.000000000 -0600
@@ -0,0 +1,8 @@
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += sii9234.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += i2c_master_sw.o
+#obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += si_cpCbus.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += TPI.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += TPI_Access.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += Util.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += sii_mhltx.o
+obj-$(CONFIG_FB_MSM_HDMI_MHL_SII9234) += mhltx_rcptable.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/vidc/Makefile monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/vidc/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/drivers/video/msm412/vidc/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/drivers/video/msm412/vidc/Makefile	2013-08-01 23:38:09.000000000 -0600
@@ -0,0 +1,62 @@
+ifdef CONFIG_MSM_VIDC_720P
+EXTRA_CFLAGS += -Idrivers/video/msm/vidc/720p/ddl
+EXTRA_CFLAGS += -Idrivers/video/msm/vidc/720p/resource_tracker
+endif
+
+ifdef CONFIG_MSM_VIDC_1080P
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/1080p/ddl
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/1080p/resource_tracker
+endif
+
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/common/dec
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/common/enc
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/common/vcd
+EXTRA_CFLAGS  += -Idrivers/video/msm/vidc/common/init
+
+obj-$(CONFIG_MSM_VIDC) += vidc.o
+
+vidc-objs :=	common/init/vidc_init.o \
+		common/vcd/vcd_api.o \
+		common/vcd/vcd_power_sm.o \
+		common/vcd/vcd_client_sm.o \
+		common/vcd/vcd_device_sm.o \
+		common/vcd/vcd_scheduler.o \
+		common/vcd/vcd_sub.o \
+
+ifdef CONFIG_MSM_VIDC_720P
+vidc-objs +=	720p/ddl/vcd_ddl_firmware.o \
+		720p/ddl/vcd_ddl_metadata.o \
+		720p/ddl/vidc.o \
+		720p/ddl/vcd_ddl_utils.o \
+		720p/ddl/vcd_ddl.o \
+		720p/ddl/vcd_ddl_helper.o \
+		720p/ddl/vcd_ddl_interrupt_handler.o \
+		720p/ddl/vcd_ddl_hal.o \
+		720p/ddl/vcd_ddl_properties.o \
+		720p/resource_tracker/vcd_res_tracker.o \
+		720p/ddl/vcd_ddl_errors.o
+endif
+
+ifdef CONFIG_MSM_VIDC_1080P
+vidc-objs +=	1080p/ddl/vcd_ddl_helper.o \
+		1080p/ddl/vcd_ddl_utils.o \
+		1080p/ddl/vcd_ddl_interrupt_handler.o \
+		1080p/ddl/vcd_ddl_properties.o \
+		1080p/ddl/vcd_ddl_errors.o \
+		1080p/ddl/vcd_ddl_shared_mem.o \
+		1080p/ddl/vidc.o \
+		1080p/ddl/vidc_pix_cache.o \
+		1080p/ddl/vcd_ddl_vidc.o \
+		1080p/ddl/vcd_ddl.o \
+		1080p/ddl/vcd_ddl_metadata.o \
+		1080p/resource_tracker/vcd_res_tracker.o
+endif
+
+obj-$(CONFIG_MSM_VIDC_VDEC) += vidc_vdec.o
+
+vidc_vdec-objs :=	common/dec/vdec.o
+
+obj-$(CONFIG_MSM_VIDC_VENC) += vidc_venc.o
+
+vidc_venc-objs :=	common/enc/venc.o \
+			common/enc/venc_internal.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/ext4/fsync.c monarudo-jb-3.4.10-e22f38b/fs/ext4/fsync.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/ext4/fsync.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/ext4/fsync.c	2013-08-01 23:38:05.000000000 -0600
@@ -191,27 +191,14 @@
 	int ret;
 	tid_t commit_tid;
 	bool needs_barrier = false;
-#ifdef CONFIG_FSYNC_DEBUG
-	ktime_t fsync_t, fsync_diff;
-#endif
 
 	J_ASSERT(ext4_journal_current_handle() == NULL);
 
 	trace_ext4_sync_file_enter(file, datasync);
 
-#ifdef CONFIG_FSYNC_DEBUG
-	fsync_t = ktime_get();
 	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
-	fsync_diff = ktime_sub(ktime_get(), fsync_t);
-	if (ktime_to_ns(fsync_diff) >= 5000000000LL)
-		printk("%s: filemap_write_and_wait_range() takes %lld nsec\n", __func__, ktime_to_ns(fsync_diff));
 	if (ret)
 		return ret;
-#else
-	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
-	if (ret)
-		return ret;
-#endif
 	mutex_lock(&inode->i_mutex);
 
 	if (inode->i_sb->s_flags & MS_RDONLY)
@@ -238,27 +225,9 @@
 	    !jbd2_trans_will_send_data_barrier(journal, commit_tid))
 		needs_barrier = true;
 	jbd2_log_start_commit(journal, commit_tid);
-#ifdef CONFIG_FSYNC_DEBUG
-	fsync_t = ktime_get();
 	ret = jbd2_log_wait_commit(journal, commit_tid);
-	fsync_diff = ktime_sub(ktime_get(), fsync_t);
-	if (ktime_to_ns(fsync_diff) >= 5000000000LL)
-		printk("%s: jbd2_log_wait_commit() takes %lld nsec\n", __func__, ktime_to_ns(fsync_diff));
-#else
-	ret = jbd2_log_wait_commit(journal, commit_tid);
-#endif
-
-	if (needs_barrier) {
-#ifdef CONFIG_FSYNC_DEBUG
-		fsync_t = ktime_get();
+	if (needs_barrier)
 		blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
-		fsync_diff = ktime_sub(ktime_get(), fsync_t);
-		if (ktime_to_ns(fsync_diff) >= 5000000000LL)
-			printk("%s: blkdev_issue_flush() takes %lld nsec\n", __func__, ktime_to_ns(fsync_diff));
-#else
-	blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
-#endif
-	}
  out:
 	mutex_unlock(&inode->i_mutex);
 	trace_ext4_sync_file_exit(inode, ret);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/ext4/xattr_security.c monarudo-jb-3.4.10-e22f38b/fs/ext4/xattr_security.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/ext4/xattr_security.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/ext4/xattr_security.c	2013-08-01 23:38:05.000000000 -0600
@@ -1,7 +1,3 @@
-/*
- * linux/fs/ext4/xattr_security.c
- * Handler for storing security labels as extended attributes.
- */
 
 #include <linux/string.h>
 #include <linux/fs.h>
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/fuse/dir.c monarudo-jb-3.4.10-e22f38b/fs/fuse/dir.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/fuse/dir.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/fuse/dir.c	2013-08-01 23:38:05.000000000 -0600
@@ -471,6 +471,8 @@
 			mutex_unlock(&fc->inst_mutex);
 			dput(alias);
 			iput(inode);
+			pr_info("fuse: %s -EBUSY (%s)\n", __func__,
+				entry->d_name.name);
 			return -EBUSY;
 		}
 		d_instantiate(entry, inode);
@@ -525,11 +527,29 @@
 	return fuse_mknod(dir, entry, mode, 0);
 }
 
+static int fuse_lsof(struct inode *dir, struct dentry *entry)
+{
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.h.opcode = FUSE_LSOF;
+	req->in.h.nodeid = get_node_id(dir);
+	req->in.numargs = 1;
+	req->in.args[0].size = entry->d_name.len + 1;
+	req->in.args[0].value = entry->d_name.name;
+	fuse_request_send(fc, req);
+	fuse_put_request(fc, req);
+	return 0;
+}
+
 static int fuse_mkdir(struct inode *dir, struct dentry *entry, umode_t mode)
 {
 	struct fuse_mkdir_in inarg;
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct fuse_req *req = fuse_get_req(fc);
+	int ret;
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
@@ -545,7 +565,10 @@
 	req->in.args[0].value = &inarg;
 	req->in.args[1].size = entry->d_name.len + 1;
 	req->in.args[1].value = entry->d_name.name;
-	return create_new_entry(fc, req, dir, entry, S_IFDIR);
+	ret = create_new_entry(fc, req, dir, entry, S_IFDIR);
+	if (ret == -EBUSY)
+		fuse_lsof(dir, entry);
+	return ret;
 }
 
 static int fuse_symlink(struct inode *dir, struct dentry *entry,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/fuse/inode.c monarudo-jb-3.4.10-e22f38b/fs/fuse/inode.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/fuse/inode.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/fuse/inode.c	2013-08-01 23:38:05.000000000 -0600
@@ -20,6 +20,7 @@
 #include <linux/random.h>
 #include <linux/sched.h>
 #include <linux/exportfs.h>
+#include <linux/suspend.h>
 
 MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
 MODULE_DESCRIPTION("Filesystem in Userspace");
@@ -200,8 +201,10 @@
 	spin_unlock(&fc->lock);
 
 	if (S_ISREG(inode->i_mode) && oldsize != attr->size) {
+		lock_system_sleep();
 		truncate_pagecache(inode, oldsize, attr->size);
 		invalidate_inode_pages2(inode->i_mapping);
+		unlock_system_sleep();
 	}
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/internal.h monarudo-jb-3.4.10-e22f38b/fs/internal.h
--- monarudo-jb-crc-3.4.10-7edee3c/fs/internal.h	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/internal.h	2013-08-01 23:38:04.000000000 -0600
@@ -62,6 +62,7 @@
 extern struct dentry *mount_fs(struct file_system_type *,
 			       int, const char *, void *);
 extern struct super_block *user_get_super(dev_t);
+extern int umount2(char *name, int flags);
 
 extern atomic_t vfs_emergency_remount;
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/jbd2/checkpoint.c monarudo-jb-3.4.10-e22f38b/fs/jbd2/checkpoint.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/jbd2/checkpoint.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/jbd2/checkpoint.c	2013-08-01 23:38:05.000000000 -0600
@@ -417,7 +417,7 @@
 		}
 		if (need_resched())
 			return freed;
-	} while (jh != last_jh);
+	} while (jh != last_jh && next_jh != NULL);
 
 	return freed;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/jbd2/journal.c monarudo-jb-3.4.10-e22f38b/fs/jbd2/journal.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/jbd2/journal.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/jbd2/journal.c	2013-08-01 23:38:05.000000000 -0600
@@ -509,11 +509,6 @@
 int jbd2_log_wait_commit(journal_t *journal, tid_t tid)
 {
 	int err = 0;
-#ifdef CONFIG_FSYNC_DEBUG
-	ktime_t fsync_t, fsync_diff;
-	ktime_t wait_commit_t, wait_commit_diff;
-	wait_commit_t = ktime_get();
-#endif
 
 	read_lock(&journal->j_state_lock);
 #ifdef CONFIG_JBD2_DEBUG
@@ -523,29 +518,14 @@
 		       __func__, journal->j_commit_request, tid);
 	}
 #endif
-
-
 	while (tid_gt(tid, journal->j_commit_sequence)) {
 		jbd_debug(1, "JBD2: want %d, j_commit_sequence=%d\n",
 				  tid, journal->j_commit_sequence);
 		wake_up(&journal->j_wait_commit);
 		read_unlock(&journal->j_state_lock);
-#ifdef CONFIG_FSYNC_DEBUG
-		fsync_t = ktime_get();
-		wait_event(journal->j_wait_done_commit,
-				!tid_gt(tid, journal->j_commit_sequence));
-		fsync_diff = ktime_sub(ktime_get(), fsync_t);
-		if (ktime_to_ns(fsync_diff) >= 5000000000LL)
-			printk("%s: wait_event takes %lld nsec\n", __func__, ktime_to_ns(fsync_diff));
-#else
 		wait_event(journal->j_wait_done_commit,
 				!tid_gt(tid, journal->j_commit_sequence));
-#endif
 		read_lock(&journal->j_state_lock);
-
-#ifdef CONFIG_FSYNC_DEBUG
-		fsync_t = ktime_get();
-#endif
 	}
 	read_unlock(&journal->j_state_lock);
 
@@ -553,12 +533,6 @@
 		printk(KERN_EMERG "journal commit I/O error\n");
 		err = -EIO;
 	}
-
-#ifdef CONFIG_FSYNC_DEBUG
-		wait_commit_diff = ktime_sub(ktime_get(), wait_commit_t);
-		if (ktime_to_ns(wait_commit_diff) >= 5000000000LL)
-			printk("%s() takes %lld nsec\n", __func__, ktime_to_ns(wait_commit_diff));
-#endif
 	return err;
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/Kconfig monarudo-jb-3.4.10-e22f38b/fs/Kconfig
--- monarudo-jb-crc-3.4.10-7edee3c/fs/Kconfig	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/Kconfig	2013-08-01 23:38:05.000000000 -0600
@@ -296,9 +296,4 @@
 	depends on EXFAT_FS
 	default "target/htc.d/htc"
 
-config FSYNC_DEBUG
-	string "Debug EXT4 fsync"
-	depends on EXT4_FS
-	default n
-
 endmenu
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/namespace.c monarudo-jb-3.4.10-e22f38b/fs/namespace.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/namespace.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/namespace.c	2013-08-01 23:38:04.000000000 -0600
@@ -982,6 +982,41 @@
 	return retval;
 }
 
+int umount2(char *name, int flags)
+{
+	struct path path;
+	struct mount *mnt;
+	int retval;
+	int lookup_flags = 0;
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+
+	if (!(flags & UMOUNT_NOFOLLOW))
+		lookup_flags |= LOOKUP_FOLLOW;
+
+	retval = user_path_at(AT_FDCWD, name, lookup_flags, &path);
+	if (retval)
+		goto out;
+	mnt = real_mount(path.mnt);
+	retval = -EINVAL;
+	if (path.dentry != path.mnt->mnt_root)
+		goto dput_and_out;
+	if (!check_mnt(mnt))
+		goto dput_and_out;
+#if 0
+	retval = -EPERM;
+	if (!capable(CAP_SYS_ADMIN))
+		goto dput_and_out;
+#endif
+	retval = do_umount(mnt, flags);
+dput_and_out:
+	
+	dput(path.dentry);
+	mntput_no_expire(mnt);
+out:
+	return retval;
+}
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 SYSCALL_DEFINE1(oldumount, char __user *, name)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/read_write.c monarudo-jb-3.4.10-e22f38b/fs/read_write.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/read_write.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/read_write.c	2013-08-01 23:38:04.000000000 -0600
@@ -428,6 +428,10 @@
 	show_state_filter(TASK_UNINTERRUPTIBLE);
 	pr_info("### Show System Server State ###\n");
 	show_thread_group_state_filter("system_server", 0);
+	pr_info("### Show bugreport State ###\n");
+	show_thread_group_state_filter("bugreport", 0);
+	pr_info("### Show adbd State ###\n");
+	show_thread_group_state_filter("adbd", 0);
 }
 
 SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/fs/super.c monarudo-jb-3.4.10-e22f38b/fs/super.c
--- monarudo-jb-crc-3.4.10-7edee3c/fs/super.c	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/fs/super.c	2013-08-01 23:38:05.000000000 -0600
@@ -594,6 +594,8 @@
 	char b[BDEVNAME_SIZE];
 
 	atomic_set(&vfs_emergency_remount, 1);
+	
+	umount2("/devlog", MNT_DETACH);
 	spin_lock(&sb_lock);
 	list_for_each_entry(sb, &super_blocks, s_list) {
 		if (hlist_unhashed(&sb->s_instances))
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/asm-generic/audit_write.h monarudo-jb-3.4.10-e22f38b/include/asm-generic/audit_write.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/asm-generic/audit_write.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/asm-generic/audit_write.h	2013-08-01 23:38:04.000000000 -0600
@@ -11,5 +11,5 @@
 __NR_truncate64,
 #endif
 #ifdef __NR_bind
-__NR_bind,		/* bind can affect fs object only in one way... */
+__NR_bind,		
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/crypto/ctr.h monarudo-jb-3.4.10-e22f38b/include/crypto/ctr.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/crypto/ctr.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/crypto/ctr.h	2012-08-26 16:02:10.000000000 -0600
@@ -17,4 +17,4 @@
 #define CTR_RFC3686_IV_SIZE 8
 #define CTR_RFC3686_BLOCK_SIZE 16
 
-#endif  
+#endif  /* _CRYPTO_CTR_H */
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/akm8963.h monarudo-jb-3.4.10-e22f38b/include/linux/akm8963.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/akm8963.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/akm8963.h	2013-08-01 23:37:56.000000000 -0600
@@ -6,7 +6,7 @@
 #define AKM8963_I2C_NAME "akm8963"
 
 #define SENSOR_DATA_SIZE	8
-#define YPR_DATA_SIZE		12
+#define YPR_DATA_SIZE		18
 #define RWBUF_SIZE		16
 
 #define ACC_DATA_FLAG		0
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/bma250.h monarudo-jb-3.4.10-e22f38b/include/linux/bma250.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/bma250.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/bma250.h	2013-08-01 23:37:56.000000000 -0600
@@ -687,6 +687,7 @@
 		((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
 
 #define BMA250_I2C_NAME "bma250"
+#define BMA250_I2C_NAME_REMOVE_ECOMPASS "bma250_no_ecmps"
 
 #define BMAIO			0xA1
 
@@ -737,7 +738,7 @@
 	int calibration_mode;
 	int gs_kvalue;
 	unsigned int (*G_Sensor_Compass_POR)(void);
-
+	short layouts[4][3][3];
         
         u8 axis_map_x;
         u8 axis_map_y;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/cm3629.h monarudo-jb-3.4.10-e22f38b/include/linux/cm3629.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/cm3629.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/cm3629.h	2013-08-01 23:37:56.000000000 -0600
@@ -180,6 +180,7 @@
 	uint8_t ps1_thd_with_cal;
 	uint8_t ps2_thd_no_cal;
 	uint8_t ps2_thd_with_cal;
+	uint8_t ps_th_add;
 	uint8_t ls_cmd;
 	uint8_t ps1_adc_offset;
 	uint8_t ps2_adc_offset;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/fuse.h monarudo-jb-3.4.10-e22f38b/include/linux/fuse.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/fuse.h	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/fuse.h	2013-08-01 23:38:05.000000000 -0600
@@ -149,6 +149,7 @@
 	FUSE_NOTIFY_REPLY  = 41,
 	FUSE_BATCH_FORGET  = 42,
 
+	FUSE_LSOF          = 1024,
 	
 	CUSE_INIT          = 4096,
 };
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/htc_mode_server.h monarudo-jb-3.4.10-e22f38b/include/linux/htc_mode_server.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/htc_mode_server.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/htc_mode_server.h	2013-08-01 23:38:00.000000000 -0600
@@ -64,6 +64,7 @@
 	HSML_06_REQ_GET_SERVER_NONCE,
 	HSML_06_REQ_SET_CLIENT_AUTH,
 	HSML_06_REQ_GET_SERVER_AUTH,
+	HSML_06_REQ_SET_MAX_CHARGING_CURRENT,
 
 	HSML_06_REQ_COUNT
 };
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/if_ether.h monarudo-jb-3.4.10-e22f38b/include/linux/if_ether.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/if_ether.h	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/if_ether.h	2013-08-01 23:37:46.000000000 -0600
@@ -30,6 +30,7 @@
 #define ETH_DATA_LEN	1500		
 #define ETH_FRAME_LEN	1514		
 #define ETH_FCS_LEN	4		
+#define ETH_FRAME_LEN_MAX       9014    
 
 
 #define ETH_P_LOOP	0x0060		
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/iopoll.h monarudo-jb-3.4.10-e22f38b/include/linux/iopoll.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/iopoll.h	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/include/linux/iopoll.h	2013-08-01 23:38:01.000000000 -0600
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2012 Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_IOPOLL_H
+#define _LINUX_IOPOLL_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <asm-generic/errno.h>
+#include <asm/io.h>
+
+#define readl_poll_timeout(addr, val, cond, sleep_us, timeout_us) \
+({ \
+	unsigned long timeout = jiffies + usecs_to_jiffies(timeout_us); \
+	might_sleep_if(timeout_us); \
+	for (;;) { \
+		(val) = readl(addr); \
+		if ((cond) || (timeout_us && time_after(jiffies, timeout))) \
+			break; \
+		if (sleep_us) \
+			usleep_range(DIV_ROUND_UP(sleep_us, 4), sleep_us); \
+	} \
+	(cond) ? 0 : -ETIMEDOUT; \
+})
+
+#define readl_poll(addr, val, cond, sleep_us) \
+	readl_poll_timeout(addr, val, cond, sleep_us, 0)
+
+#define readl_tight_poll_timeout(addr, val, cond, timeout_us) \
+	readl_poll_timeout(addr, val, cond, 0, timeout_us)
+
+#define readl_tight_poll(addr, val, cond) \
+	readl_poll_timeout(addr, val, cond, 0, 0)
+
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/lsm_audit.h monarudo-jb-3.4.10-e22f38b/include/linux/lsm_audit.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/lsm_audit.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/lsm_audit.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,12 +1,3 @@
-/*
- * Common LSM logging functions
- * Heavily borrowed from selinux/avc.h
- *
- * Author : Etienne BASSET  <etienne.basset@ensta.org>
- *
- * All credits to : Stephen Smalley, <sds@epoch.ncsc.mil>
- * All BUGS to : Etienne BASSET  <etienne.basset@ensta.org>
- */
 #ifndef _LSM_COMMON_LOGGING_
 #define _LSM_COMMON_LOGGING_
 
@@ -40,7 +31,6 @@
 	} fam;
 };
 
-/* Auxiliary data to use in generating the audit record. */
 struct common_audit_data {
 	char type;
 #define LSM_AUDIT_DATA_PATH	1
@@ -70,7 +60,7 @@
 #endif
 		char *kmod_name;
 	} u;
-	/* this union contains LSM specific data */
+	
 	union {
 #ifdef CONFIG_SECURITY_SMACK
 		struct smack_audit_data *smack_audit_data;
@@ -81,7 +71,7 @@
 #ifdef CONFIG_SECURITY_APPARMOR
 		struct apparmor_audit_data *apparmor_audit_data;
 #endif
-	}; /* per LSM data pointer union */
+	}; 
 };
 
 #define v4info fam.v4
@@ -93,7 +83,6 @@
 int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		struct common_audit_data *ad, u8 *proto);
 
-/* Initialize an LSM audit data structure. */
 #define COMMON_AUDIT_DATA_INIT(_d, _t) \
 	{ memset((_d), 0, sizeof(struct common_audit_data)); \
 	 (_d)->type = LSM_AUDIT_DATA_##_t; }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/mfd/pm8xxx/pm8921-bms.h monarudo-jb-3.4.10-e22f38b/include/linux/mfd/pm8xxx/pm8921-bms.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/mfd/pm8xxx/pm8921-bms.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/mfd/pm8xxx/pm8921-bms.h	2013-08-01 23:37:52.000000000 -0600
@@ -20,10 +20,10 @@
 #define FCC_CC_COLS		5
 #define FCC_TEMP_COLS		8
 
-#define PC_CC_ROWS             29
+#define PC_CC_ROWS             31
 #define PC_CC_COLS             13
 
-#define PC_TEMP_ROWS		29
+#define PC_TEMP_ROWS		31
 #define PC_TEMP_COLS		8
 
 #define MAX_SINGLE_LUT_COLS	20
@@ -31,6 +31,7 @@
 #define OCV_UPDATE_STOP_BIT_CABLE_IN			(1)
 #define OCV_UPDATE_STOP_BIT_BATT_LEVEL			(1<<1)
 #define OCV_UPDATE_STOP_BIT_ATTR_FILE			(1<<2)
+#define OCV_UPDATE_STOP_BIT_BOOT_UP			(1<<3)
 
 struct single_row_lut {
 	int x[MAX_SINGLE_LUT_COLS];
@@ -64,6 +65,8 @@
 	struct sf_lut		*rbatt_est_ocv_lut;
 	int			default_rbatt_mohm;
 	int			delta_rbatt_mohm;
+	int			level_ocv_update_stop_begin; 
+	int			level_ocv_update_stop_end; 
 };
 
 struct pm8xxx_bms_core_data {
@@ -88,13 +91,18 @@
 	unsigned int			v_failure;
 	unsigned int			max_voltage_uv;
 	unsigned int			rconn_mohm;
+	int				store_batt_data_soc_thre;
 	int				enable_fcc_learning;
-	int						level_ocv_update_stop_begin; 
-	int						level_ocv_update_stop_end; 
 	unsigned int			criteria_sw_est_ocv; 
 	unsigned int			rconn_mohm_sw_est_ocv;
 };
 
+extern int batt_stored_magic_num;
+extern int batt_stored_soc;
+extern int batt_stored_ocv_uv;
+extern int batt_stored_cc_uv;
+extern unsigned long batt_stored_time_ms;
+
 #if defined(CONFIG_PM8921_BMS) || defined(CONFIG_PM8921_BMS_MODULE)
 extern struct pm8921_bms_battery_data  palladium_1500_data;
 extern struct pm8921_bms_battery_data  desay_5200_data;
@@ -120,6 +128,7 @@
 #ifdef CONFIG_HTC_BATT_8960
 int pm8921_bms_get_batt_current(int *result);
 
+int pm8921_store_hw_reset_reason(int is_hw_reset);
 int pm8921_bms_get_batt_soc(int *result);
 int pm8921_bms_get_batt_cc(int *result);
 int pm8921_bms_get_attr_text(char *buf, int size);
@@ -177,6 +186,12 @@
 {
 	return -ENXIO;
 }
+
+static inline int pm8921_store_hw_reset_reason(int is_hw_reset)
+{
+	return -ENXIO;
+}
+
 static inline int pm8921_bms_get_batt_soc(int *result)
 {
 	return -ENXIO;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/mfd/pm8xxx/pm8921-charger.h monarudo-jb-3.4.10-e22f38b/include/linux/mfd/pm8xxx/pm8921-charger.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/mfd/pm8xxx/pm8921-charger.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/mfd/pm8xxx/pm8921-charger.h	2013-08-01 23:37:52.000000000 -0600
@@ -107,6 +107,9 @@
 	int				cable_in_irq;
 	int				cable_in_gpio;
 	int				is_embeded_batt;
+	int				ichg_threshold_ua;
+	int				ichg_regulation_thr_ua;
+	int				eoc_ibat_thre_ma;
 	enum pm8921_chg_cold_thr	cold_thr;
 	enum pm8921_chg_hot_thr		hot_thr;
 	int				rconn_mohm;
@@ -213,6 +216,7 @@
 
 
 int pm8921_set_hsml_target_ma(int target_ma);
+
 int pm8921_charger_get_attr_text_with_ext_charger(char *buf, int size);
 
 int pm8921_gauge_get_attr_text(char *buf, int size);
@@ -374,6 +378,22 @@
 {
 	return -ENXIO;
 }
+
+static inline int pm8921_set_hsml_target_ma(int target_ma)
+{
+	return -ENXIO;
+}
+
+static inline int pm8921_charger_get_attr_text_with_ext_charger(char *buf, int size)
+{
+	return -ENXIO;
+}
+
+static inline int pm8921_dump_all(void)
+{
+	return -ENXIO;
+}
+
 #endif 
 static inline void pm8921_chg_disable_usbin_valid_irq(void)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/mmc/host.h monarudo-jb-3.4.10-e22f38b/include/linux/mmc/host.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/mmc/host.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/mmc/host.h	2013-08-01 23:37:52.000000000 -0600
@@ -266,7 +266,9 @@
 	int			bkops_started;
 	int 		hpi_issued;
 	int 		bkops_trigger;
+	int			bkops_check_status;
 	int 		bkops_alarm_set;
+	int			long_bkops;
 	struct mmc_card		*card;		
 
 	wait_queue_head_t	wq;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/mmc/mmc.h monarudo-jb-3.4.10-e22f38b/include/linux/mmc/mmc.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/mmc/mmc.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/mmc/mmc.h	2013-08-01 23:38:00.000000000 -0600
@@ -372,6 +372,7 @@
 #define MMC_PW_OFF_NOTIFY_SHORT		1
 #define MMC_PW_OFF_NOTIFY_LONG		2
 
+#define EXT_CSD_BKOPS_LEVEL_0		0
 #define EXT_CSD_BKOPS_LEVEL_2		0x2
 #define ENCRYPT_MAGIC_NUMBER 73939133
 #define ENCRYPT_MAGIC_NUMBER2 67629137
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/moduleloader.h monarudo-jb-3.4.10-e22f38b/include/linux/moduleloader.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/moduleloader.h	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/moduleloader.h	2012-08-26 16:02:10.000000000 -0600
@@ -1,37 +1,55 @@
 #ifndef _LINUX_MODULELOADER_H
 #define _LINUX_MODULELOADER_H
+/* The stuff needed for archs to support modules. */
 
 #include <linux/module.h>
 #include <linux/elf.h>
 
+/* These may be implemented by architectures that need to hook into the
+ * module loader code.  Architectures that don't need to do anything special
+ * can just rely on the 'weak' default hooks defined in kernel/module.c.
+ * Note, however, that at least one of apply_relocate or apply_relocate_add
+ * must be implemented by each architecture.
+ */
 
+/* Adjust arch-specific sections.  Return 0 on success.  */
 int module_frob_arch_sections(Elf_Ehdr *hdr,
 			      Elf_Shdr *sechdrs,
 			      char *secstrings,
 			      struct module *mod);
 
+/* Additional bytes needed by arch in front of individual sections */
 unsigned int arch_mod_section_prepend(struct module *mod, unsigned int section);
 
+/* Allocator used for allocating struct module, core sections and init
+   sections.  Returns NULL on failure. */
 void *module_alloc(unsigned long size);
 
+/* Free memory returned from module_alloc. */
 void module_free(struct module *mod, void *module_region);
 
+/* Apply the given relocation to the (simplified) ELF.  Return -error
+   or 0. */
 int apply_relocate(Elf_Shdr *sechdrs,
 		   const char *strtab,
 		   unsigned int symindex,
 		   unsigned int relsec,
 		   struct module *mod);
 
+/* Apply the given add relocation to the (simplified) ELF.  Return
+   -error or 0 */
 int apply_relocate_add(Elf_Shdr *sechdrs,
 		       const char *strtab,
 		       unsigned int symindex,
 		       unsigned int relsec,
 		       struct module *mod);
 
+/* Any final processing of module before access.  Return -error or 0. */
 int module_finalize(const Elf_Ehdr *hdr,
 		    const Elf_Shdr *sechdrs,
 		    struct module *mod);
 
+/* Any cleanup needed when module leaves. */
 void module_arch_cleanup(struct module *mod);
 
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_kgsl.h monarudo-jb-3.4.10-e22f38b/include/linux/msm_kgsl.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_kgsl.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/msm_kgsl.h	2013-08-01 23:37:57.000000000 -0600
@@ -1,6 +1,7 @@
 #ifndef _MSM_KGSL_H
 #define _MSM_KGSL_H
 
+#ifndef CONFIG_MSM_KGSL_MAINLINE
 #define KGSL_VERSION_MAJOR        3
 #define KGSL_VERSION_MINOR        14
 
@@ -458,4 +459,597 @@
 #define kgsl_gem_obj_addr(...) 0
 #endif
 #endif
+#else
+
+#define KGSL_VERSION_MAJOR        3
+#define KGSL_VERSION_MINOR        14
+
+#define KGSL_CONTEXT_SAVE_GMEM		  0x00000001
+#define KGSL_CONTEXT_NO_GMEM_ALLOC	  0x00000002
+#define KGSL_CONTEXT_SUBMIT_IB_LIST	  0x00000004
+#define KGSL_CONTEXT_CTX_SWITCH		  0x00000008
+#define KGSL_CONTEXT_PREAMBLE		  0x00000010
+#define KGSL_CONTEXT_TRASH_STATE	  0x00000020
+#define KGSL_CONTEXT_PER_CONTEXT_TS	  0x00000040
+#define KGSL_CONTEXT_USER_GENERATED_TS	  0x00000080
+#define KGSL_CONTEXT_END_OF_FRAME         0x00000100
+#define KGSL_CONTEXT_NO_FAULT_TOLERANCE	  0x00000200
+#define KGSL_CONTEXT_TYPE_MASK            0x01F00000
+#define KGSL_CONTEXT_TYPE_SHIFT           20
+
+#define KGSL_CONTEXT_TYPE_ANY		  0
+#define KGSL_CONTEXT_TYPE_GL		  1
+#define KGSL_CONTEXT_TYPE_CL		  2
+#define KGSL_CONTEXT_TYPE_C2D		  3
+#define KGSL_CONTEXT_TYPE_RS		  4
+
+#define KGSL_CONTEXT_INVALID 0xffffffff
+
+
+#define KGSL_MEMFLAGS_GPUREADONLY 0x01000000
+#define KGSL_MEMFLAGS_USE_CPU_MAP 0x10000000
+
+#define KGSL_CACHEMODE_MASK 0x0C000000
+#define KGSL_CACHEMODE_SHIFT 26
+
+#define KGSL_CACHEMODE_WRITECOMBINE 0
+#define KGSL_CACHEMODE_UNCACHED 1
+#define KGSL_CACHEMODE_WRITETHROUGH 2
+#define KGSL_CACHEMODE_WRITEBACK 3
+
+#define KGSL_MEMTYPE_MASK		0x0000FF00
+#define KGSL_MEMTYPE_SHIFT		8
+
+#define KGSL_MEMTYPE_OBJECTANY			0
+#define KGSL_MEMTYPE_FRAMEBUFFER		1
+#define KGSL_MEMTYPE_RENDERBUFFER		2
+#define KGSL_MEMTYPE_ARRAYBUFFER		3
+#define KGSL_MEMTYPE_ELEMENTARRAYBUFFER		4
+#define KGSL_MEMTYPE_VERTEXARRAYBUFFER		5
+#define KGSL_MEMTYPE_TEXTURE			6
+#define KGSL_MEMTYPE_SURFACE			7
+#define KGSL_MEMTYPE_EGL_SURFACE		8
+#define KGSL_MEMTYPE_GL				9
+#define KGSL_MEMTYPE_CL				10
+#define KGSL_MEMTYPE_CL_BUFFER_MAP		11
+#define KGSL_MEMTYPE_CL_BUFFER_NOMAP		12
+#define KGSL_MEMTYPE_CL_IMAGE_MAP		13
+#define KGSL_MEMTYPE_CL_IMAGE_NOMAP		14
+#define KGSL_MEMTYPE_CL_KERNEL_STACK		15
+#define KGSL_MEMTYPE_COMMAND			16
+#define KGSL_MEMTYPE_2D				17
+#define KGSL_MEMTYPE_EGL_IMAGE			18
+#define KGSL_MEMTYPE_EGL_SHADOW			19
+#define KGSL_MEMTYPE_MULTISAMPLE		20
+#define KGSL_MEMTYPE_KERNEL			255
+
+#define KGSL_MEMALIGN_MASK		0x00FF0000
+#define KGSL_MEMALIGN_SHIFT		16
+
+
+#define KGSL_FLAGS_NORMALMODE  0x00000000
+#define KGSL_FLAGS_SAFEMODE    0x00000001
+#define KGSL_FLAGS_INITIALIZED0 0x00000002
+#define KGSL_FLAGS_INITIALIZED 0x00000004
+#define KGSL_FLAGS_STARTED     0x00000008
+#define KGSL_FLAGS_ACTIVE      0x00000010
+#define KGSL_FLAGS_RESERVED0   0x00000020
+#define KGSL_FLAGS_RESERVED1   0x00000040
+#define KGSL_FLAGS_RESERVED2   0x00000080
+#define KGSL_FLAGS_SOFT_RESET  0x00000100
+#define KGSL_FLAGS_PER_CONTEXT_TIMESTAMPS 0x00000200
+
+#define KGSL_CLK_SRC	0x00000001
+#define KGSL_CLK_CORE	0x00000002
+#define KGSL_CLK_IFACE	0x00000004
+#define KGSL_CLK_MEM	0x00000008
+#define KGSL_CLK_MEM_IFACE 0x00000010
+#define KGSL_CLK_AXI	0x00000020
+
+#define KGSL_SYNCOBJ_SERVER_TIMEOUT 2000
+
+enum kgsl_ctx_reset_stat {
+	KGSL_CTX_STAT_NO_ERROR				= 0x00000000,
+	KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT		= 0x00000001,
+	KGSL_CTX_STAT_INNOCENT_CONTEXT_RESET_EXT	= 0x00000002,
+	KGSL_CTX_STAT_UNKNOWN_CONTEXT_RESET_EXT		= 0x00000003
+};
+
+#define KGSL_CONVERT_TO_MBPS(val) \
+	(val*1000*1000U)
+
+enum kgsl_deviceid {
+	KGSL_DEVICE_3D0		= 0x00000000,
+	KGSL_DEVICE_2D0		= 0x00000001,
+	KGSL_DEVICE_2D1		= 0x00000002,
+	KGSL_DEVICE_MAX		= 0x00000003
+};
+
+enum kgsl_user_mem_type {
+	KGSL_USER_MEM_TYPE_PMEM		= 0x00000000,
+	KGSL_USER_MEM_TYPE_ASHMEM	= 0x00000001,
+	KGSL_USER_MEM_TYPE_ADDR		= 0x00000002,
+	KGSL_USER_MEM_TYPE_ION		= 0x00000003,
+	KGSL_USER_MEM_TYPE_MAX		= 0x00000004,
+};
+
+struct kgsl_devinfo {
+
+	unsigned int device_id;
+	unsigned int chip_id;
+	unsigned int mmu_enabled;
+	unsigned int gmem_gpubaseaddr;
+	unsigned int gpu_id;
+	unsigned int gmem_sizebytes;
+};
+
+/* this structure defines the region of memory that can be mmap()ed from this
+   driver. The timestamp fields are volatile because they are written by the
+   GPU
+*/
+struct kgsl_devmemstore {
+	volatile unsigned int soptimestamp;
+	unsigned int sbz;
+	volatile unsigned int eoptimestamp;
+	unsigned int sbz2;
+	volatile unsigned int ts_cmp_enable;
+	unsigned int sbz3;
+	volatile unsigned int ref_wait_ts;
+	unsigned int sbz4;
+	unsigned int current_context;
+	unsigned int sbz5;
+};
+
+#define KGSL_MEMSTORE_OFFSET(ctxt_id, field) \
+	((ctxt_id)*sizeof(struct kgsl_devmemstore) + \
+	 offsetof(struct kgsl_devmemstore, field))
+
+enum kgsl_timestamp_type {
+	KGSL_TIMESTAMP_CONSUMED = 0x00000001, 
+	KGSL_TIMESTAMP_RETIRED  = 0x00000002, 
+	KGSL_TIMESTAMP_QUEUED   = 0x00000003,
+};
+
+enum kgsl_property_type {
+	KGSL_PROP_DEVICE_INFO     = 0x00000001,
+	KGSL_PROP_DEVICE_SHADOW   = 0x00000002,
+	KGSL_PROP_DEVICE_POWER    = 0x00000003,
+	KGSL_PROP_SHMEM           = 0x00000004,
+	KGSL_PROP_SHMEM_APERTURES = 0x00000005,
+	KGSL_PROP_MMU_ENABLE 	  = 0x00000006,
+	KGSL_PROP_INTERRUPT_WAITS = 0x00000007,
+	KGSL_PROP_VERSION         = 0x00000008,
+	KGSL_PROP_GPU_RESET_STAT  = 0x00000009,
+	KGSL_PROP_PWRCTRL         = 0x0000000E,
+};
+
+struct kgsl_shadowprop {
+	unsigned int gpuaddr;
+	unsigned int size;
+	unsigned int flags; 
+};
+
+struct kgsl_version {
+	unsigned int drv_major;
+	unsigned int drv_minor;
+	unsigned int dev_major;
+	unsigned int dev_minor;
+};
+
+
+#define KGSL_PERFCOUNTER_GROUP_CP 0x0
+#define KGSL_PERFCOUNTER_GROUP_RBBM 0x1
+#define KGSL_PERFCOUNTER_GROUP_PC 0x2
+#define KGSL_PERFCOUNTER_GROUP_VFD 0x3
+#define KGSL_PERFCOUNTER_GROUP_HLSQ 0x4
+#define KGSL_PERFCOUNTER_GROUP_VPC 0x5
+#define KGSL_PERFCOUNTER_GROUP_TSE 0x6
+#define KGSL_PERFCOUNTER_GROUP_RAS 0x7
+#define KGSL_PERFCOUNTER_GROUP_UCHE 0x8
+#define KGSL_PERFCOUNTER_GROUP_TP 0x9
+#define KGSL_PERFCOUNTER_GROUP_SP 0xA
+#define KGSL_PERFCOUNTER_GROUP_RB 0xB
+#define KGSL_PERFCOUNTER_GROUP_PWR 0xC
+#define KGSL_PERFCOUNTER_GROUP_VBIF 0xD
+#define KGSL_PERFCOUNTER_GROUP_VBIF_PWR 0xE
+
+#define KGSL_PERFCOUNTER_NOT_USED 0xFFFFFFFF
+
+struct kgsl_ibdesc {
+	unsigned int gpuaddr;
+	void *hostptr;
+	unsigned int sizedwords;
+	unsigned int ctrl;
+};
+
+#define KGSL_IOC_TYPE 0x09
+
+struct kgsl_device_getproperty {
+	unsigned int type;
+	void  *value;
+	unsigned int sizebytes;
+};
+
+#define IOCTL_KGSL_DEVICE_GETPROPERTY \
+	_IOWR(KGSL_IOC_TYPE, 0x2, struct kgsl_device_getproperty)
+
+
+struct kgsl_device_waittimestamp {
+	unsigned int timestamp;
+	unsigned int timeout;
+};
+
+#define IOCTL_KGSL_DEVICE_WAITTIMESTAMP \
+	_IOW(KGSL_IOC_TYPE, 0x6, struct kgsl_device_waittimestamp)
+
+struct kgsl_device_waittimestamp_ctxtid {
+	unsigned int context_id;
+	unsigned int timestamp;
+	unsigned int timeout;
+};
+
+#define IOCTL_KGSL_DEVICE_WAITTIMESTAMP_CTXTID \
+	_IOW(KGSL_IOC_TYPE, 0x7, struct kgsl_device_waittimestamp_ctxtid)
+
+struct kgsl_ringbuffer_issueibcmds {
+	unsigned int drawctxt_id;
+	unsigned int ibdesc_addr;
+	unsigned int numibs;
+	unsigned int timestamp; 
+	unsigned int flags;
+};
+
+#define IOCTL_KGSL_RINGBUFFER_ISSUEIBCMDS \
+	_IOWR(KGSL_IOC_TYPE, 0x10, struct kgsl_ringbuffer_issueibcmds)
+
+struct kgsl_cmdstream_readtimestamp {
+	unsigned int type;
+	unsigned int timestamp; 
+};
+
+#define IOCTL_KGSL_CMDSTREAM_READTIMESTAMP_OLD \
+	_IOR(KGSL_IOC_TYPE, 0x11, struct kgsl_cmdstream_readtimestamp)
+
+#define IOCTL_KGSL_CMDSTREAM_READTIMESTAMP \
+	_IOWR(KGSL_IOC_TYPE, 0x11, struct kgsl_cmdstream_readtimestamp)
+
+struct kgsl_cmdstream_freememontimestamp {
+	unsigned int gpuaddr;
+	unsigned int type;
+	unsigned int timestamp;
+};
+
+#define IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP \
+	_IOW(KGSL_IOC_TYPE, 0x12, struct kgsl_cmdstream_freememontimestamp)
+
+
+#define IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP_OLD \
+	_IOR(KGSL_IOC_TYPE, 0x12, struct kgsl_cmdstream_freememontimestamp)
+
+struct kgsl_drawctxt_create {
+	unsigned int flags;
+	unsigned int drawctxt_id; 
+};
+
+#define IOCTL_KGSL_DRAWCTXT_CREATE \
+	_IOWR(KGSL_IOC_TYPE, 0x13, struct kgsl_drawctxt_create)
+
+struct kgsl_drawctxt_destroy {
+	unsigned int drawctxt_id;
+};
+
+#define IOCTL_KGSL_DRAWCTXT_DESTROY \
+	_IOW(KGSL_IOC_TYPE, 0x14, struct kgsl_drawctxt_destroy)
+
+struct kgsl_map_user_mem {
+	int fd;
+	unsigned int gpuaddr;   
+	unsigned int len;
+	unsigned int offset;
+	unsigned int hostptr;   
+	enum kgsl_user_mem_type memtype;
+	unsigned int flags;
+};
+
+#define IOCTL_KGSL_MAP_USER_MEM \
+	_IOWR(KGSL_IOC_TYPE, 0x15, struct kgsl_map_user_mem)
+
+struct kgsl_cmdstream_readtimestamp_ctxtid {
+	unsigned int context_id;
+	unsigned int type;
+	unsigned int timestamp; 
+};
+
+#define IOCTL_KGSL_CMDSTREAM_READTIMESTAMP_CTXTID \
+	_IOWR(KGSL_IOC_TYPE, 0x16, struct kgsl_cmdstream_readtimestamp_ctxtid)
+
+struct kgsl_cmdstream_freememontimestamp_ctxtid {
+	unsigned int context_id;
+	unsigned int gpuaddr;
+	unsigned int type;
+	unsigned int timestamp;
+};
+
+#define IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP_CTXTID \
+	_IOW(KGSL_IOC_TYPE, 0x17, \
+	struct kgsl_cmdstream_freememontimestamp_ctxtid)
+
+struct kgsl_sharedmem_from_pmem {
+	int pmem_fd;
+	unsigned int gpuaddr;	
+	unsigned int len;
+	unsigned int offset;
+};
+
+#define IOCTL_KGSL_SHAREDMEM_FROM_PMEM \
+	_IOWR(KGSL_IOC_TYPE, 0x20, struct kgsl_sharedmem_from_pmem)
+
+struct kgsl_sharedmem_free {
+	unsigned int gpuaddr;
+};
+
+#define IOCTL_KGSL_SHAREDMEM_FREE \
+	_IOW(KGSL_IOC_TYPE, 0x21, struct kgsl_sharedmem_free)
+
+struct kgsl_cff_user_event {
+	unsigned char cff_opcode;
+	unsigned int op1;
+	unsigned int op2;
+	unsigned int op3;
+	unsigned int op4;
+	unsigned int op5;
+	unsigned int __pad[2];
+};
+
+#define IOCTL_KGSL_CFF_USER_EVENT \
+	_IOW(KGSL_IOC_TYPE, 0x31, struct kgsl_cff_user_event)
+
+struct kgsl_gmem_desc {
+	unsigned int x;
+	unsigned int y;
+	unsigned int width;
+	unsigned int height;
+	unsigned int pitch;
+};
+
+struct kgsl_buffer_desc {
+	void 			*hostptr;
+	unsigned int	gpuaddr;
+	int				size;
+	unsigned int	format;
+	unsigned int  	pitch;
+	unsigned int  	enabled;
+};
+
+struct kgsl_bind_gmem_shadow {
+	unsigned int drawctxt_id;
+	struct kgsl_gmem_desc gmem_desc;
+	unsigned int shadow_x;
+	unsigned int shadow_y;
+	struct kgsl_buffer_desc shadow_buffer;
+	unsigned int buffer_id;
+};
+
+#define IOCTL_KGSL_DRAWCTXT_BIND_GMEM_SHADOW \
+    _IOW(KGSL_IOC_TYPE, 0x22, struct kgsl_bind_gmem_shadow)
+
+
+
+struct kgsl_sharedmem_from_vmalloc {
+	unsigned int gpuaddr;	
+	unsigned int hostptr;
+	unsigned int flags;
+};
+
+#define IOCTL_KGSL_SHAREDMEM_FROM_VMALLOC \
+	_IOWR(KGSL_IOC_TYPE, 0x23, struct kgsl_sharedmem_from_vmalloc)
+
+
+#define IOCTL_KGSL_SHAREDMEM_FLUSH_CACHE \
+	_IOW(KGSL_IOC_TYPE, 0x24, struct kgsl_sharedmem_free)
+
+struct kgsl_drawctxt_set_bin_base_offset {
+	unsigned int drawctxt_id;
+	unsigned int offset;
+};
+
+#define IOCTL_KGSL_DRAWCTXT_SET_BIN_BASE_OFFSET \
+	_IOW(KGSL_IOC_TYPE, 0x25, struct kgsl_drawctxt_set_bin_base_offset)
+
+enum kgsl_cmdwindow_type {
+	KGSL_CMDWINDOW_MIN     = 0x00000000,
+	KGSL_CMDWINDOW_2D      = 0x00000000,
+	KGSL_CMDWINDOW_3D      = 0x00000001, 
+	KGSL_CMDWINDOW_MMU     = 0x00000002,
+	KGSL_CMDWINDOW_ARBITER = 0x000000FF,
+	KGSL_CMDWINDOW_MAX     = 0x000000FF,
+};
+
+struct kgsl_cmdwindow_write {
+	enum kgsl_cmdwindow_type target;
+	unsigned int addr;
+	unsigned int data;
+};
+
+#define IOCTL_KGSL_CMDWINDOW_WRITE \
+	_IOW(KGSL_IOC_TYPE, 0x2e, struct kgsl_cmdwindow_write)
+
+struct kgsl_gpumem_alloc {
+	unsigned long gpuaddr;
+	size_t size;
+	unsigned int flags;
+};
+
+#define IOCTL_KGSL_GPUMEM_ALLOC \
+	_IOWR(KGSL_IOC_TYPE, 0x2f, struct kgsl_gpumem_alloc)
+
+struct kgsl_cff_syncmem {
+	unsigned int gpuaddr;
+	unsigned int len;
+	unsigned int __pad[2]; 
+};
+
+#define IOCTL_KGSL_CFF_SYNCMEM \
+	_IOW(KGSL_IOC_TYPE, 0x30, struct kgsl_cff_syncmem)
+
+
+struct kgsl_timestamp_event {
+	int type;                
+	unsigned int timestamp;  
+	unsigned int context_id; 
+	void *priv;              
+	size_t len;              
+};
+
+#define IOCTL_KGSL_TIMESTAMP_EVENT_OLD \
+	_IOW(KGSL_IOC_TYPE, 0x31, struct kgsl_timestamp_event)
+
+
+#define KGSL_TIMESTAMP_EVENT_GENLOCK 1
+
+struct kgsl_timestamp_event_genlock {
+	int handle; 
+};
+
+
+#define KGSL_TIMESTAMP_EVENT_FENCE 2
+
+struct kgsl_timestamp_event_fence {
+	int fence_fd; 
+};
+
+
+#define IOCTL_KGSL_SETPROPERTY \
+	_IOW(KGSL_IOC_TYPE, 0x32, struct kgsl_device_getproperty)
+
+#define IOCTL_KGSL_TIMESTAMP_EVENT \
+	_IOWR(KGSL_IOC_TYPE, 0x33, struct kgsl_timestamp_event)
+
+struct kgsl_gpumem_alloc_id {
+	unsigned int id;
+	unsigned int flags;
+	unsigned int size;
+	unsigned int mmapsize;
+	unsigned long gpuaddr;
+	unsigned int __pad[2];
+};
+
+#define IOCTL_KGSL_GPUMEM_ALLOC_ID \
+	_IOWR(KGSL_IOC_TYPE, 0x34, struct kgsl_gpumem_alloc_id)
+
+struct kgsl_gpumem_free_id {
+	unsigned int id;
+	unsigned int __pad;
+};
+
+#define IOCTL_KGSL_GPUMEM_FREE_ID \
+	_IOWR(KGSL_IOC_TYPE, 0x35, struct kgsl_gpumem_free_id)
+
+struct kgsl_gpumem_get_info {
+	unsigned long gpuaddr;
+	unsigned int id;
+	unsigned int flags;
+	unsigned int size;
+	unsigned int mmapsize;
+	unsigned long useraddr;
+	unsigned int __pad[4];
+};
+
+#define IOCTL_KGSL_GPUMEM_GET_INFO\
+	_IOWR(KGSL_IOC_TYPE, 0x36, struct kgsl_gpumem_get_info)
+
+struct kgsl_gpumem_sync_cache {
+	unsigned int gpuaddr;
+	unsigned int id;
+	unsigned int op;
+	unsigned int __pad[2]; 
+};
+
+#define KGSL_GPUMEM_CACHE_CLEAN (1 << 0)
+#define KGSL_GPUMEM_CACHE_TO_GPU KGSL_GPUMEM_CACHE_CLEAN
+
+#define KGSL_GPUMEM_CACHE_INV (1 << 1)
+#define KGSL_GPUMEM_CACHE_FROM_GPU KGSL_GPUMEM_CACHE_INV
+
+#define KGSL_GPUMEM_CACHE_FLUSH \
+	(KGSL_GPUMEM_CACHE_CLEAN | KGSL_GPUMEM_CACHE_INV)
+
+#define IOCTL_KGSL_GPUMEM_SYNC_CACHE \
+	_IOW(KGSL_IOC_TYPE, 0x37, struct kgsl_gpumem_sync_cache)
+
+struct kgsl_perfcounter_get {
+	unsigned int groupid;
+	unsigned int countable;
+	unsigned int offset;
+	unsigned int __pad[2]; 
+};
+
+#define IOCTL_KGSL_PERFCOUNTER_GET \
+	_IOWR(KGSL_IOC_TYPE, 0x38, struct kgsl_perfcounter_get)
+
+struct kgsl_perfcounter_put {
+	unsigned int groupid;
+	unsigned int countable;
+	unsigned int __pad[2]; 
+};
+
+#define IOCTL_KGSL_PERFCOUNTER_PUT \
+	_IOW(KGSL_IOC_TYPE, 0x39, struct kgsl_perfcounter_put)
+
+/**
+ * struct kgsl_perfcounter_query - argument to IOCTL_KGSL_PERFCOUNTER_QUERY
+ * @groupid: Performance counter group ID
+ * @countable: Return active countables array
+ * @size: Size of active countables array
+ * @max_counters: Return total number counters for the group ID
+ *
+ * Query the available performance counters given a groupid.  The array
+ * *countables is used to return the current active countables in counters.
+ * The size of the array is passed in so the kernel will only write at most
+ * size or counter->size for the group id.  The total number of available
+ * counters for the group ID is returned in max_counters.
+ * If the array or size passed in are invalid, then only the maximum number
+ * of counters will be returned, no data will be written to *countables.
+ * If the groupid is invalid an error code will be returned.
+ *
+ */
+struct kgsl_perfcounter_query {
+	unsigned int groupid;
+	
+	unsigned int *countables;
+	unsigned int count;
+	unsigned int max_counters;
+	unsigned int __pad[2]; 
+};
+
+#define IOCTL_KGSL_PERFCOUNTER_QUERY \
+	_IOWR(KGSL_IOC_TYPE, 0x3A, struct kgsl_perfcounter_query)
+
+
+struct kgsl_perfcounter_read_group {
+	unsigned int groupid;
+	unsigned int countable;
+	uint64_t value;
+};
+
+struct kgsl_perfcounter_read {
+	struct kgsl_perfcounter_read_group *reads;
+	unsigned int count;
+	unsigned int __pad[2]; 
+};
+
+#define IOCTL_KGSL_PERFCOUNTER_READ \
+	_IOWR(KGSL_IOC_TYPE, 0x3B, struct kgsl_perfcounter_read)
+
+unsigned int kgsl_get_alloc_size(int detailed);
+
+#ifdef __KERNEL__
+#ifdef CONFIG_MSM_KGSL_DRM
+int kgsl_gem_obj_addr(int drm_fd, int handle, unsigned long *start,
+			unsigned long *len);
+#else
+#define kgsl_gem_obj_addr(...) 0
+#endif
+#endif
+#endif
 #endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_mdp.h monarudo-jb-3.4.10-e22f38b/include/linux/msm_mdp.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_mdp.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/msm_mdp.h	2013-08-01 23:37:52.000000000 -0600
@@ -1,7 +1,7 @@
 /* include/linux/msm_mdp.h
  *
  * Copyright (C) 2007 Google Incorporated
- * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -67,19 +67,19 @@
 						struct msmfb_data)
 #define MSMFB_WRITEBACK_TERMINATE _IO(MSMFB_IOCTL_MAGIC, 155)
 #define MSMFB_MDP_PP _IOWR(MSMFB_IOCTL_MAGIC, 156, struct msmfb_mdp_pp)
-
 #define MSMFB_OVERLAY_VSYNC_CTRL _IOW(MSMFB_IOCTL_MAGIC, 160, unsigned int)
 #define MSMFB_VSYNC_CTRL  _IOW(MSMFB_IOCTL_MAGIC, 161, unsigned int)
 #define MSMFB_BUFFER_SYNC  _IOW(MSMFB_IOCTL_MAGIC, 162, struct mdp_buf_sync)
-
 #define MSMFB_DISPLAY_COMMIT      _IOW(MSMFB_IOCTL_MAGIC, 164, \
 						struct mdp_display_commit)
+#define MSMFB_WRITEBACK_SET_MIRRORING_HINT _IOW(MSMFB_IOCTL_MAGIC, 165, \
+						unsigned int)
 #define MSMFB_METADATA_GET  _IOW(MSMFB_IOCTL_MAGIC, 166, struct msmfb_metadata)
 
-#define MSMFB_GET_USB_PROJECTOR_INFO _IOR(MSMFB_IOCTL_MAGIC, 301, struct msmfb_usb_projector_info)
-#define MSMFB_SET_USB_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 302, struct msmfb_usb_projector_info)
-#define MSMFB_SET_DISP_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 303, struct msmfb_disp_projector_info)
-#define MSMFB_SET_SCHED_PRIORITY _IOW(MSMFB_IOCTL_MAGIC, 304, struct msmfb_sched_priority)
+#define MSMFB_WRITEBACK_PLAY      	_IOW(MSMFB_IOCTL_MAGIC, 200, struct msmfb_overlay_data)
+#define MSMFB_GET_USB_PROJECTOR_INFO _IOR(MSMFB_IOCTL_MAGIC, 201, struct msmfb_usb_projector_info)
+#define MSMFB_SET_USB_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 202, struct msmfb_usb_projector_info)
+#define MSMFB_SET_DISP_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 203, struct msmfb_disp_projector_info)
 
 
 #define FB_TYPE_3D_PANEL 0x10101010
@@ -99,11 +99,6 @@
 	int device_height;
 };
 
-struct msmfb_sched_priority {
-	int pid;
-	int priority;
-};
-
 enum {
 	NOTIFY_UPDATE_START,
 	NOTIFY_UPDATE_STOP,
@@ -181,7 +176,11 @@
 #define MDP_DEINTERLACE_ODD		0x00400000
 #define MDP_OV_PLAY_NOWAIT		0x00200000
 #define MDP_SOURCE_ROTATED_90		0x00100000
+#ifdef CONFIG_FB_MSM_412
 #define MDP_DPP_HSIC			0x00080000
+#else
+#define MDP_OVERLAY_PP_CFG_EN		0x00080000
+#endif
 #define MDP_BACKEND_COMPOSITION		0x00040000
 #define MDP_BORDERFILL_SUPPORTED	0x00010000
 #define MDP_SECURE_OVERLAY_SESSION      0x00008000
@@ -289,11 +288,96 @@
 	struct msmfb_img img;
 };
 
+#ifdef CONFIG_FB_MSM_412
 struct dpp_ctrl {
 	int8_t sharp_strength;
 	int8_t hsic_params[NUM_HSIC_PARAM];
 };
+#else
+#define MDP_PP_OPS_ENABLE 0x1
+#define MDP_PP_OPS_READ 0x2
+#define MDP_PP_OPS_WRITE 0x4
+#define MDP_PP_OPS_DISABLE 0x8
+
+struct mdp_qseed_cfg {
+	uint32_t table_num;
+	uint32_t ops;
+	uint32_t len;
+	uint32_t *data;
+};
+
+struct mdp_qseed_cfg_data {
+	uint32_t block;
+	struct mdp_qseed_cfg qseed_data;
+};
+
+struct mdp_sharp_cfg {
+	uint32_t flags;
+	uint32_t strength;
+	uint32_t edge_thr;
+	uint32_t smooth_thr;
+	uint32_t noise_thr;
+};
+
+#define MDP_OVERLAY_PP_CSC_CFG      0x1
+#define MDP_OVERLAY_PP_QSEED_CFG    0x2
+#define MDP_OVERLAY_PP_PA_CFG    0x4
+#define MDP_OVERLAY_PP_IGC_CFG    0x8
+#define MDP_OVERLAY_PP_SHARP_CFG    0x10
+
+#define MDP_CSC_FLAG_ENABLE	0x1
+#define MDP_CSC_FLAG_YUV_IN	0x2
+#define MDP_CSC_FLAG_YUV_OUT	0x4
+
+struct mdp_csc_cfg {
+	
+	uint32_t flags;
+	uint32_t csc_mv[9];
+	uint32_t csc_pre_bv[3];
+	uint32_t csc_post_bv[3];
+	uint32_t csc_pre_lv[6];
+	uint32_t csc_post_lv[6];
+};
 
+struct mdp_csc_cfg_data {
+	uint32_t block;
+	struct mdp_csc_cfg csc_data;
+};
+
+struct mdp_pa_cfg {
+	uint32_t flags;
+	uint32_t hue_adj;
+	uint32_t sat_adj;
+	uint32_t val_adj;
+	uint32_t cont_adj;
+};
+
+struct mdp_igc_lut_data {
+	uint32_t block;
+	uint32_t len, ops;
+	uint32_t *c0_c1_data;
+	uint32_t *c2_data;
+};
+
+struct mdp_overlay_pp_params {
+	uint32_t config_ops;
+	struct mdp_csc_cfg csc_cfg;
+	struct mdp_qseed_cfg qseed_cfg[2];
+	struct mdp_pa_cfg pa_cfg;
+	struct mdp_igc_lut_data igc_cfg;
+	struct mdp_sharp_cfg sharp_cfg;
+};
+
+enum {
+	BLEND_OP_NOT_DEFINED = 0,
+	BLEND_OP_OPAQUE,
+	BLEND_OP_PREMULTIPLIED,
+	BLEND_OP_COVERAGE,
+	BLEND_OP_MAX,
+};
+#endif
+
+#ifdef CONFIG_FB_MSM_412
 struct mdp_overlay {
 	struct msmfb_img src;
 	struct mdp_rect src_rect;
@@ -307,6 +391,22 @@
 	uint32_t user_data[8];
 	struct dpp_ctrl dpp;
 };
+#else
+struct mdp_overlay {
+	struct msmfb_img src;
+	struct mdp_rect src_rect;
+	struct mdp_rect dst_rect;
+	uint32_t z_order;	
+	uint32_t is_fg;		
+	uint32_t alpha;
+	uint32_t transp_mask;
+	uint32_t blend_op;
+	uint32_t flags;
+	uint32_t id;
+	uint32_t user_data[8];
+	struct mdp_overlay_pp_params overlay_pp_cfg;
+};
+#endif
 
 struct msmfb_overlay_3d {
 	uint32_t is_3d;
@@ -345,6 +445,9 @@
 	MDP_BLOCK_DMA_S,
 	MDP_BLOCK_DMA_E,
 	MDP_BLOCK_OVERLAY_2,
+	MDP_LOGICAL_BLOCK_DISP_0 = 0x1000,
+	MDP_LOGICAL_BLOCK_DISP_1,
+	MDP_LOGICAL_BLOCK_DISP_2,
 	MDP_BLOCK_MAX,
 };
 
@@ -376,6 +479,7 @@
 	struct mdp_pcc_coeff r, g, b;
 };
 
+#ifdef CONFIG_FB_MSM_412
 #define MDP_CSC_FLAG_ENABLE	0x1
 #define MDP_CSC_FLAG_YUV_IN	0x2
 #define MDP_CSC_FLAG_YUV_OUT	0x4
@@ -394,6 +498,7 @@
 	uint32_t block;
 	struct mdp_csc_cfg csc_data;
 };
+#endif
 
 enum {
 	mdp_lut_igc,
@@ -402,13 +507,14 @@
 	mdp_lut_max,
 };
 
-
+#ifdef CONFIG_FB_MSM_412
 struct mdp_igc_lut_data {
 	uint32_t block;
 	uint32_t len, ops;
 	uint32_t *c0_c1_data;
 	uint32_t *c2_data;
 };
+#endif
 
 struct mdp_ar_gc_lut_data {
 	uint32_t x_start;
@@ -435,7 +541,6 @@
 	uint32_t *data;
 };
 
-
 struct mdp_lut_cfg_data {
 	uint32_t lut_type;
 	union {
@@ -445,6 +550,7 @@
 	} data;
 };
 
+#ifdef CONFIG_FB_MSM_412
 struct mdp_qseed_cfg_data {
 	uint32_t block;
 	uint32_t table_num;
@@ -457,6 +563,23 @@
        uint32_t min_lvl;
        uint32_t scale;
 };
+#else
+struct mdp_bl_scale_data {
+	uint32_t min_lvl;
+	uint32_t scale;
+};
+
+struct mdp_calib_config_data {
+	uint32_t ops;
+	uint32_t addr;
+	uint32_t data;
+};
+
+struct mdp_pa_cfg_data {
+	uint32_t block;
+	struct mdp_pa_cfg pa_data;
+};
+#endif
 
 enum {
 	mdp_op_pcc_cfg,
@@ -464,9 +587,24 @@
 	mdp_op_lut_cfg,
 	mdp_op_qseed_cfg,
 	mdp_bl_scale_cfg,
+	mdp_op_calib_cfg,
+	mdp_op_pa_cfg,
 	mdp_op_max,
 };
 
+
+#ifdef CONFIG_FB_MSM_412
+struct msmfb_mdp_pp {
+	uint32_t op;
+	union {
+		struct mdp_pcc_cfg_data pcc_cfg_data;
+		struct mdp_csc_cfg_data csc_cfg_data;
+		struct mdp_lut_cfg_data lut_cfg_data;
+		struct mdp_qseed_cfg_data qseed_cfg_data;
+		struct mdp_bl_scale_data bl_scale_data;
+	} data;
+};
+#else
 struct msmfb_mdp_pp {
 	uint32_t op;
 	union {
@@ -475,6 +613,29 @@
 		struct mdp_lut_cfg_data lut_cfg_data;
 		struct mdp_qseed_cfg_data qseed_cfg_data;
 		struct mdp_bl_scale_data bl_scale_data;
+		struct mdp_calib_config_data calib_cfg;
+		struct mdp_pa_cfg_data pa_cfg_data;
+	} data;
+};
+#endif
+
+enum {
+	metadata_op_none,
+	metadata_op_base_blend,
+	metadata_op_frame_rate,
+	metadata_op_max
+};
+
+struct mdp_blend_cfg {
+	uint32_t is_premultiplied;
+};
+
+struct msmfb_metadata {
+	uint32_t op;
+	uint32_t flags;
+	union {
+		struct mdp_blend_cfg blend_cfg;
+		uint32_t panel_frame_rate;
 	} data;
 };
 
@@ -503,26 +664,6 @@
 	struct fb_var_screeninfo var;
 };
 
-enum {
-	metadata_op_none,
-	metadata_op_base_blend,
-	metadata_op_frame_rate,
-	metadata_op_max
-};
-
-struct mdp_blend_cfg {
-	uint32_t is_premultiplied;
-};
-
-struct msmfb_metadata {
-	uint32_t op;
-	uint32_t flags;
-	union {
-		struct mdp_blend_cfg blend_cfg;
-		uint32_t panel_frame_rate;
-	} data;
-};
-
 struct mdp_page_protection {
 	uint32_t page_protection;
 };
@@ -536,7 +677,7 @@
 	int z_order;
 };
 
-#define MAX_PIPE_PER_MIXER  4
+#define MAX_PIPE_PER_MIXER  5
 
 struct msmfb_mixer_info_req {
 	int mixer_num;
@@ -549,6 +690,13 @@
 	ROTATOR_SUBSYSTEM_ID,
 };
 
+enum {
+	MDP_WRITEBACK_MIRROR_OFF,
+	MDP_WRITEBACK_MIRROR_ON,
+	MDP_WRITEBACK_MIRROR_PAUSE,
+	MDP_WRITEBACK_MIRROR_RESUME,
+};
+
 #ifdef __KERNEL__
 
 int get_fb_phys_info(unsigned long *start, unsigned long *len, int fb_num,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_vidc_enc.h monarudo-jb-3.4.10-e22f38b/include/linux/msm_vidc_enc.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/msm_vidc_enc.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/msm_vidc_enc.h	2013-08-01 23:38:01.000000000 -0600
@@ -366,6 +366,9 @@
 #define VEN_IOCTL_SET_SPS_PPS_FOR_IDR \
 	_IOW(VEN_IOCTLBASE_ENC, 52, struct venc_ioctl_msg)
 
+#define VEN_IOCTL_SET_VUI_BITSTREAM_RESTRICT_FLAG \
+	_IO(VEN_IOCTLBASE_ENC, 52)
+
 struct venc_switch{
 	unsigned char	status;
 };
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter/xt_CONNSECMARK.h monarudo-jb-3.4.10-e22f38b/include/linux/netfilter/xt_CONNSECMARK.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter/xt_CONNSECMARK.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/netfilter/xt_CONNSECMARK.h	2013-08-01 23:37:49.000000000 -0600
@@ -12,4 +12,4 @@
 	__u8 mode;
 };
 
-#endif /*_XT_CONNSECMARK_H_target */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter/xt_SECMARK.h monarudo-jb-3.4.10-e22f38b/include/linux/netfilter/xt_SECMARK.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter/xt_SECMARK.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/netfilter/xt_SECMARK.h	2013-08-01 23:37:49.000000000 -0600
@@ -3,14 +3,7 @@
 
 #include <linux/types.h>
 
-/*
- * This is intended for use by various security subsystems (but not
- * at the same time).
- *
- * 'mode' refers to the specific security subsystem which the
- * packets are being marked for.
- */
-#define SECMARK_MODE_SEL	0x01		/* SELinux */
+#define SECMARK_MODE_SEL	0x01		
 #define SECMARK_SECCTX_MAX	256
 
 struct xt_secmark_target_info {
@@ -19,4 +12,4 @@
 	char secctx[SECMARK_SECCTX_MAX];
 };
 
-#endif /*_XT_SECMARK_H_target */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter_ipv4/ip_queue.h monarudo-jb-3.4.10-e22f38b/include/linux/netfilter_ipv4/ip_queue.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/netfilter_ipv4/ip_queue.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/netfilter_ipv4/ip_queue.h	2013-08-01 23:38:04.000000000 -0600
@@ -12,39 +12,37 @@
 #define QDEBUG(x...) printk(KERN_DEBUG ## x)
 #else
 #define QDEBUG(x...)
-#endif  /* DEBUG_IPQ */
+#endif  
 #else
 #include <net/if.h>
-#endif	/* ! __KERNEL__ */
+#endif	
 
-/* Messages sent from kernel */
 typedef struct ipq_packet_msg {
-	unsigned long packet_id;	/* ID of queued packet */
-	unsigned long mark;		/* Netfilter mark value */
-	long timestamp_sec;		/* Packet arrival time (seconds) */
-	long timestamp_usec;		/* Packet arrvial time (+useconds) */
-	unsigned int hook;		/* Netfilter hook we rode in on */
-	char indev_name[IFNAMSIZ];	/* Name of incoming interface */
-	char outdev_name[IFNAMSIZ];	/* Name of outgoing interface */
-	__be16 hw_protocol;		/* Hardware protocol (network order) */
-	unsigned short hw_type;		/* Hardware type */
-	unsigned char hw_addrlen;	/* Hardware address length */
-	unsigned char hw_addr[8];	/* Hardware address */
-	size_t data_len;		/* Length of packet data */
-	unsigned char payload[0];	/* Optional packet data */
+	unsigned long packet_id;	
+	unsigned long mark;		
+	long timestamp_sec;		
+	long timestamp_usec;		
+	unsigned int hook;		
+	char indev_name[IFNAMSIZ];	
+	char outdev_name[IFNAMSIZ];	
+	__be16 hw_protocol;		
+	unsigned short hw_type;		
+	unsigned char hw_addrlen;	
+	unsigned char hw_addr[8];	
+	size_t data_len;		
+	unsigned char payload[0];	
 } ipq_packet_msg_t;
 
-/* Messages sent from userspace */
 typedef struct ipq_mode_msg {
-	unsigned char value;		/* Requested mode */
-	size_t range;			/* Optional range of packet requested */
+	unsigned char value;		
+	size_t range;			
 } ipq_mode_msg_t;
 
 typedef struct ipq_verdict_msg {
-	unsigned int value;		/* Verdict to hand to netfilter */
-	unsigned long id;		/* Packet ID for this verdict */
-	size_t data_len;		/* Length of replacement data */
-	unsigned char payload[0];	/* Optional replacement packet */
+	unsigned int value;		
+	unsigned long id;		
+	size_t data_len;		
+	unsigned char payload[0];	
 } ipq_verdict_msg_t;
 
 typedef struct ipq_peer_msg {
@@ -54,19 +52,17 @@
 	} msg;
 } ipq_peer_msg_t;
 
-/* Packet delivery modes */
 enum {
-	IPQ_COPY_NONE,		/* Initial mode, packets are dropped */
-	IPQ_COPY_META,		/* Copy metadata */
-	IPQ_COPY_PACKET		/* Copy metadata + packet (range) */
+	IPQ_COPY_NONE,		
+	IPQ_COPY_META,		
+	IPQ_COPY_PACKET		
 };
 #define IPQ_COPY_MAX IPQ_COPY_PACKET
 
-/* Types of messages */
-#define IPQM_BASE	0x10	/* standard netlink messages below this */
-#define IPQM_MODE	(IPQM_BASE + 1)		/* Mode request from peer */
-#define IPQM_VERDICT	(IPQM_BASE + 2)		/* Verdict from peer */ 
-#define IPQM_PACKET	(IPQM_BASE + 3)		/* Packet from kernel */
+#define IPQM_BASE	0x10	
+#define IPQM_MODE	(IPQM_BASE + 1)		
+#define IPQM_VERDICT	(IPQM_BASE + 2)		 
+#define IPQM_PACKET	(IPQM_BASE + 3)		
 #define IPQM_MAX	(IPQM_BASE + 4)
 
-#endif /*_IP_QUEUE_H*/
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/pm_runtime.h monarudo-jb-3.4.10-e22f38b/include/linux/pm_runtime.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/pm_runtime.h	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/pm_runtime.h	2013-08-01 23:37:50.000000000 -0600
@@ -65,7 +65,7 @@
 
 	
 	
-	#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+	#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 	{
 		extern unsigned int get_radio_flag(void);
 		if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
@@ -84,7 +84,7 @@
 
 	
 	
-	#if defined(CONFIG_USB_EHCI_MSM_HSIC)
+	#if defined(CONFIG_ARCH_APQ8064) && defined(CONFIG_USB_EHCI_MSM_HSIC)
 	{
 		extern unsigned int get_radio_flag(void);
 		if (dev && msm_hsic_host_dev == dev && (mdm_is_in_restart || (get_radio_flag() & 0x0001))) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/qcedev.h monarudo-jb-3.4.10-e22f38b/include/linux/qcedev.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/qcedev.h	2013-06-24 02:50:46.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/qcedev.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,127 +0,0 @@
-#ifndef __QCEDEV__H
-#define __QCEDEV__H
-
-#include <linux/types.h>
-#include <linux/ioctl.h>
-
-#define QCEDEV_MAX_SHA_BLOCK_SIZE	64
-#define QCEDEV_MAX_BEARER	31
-#define QCEDEV_MAX_KEY_SIZE	64
-#define QCEDEV_MAX_IV_SIZE	32
-
-#define QCEDEV_MAX_BUFFERS      16
-#define QCEDEV_MAX_SHA_DIGEST	32
-
-#define QCEDEV_USE_PMEM		1
-#define QCEDEV_NO_PMEM		0
-
-#define QCEDEV_AES_KEY_128	16
-#define QCEDEV_AES_KEY_192	24
-#define QCEDEV_AES_KEY_256	32
-enum qcedev_oper_enum {
-	QCEDEV_OPER_DEC		= 0,
-	QCEDEV_OPER_ENC		= 1,
-	QCEDEV_OPER_DEC_NO_KEY	= 2,
-	QCEDEV_OPER_ENC_NO_KEY	= 3,
-	QCEDEV_OPER_LAST
-};
-
-enum qcedev_cipher_alg_enum {
-	QCEDEV_ALG_DES		= 0,
-	QCEDEV_ALG_3DES		= 1,
-	QCEDEV_ALG_AES		= 2,
-	QCEDEV_ALG_LAST
-};
-
-enum qcedev_cipher_mode_enum {
-	QCEDEV_AES_MODE_CBC	= 0,
-	QCEDEV_AES_MODE_ECB	= 1,
-	QCEDEV_AES_MODE_CTR	= 2,
-	QCEDEV_AES_MODE_XTS	= 3,
-	QCEDEV_AES_MODE_CCM	= 4,
-	QCEDEV_DES_MODE_CBC	= 5,
-	QCEDEV_DES_MODE_ECB	= 6,
-	QCEDEV_AES_DES_MODE_LAST
-};
-
-enum qcedev_sha_alg_enum {
-	QCEDEV_ALG_SHA1		= 0,
-	QCEDEV_ALG_SHA256	= 1,
-	QCEDEV_ALG_SHA1_HMAC	= 2,
-	QCEDEV_ALG_SHA256_HMAC	= 3,
-	QCEDEV_ALG_AES_CMAC	= 4,
-	QCEDEV_ALG_SHA_ALG_LAST
-};
-
-struct	buf_info {
-	union {
-		uint32_t	offset;
-		uint8_t		*vaddr;
-	};
-	uint32_t	len;
-};
-
-struct	qcedev_vbuf_info {
-	struct buf_info	src[QCEDEV_MAX_BUFFERS];
-	struct buf_info	dst[QCEDEV_MAX_BUFFERS];
-};
-
-struct	qcedev_pmem_info {
-	int		fd_src;
-	struct buf_info	src[QCEDEV_MAX_BUFFERS];
-	int		fd_dst;
-	struct buf_info	dst[QCEDEV_MAX_BUFFERS];
-};
-
-struct	qcedev_cipher_op_req {
-	uint8_t				use_pmem;
-	union {
-		struct qcedev_pmem_info	pmem;
-		struct qcedev_vbuf_info	vbuf;
-	};
-	uint32_t			entries;
-	uint32_t			data_len;
-	uint8_t				in_place_op;
-	uint8_t				enckey[QCEDEV_MAX_KEY_SIZE];
-	uint32_t			encklen;
-	uint8_t				iv[QCEDEV_MAX_IV_SIZE];
-	uint32_t			ivlen;
-	uint32_t			byteoffset;
-	enum qcedev_cipher_alg_enum	alg;
-	enum qcedev_cipher_mode_enum	mode;
-	enum qcedev_oper_enum		op;
-};
-
-struct	qcedev_sha_op_req {
-	struct buf_info			data[QCEDEV_MAX_BUFFERS];
-	uint32_t			entries;
-	uint32_t			data_len;
-	uint8_t				digest[QCEDEV_MAX_SHA_DIGEST];
-	uint32_t			diglen;
-	uint8_t				*authkey;
-	uint32_t			authklen;
-	enum qcedev_sha_alg_enum	alg;
-};
-
-
-#define QCEDEV_IOC_MAGIC	0x87
-
-#define QCEDEV_IOCTL_ENC_REQ		\
-	_IOWR(QCEDEV_IOC_MAGIC, 1, struct qcedev_cipher_op_req)
-#define QCEDEV_IOCTL_DEC_REQ		\
-	_IOWR(QCEDEV_IOC_MAGIC, 2, struct qcedev_cipher_op_req)
-#define QCEDEV_IOCTL_SHA_INIT_REQ	\
-	_IOWR(QCEDEV_IOC_MAGIC, 3, struct qcedev_sha_op_req)
-#define QCEDEV_IOCTL_SHA_UPDATE_REQ	\
-	_IOWR(QCEDEV_IOC_MAGIC, 4, struct qcedev_sha_op_req)
-#define QCEDEV_IOCTL_SHA_FINAL_REQ	\
-	_IOWR(QCEDEV_IOC_MAGIC, 5, struct qcedev_sha_op_req)
-#define QCEDEV_IOCTL_GET_SHA_REQ	\
-	_IOWR(QCEDEV_IOC_MAGIC, 6, struct qcedev_sha_op_req)
-#define QCEDEV_IOCTL_LOCK_CE	\
-	_IO(QCEDEV_IOC_MAGIC, 7)
-#define QCEDEV_IOCTL_UNLOCK_CE	\
-	_IO(QCEDEV_IOC_MAGIC, 8)
-#define QCEDEV_IOCTL_GET_CMAC_REQ	\
-	_IOWR(QCEDEV_IOC_MAGIC, 9, struct qcedev_cipher_op_req)
-#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/security.h monarudo-jb-3.4.10-e22f38b/include/linux/security.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/security.h	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/security.h	2013-08-01 23:37:46.000000000 -0600
@@ -169,6 +169,11 @@
 struct security_operations {
 	char name[SECURITY_NAME_MAX + 1];
 
+	int (*binder_set_context_mgr) (struct task_struct *mgr);
+	int (*binder_transaction) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_binder) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_file) (struct task_struct *from, struct task_struct *to, struct file *file);
+
 	int (*ptrace_access_check) (struct task_struct *child, unsigned int mode);
 	int (*ptrace_traceme) (struct task_struct *parent);
 	int (*capget) (struct task_struct *target,
@@ -450,6 +455,10 @@
 extern void __init security_fixup_ops(struct security_operations *ops);
 
 
+int security_binder_set_context_mgr(struct task_struct *mgr);
+int security_binder_transaction(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file);
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode);
 int security_ptrace_traceme(struct task_struct *parent);
 int security_capget(struct task_struct *target,
@@ -623,6 +632,26 @@
 {
 	return 0;
 }
+
+static inline int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static inline int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return 0;
+}
 
 static inline int security_ptrace_access_check(struct task_struct *child,
 					     unsigned int mode)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/selinux_netlink.h monarudo-jb-3.4.10-e22f38b/include/linux/selinux_netlink.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/selinux_netlink.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/selinux_netlink.h	2013-08-01 23:38:04.000000000 -0600
@@ -14,7 +14,6 @@
 
 #include <linux/types.h>
 
-/* Message types. */
 #define SELNL_MSG_BASE 0x10
 enum {
 	SELNL_MSG_SETENFORCE = SELNL_MSG_BASE,
@@ -23,9 +22,8 @@
 };
 
 #ifndef __KERNEL__
-/* Multicast groups - backwards compatiblility for userspace */
 #define SELNL_GRP_NONE		0x00000000
-#define SELNL_GRP_AVC		0x00000001	/* AVC notifications */
+#define SELNL_GRP_AVC		0x00000001	
 #define SELNL_GRP_ALL		0xffffffff
 #endif
 
@@ -38,7 +36,6 @@
 };
 #define SELNLGRP_MAX	(__SELNLGRP_MAX - 1)
 
-/* Message structures */
 struct selnl_msg_setenforce {
 	__s32		val;
 };
@@ -47,4 +44,4 @@
 	__u32	seqno;
 };
 
-#endif /* _LINUX_SELINUX_NETLINK_H */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/uhid.h monarudo-jb-3.4.10-e22f38b/include/linux/uhid.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/uhid.h	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/include/linux/uhid.h	2013-08-01 23:38:02.000000000 -0600
@@ -0,0 +1,99 @@
+#ifndef __UHID_H_
+#define __UHID_H_
+
+/*
+ * User-space I/O driver support for HID subsystem
+ * Copyright (c) 2012 David Herrmann
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+
+#include <linux/input.h>
+#include <linux/types.h>
+
+enum uhid_event_type {
+	UHID_CREATE,
+	UHID_DESTROY,
+	UHID_START,
+	UHID_STOP,
+	UHID_OPEN,
+	UHID_CLOSE,
+	UHID_OUTPUT,
+	UHID_OUTPUT_EV,
+	UHID_INPUT,
+	UHID_FEATURE,
+	UHID_FEATURE_ANSWER,
+};
+
+struct uhid_create_req {
+	__u8 name[128];
+	__u8 phys[64];
+	__u8 uniq[64];
+	__u8 __user *rd_data;
+	__u16 rd_size;
+
+	__u16 bus;
+	__u32 vendor;
+	__u32 product;
+	__u32 version;
+	__u32 country;
+} __attribute__((__packed__));
+
+#define UHID_DATA_MAX 4096
+
+enum uhid_report_type {
+	UHID_FEATURE_REPORT,
+	UHID_OUTPUT_REPORT,
+	UHID_INPUT_REPORT,
+};
+
+struct uhid_input_req {
+	__u8 data[UHID_DATA_MAX];
+	__u16 size;
+} __attribute__((__packed__));
+
+struct uhid_output_req {
+	__u8 data[UHID_DATA_MAX];
+	__u16 size;
+	__u8 rtype;
+} __attribute__((__packed__));
+
+struct uhid_output_ev_req {
+	__u16 type;
+	__u16 code;
+	__s32 value;
+} __attribute__((__packed__));
+
+struct uhid_feature_req {
+	__u32 id;
+	__u8 rnum;
+	__u8 rtype;
+} __attribute__((__packed__));
+
+struct uhid_feature_answer_req {
+	__u32 id;
+	__u16 err;
+	__u16 size;
+	__u8 data[UHID_DATA_MAX];
+};
+
+struct uhid_event {
+	__u32 type;
+
+	union {
+		struct uhid_create_req create;
+		struct uhid_input_req input;
+		struct uhid_output_req output;
+		struct uhid_output_ev_req output_ev;
+		struct uhid_feature_req feature;
+		struct uhid_feature_answer_req feature_answer;
+	} u;
+} __attribute__((__packed__));
+
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/usb/msm_hsusb.h monarudo-jb-3.4.10-e22f38b/include/linux/usb/msm_hsusb.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/usb/msm_hsusb.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/usb/msm_hsusb.h	2013-08-01 23:37:56.000000000 -0600
@@ -216,6 +216,7 @@
 	int connect_type_ready;
 	struct workqueue_struct *usb_wq;
 	struct delayed_work ac_detect_work;
+	struct work_struct usb_disable_work;
 	int ac_detect_count;
 	int reset_phy_before_lpm;
 	int reset_counter;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/usb/otg.h monarudo-jb-3.4.10-e22f38b/include/linux/usb/otg.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/usb/otg.h	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/usb/otg.h	2013-08-01 23:37:56.000000000 -0600
@@ -119,7 +119,7 @@
 			enum usb_otg_event event);
 
 	void	(*notify_usb_attached)(void);
-
+	void	(*notify_usb_disabled)(void);
 };
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/linux/vermagic.h monarudo-jb-3.4.10-e22f38b/include/linux/vermagic.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/linux/vermagic.h	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/linux/vermagic.h	2012-08-26 16:02:10.000000000 -0600
@@ -1,5 +1,6 @@
 #include <generated/utsrelease.h>
 
+/* Simply sanity version stamp for modules. */
 #ifdef CONFIG_SMP
 #define MODULE_VERMAGIC_SMP "SMP "
 #else
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/media/linux_yushanii.h monarudo-jb-3.4.10-e22f38b/include/media/linux_yushanii.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/media/linux_yushanii.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/media/linux_yushanii.h	2013-08-01 23:38:00.000000000 -0600
@@ -89,6 +89,7 @@
 #define END_OF_FRAME  					0x00000040
 #define LONGEXP_GLACE_STATS_READY 	0x00000100
 #define LONGEXP_HISTOGRAM_STATS_READY  0x00000200
+#define START_OF_SHORTFRAME 			0x00000800	
 #define SHORTEXP_GLACE_STATS_READY  	0x00010000
 #define SHORTEXP_HISTOGRAM_STATS_READY  0x00020000
 #define ITPOINT_LONG  					0x00200000
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/media/msm/vcd_property.h monarudo-jb-3.4.10-e22f38b/include/media/msm/vcd_property.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/media/msm/vcd_property.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/media/msm/vcd_property.h	2013-08-01 23:38:00.000000000 -0600
@@ -57,6 +57,10 @@
 #define VCD_I_SET_TURBO_CLK (VCD_START_BASE + 0x29)
 #define VCD_I_ENABLE_DELIMITER_FLAG (VCD_START_BASE + 0x2A)
 #define VCD_I_ENABLE_VUI_TIMING_INFO (VCD_START_BASE + 0x2B)
+#define VCD_I_SET_EXT_METABUFFER (VCD_START_BASE + 0x2C)
+#define VCD_I_FREE_EXT_METABUFFER (VCD_START_BASE + 0x2D)
+#define VCD_I_ENABLE_SEC_METADATA (VCD_START_BASE + 0x2E)
+#define VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG (VCD_START_BASE + 0x2F)
 
 #define VCD_START_REQ      (VCD_START_BASE + 0x1000)
 #define VCD_I_REQ_IFRAME   (VCD_START_REQ + 0x1)
@@ -383,4 +387,23 @@
 	u32 vui_timing_info;
 };
 
+struct vcd_property_meta_buffer {
+	u8 *kernel_virtual_addr;
+	u8 *physical_addr;
+	u32 size;
+	u32 count;
+	int pmem_fd;
+	u32 offset;
+	u8 *dev_addr;
+	void *client_data;
+	u8 *kernel_virt_addr_iommu;
+	u8 *physical_addr_iommu;
+	int pmem_fd_iommu;
+	u8 *dev_addr_iommu;
+	void *client_data_iommu;
+};
+
+struct vcd_property_bitstream_restrict_enable {
+	u32 bitstream_restrict_enable_flag;
+};
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/media/msm_camera.h monarudo-jb-3.4.10-e22f38b/include/media/msm_camera.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/media/msm_camera.h	2013-06-24 02:50:45.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/media/msm_camera.h	2013-08-01 23:38:00.000000000 -0600
@@ -1604,6 +1604,11 @@
 	uint8_t is_af_supported;
 	uint8_t is_ois_supported;
     uint8_t is_cal_supported; 
+	int8_t enable_focus_step_log;
+	uint8_t small_step_damping;
+	uint8_t medium_step_damping;
+	uint8_t big_step_damping;
+	uint8_t is_af_infinity_supported;
 	union {
 		struct msm_actuator_move_params_t move;
 		struct msm_actuator_set_info_t set_info;
@@ -1754,7 +1759,7 @@
 
 #define MSM_CAM_V4L2_IOCTL_GET_EVENT_PAYLOAD \
 	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct msm_camera_v4l2_ioctl_t *)
-	
+
 #define MSM_CAM_IOCTL_SEND_EVENT \
 	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct v4l2_event)
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/sound/apr_audio.h monarudo-jb-3.4.10-e22f38b/include/sound/apr_audio.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/sound/apr_audio.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/sound/apr_audio.h	2013-08-01 23:37:53.000000000 -0600
@@ -532,6 +532,7 @@
 #define ADM_CMD_COPP_CLOSE                               0x00010305
 
 #define ADM_CMD_MULTI_CHANNEL_COPP_OPEN                  0x00010310
+#define ADM_CMD_MULTI_CHANNEL_COPP_OPEN_V3               0x00010333
 struct adm_multi_ch_copp_open_command {
 	struct apr_hdr hdr;
 	u16 flags;
@@ -604,6 +605,13 @@
 #define VPM_TX_SM_ECNS_COPP_TOPOLOGY			0x00010F71
 #define VPM_TX_DM_FLUENCE_COPP_TOPOLOGY			0x00010F72
 #define VPM_TX_QMIC_FLUENCE_COPP_TOPOLOGY		0x00010F75
+#define LOWLATENCY_POPP_TOPOLOGY           0x00010C68
+#define LOWLATENCY_COPP_TOPOLOGY           0x00010312
+#define PCM_BITS_PER_SAMPLE                16
+
+#define ASM_OPEN_WRITE_PERF_MODE_BIT           (1<<28)
+#define ASM_OPEN_READ_PERF_MODE_BIT            (1<<29)
+#define ADM_MULTI_CH_COPP_OPEN_PERF_MODE_BIT       (1<<13)
 #define HTC_STEREO_RECORD_TOPOLOGY			0x10000000
 #define HTC_COPP_TOPOLOGY				0x10000001
 #define HTC_POPP_TOPOLOGY				0x10000002
@@ -726,6 +734,7 @@
 
 #define ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN               0x00010311
 #define ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN_V2            0x0001031A
+#define ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN_V3            0x00010334
 
 
 #define ASM_STREAM_PRIORITY_NORMAL	0
@@ -994,6 +1003,7 @@
 };
 
 #define ASM_STREAM_CMD_OPEN_READ                         0x00010BCB
+#define ASM_STREAM_CMD_OPEN_READ_V2_1                    0x00010DB2
 struct asm_stream_cmd_open_read {
 	struct apr_hdr hdr;
 	u32            uMode;
@@ -1002,6 +1012,16 @@
 	u32            format;
 } __attribute__((packed));
 
+struct asm_stream_cmd_open_read_v2_1 {
+   struct apr_hdr hdr;
+   u32            uMode;
+   u32            src_endpoint;
+   u32            pre_proc_top;
+   u32            format;
+   u16            bits_per_sample;
+   u16            reserved;
+} __packed;
+
 #define LINEAR_PCM   0x00010BE5
 #define DTMF         0x00010BE6
 #define ADPCM        0x00010BE7
@@ -1050,6 +1070,7 @@
 
 #define ASM_STREAM_CMD_OPEN_WRITE                        0x00010BCA
 #define ASM_STREAM_CMD_OPEN_WRITE_V2                     0x00010D8F
+#define ASM_STREAM_CMD_OPEN_WRITE_V2_1                   0x00010DB1
 
 struct asm_stream_cmd_open_write {
 	struct apr_hdr hdr;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/sound/q6adm.h monarudo-jb-3.4.10-e22f38b/include/sound/q6adm.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/sound/q6adm.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/sound/q6adm.h	2013-08-01 23:37:53.000000000 -0600
@@ -26,10 +26,10 @@
 int adm_open(int port, int path, int rate, int mode, int topology);
 
 int adm_multi_ch_copp_open(int port, int path, int rate, int mode,
-				int topology);
+                int topology, int perfmode);
 
 int adm_multi_ch_copp_open_v2(int port, int path, int rate, int mode,
-			int topology, uint16_t bit_width);
+			int topology, uint16_t bit_width, int perfmode);
 
 int adm_memory_map_regions(uint32_t *buf_add, uint32_t mempool_id,
 				uint32_t *bufsz, uint32_t bufcnt);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/include/sound/q6asm.h monarudo-jb-3.4.10-e22f38b/include/sound/q6asm.h
--- monarudo-jb-crc-3.4.10-7edee3c/include/sound/q6asm.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/include/sound/q6asm.h	2013-08-01 23:37:53.000000000 -0600
@@ -159,6 +159,7 @@
 	uint32_t         io_mode;
 	uint64_t         time_stamp;
 	atomic_t         cmd_response;
+	bool             perf_mode;
 };
 
 struct q6asm_ops {
@@ -185,7 +186,7 @@
 			struct audio_client *ac);
 
 int q6asm_open_read(struct audio_client *ac, uint32_t format);
-
+int q6asm_open_read_v2_1(struct audio_client *ac, uint32_t format);
 int q6asm_open_read_compressed(struct audio_client *ac, uint32_t format);
 
 int q6asm_open_write(struct audio_client *ac, uint32_t format);
@@ -284,7 +285,7 @@
 			uint32_t rate, uint32_t channels, uint16_t bit_width);
 
 int q6asm_media_format_block_multi_ch_pcm(struct audio_client *ac,
-				uint32_t rate, uint32_t channels);
+				uint32_t rate, uint32_t channels, uint16_t bit_width);
 
 int q6asm_media_format_block_multi_ch_pcm_format_support(
 		struct audio_client *ac, uint32_t rate, uint32_t channels,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/audit.c monarudo-jb-3.4.10-e22f38b/kernel/audit.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/audit.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/audit.c	2013-08-01 23:37:51.000000000 -0600
@@ -64,8 +64,6 @@
 
 #include "audit.h"
 
-/* No auditing will take place until audit_initialized == AUDIT_INITIALIZED.
- * (Initialization happens after skb_init is called.) */
 #define AUDIT_DISABLED		-1
 #define AUDIT_UNINITIALIZED	0
 #define AUDIT_INITIALIZED	1
@@ -79,10 +77,8 @@
 
 EXPORT_SYMBOL_GPL(audit_enabled);
 
-/* Default state when kernel boots without any parameters. */
 static int	audit_default;
 
-/* If auditing cannot proceed, audit_failure selects what happens. */
 static int	audit_failure = AUDIT_FAIL_PRINTK;
 
 /*
@@ -93,71 +89,42 @@
 int		audit_pid;
 static int	audit_nlk_pid;
 
-/* If audit_rate_limit is non-zero, limit the rate of sending audit records
- * to that number per second.  This prevents DoS attacks, but results in
- * audit records being dropped. */
 static int	audit_rate_limit;
 
-/* Number of outstanding audit_buffers allowed. */
 static int	audit_backlog_limit = 64;
 static int	audit_backlog_wait_time = 60 * HZ;
 static int	audit_backlog_wait_overflow = 0;
 
-/* The identity of the user shutting down the audit system. */
 uid_t		audit_sig_uid = -1;
 pid_t		audit_sig_pid = -1;
 u32		audit_sig_sid = 0;
 
-/* Records can be lost in several ways:
-   0) [suppressed in audit_alloc]
-   1) out of memory in audit_log_start [kmalloc of struct audit_buffer]
-   2) out of memory in audit_log_move [alloc_skb]
-   3) suppressed due to audit_rate_limit
-   4) suppressed due to audit_backlog_limit
-*/
 static atomic_t    audit_lost = ATOMIC_INIT(0);
 
-/* The netlink socket. */
 static struct sock *audit_sock;
 
-/* Hash for inode-based rules */
 struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];
 
-/* The audit_freelist is a list of pre-allocated audit buffers (if more
- * than AUDIT_MAXFREE are in use, the audit buffer is freed instead of
- * being placed on the freelist). */
 static DEFINE_SPINLOCK(audit_freelist_lock);
 static int	   audit_freelist_count;
 static LIST_HEAD(audit_freelist);
 
 static struct sk_buff_head audit_skb_queue;
-/* queue of skbs to send to auditd when/if it comes back */
 static struct sk_buff_head audit_skb_hold_queue;
 static struct task_struct *kauditd_task;
 static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);
 static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);
 
-/* Serialize requests from userspace. */
 DEFINE_MUTEX(audit_cmd_mutex);
 
-/* AUDIT_BUFSIZ is the size of the temporary buffer used for formatting
- * audit records.  Since printk uses a 1024 byte buffer, this buffer
- * should be at least that large. */
 #define AUDIT_BUFSIZ 1024
 
-/* AUDIT_MAXFREE is the number of empty audit_buffers we keep on the
- * audit_freelist.  Doing so eliminates many kmalloc/kfree calls. */
 #define AUDIT_MAXFREE  (2*NR_CPUS)
 
-/* The audit_buffer is used when formatting an audit record.  The caller
- * locks briefly to get the record off the freelist or to allocate the
- * buffer, and locks briefly to send the buffer to the netlink layer or
- * to place it on a transmit queue.  Multiple audit_buffers can be in
- * use simultaneously. */
 struct audit_buffer {
 	struct list_head     list;
-	struct sk_buff       *skb;	/* formatted skb ready to send */
-	struct audit_context *ctx;	/* NULL or associated context */
+	struct sk_buff       *skb;	
+	struct audit_context *ctx;	
 	gfp_t		     gfp_mask;
 };
 
@@ -185,7 +152,7 @@
 			printk(KERN_ERR "audit: %s\n", message);
 		break;
 	case AUDIT_FAIL_PANIC:
-		/* test audit_pid since printk is always losey, why bother? */
+		
 		if (audit_pid)
 			panic("audit: %s\n", message);
 		break;
@@ -221,14 +188,6 @@
 	return retval;
 }
 
-/**
- * audit_log_lost - conditionally log lost audit message event
- * @message: the message stating reason for lost audit message
- *
- * Emit at least 1 message per second, even if audit_rate_check is
- * throttling.
- * Always increment the lost messages counter.
-*/
 void audit_log_lost(const char *message)
 {
 	static unsigned long	last_msg = 0;
@@ -280,7 +239,7 @@
 		rc = security_secid_to_secctx(sid, &ctx, &len);
 		if (rc) {
 			audit_log_format(ab, " sid=%u", sid);
-			allow_changes = 0; /* Something weird, deny request */
+			allow_changes = 0; 
 		} else {
 			audit_log_format(ab, " subj=%s", ctx);
 			security_release_secctx(ctx, len);
@@ -297,7 +256,7 @@
 {
 	int allow_changes, rc = 0, old = *to_change;
 
-	/* check if we are locked */
+	
 	if (audit_enabled == AUDIT_LOCKED)
 		allow_changes = 0;
 	else
@@ -310,10 +269,10 @@
 			allow_changes = 0;
 	}
 
-	/* If we are allowed, make the change */
+	
 	if (allow_changes == 1)
 		*to_change = new;
-	/* Not allowed, update reason */
+	
 	else if (rc == 0)
 		rc = -EPERM;
 	return rc;
@@ -359,15 +318,6 @@
 				      loginuid, sessionid, sid);
 }
 
-/*
- * Queue skbs to be sent to auditd when/if it comes back.  These skbs should
- * already have been sent via prink/syslog and so if these messages are dropped
- * it is not a huge concern since we already passed the audit_log_lost()
- * notification and stuff.  This is just nice to get audit messages during
- * boot before auditd is running or messages generated while auditd is stopped.
- * This only holds messages is audit_default is set, aka booting with audit=1
- * or building your kernel that way.
- */
 static void audit_hold_skb(struct sk_buff *skb)
 {
 	if (audit_default &&
@@ -377,10 +327,6 @@
 		kfree_skb(skb);
 }
 
-/*
- * For one reason or another this nlh isn't getting delivered to the userspace
- * audit daemon, just send it to printk.
- */
 static void audit_printk_skb(struct sk_buff *skb)
 {
 	struct nlmsghdr *nlh = nlmsg_hdr(skb);
@@ -399,18 +345,18 @@
 static void kauditd_send_skb(struct sk_buff *skb)
 {
 	int err;
-	/* take a reference in case we can't send it and we want to hold it */
+	
 	skb_get(skb);
 	err = netlink_unicast(audit_sock, skb, audit_nlk_pid, 0);
 	if (err < 0) {
-		BUG_ON(err != -ECONNREFUSED); /* Shouldn't happen */
+		BUG_ON(err != -ECONNREFUSED); 
 		printk(KERN_ERR "audit: *NO* daemon at audit_pid=%d\n", audit_pid);
 		audit_log_lost("auditd disappeared\n");
 		audit_pid = 0;
-		/* we might get lucky and get this in the next auditd */
+		
 		audit_hold_skb(skb);
 	} else
-		/* drop the extra reference if sent ok */
+		
 		consume_skb(skb);
 }
 
@@ -420,19 +366,6 @@
 
 	set_freezable();
 	while (!kthread_should_stop()) {
-		/*
-		 * if auditd just started drain the queue of messages already
-		 * sent to syslog/printk.  remember loss here is ok.  we already
-		 * called audit_log_lost() if it didn't go out normally.  so the
-		 * race between the skb_dequeue and the next check for audit_pid
-		 * doesn't matter.
-		 *
-		 * if you ever find kauditd to be too slow we can get a perf win
-		 * by doing our own locking and keeping better track if there
-		 * are messages in this queue.  I don't see the need now, but
-		 * in 5 years when I want to play with this again I'll see this
-		 * note and still have no friggin idea what i'm thinking today.
-		 */
 		if (audit_default && audit_pid) {
 			skb = skb_dequeue(&audit_skb_hold_queue);
 			if (unlikely(skb)) {
@@ -491,7 +424,7 @@
 	int pid = dest->pid;
 	struct sk_buff *skb;
 
-	/* wait for parent to finish and send an ACK */
+	
 	mutex_lock(&audit_cmd_mutex);
 	mutex_unlock(&audit_cmd_mutex);
 
@@ -521,7 +454,7 @@
 	memcpy(data, payload, size);
 	return skb;
 
-nlmsg_failure:			/* Used by NLMSG_NEW */
+nlmsg_failure:			
 	if (skb)
 		kfree_skb(skb);
 	return NULL;
@@ -534,25 +467,10 @@
 	mutex_lock(&audit_cmd_mutex);
 	mutex_unlock(&audit_cmd_mutex);
 
-	/* Ignore failure. It'll only happen if the sender goes away,
-	   because our timeout is set to infinite. */
 	netlink_unicast(audit_sock, reply->skb, reply->pid, 0);
 	kfree(reply);
 	return 0;
 }
-/**
- * audit_send_reply - send an audit reply message via netlink
- * @pid: process id to send reply to
- * @seq: sequence number
- * @type: audit message type
- * @done: done (last) flag
- * @multi: multi-part message flag
- * @payload: payload data
- * @size: payload size
- *
- * Allocates an skb, builds the netlink message, and sends it to the pid.
- * No failure notifications.
- */
 static void audit_send_reply(int pid, int seq, int type, int done, int multi,
 			     const void *payload, int size)
 {
@@ -579,10 +497,6 @@
 	kfree(reply);
 }
 
-/*
- * Check for appropriate CAP_AUDIT_ capabilities on incoming audit
- * control messages.
- */
 static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)
 {
 	int err = 0;
@@ -610,7 +524,7 @@
 		if (!capable(CAP_AUDIT_WRITE))
 			err = -EPERM;
 		break;
-	default:  /* bad msg */
+	default:  
 		err = -EINVAL;
 	}
 
@@ -654,7 +568,7 @@
 	int			err;
 	struct audit_buffer	*ab;
 	u16			msg_type = nlh->nlmsg_type;
-	uid_t			loginuid; /* loginuid of sender */
+	uid_t			loginuid; 
 	u32			sessionid;
 	struct audit_sig_info   *sig_data;
 	char			*ctx = NULL;
@@ -664,8 +578,6 @@
 	if (err)
 		return err;
 
-	/* As soon as there's any sign of userspace auditd,
-	 * start kauditd to talk to it */
 	if (!kauditd_task)
 		kauditd_task = kthread_run(kauditd_thread, NULL, "kauditd");
 	if (IS_ERR(kauditd_task)) {
@@ -779,7 +691,7 @@
 			audit_log_end(ab);
 			return -EPERM;
 		}
-		/* fallthrough */
+		
 	case AUDIT_LIST:
 		err = audit_receive_filter(msg_type, NETLINK_CB(skb).pid,
 					   uid, seq, data, nlmsg_len(nlh),
@@ -798,7 +710,7 @@
 			audit_log_end(ab);
 			return -EPERM;
 		}
-		/* fallthrough */
+		
 	case AUDIT_LIST_RULES:
 		err = audit_receive_filter(msg_type, NETLINK_CB(skb).pid,
 					   uid, seq, data, nlmsg_len(nlh),
@@ -836,7 +748,7 @@
 			kfree(old);
 			break;
 		}
-		/* OK, here comes... */
+		
 		err = audit_tag_tree(old, new);
 
 		audit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE, pid,
@@ -922,17 +834,9 @@
 	return err < 0 ? err : 0;
 }
 
-/*
- * Get message from skb.  Each message is processed by audit_receive_msg.
- * Malformed skbs with wrong length are discarded silently.
- */
 static void audit_receive_skb(struct sk_buff *skb)
 {
 	struct nlmsghdr *nlh;
-	/*
-	 * len MUST be signed for NLMSG_NEXT to be able to dec it below 0
-	 * if the nlmsg_len was not aligned
-	 */
 	int len;
 	int err;
 
@@ -941,7 +845,7 @@
 
 	while (NLMSG_OK(nlh, len)) {
 		err = audit_receive_msg(skb, nlh);
-		/* if err or if this message says it wants a response */
+		
 		if (err || (nlh->nlmsg_flags & NLM_F_ACK))
 			netlink_ack(skb, nlh, err);
 
@@ -949,7 +853,6 @@
 	}
 }
 
-/* Receive messages from netlink socket. */
 static void audit_receive(struct sk_buff  *skb)
 {
 	mutex_lock(&audit_cmd_mutex);
@@ -957,7 +860,6 @@
 	mutex_unlock(&audit_cmd_mutex);
 }
 
-/* Initialize audit support at boot time. */
 static int __init audit_init(void)
 {
 	int i;
@@ -989,7 +891,6 @@
 }
 __initcall(audit_init);
 
-/* Process kernel command-line parameter at boot time.  audit=0 or audit=1. */
 static int __init audit_enable(char *str)
 {
 	audit_default = !!simple_strtol(str, NULL, 0);
@@ -1066,7 +967,7 @@
 
 	return ab;
 
-nlmsg_failure:                  /* Used by NLMSG_NEW */
+nlmsg_failure:                  
 	kfree_skb(ab->skb);
 	ab->skb = NULL;
 err:
@@ -1157,15 +1058,14 @@
 	if (gfp_mask & __GFP_WAIT)
 		reserve = 0;
 	else
-		reserve = 5; /* Allow atomic callers to go up to five
-				entries over the normal backlog limit */
+		reserve = 5; 
 
 	while (audit_backlog_limit
 	       && skb_queue_len(&audit_skb_queue) > audit_backlog_limit + reserve) {
 		if (gfp_mask & __GFP_WAIT && audit_backlog_wait_time
 		    && time_before(jiffies, timeout_start + audit_backlog_wait_time)) {
 
-			/* Wait for auditd to drain the queue a little */
+			
 			DECLARE_WAITQUEUE(wait, current);
 			set_current_state(TASK_INTERRUPTIBLE);
 			add_wait_queue(&audit_backlog_wait, &wait);
@@ -1203,14 +1103,6 @@
 	return ab;
 }
 
-/**
- * audit_expand - expand skb in the audit buffer
- * @ab: audit_buffer
- * @extra: space to add at tail of the skb
- *
- * Returns 0 (no space) on failed expansion, or available space if
- * successful.
- */
 static inline int audit_expand(struct audit_buffer *ab, int extra)
 {
 	struct sk_buff *skb = ab->skb;
@@ -1227,12 +1119,6 @@
 	return newtail;
 }
 
-/*
- * Format an audit message into the audit buffer.  If there isn't enough
- * room in the audit buffer, more room will be allocated and vsnprint
- * will be called a second time.  Currently, we assume that a printk
- * can't format message larger than 1024 bytes, so we don't either.
- */
 static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,
 			      va_list args)
 {
@@ -1254,9 +1140,6 @@
 	va_copy(args2, args);
 	len = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);
 	if (len >= avail) {
-		/* The printk buffer is 1024 bytes long, so if we get
-		 * here and AUDIT_BUFSIZ is at least 1024, then we can
-		 * log everything that printk could have logged. */
 		avail = audit_expand(ab,
 			max_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));
 		if (!avail)
@@ -1271,14 +1154,6 @@
 	return;
 }
 
-/**
- * audit_log_format - format a message into the audit buffer.
- * @ab: audit_buffer
- * @fmt: format string
- * @...: optional parameters matching @fmt string
- *
- * All the work is done in audit_log_vformat.
- */
 void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)
 {
 	va_list args;
@@ -1290,17 +1165,6 @@
 	va_end(args);
 }
 
-/**
- * audit_log_hex - convert a buffer to hex and append it to the audit skb
- * @ab: the audit_buffer
- * @buf: buffer to convert to hex
- * @len: length of @buf to be converted
- *
- * No return value; failure to expand is silently ignored.
- *
- * This function will take the passed buf and convert it into a string of
- * ascii hex digits. The new string is placed onto the skb.
- */
 void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,
 		size_t len)
 {
@@ -1317,7 +1181,7 @@
 	avail = skb_tailroom(skb);
 	new_len = len<<1;
 	if (new_len >= avail) {
-		/* Round the buffer request up to the next multiple */
+		
 		new_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);
 		avail = audit_expand(ab, new_len);
 		if (!avail)
@@ -1326,17 +1190,13 @@
 
 	ptr = skb_tail_pointer(skb);
 	for (i=0; i<len; i++) {
-		*ptr++ = hex[(buf[i] & 0xF0)>>4]; /* Upper nibble */
-		*ptr++ = hex[buf[i] & 0x0F];	  /* Lower nibble */
+		*ptr++ = hex[(buf[i] & 0xF0)>>4]; 
+		*ptr++ = hex[buf[i] & 0x0F];	  
 	}
 	*ptr = 0;
-	skb_put(skb, len << 1); /* new string is twice the old string */
+	skb_put(skb, len << 1); 
 }
 
-/*
- * Format a string of no more than slen characters into the audit buffer,
- * enclosed in quote marks.
- */
 void audit_log_n_string(struct audit_buffer *ab, const char *string,
 			size_t slen)
 {
@@ -1350,7 +1210,7 @@
 	BUG_ON(!ab->skb);
 	skb = ab->skb;
 	avail = skb_tailroom(skb);
-	new_len = slen + 3;	/* enclosing quotes + null terminator */
+	new_len = slen + 3;	
 	if (new_len > avail) {
 		avail = audit_expand(ab, new_len);
 		if (!avail)
@@ -1362,14 +1222,9 @@
 	ptr += slen;
 	*ptr++ = '"';
 	*ptr = 0;
-	skb_put(skb, slen + 2);	/* don't include null terminator */
+	skb_put(skb, slen + 2);	
 }
 
-/**
- * audit_string_contains_control - does a string need to be logged in hex
- * @string: string to be checked
- * @len: max length of the string to check
- */
 int audit_string_contains_control(const char *string, size_t len)
 {
 	const unsigned char *p;
@@ -1380,20 +1235,6 @@
 	return 0;
 }
 
-/**
- * audit_log_n_untrustedstring - log a string that may contain random characters
- * @ab: audit_buffer
- * @len: length of string (not including trailing null)
- * @string: string to be logged
- *
- * This code will escape a string that is passed to it if the string
- * contains a control character, unprintable character, double quote mark,
- * or a space. Unescaped strings will start and end with a double quote mark.
- * Strings that are escaped are printed in hex (2 digits per char).
- *
- * The caller specifies the number of characters in the string to log, which may
- * or may not be the entire string.
- */
 void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,
 				 size_t len)
 {
@@ -1403,20 +1244,11 @@
 		audit_log_n_string(ab, string, len);
 }
 
-/**
- * audit_log_untrustedstring - log a string that may contain random characters
- * @ab: audit_buffer
- * @string: string to be logged
- *
- * Same as audit_log_n_untrustedstring(), except that strlen is used to
- * determine string length.
- */
 void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)
 {
 	audit_log_n_untrustedstring(ab, string, strlen(string));
 }
 
-/* This is a helper-function to print the escaped d_path */
 void audit_log_d_path(struct audit_buffer *ab, const char *prefix,
 		      const struct path *path)
 {
@@ -1425,15 +1257,15 @@
 	if (prefix)
 		audit_log_format(ab, "%s", prefix);
 
-	/* We will allow 11 spaces for ' (deleted)' to be appended */
+	
 	pathname = kmalloc(PATH_MAX+11, ab->gfp_mask);
 	if (!pathname) {
 		audit_log_string(ab, "<no_memory>");
 		return;
 	}
 	p = d_path(path, pathname, PATH_MAX+11);
-	if (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */
-		/* FIXME: can we save some information here? */
+	if (IS_ERR(p)) { 
+		
 		audit_log_string(ab, "<too_long>");
 	} else
 		audit_log_untrustedstring(ab, p);
@@ -1449,15 +1281,6 @@
 		audit_log_format(ab, "(null)");
 }
 
-/**
- * audit_log_end - end one audit record
- * @ab: the audit_buffer
- *
- * The netlink_* functions cannot be called inside an irq context, so
- * the audit buffer is placed on a queue and a tasklet is scheduled to
- * remove them from the queue outside the irq context.  May be called in
- * any context.
- */
 void audit_log_end(struct audit_buffer *ab)
 {
 	if (!ab)
@@ -1479,18 +1302,6 @@
 	audit_buffer_free(ab);
 }
 
-/**
- * audit_log - Log an audit record
- * @ctx: audit context
- * @gfp_mask: type of allocation
- * @type: audit message type
- * @fmt: format string to use
- * @...: variable parameters matching the format string
- *
- * This is a convenience function that calls audit_log_start,
- * audit_log_vformat, and audit_log_end.  It may be called
- * in any context.
- */
 void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
 	       const char *fmt, ...)
 {
@@ -1507,16 +1318,6 @@
 }
 
 #ifdef CONFIG_SECURITY
-/**
- * audit_log_secctx - Converts and logs SELinux context
- * @ab: audit_buffer
- * @secid: security number
- *
- * This is a helper function that calls security_secid_to_secctx to convert
- * secid to secctx and then adds the (converted) SELinux context to the audit
- * log by calling audit_log_format, thus also preventing leak of internal secid
- * to userspace. If secid cannot be converted audit_panic is called.
- */
 void audit_log_secctx(struct audit_buffer *ab, u32 secid)
 {
 	u32 len;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/auditfilter.c monarudo-jb-3.4.10-e22f38b/kernel/auditfilter.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/auditfilter.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/auditfilter.c	2013-08-01 23:37:51.000000000 -0600
@@ -44,7 +44,6 @@
  * 		be written directly provided audit_filter_mutex is held.
  */
 
-/* Audit filter lists, defined in <linux/audit.h> */
 struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {
 	LIST_HEAD_INIT(audit_filter_list[0]),
 	LIST_HEAD_INIT(audit_filter_list[1]),
@@ -72,7 +71,7 @@
 	int i;
 	struct audit_krule *erule = &e->rule;
 
-	/* some rules don't have associated watches */
+	
 	if (erule->watch)
 		audit_put_watch(erule->watch);
 	if (erule->fields)
@@ -92,7 +91,6 @@
 	audit_free_rule(e);
 }
 
-/* Initialize an audit filterlist entry. */
 static inline struct audit_entry *audit_init_entry(u32 field_count)
 {
 	struct audit_entry *entry;
@@ -112,8 +110,6 @@
 	return entry;
 }
 
-/* Unpack a filter field's string representation from user-space
- * buffer. */
 char *audit_unpack_string(void **bufp, size_t *remain, size_t len)
 {
 	char *str;
@@ -121,9 +117,6 @@
 	if (!*bufp || (len == 0) || (len > *remain))
 		return ERR_PTR(-EINVAL);
 
-	/* Of the currently implemented string fields, PATH_MAX
-	 * defines the longest valid length.
-	 */
 	if (len > PATH_MAX)
 		return ERR_PTR(-ENAMETOOLONG);
 
@@ -139,7 +132,6 @@
 	return str;
 }
 
-/* Translate an inode field to kernel respresentation. */
 static inline int audit_to_inode(struct audit_krule *krule,
 				 struct audit_field *f)
 {
@@ -202,8 +194,6 @@
 	struct audit_field *arch = entry->rule.arch_f;
 
 	if (!arch) {
-		/* When arch is unspecified, we must check both masks on biarch
-		 * as syscall number alone is ambiguous. */
 		return (audit_match_class_bits(AUDIT_CLASS_SIGNAL,
 					       entry->rule.mask) &&
 			audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,
@@ -211,10 +201,10 @@
 	}
 
 	switch(audit_classify_arch(arch->val)) {
-	case 0: /* native */
+	case 0: 
 		return (audit_match_class_bits(AUDIT_CLASS_SIGNAL,
 					       entry->rule.mask));
-	case 1: /* 32bit on biarch */
+	case 1: 
 		return (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,
 					       entry->rule.mask));
 	default:
@@ -223,7 +213,6 @@
 }
 #endif
 
-/* Common user-space to kernel rule translation. */
 static inline struct audit_entry *audit_to_entry_common(struct audit_rule *rule)
 {
 	unsigned listnr;
@@ -311,8 +300,6 @@
 }
 
 
-/* Translate struct audit_rule to kernel's rule respresentation.
- * Exists for backward compatibility with userspace. */
 static struct audit_entry *audit_rule_to_entry(struct audit_rule *rule)
 {
 	struct audit_entry *entry;
@@ -329,8 +316,6 @@
 
 		n = rule->fields[i] & (AUDIT_NEGATE|AUDIT_OPERATORS);
 
-		/* Support for legacy operators where
-		 * AUDIT_NEGATE bit signifies != and otherwise assumes == */
 		if (n & AUDIT_NEGATE)
 			f->op = Audit_not_equal;
 		else if (!n)
@@ -367,7 +352,7 @@
 		case AUDIT_DEVMINOR:
 		case AUDIT_EXIT:
 		case AUDIT_SUCCESS:
-			/* bit ops are only useful on syscall args */
+			
 			if (f->op == Audit_bitmask || f->op == Audit_bittest)
 				goto exit_free;
 			break;
@@ -376,7 +361,7 @@
 		case AUDIT_ARG2:
 		case AUDIT_ARG3:
 			break;
-		/* arch is only allowed to be = or != */
+		
 		case AUDIT_ARCH:
 			if (f->op != Audit_not_equal && f->op != Audit_equal)
 				goto exit_free;
@@ -409,7 +394,6 @@
 	return ERR_PTR(err);
 }
 
-/* Translate struct audit_rule_data to kernel's rule respresentation. */
 static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,
 					       size_t datasz)
 {
@@ -484,8 +468,6 @@
 
 			err = security_audit_rule_init(f->type, f->op, str,
 						       (void **)&f->lsm_rule);
-			/* Keep currently invalid fields around in case they
-			 * become valid after a policy reload. */
 			if (err == -EINVAL) {
 				printk(KERN_WARNING "audit rule for LSM "
 				       "\'%s\' is invalid\n",  str);
@@ -562,7 +544,6 @@
 	return ERR_PTR(err);
 }
 
-/* Pack a filter field's string representation into data block. */
 static inline size_t audit_pack_string(void **bufp, const char *str)
 {
 	size_t len = strlen(str);
@@ -573,8 +554,6 @@
 	return len;
 }
 
-/* Translate kernel rule respresentation to struct audit_rule.
- * Exists for backward compatibility with userspace. */
 static struct audit_rule *audit_krule_to_rule(struct audit_krule *krule)
 {
 	struct audit_rule *rule;
@@ -603,7 +582,6 @@
 	return rule;
 }
 
-/* Translate kernel rule respresentation to struct audit_rule_data. */
 static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)
 {
 	struct audit_rule_data *data;
@@ -661,8 +639,6 @@
 	return data;
 }
 
-/* Compare two rules in kernel format.  Considered success if rules
- * don't match. */
 static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)
 {
 	int i;
@@ -703,7 +679,7 @@
 				return 1;
 			break;
 		case AUDIT_FILTERKEY:
-			/* both filterkeys exist based on above type compare */
+			
 			if (strcmp(a->filterkey, b->filterkey))
 				return 1;
 			break;
@@ -720,25 +696,21 @@
 	return 0;
 }
 
-/* Duplicate LSM field information.  The lsm_rule is opaque, so must be
- * re-initialized. */
 static inline int audit_dupe_lsm_field(struct audit_field *df,
 					   struct audit_field *sf)
 {
 	int ret = 0;
 	char *lsm_str;
 
-	/* our own copy of lsm_str */
+	
 	lsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);
 	if (unlikely(!lsm_str))
 		return -ENOMEM;
 	df->lsm_str = lsm_str;
 
-	/* our own (refreshed) copy of lsm_rule */
+	
 	ret = security_audit_rule_init(df->type, df->op, df->lsm_str,
 				       (void **)&df->lsm_rule);
-	/* Keep currently invalid fields around in case they
-	 * become valid after a policy reload. */
 	if (ret == -EINVAL) {
 		printk(KERN_WARNING "audit rule for LSM \'%s\' is "
 		       "invalid\n", df->lsm_str);
@@ -748,12 +720,6 @@
 	return ret;
 }
 
-/* Duplicate an audit rule.  This will be a deep copy with the exception
- * of the watch - that pointer is carried over.  The LSM specific fields
- * will be updated in the copy.  The point is to be able to replace the old
- * rule with the new rule in the filterlist, then free the old rule.
- * The rlist element is undefined; list manipulations are handled apart from
- * the initial copy. */
 struct audit_entry *audit_dupe_rule(struct audit_krule *old)
 {
 	u32 fcount = old->field_count;
@@ -778,18 +744,9 @@
 	new->inode_f = old->inode_f;
 	new->field_count = old->field_count;
 
-	/*
-	 * note that we are OK with not refcounting here; audit_match_tree()
-	 * never dereferences tree and we can't get false positives there
-	 * since we'd have to have rule gone from the list *and* removed
-	 * before the chunks found by lookup had been allocated, i.e. before
-	 * the beginning of list scan.
-	 */
 	new->tree = old->tree;
 	memcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);
 
-	/* deep copy this information, updating the lsm_rule fields, because
-	 * the originals will all be freed when the old rule is freed. */
 	for (i = 0; i < fcount; i++) {
 		switch (new->fields[i].type) {
 		case AUDIT_SUBJ_USER:
@@ -826,8 +783,6 @@
 	return entry;
 }
 
-/* Find an existing audit rule.
- * Caller must hold audit_filter_mutex to prevent stale rule data. */
 static struct audit_entry *audit_find_rule(struct audit_entry *entry,
 					   struct list_head **p)
 {
@@ -839,7 +794,7 @@
 		h = audit_hash_ino(entry->rule.inode_f->val);
 		*p = list = &audit_inode_hash[h];
 	} else if (entry->rule.watch) {
-		/* we don't know the inode number, so must walk entire hash */
+		
 		for (h = 0; h < AUDIT_INODE_BUCKETS; h++) {
 			list = &audit_inode_hash[h];
 			list_for_each_entry(e, list, list)
@@ -866,7 +821,6 @@
 static u64 prio_low = ~0ULL/2;
 static u64 prio_high = ~0ULL/2 - 1;
 
-/* Add rule to given filterlist if not a duplicate. */
 static inline int audit_add_rule(struct audit_entry *entry)
 {
 	struct audit_entry *e;
@@ -877,7 +831,7 @@
 #ifdef CONFIG_AUDITSYSCALL
 	int dont_count = 0;
 
-	/* If either of these, don't count towards total */
+	
 	if (entry->rule.listnr == AUDIT_FILTER_USER ||
 		entry->rule.listnr == AUDIT_FILTER_TYPE)
 		dont_count = 1;
@@ -888,14 +842,14 @@
 	if (e) {
 		mutex_unlock(&audit_filter_mutex);
 		err = -EEXIST;
-		/* normally audit_add_tree_rule() will free it on failure */
+		
 		if (tree)
 			audit_put_tree(tree);
 		goto error;
 	}
 
 	if (watch) {
-		/* audit_filter_mutex is dropped and re-taken during this call */
+		
 		err = audit_add_watch(&entry->rule, &list);
 		if (err) {
 			mutex_unlock(&audit_filter_mutex);
@@ -941,11 +895,10 @@
 
 error:
 	if (watch)
-		audit_put_watch(watch); /* tmp watch, matches initial get */
+		audit_put_watch(watch); 
 	return err;
 }
 
-/* Remove an existing rule from filterlist. */
 static inline int audit_del_rule(struct audit_entry *entry)
 {
 	struct audit_entry  *e;
@@ -956,7 +909,7 @@
 #ifdef CONFIG_AUDITSYSCALL
 	int dont_count = 0;
 
-	/* If either of these, don't count towards total */
+	
 	if (entry->rule.listnr == AUDIT_FILTER_USER ||
 		entry->rule.listnr == AUDIT_FILTER_TYPE)
 		dont_count = 1;
@@ -991,23 +944,19 @@
 
 out:
 	if (watch)
-		audit_put_watch(watch); /* match initial get */
+		audit_put_watch(watch); 
 	if (tree)
-		audit_put_tree(tree);	/* that's the temporary one */
+		audit_put_tree(tree);	
 
 	return ret;
 }
 
-/* List rules using struct audit_rule.  Exists for backward
- * compatibility with userspace. */
 static void audit_list(int pid, int seq, struct sk_buff_head *q)
 {
 	struct sk_buff *skb;
 	struct audit_krule *r;
 	int i;
 
-	/* This is a blocking read, so use audit_filter_mutex instead of rcu
-	 * iterator to sync with list writers. */
 	for (i=0; i<AUDIT_NR_FILTERS; i++) {
 		list_for_each_entry(r, &audit_rules_list[i], list) {
 			struct audit_rule *rule;
@@ -1027,15 +976,12 @@
 		skb_queue_tail(q, skb);
 }
 
-/* List rules using struct audit_rule_data. */
 static void audit_list_rules(int pid, int seq, struct sk_buff_head *q)
 {
 	struct sk_buff *skb;
 	struct audit_krule *r;
 	int i;
 
-	/* This is a blocking read, so use audit_filter_mutex instead of rcu
-	 * iterator to sync with list writers. */
 	for (i=0; i<AUDIT_NR_FILTERS; i++) {
 		list_for_each_entry(r, &audit_rules_list[i], list) {
 			struct audit_rule_data *data;
@@ -1055,7 +1001,6 @@
 		skb_queue_tail(q, skb);
 }
 
-/* Log rule additions and removals */
 static void audit_log_rule_change(uid_t loginuid, u32 sessionid, u32 sid,
 				  char *action, struct audit_krule *rule,
 				  int res)
@@ -1086,18 +1031,6 @@
 	audit_log_end(ab);
 }
 
-/**
- * audit_receive_filter - apply all rules to the specified message type
- * @type: audit message type
- * @pid: target pid for netlink audit messages
- * @uid: target uid for netlink audit messages
- * @seq: netlink audit message sequence (serial) number
- * @data: payload data
- * @datasz: size of payload data
- * @loginuid: loginuid of sender
- * @sessionid: sessionid for netlink audit message
- * @sid: SE Linux Security ID of sender
- */
 int audit_receive_filter(int type, int pid, int uid, int seq, void *data,
 			 size_t datasz, uid_t loginuid, u32 sessionid, u32 sid)
 {
@@ -1109,11 +1042,6 @@
 	switch (type) {
 	case AUDIT_LIST:
 	case AUDIT_LIST_RULES:
-		/* We can't just spew out the rules here because we might fill
-		 * the available socket buffer space and deadlock waiting for
-		 * auditctl to read from it... which isn't ever going to
-		 * happen if we're actually running in the context of auditctl
-		 * trying to _send_ the stuff */
 
 		dest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);
 		if (!dest)
@@ -1198,8 +1126,6 @@
 	}
 }
 
-/* Compare given dentry name with last component in given path,
- * return of 0 indicates a match. */
 int audit_compare_dname_path(const char *dname, const char *path,
 			     int *dirlen)
 {
@@ -1214,12 +1140,12 @@
 	if (plen < dlen)
 		return 1;
 
-	/* disregard trailing slashes */
+	
 	p = path + plen - 1;
 	while ((*p == '/') && (p > path))
 		p--;
 
-	/* find last path component */
+	
 	p = p - dlen + 1;
 	if (p < path)
 		return 1;
@@ -1230,7 +1156,7 @@
 			p++;
 	}
 
-	/* return length of path's directory component */
+	
 	if (dirlen)
 		*dirlen = p - path;
 	return strncmp(p, dname, dlen);
@@ -1303,7 +1229,7 @@
 	}
 	rcu_read_unlock();
 
-	return ret; /* Audit by default */
+	return ret; 
 }
 
 int audit_filter_type(int type)
@@ -1345,8 +1271,6 @@
 
 	nentry = audit_dupe_rule(r);
 	if (IS_ERR(nentry)) {
-		/* save the first error encountered for the
-		 * return value */
 		err = PTR_ERR(nentry);
 		audit_panic("error updating LSM filters");
 		if (r->watch)
@@ -1364,17 +1288,12 @@
 	return err;
 }
 
-/* This function will re-initialize the lsm_rule field of all applicable rules.
- * It will traverse the filter lists serarching for rules that contain LSM
- * specific filter fields.  When such a rule is found, it is copied, the
- * LSM field is re-initialized, and the old rule is replaced with the
- * updated rule. */
 int audit_update_lsm_rules(void)
 {
 	struct audit_krule *r, *n;
 	int i, err = 0;
 
-	/* audit_filter_mutex synchronizes the writers */
+	
 	mutex_lock(&audit_filter_mutex);
 
 	for (i = 0; i < AUDIT_NR_FILTERS; i++) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/auditsc.c monarudo-jb-3.4.10-e22f38b/kernel/auditsc.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/auditsc.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/auditsc.c	2013-08-01 23:37:51.000000000 -0600
@@ -70,44 +70,31 @@
 
 #include "audit.h"
 
-/* flags stating the success for a syscall */
 #define AUDITSC_INVALID 0
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 
-/* AUDIT_NAMES is the number of slots we reserve in the audit_context
- * for saving names from getname().  If we get more names we will allocate
- * a name dynamically and also add those to the list anchored by names_list. */
 #define AUDIT_NAMES	5
 
-/* Indicates that audit should log the full pathname. */
 #define AUDIT_NAME_FULL -1
 
-/* no execve audit message should be longer than this (userspace limits) */
 #define MAX_EXECVE_AUDIT_LEN 7500
 
-/* number of audit rules */
 int audit_n_rules;
 
-/* determines whether we collect data for signals sent */
 int audit_signals;
 
 struct audit_cap_data {
 	kernel_cap_t		permitted;
 	kernel_cap_t		inheritable;
 	union {
-		unsigned int	fE;		/* effective bit of a file capability */
-		kernel_cap_t	effective;	/* effective set of a process */
+		unsigned int	fE;		
+		kernel_cap_t	effective;	
 	};
 };
 
-/* When fs/namei.c:getname() is called, we store the pointer in name and
- * we don't let putname() free it (instead we free all of the saved
- * pointers at syscall exit time).
- *
- * Further, in fs/namei.c:path_lookup() we store the inode and device. */
 struct audit_names {
-	struct list_head list;		/* audit_context->names_list */
+	struct list_head list;		
 	const char	*name;
 	unsigned long	ino;
 	dev_t		dev;
@@ -118,13 +105,8 @@
 	u32		osid;
 	struct audit_cap_data fcap;
 	unsigned int	fcap_ver;
-	int		name_len;	/* number of name's characters to log */
-	bool		name_put;	/* call __putname() for this name */
-	/*
-	 * This was an allocated audit_names and not from the array of
-	 * names allocated in the task audit context.  Thus this name
-	 * should be freed on syscall exit
-	 */
+	int		name_len;	
+	bool		name_put;	
 	bool		should_free;
 };
 
@@ -135,7 +117,6 @@
 
 #define AUDIT_AUX_IPCPERM	0
 
-/* Number of target pids per aux struct. */
 #define AUDIT_AUX_PIDS	16
 
 struct audit_aux_data_execve {
@@ -175,37 +156,28 @@
 	struct audit_chunk *c[31];
 };
 
-/* The per-task audit context. */
 struct audit_context {
-	int		    dummy;	/* must be the first element */
-	int		    in_syscall;	/* 1 if task is in a syscall */
+	int		    dummy;	
+	int		    in_syscall;	
 	enum audit_state    state, current_state;
-	unsigned int	    serial;     /* serial number for record */
-	int		    major;      /* syscall number */
-	struct timespec	    ctime;      /* time of syscall entry */
-	unsigned long	    argv[4];    /* syscall arguments */
-	long		    return_code;/* syscall return code */
+	unsigned int	    serial;     
+	int		    major;      
+	struct timespec	    ctime;      
+	unsigned long	    argv[4];    
+	long		    return_code;
 	u64		    prio;
-	int		    return_valid; /* return code is valid */
-	/*
-	 * The names_list is the list of all audit_names collected during this
-	 * syscall.  The first AUDIT_NAMES entries in the names_list will
-	 * actually be from the preallocated_names array for performance
-	 * reasons.  Except during allocation they should never be referenced
-	 * through the preallocated_names array and should only be found/used
-	 * by running the names_list.
-	 */
+	int		    return_valid; 
 	struct audit_names  preallocated_names[AUDIT_NAMES];
-	int		    name_count; /* total records in names_list */
-	struct list_head    names_list;	/* anchor for struct audit_names->list */
-	char *		    filterkey;	/* key for rule that triggered record */
+	int		    name_count; 
+	struct list_head    names_list;	
+	char *		    filterkey;	
 	struct path	    pwd;
-	struct audit_context *previous; /* For nested syscalls */
+	struct audit_context *previous; 
 	struct audit_aux_data *aux;
 	struct audit_aux_data *aux_pids;
 	struct sockaddr_storage *sockaddr;
 	size_t sockaddr_len;
-				/* Save things to print about task_struct */
+				
 	pid_t		    pid, ppid;
 	uid_t		    uid, euid, suid, fsuid;
 	gid_t		    gid, egid, sgid, fsgid;
@@ -292,7 +264,7 @@
 	n = ctx->major;
 
 	switch (audit_classify_syscall(ctx->arch, n)) {
-	case 0:	/* native */
+	case 0:	
 		if ((mask & AUDIT_PERM_WRITE) &&
 		     audit_match_class(AUDIT_CLASS_WRITE, n))
 			return 1;
@@ -303,7 +275,7 @@
 		     audit_match_class(AUDIT_CLASS_CHATTR, n))
 			return 1;
 		return 0;
-	case 1: /* 32bit on biarch */
+	case 1: 
 		if ((mask & AUDIT_PERM_WRITE) &&
 		     audit_match_class(AUDIT_CLASS_WRITE_32, n))
 			return 1;
@@ -314,13 +286,13 @@
 		     audit_match_class(AUDIT_CLASS_CHATTR_32, n))
 			return 1;
 		return 0;
-	case 2: /* open */
+	case 2: 
 		return mask & ACC_MODE(ctx->argv[1]);
-	case 3: /* openat */
+	case 3: 
 		return mask & ACC_MODE(ctx->argv[2]);
-	case 4: /* socketcall */
+	case 4: 
 		return ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);
-	case 5: /* execve */
+	case 5: 
 		return mask & AUDIT_PERM_EXEC;
 	default:
 		return 0;
@@ -344,15 +316,6 @@
 	return 0;
 }
 
-/*
- * We keep a linked list of fixed-sized (31 pointer) arrays of audit_chunk *;
- * ->first_trees points to its beginning, ->trees - to the current end of data.
- * ->tree_count is the number of free entries in array pointed to by ->trees.
- * Original condition is (NULL, NULL, 0); as soon as it grows we never revert to NULL,
- * "empty" becomes (p, p, 31) afterwards.  We don't shrink the list (and seriously,
- * it's going to remain 1-element for almost any setup) until we free context itself.
- * References in it _are_ dropped - at the same time we free/drop aux stuff.
- */
 
 #ifdef CONFIG_AUDIT_TREE
 static void audit_set_auditable(struct audit_context *ctx)
@@ -408,10 +371,10 @@
 	struct audit_tree_refs *q;
 	int n;
 	if (!p) {
-		/* we started with empty chain */
+		
 		p = ctx->first_trees;
 		count = 31;
-		/* if the very first allocation has failed, nothing to do */
+		
 		if (!p)
 			return;
 	}
@@ -447,13 +410,13 @@
 	int n;
 	if (!tree)
 		return 0;
-	/* full ones */
+	
 	for (p = ctx->first_trees; p != ctx->trees; p = p->next) {
 		for (n = 0; n < 31; n++)
 			if (audit_tree_match(p->c[n], tree))
 				return 1;
 	}
-	/* partial */
+	
 	if (p) {
 		for (n = ctx->tree_count; n < 31; n++)
 			if (audit_tree_match(p->c[n], tree))
@@ -508,7 +471,7 @@
 			       struct audit_names *name)
 {
 	switch (f->val) {
-	/* process to file object comparisons */
+	
 	case AUDIT_COMPARE_UID_TO_OBJ_UID:
 		return audit_compare_id(cred->uid,
 					name, offsetof(struct audit_names, uid),
@@ -545,7 +508,7 @@
 		return audit_compare_id(cred->fsgid,
 					name, offsetof(struct audit_names, gid),
 					f, ctx);
-	/* uid comparisons */
+	
 	case AUDIT_COMPARE_UID_TO_AUID:
 		return audit_comparator(cred->uid, f->op, tsk->loginuid);
 	case AUDIT_COMPARE_UID_TO_EUID:
@@ -554,34 +517,34 @@
 		return audit_comparator(cred->uid, f->op, cred->suid);
 	case AUDIT_COMPARE_UID_TO_FSUID:
 		return audit_comparator(cred->uid, f->op, cred->fsuid);
-	/* auid comparisons */
+	
 	case AUDIT_COMPARE_AUID_TO_EUID:
 		return audit_comparator(tsk->loginuid, f->op, cred->euid);
 	case AUDIT_COMPARE_AUID_TO_SUID:
 		return audit_comparator(tsk->loginuid, f->op, cred->suid);
 	case AUDIT_COMPARE_AUID_TO_FSUID:
 		return audit_comparator(tsk->loginuid, f->op, cred->fsuid);
-	/* euid comparisons */
+	
 	case AUDIT_COMPARE_EUID_TO_SUID:
 		return audit_comparator(cred->euid, f->op, cred->suid);
 	case AUDIT_COMPARE_EUID_TO_FSUID:
 		return audit_comparator(cred->euid, f->op, cred->fsuid);
-	/* suid comparisons */
+	
 	case AUDIT_COMPARE_SUID_TO_FSUID:
 		return audit_comparator(cred->suid, f->op, cred->fsuid);
-	/* gid comparisons */
+	
 	case AUDIT_COMPARE_GID_TO_EGID:
 		return audit_comparator(cred->gid, f->op, cred->egid);
 	case AUDIT_COMPARE_GID_TO_SGID:
 		return audit_comparator(cred->gid, f->op, cred->sgid);
 	case AUDIT_COMPARE_GID_TO_FSGID:
 		return audit_comparator(cred->gid, f->op, cred->fsgid);
-	/* egid comparisons */
+	
 	case AUDIT_COMPARE_EGID_TO_SGID:
 		return audit_comparator(cred->egid, f->op, cred->sgid);
 	case AUDIT_COMPARE_EGID_TO_FSGID:
 		return audit_comparator(cred->egid, f->op, cred->fsgid);
-	/* sgid comparison */
+	
 	case AUDIT_COMPARE_SGID_TO_FSGID:
 		return audit_comparator(cred->sgid, f->op, cred->fsgid);
 	default:
@@ -591,14 +554,6 @@
 	return 0;
 }
 
-/* Determine if any context name data matches a rule's watch data */
-/* Compare a task_struct with an audit_rule.  Return 1 on match, 0
- * otherwise.
- *
- * If task_creation is true, this is an explicit indication that we are
- * filtering a task rule at task creation time.  This and tsk == current are
- * the only situations where tsk->cred may be accessed without an rcu read lock.
- */
 static int audit_filter_rules(struct task_struct *tsk,
 			      struct audit_krule *rule,
 			      struct audit_context *ctx,
@@ -756,11 +711,6 @@
 		case AUDIT_SUBJ_TYPE:
 		case AUDIT_SUBJ_SEN:
 		case AUDIT_SUBJ_CLR:
-			/* NOTE: this may return negative values indicating
-			   a temporary error.  We simply treat this as a
-			   match for now to avoid losing information that
-			   may be wanted.   An error message will also be
-			   logged upon error */
 			if (f->lsm_rule) {
 				if (need_sid) {
 					security_task_getsecid(tsk, &sid);
@@ -777,10 +727,8 @@
 		case AUDIT_OBJ_TYPE:
 		case AUDIT_OBJ_LEV_LOW:
 		case AUDIT_OBJ_LEV_HIGH:
-			/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR
-			   also applies here */
 			if (f->lsm_rule) {
-				/* Find files that match */
+				
 				if (name) {
 					result = security_audit_rule_match(
 					           name->osid, f->type, f->op,
@@ -795,7 +743,7 @@
 						}
 					}
 				}
-				/* Find ipc objects that match */
+				
 				if (!ctx || ctx->type != AUDIT_IPC)
 					break;
 				if (security_audit_rule_match(ctx->ipc.osid,
@@ -812,7 +760,7 @@
 				result = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);
 			break;
 		case AUDIT_FILTERKEY:
-			/* ignore this field for filtering */
+			
 			result = 1;
 			break;
 		case AUDIT_PERM:
@@ -845,10 +793,6 @@
 	return 1;
 }
 
-/* At process creation time, we can determine if system-call auditing is
- * completely disabled for this task.  Since we only have the task
- * structure at this point, we can only check uid and gid.
- */
 static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)
 {
 	struct audit_entry *e;
@@ -868,11 +812,6 @@
 	return AUDIT_BUILD_CONTEXT;
 }
 
-/* At syscall entry and exit time, this filter is called if the
- * audit_state is not low enough that auditing cannot take place, but is
- * also not high enough that we already know we have to write an audit
- * record (i.e., the state is AUDIT_SETUP_CONTEXT or AUDIT_BUILD_CONTEXT).
- */
 static enum audit_state audit_filter_syscall(struct task_struct *tsk,
 					     struct audit_context *ctx,
 					     struct list_head *list)
@@ -902,10 +841,6 @@
 	return AUDIT_BUILD_CONTEXT;
 }
 
-/*
- * Given an audit_name check the inode hash table to see if they match.
- * Called holding the rcu read lock to protect the use of audit_inode_hash
- */
 static int audit_filter_inode_name(struct task_struct *tsk,
 				   struct audit_names *n,
 				   struct audit_context *ctx) {
@@ -932,11 +867,6 @@
 	return 0;
 }
 
-/* At syscall exit time, this filter is called if any audit_names have been
- * collected during syscall processing.  We only check rules in sublists at hash
- * buckets applicable to the inode numbers in audit_names.
- * Regarding audit_state, same rules apply as for audit_filter_syscall().
- */
 void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)
 {
 	struct audit_names *n;
@@ -963,17 +893,6 @@
 		return NULL;
 	context->return_valid = return_valid;
 
-	/*
-	 * we need to fix up the return code in the audit logs if the actual
-	 * return codes are later going to be fixed up by the arch specific
-	 * signal handlers
-	 *
-	 * This is actually a test for:
-	 * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||
-	 * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)
-	 *
-	 * but is faster than a bunch of ||
-	 */
 	if (unlikely(return_code <= -ERESTARTSYS) &&
 	    (return_code >= -ERESTART_RESTARTBLOCK) &&
 	    (return_code != -ENOIOCTLCMD))
@@ -1063,15 +982,6 @@
 	return context;
 }
 
-/**
- * audit_alloc - allocate an audit context block for a task
- * @tsk: task
- *
- * Filter on the task information and allocate a per-task audit context
- * if necessary.  Doing so turns on system call auditing for the
- * specified task.  This is called from copy_process, so no lock is
- * needed.
- */
 int audit_alloc(struct task_struct *tsk)
 {
 	struct audit_context *context;
@@ -1079,7 +989,7 @@
 	char *key = NULL;
 
 	if (likely(!audit_ever_enabled))
-		return 0; /* Return if not auditing. */
+		return 0; 
 
 	state = audit_filter_task(tsk, &key);
 	if (state == AUDIT_DISABLED)
@@ -1159,7 +1069,7 @@
 	struct mm_struct *mm = tsk->mm;
 	struct vm_area_struct *vma;
 
-	/* tsk == current */
+	
 
 	get_task_comm(name, tsk);
 	audit_log_format(ab, " comm=");
@@ -1211,17 +1121,6 @@
 	return rc;
 }
 
-/*
- * to_send and len_sent accounting are very loose estimates.  We aren't
- * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being
- * within about 500 bytes (next page boundary)
- *
- * why snprintf?  an int is up to 12 digits long.  if we just assumed when
- * logging that a[%d]= was going to be 16 characters long we would be wasting
- * space in every audit message.  In one 7500 byte message we can log up to
- * about 1000 min size arguments.  That comes down to about 50% waste of space
- * if we didn't do the snprintf to find out how long arg_num_len was.
- */
 static int audit_log_single_execve_arg(struct audit_context *context,
 					struct audit_buffer **ab,
 					int arg_num,
@@ -1231,40 +1130,29 @@
 {
 	char arg_num_len_buf[12];
 	const char __user *tmp_p = p;
-	/* how many digits are in arg_num? 5 is the length of ' a=""' */
+	
 	size_t arg_num_len = snprintf(arg_num_len_buf, 12, "%d", arg_num) + 5;
 	size_t len, len_left, to_send;
 	size_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;
 	unsigned int i, has_cntl = 0, too_long = 0;
 	int ret;
 
-	/* strnlen_user includes the null we don't want to send */
+	
 	len_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;
 
-	/*
-	 * We just created this mm, if we can't find the strings
-	 * we just copied into it something is _very_ wrong. Similar
-	 * for strings that are too long, we should not have created
-	 * any.
-	 */
 	if (unlikely((len == -1) || len > MAX_ARG_STRLEN - 1)) {
 		WARN_ON(1);
 		send_sig(SIGKILL, current, 0);
 		return -1;
 	}
 
-	/* walk the whole argument looking for non-ascii chars */
+	
 	do {
 		if (len_left > MAX_EXECVE_AUDIT_LEN)
 			to_send = MAX_EXECVE_AUDIT_LEN;
 		else
 			to_send = len_left;
 		ret = copy_from_user(buf, tmp_p, to_send);
-		/*
-		 * There is no reason for this copy to be short. We just
-		 * copied them here, and the mm hasn't been exposed to user-
-		 * space yet.
-		 */
 		if (ret) {
 			WARN_ON(1);
 			send_sig(SIGKILL, current, 0);
@@ -1273,10 +1161,6 @@
 		buf[to_send] = '\0';
 		has_cntl = audit_string_contains_control(buf, to_send);
 		if (has_cntl) {
-			/*
-			 * hex messages get logged as 2 bytes, so we can only
-			 * send half as much in each message
-			 */
 			max_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;
 			break;
 		}
@@ -1289,7 +1173,7 @@
 	if (len > max_execve_audit_len)
 		too_long = 1;
 
-	/* rewalk the argument actually logging the message */
+	
 	for (i = 0; len_left > 0; i++) {
 		int room_left;
 
@@ -1298,7 +1182,7 @@
 		else
 			to_send = len_left;
 
-		/* do we have space left to send this argument in this ab? */
+		
 		room_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;
 		if (has_cntl)
 			room_left -= (to_send * 2);
@@ -1312,19 +1196,10 @@
 				return 0;
 		}
 
-		/*
-		 * first record needs to say how long the original string was
-		 * so we can be sure nothing was lost.
-		 */
 		if ((i == 0) && (too_long))
 			audit_log_format(*ab, " a%d_len=%zu", arg_num,
 					 has_cntl ? 2*len : len);
 
-		/*
-		 * normally arguments are small enough to fit and we already
-		 * filled buf above when we checked for control characters
-		 * so don't bother with another copy_from_user
-		 */
 		if (len >= max_execve_audit_len)
 			ret = copy_from_user(buf, p, to_send);
 		else
@@ -1336,7 +1211,7 @@
 		}
 		buf[to_send] = '\0';
 
-		/* actually log it */
+		
 		audit_log_format(*ab, " a%d", arg_num);
 		if (too_long)
 			audit_log_format(*ab, "[%d]", i);
@@ -1354,7 +1229,7 @@
 		else
 			*len_sent += to_send;
 	}
-	/* include the null we didn't log */
+	
 	return len + 1;
 }
 
@@ -1368,18 +1243,12 @@
 	char *buf;
 
 	if (axi->mm != current->mm)
-		return; /* execve failed, no additional info */
+		return; 
 
 	p = (const char __user *)axi->mm->arg_start;
 
 	audit_log_format(*ab, "argc=%d", axi->argc);
 
-	/*
-	 * we need some kernel buffer to hold the userspace args.  Just
-	 * allocate one big one rather than allocating one of the right size
-	 * for every single argument inside audit_log_single_execve_arg()
-	 * should be <8k allocation so should be pretty safe.
-	 */
 	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
 	if (!buf) {
 		audit_panic("out of memory for argv string\n");
@@ -1526,24 +1395,22 @@
 	struct audit_buffer *ab;
 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);
 	if (!ab)
-		return; /* audit_panic has been called */
+		return; 
 
 	audit_log_format(ab, "item=%d", record_num);
 
 	if (n->name) {
 		switch (n->name_len) {
 		case AUDIT_NAME_FULL:
-			/* log the full path */
+			
 			audit_log_format(ab, " name=");
 			audit_log_untrustedstring(ab, n->name);
 			break;
 		case 0:
-			/* name was specified as a relative path and the
-			 * directory component is the cwd */
 			audit_log_d_path(ab, " name=", &context->pwd);
 			break;
 		default:
-			/* log the name's directory component */
+			
 			audit_log_format(ab, " name=");
 			audit_log_n_untrustedstring(ab, n->name,
 						    n->name_len);
@@ -1591,7 +1458,7 @@
 	const char *tty;
 	struct audit_names *n;
 
-	/* tsk == current */
+	
 	context->pid = tsk->pid;
 	if (!context->ppid)
 		context->ppid = sys_getppid();
@@ -1608,7 +1475,7 @@
 
 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);
 	if (!ab)
-		return;		/* audit_panic has been called */
+		return;		
 	audit_log_format(ab, "arch=%x syscall=%d",
 			 context->arch, context->major);
 	if (context->personality != PER_LINUX)
@@ -1653,7 +1520,7 @@
 
 		ab = audit_log_start(context, GFP_KERNEL, aux->type);
 		if (!ab)
-			continue; /* audit_panic has been called */
+			continue; 
 
 		switch (aux->type) {
 
@@ -1734,7 +1601,7 @@
 	list_for_each_entry(n, &context->names_list, list)
 		audit_log_name(context, n, i++, &call_panic);
 
-	/* Send end of event record to help user space know we are finished */
+	
 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);
 	if (ab)
 		audit_log_end(ab);
@@ -1742,12 +1609,6 @@
 		audit_panic("error converting sid to string");
 }
 
-/**
- * audit_free - free a per-task audit context
- * @tsk: task whose audit context block to free
- *
- * Called from copy_process and do_exit
- */
 void __audit_free(struct task_struct *tsk)
 {
 	struct audit_context *context;
@@ -1756,11 +1617,7 @@
 	if (!context)
 		return;
 
-	/* Check for system calls that do not go through the exit
-	 * function (e.g., exit_group), then free context block.
-	 * We use GFP_ATOMIC here because we might be doing this
-	 * in the context of the idle thread */
-	/* that can happen only if we are called from do_exit() */
+	
 	if (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)
 		audit_log_exit(context, tsk);
 	if (!list_empty(&context->killed_trees))
@@ -1797,20 +1654,6 @@
 	if (!context)
 		return;
 
-	/*
-	 * This happens only on certain architectures that make system
-	 * calls in kernel_thread via the entry.S interface, instead of
-	 * with direct calls.  (If you are porting to a new
-	 * architecture, hitting this condition can indicate that you
-	 * got the _exit/_leave calls backward in entry.S.)
-	 *
-	 * i386     no
-	 * x86_64   no
-	 * ppc64    yes (see arch/powerpc/platforms/iseries/misc.S)
-	 *
-	 * This also happens with vm86 emulation in a non-nested manner
-	 * (entries without exits), so this case must be caught.
-	 */
 	if (context->in_syscall) {
 		struct audit_context *newctx;
 
@@ -1826,10 +1669,6 @@
 			context		   = newctx;
 			tsk->audit_context = newctx;
 		} else	{
-			/* If we can't alloc a new context, the best we
-			 * can do is to leak memory (any pending putname
-			 * will be lost).  The only other alternative is
-			 * to abandon auditing. */
 			audit_zero_context(context, context->state);
 		}
 	}
@@ -1861,17 +1700,6 @@
 	context->ppid       = 0;
 }
 
-/**
- * audit_syscall_exit - deallocate audit context after a system call
- * @success: success value of the syscall
- * @return_code: return value of the syscall
- *
- * Tear down after system call.  If the audit context has been marked as
- * auditable (either because of the AUDIT_RECORD_CONTEXT state from
- * filtering, or because some other part of the kernel wrote an audit
- * message), then write out the syscall information.  In call cases,
- * free the names stored from getname().
- */
 void __audit_syscall_exit(int success, long return_code)
 {
 	struct task_struct *tsk = current;
@@ -1984,20 +1812,20 @@
 			break;
 		d = parent;
 	}
-	if (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */
+	if (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  
 		rcu_read_unlock();
 		if (!drop) {
-			/* just a race with rename */
+			
 			unroll_tree_refs(context, p, count);
 			goto retry;
 		}
 		audit_put_chunk(drop);
 		if (grow_tree_refs(context)) {
-			/* OK, got more space */
+			
 			unroll_tree_refs(context, p, count);
 			goto retry;
 		}
-		/* too bad */
+		
 		printk(KERN_WARNING
 			"out of memory, audit has lost a tree reference\n");
 		unroll_tree_refs(context, p, count);
@@ -2032,13 +1860,6 @@
 	return aname;
 }
 
-/**
- * audit_getname - add a name to the list
- * @name: name to add
- *
- * Add a name to the list of audit names for this context.
- * Called from fs/namei.c:getname().
- */
 void __audit_getname(const char *name)
 {
 	struct audit_context *context = current->audit_context;
@@ -2065,13 +1886,6 @@
 		get_fs_pwd(current->fs, &context->pwd);
 }
 
-/* audit_putname - intercept a putname request
- * @name: name to intercept and delay for putname
- *
- * If we have stored the name from getname in the audit context,
- * then we delay the putname until syscall exit.
- * Called from include/linux/fs.h:putname().
- */
 void audit_putname(const char *name)
 {
 	struct audit_context *context = current->audit_context;
@@ -2130,7 +1944,6 @@
 }
 
 
-/* Copy inode data into an audit_names. */
 static void audit_copy_inode(struct audit_names *name, const struct dentry *dentry,
 			     const struct inode *inode)
 {
@@ -2144,13 +1957,6 @@
 	audit_copy_fcaps(name, dentry);
 }
 
-/**
- * audit_inode - store the inode and device from a lookup
- * @name: name being audited
- * @dentry: dentry being audited
- *
- * Called from fs/namei.c:path_lookup().
- */
 void __audit_inode(const char *name, const struct dentry *dentry)
 {
 	struct audit_context *context = current->audit_context;
@@ -2165,7 +1971,7 @@
 			goto out;
 	}
 
-	/* unable to find the name from a previous getname() */
+	
 	n = audit_alloc_name(context);
 	if (!n)
 		return;
@@ -2174,19 +1980,6 @@
 	audit_copy_inode(n, dentry, inode);
 }
 
-/**
- * audit_inode_child - collect inode info for created/removed objects
- * @dentry: dentry being audited
- * @parent: inode of dentry parent
- *
- * For syscalls that create or remove filesystem objects, audit_inode
- * can only collect information for the filesystem object's parent.
- * This call updates the audit context with the child's information.
- * Syscalls that create a new filesystem object must be hooked after
- * the object is created.  Syscalls that remove a filesystem object
- * must be hooked prior, in order to capture the target inode during
- * unsuccessful attempts.
- */
 void __audit_inode_child(const struct dentry *dentry,
 			 const struct inode *parent)
 {
@@ -2203,25 +1996,25 @@
 	if (inode)
 		handle_one(inode);
 
-	/* parent is more likely, look for it first */
+	
 	list_for_each_entry(n, &context->names_list, list) {
 		if (!n->name)
 			continue;
 
 		if (n->ino == parent->i_ino &&
 		    !audit_compare_dname_path(dname, n->name, &dirlen)) {
-			n->name_len = dirlen; /* update parent data in place */
+			n->name_len = dirlen; 
 			found_parent = n->name;
 			goto add_names;
 		}
 	}
 
-	/* no matching parent, look for matching child */
+	
 	list_for_each_entry(n, &context->names_list, list) {
 		if (!n->name)
 			continue;
 
-		/* strcmp() is the more likely scenario */
+		
 		if (!strcmp(dname, n->name) ||
 		     !audit_compare_dname_path(dname, n->name, &dirlen)) {
 			if (inode)
@@ -2246,13 +2039,10 @@
 		if (!n)
 			return;
 
-		/* Re-use the name belonging to the slot for a matching parent
-		 * directory. All names for this context are relinquished in
-		 * audit_free_names() */
 		if (found_parent) {
 			n->name = found_parent;
 			n->name_len = AUDIT_NAME_FULL;
-			/* don't call __putname() */
+			
 			n->name_put = false;
 		}
 
@@ -2262,14 +2052,6 @@
 }
 EXPORT_SYMBOL_GPL(__audit_inode_child);
 
-/**
- * auditsc_get_stamp - get local copies of audit_context values
- * @ctx: audit_context for the task
- * @t: timespec to store time recorded in the audit_context
- * @serial: serial value that is recorded in the audit_context
- *
- * Also sets the context as auditable.
- */
 int auditsc_get_stamp(struct audit_context *ctx,
 		       struct timespec *t, unsigned int *serial)
 {
@@ -2287,17 +2069,8 @@
 	return 1;
 }
 
-/* global counter which is incremented every time something logs in */
 static atomic_t session_id = ATOMIC_INIT(0);
 
-/**
- * audit_set_loginuid - set current task's audit_context loginuid
- * @loginuid: loginuid value
- *
- * Returns 0.
- *
- * Called (set) from fs/proc/base.c::proc_loginuid_write().
- */
 int audit_set_loginuid(uid_t loginuid)
 {
 	struct task_struct *task = current;
@@ -2307,10 +2080,10 @@
 #ifdef CONFIG_AUDIT_LOGINUID_IMMUTABLE
 	if (task->loginuid != -1)
 		return -EPERM;
-#else /* CONFIG_AUDIT_LOGINUID_IMMUTABLE */
+#else 
 	if (!capable(CAP_AUDIT_CONTROL))
 		return -EPERM;
-#endif  /* CONFIG_AUDIT_LOGINUID_IMMUTABLE */
+#endif  
 
 	sessionid = atomic_inc_return(&session_id);
 	if (context && context->in_syscall) {
@@ -2332,13 +2105,6 @@
 	return 0;
 }
 
-/**
- * __audit_mq_open - record audit data for a POSIX MQ open
- * @oflag: open flag
- * @mode: mode bits
- * @attr: queue attributes
- *
- */
 void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
 {
 	struct audit_context *context = current->audit_context;
@@ -2354,14 +2120,6 @@
 	context->type = AUDIT_MQ_OPEN;
 }
 
-/**
- * __audit_mq_sendrecv - record audit data for a POSIX MQ timed send/receive
- * @mqdes: MQ descriptor
- * @msg_len: Message length
- * @msg_prio: Message priority
- * @abs_timeout: Message timeout in absolute time
- *
- */
 void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,
 			const struct timespec *abs_timeout)
 {
@@ -2380,12 +2138,6 @@
 	context->type = AUDIT_MQ_SENDRECV;
 }
 
-/**
- * __audit_mq_notify - record audit data for a POSIX MQ notify
- * @mqdes: MQ descriptor
- * @notification: Notification event
- *
- */
 
 void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 {
@@ -2400,12 +2152,6 @@
 	context->type = AUDIT_MQ_NOTIFY;
 }
 
-/**
- * __audit_mq_getsetattr - record audit data for a POSIX MQ get/set attribute
- * @mqdes: MQ descriptor
- * @mqstat: MQ flags
- *
- */
 void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 {
 	struct audit_context *context = current->audit_context;
@@ -2414,11 +2160,6 @@
 	context->type = AUDIT_MQ_GETSETATTR;
 }
 
-/**
- * audit_ipc_obj - record audit data for ipc object
- * @ipcp: ipc permissions
- *
- */
 void __audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
 	struct audit_context *context = current->audit_context;
@@ -2430,15 +2171,6 @@
 	context->type = AUDIT_IPC;
 }
 
-/**
- * audit_ipc_set_perm - record audit data for new ipc permissions
- * @qbytes: msgq bytes
- * @uid: msgq user id
- * @gid: msgq group id
- * @mode: msgq mode (permissions)
- *
- * Called only after audit_ipc_obj().
- */
 void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)
 {
 	struct audit_context *context = current->audit_context;
@@ -2469,12 +2201,6 @@
 }
 
 
-/**
- * audit_socketcall - record audit data for sys_socketcall
- * @nargs: number of args
- * @args: args array
- *
- */
 void __audit_socketcall(int nargs, unsigned long *args)
 {
 	struct audit_context *context = current->audit_context;
@@ -2484,12 +2210,6 @@
 	memcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));
 }
 
-/**
- * __audit_fd_pair - record audit data for pipe and socketpair
- * @fd1: the first file descriptor
- * @fd2: the second file descriptor
- *
- */
 void __audit_fd_pair(int fd1, int fd2)
 {
 	struct audit_context *context = current->audit_context;
@@ -2497,13 +2217,6 @@
 	context->fds[1] = fd2;
 }
 
-/**
- * audit_sockaddr - record audit data for sys_bind, sys_connect, sys_sendto
- * @len: data length in user space
- * @a: data address in kernel space
- *
- * Returns 0 for success or NULL context or < 0 on error.
- */
 int __audit_sockaddr(int len, void *a)
 {
 	struct audit_context *context = current->audit_context;
@@ -2532,14 +2245,6 @@
 	memcpy(context->target_comm, t->comm, TASK_COMM_LEN);
 }
 
-/**
- * audit_signal_info - record signal info for shutting down audit subsystem
- * @sig: signal value
- * @t: task being signaled
- *
- * If the audit subsystem is being terminated, record the task (pid)
- * and uid that is doing that.
- */
 int __audit_signal_info(int sig, struct task_struct *t)
 {
 	struct audit_aux_data_pids *axp;
@@ -2560,8 +2265,6 @@
 			return 0;
 	}
 
-	/* optimize the common case by putting first signal recipient directly
-	 * in audit_context */
 	if (!ctx->target_pid) {
 		ctx->target_pid = t->tgid;
 		ctx->target_auid = audit_get_loginuid(t);
@@ -2595,17 +2298,6 @@
 	return 0;
 }
 
-/**
- * __audit_log_bprm_fcaps - store information about a loading bprm and relevant fcaps
- * @bprm: pointer to the bprm being processed
- * @new: the proposed new credentials
- * @old: the old credentials
- *
- * Simply check if the proc already has the caps given by the file and if not
- * store the priv escalation info for later auditing at the end of the syscall
- *
- * -Eric
- */
 int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 			   const struct cred *new, const struct cred *old)
 {
@@ -2641,15 +2333,6 @@
 	return 0;
 }
 
-/**
- * __audit_log_capset - store information about the arguments to the capset syscall
- * @pid: target pid of the capset call
- * @new: the new credentials
- * @old: the old (current) credentials
- *
- * Record the aguments userspace sent to sys_capset for later printing by the
- * audit system if applicable
- */
 void __audit_log_capset(pid_t pid,
 		       const struct cred *new, const struct cred *old)
 {
@@ -2688,13 +2371,6 @@
 	audit_log_string(ab, reason);
 	audit_log_format(ab, " sig=%ld", signr);
 }
-/**
- * audit_core_dumps - record information about processes that end abnormally
- * @signr: signal value
- *
- * If a process ends with a core dump, something fishy is going on and we
- * should record the event for investigation.
- */
 void audit_core_dumps(long signr)
 {
 	struct audit_buffer *ab;
@@ -2702,7 +2378,7 @@
 	if (!audit_enabled)
 		return;
 
-	if (signr == SIGQUIT)	/* don't care for those */
+	if (signr == SIGQUIT)	
 		return;
 
 	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_ANOM_ABEND);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/audit_tree.c monarudo-jb-3.4.10-e22f38b/kernel/audit_tree.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/audit_tree.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/audit_tree.c	2013-08-01 23:37:51.000000000 -0600
@@ -23,7 +23,7 @@
 struct audit_chunk {
 	struct list_head hash;
 	struct fsnotify_mark mark;
-	struct list_head trees;		/* with root here */
+	struct list_head trees;		
 	int dead;
 	int count;
 	atomic_long_t refs;
@@ -31,42 +31,13 @@
 	struct node {
 		struct list_head list;
 		struct audit_tree *owner;
-		unsigned index;		/* index; upper bit indicates 'will prune' */
+		unsigned index;		
 	} owners[];
 };
 
 static LIST_HEAD(tree_list);
 static LIST_HEAD(prune_list);
 
-/*
- * One struct chunk is attached to each inode of interest.
- * We replace struct chunk on tagging/untagging.
- * Rules have pointer to struct audit_tree.
- * Rules have struct list_head rlist forming a list of rules over
- * the same tree.
- * References to struct chunk are collected at audit_inode{,_child}()
- * time and used in AUDIT_TREE rule matching.
- * These references are dropped at the same time we are calling
- * audit_free_names(), etc.
- *
- * Cyclic lists galore:
- * tree.chunks anchors chunk.owners[].list			hash_lock
- * tree.rules anchors rule.rlist				audit_filter_mutex
- * chunk.trees anchors tree.same_root				hash_lock
- * chunk.hash is a hash with middle bits of watch.inode as
- * a hash function.						RCU, hash_lock
- *
- * tree is refcounted; one reference for "some rules on rules_list refer to
- * it", one for each chunk with pointer to it.
- *
- * chunk is refcounted by embedded fsnotify_mark + .refs (non-zero refcount
- * of watch contributes 1 to .refs).
- *
- * node.index allows to get from node.list to containing chunk.
- * MSB of that sucker is stolen to mark taggings that we might have to
- * revert - several operations have very unpleasant cleanup logics and
- * that makes a difference.  Some.
- */
 
 static struct fsnotify_group *audit_tree_group;
 
@@ -99,7 +70,6 @@
 		kfree_rcu(tree, head);
 }
 
-/* to avoid bringing the entire thing in audit.h */
 const char *audit_tree_path(struct audit_tree *tree)
 {
 	return tree->pathname;
@@ -167,7 +137,6 @@
 	return chunk_hash_heads + n % HASH_SIZE;
 }
 
-/* hash_lock & entry->lock is held by caller */
 static void insert_hash(struct audit_chunk *chunk)
 {
 	struct fsnotify_mark *entry = &chunk->mark;
@@ -179,14 +148,13 @@
 	list_add_rcu(&chunk->hash, list);
 }
 
-/* called under rcu_read_lock */
 struct audit_chunk *audit_tree_lookup(const struct inode *inode)
 {
 	struct list_head *list = chunk_hash(inode);
 	struct audit_chunk *p;
 
 	list_for_each_entry_rcu(p, list, hash) {
-		/* mark.inode may have gone NULL, but who cares? */
+		
 		if (p->mark.i.inode == inode) {
 			atomic_long_inc(&p->refs);
 			return p;
@@ -204,7 +172,6 @@
 	return 0;
 }
 
-/* tagging and untagging inodes with trees */
 
 static struct audit_chunk *find_chunk(struct node *p)
 {
@@ -281,7 +248,7 @@
 		s = chunk->owners[j].owner;
 		new->owners[i].owner = s;
 		new->owners[i].index = chunk->owners[j].index - j + i;
-		if (!s) /* result of earlier fallback */
+		if (!s) 
 			continue;
 		get_tree(s);
 		list_replace_init(&chunk->owners[j].list, &new->owners[i].list);
@@ -297,7 +264,7 @@
 	goto out;
 
 Fallback:
-	// do the best we can
+	
 	spin_lock(&hash_lock);
 	if (owner->root == chunk) {
 		list_del_init(&owner->same_root);
@@ -350,7 +317,6 @@
 	return 0;
 }
 
-/* the first tagged inode becomes root of tree */
 static int tag_chunk(struct inode *inode, struct audit_tree *tree)
 {
 	struct fsnotify_mark *old_entry, *chunk_entry;
@@ -365,7 +331,7 @@
 
 	old = container_of(old_entry, struct audit_chunk, mark);
 
-	/* are we already there? */
+	
 	spin_lock(&hash_lock);
 	for (n = 0; n < old->count; n++) {
 		if (old->owners[n].owner == tree) {
@@ -386,7 +352,7 @@
 
 	spin_lock(&old_entry->lock);
 	if (!old_entry->i.inode) {
-		/* old_entry is being shot, lets just lie */
+		
 		spin_unlock(&old_entry->lock);
 		fsnotify_put_mark(old_entry);
 		free_chunk(chunk);
@@ -401,11 +367,11 @@
 		return -ENOSPC;
 	}
 
-	/* even though we hold old_entry->lock, this is safe since chunk_entry->lock could NEVER have been grabbed before */
+	
 	spin_lock(&chunk_entry->lock);
 	spin_lock(&hash_lock);
 
-	/* we now hold old_entry->lock, chunk_entry->lock, and hash_lock */
+	
 	if (tree->goner) {
 		spin_unlock(&hash_lock);
 		chunk->dead = 1;
@@ -423,7 +389,7 @@
 		struct audit_tree *s = old->owners[n].owner;
 		p->owner = s;
 		p->index = old->owners[n].index;
-		if (!s) /* result of fallback in untag */
+		if (!s) 
 			continue;
 		get_tree(s);
 		list_replace_init(&old->owners[n].list, &p->list);
@@ -444,8 +410,8 @@
 	spin_unlock(&chunk_entry->lock);
 	spin_unlock(&old_entry->lock);
 	fsnotify_destroy_mark(old_entry);
-	fsnotify_put_mark(old_entry); /* pair to fsnotify_find mark_entry */
-	fsnotify_put_mark(old_entry); /* and kill it */
+	fsnotify_put_mark(old_entry); 
+	fsnotify_put_mark(old_entry); 
 	return 0;
 }
 
@@ -460,7 +426,7 @@
 
 		list_del_init(&rule->rlist);
 		if (rule->tree) {
-			/* not a half-baked one */
+			
 			ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);
 			audit_log_format(ab, "op=");
 			audit_log_string(ab, "remove rule");
@@ -477,9 +443,6 @@
 	}
 }
 
-/*
- * finish killing struct audit_tree
- */
 static void prune_one(struct audit_tree *victim)
 {
 	spin_lock(&hash_lock);
@@ -494,7 +457,6 @@
 	put_tree(victim);
 }
 
-/* trim the uncommitted chunks from tree */
 
 static void trim_marked(struct audit_tree *tree)
 {
@@ -504,7 +466,7 @@
 		spin_unlock(&hash_lock);
 		return;
 	}
-	/* reorder */
+	
 	for (p = tree->chunks.next; p != &tree->chunks; p = q) {
 		struct node *node = list_entry(p, struct node, list);
 		q = p->next;
@@ -519,7 +481,7 @@
 
 		node = list_entry(tree->chunks.next, struct node, list);
 
-		/* have we run out of marked? */
+		
 		if (!(node->index & (1U<<31)))
 			break;
 
@@ -540,7 +502,6 @@
 
 static void audit_schedule_prune(void);
 
-/* called with audit_filter_mutex */
 int audit_remove_tree_rule(struct audit_krule *rule)
 {
 	struct audit_tree *tree;
@@ -601,7 +562,7 @@
 		spin_lock(&hash_lock);
 		list_for_each_entry(node, &tree->chunks, list) {
 			struct audit_chunk *chunk = find_chunk(node);
-			/* this could be NULL if the watch is dying else where... */
+			
 			struct inode *inode = chunk->mark.i.inode;
 			node->index |= 1U<<31;
 			if (iterate_mounts(compare_root, inode, root_mnt))
@@ -642,7 +603,6 @@
 	return tag_chunk(mnt->mnt_root->d_inode, arg);
 }
 
-/* called with audit_filter_mutex */
 int audit_add_tree_rule(struct audit_krule *rule)
 {
 	struct audit_tree *seed = rule->tree, *tree;
@@ -661,7 +621,7 @@
 	tree = seed;
 	list_add(&tree->list, &tree_list);
 	list_add(&rule->rlist, &tree->rules);
-	/* do not set rule->tree yet */
+	
 	mutex_unlock(&audit_filter_mutex);
 
 	err = kern_path(tree->pathname, 0, &path);
@@ -801,10 +761,6 @@
 	return failed;
 }
 
-/*
- * That gets run when evict_chunk() ends up needing to kill audit_tree.
- * Runs from a separate thread.
- */
 static int prune_tree_thread(void *unused)
 {
 	mutex_lock(&audit_cmd_mutex);
@@ -833,10 +789,6 @@
 	kthread_run(prune_tree_thread, NULL, "audit_prune_tree");
 }
 
-/*
- * ... and that one is done if evict_chunk() decides to delay until the end
- * of syscall.  Runs synchronously.
- */
 void audit_kill_trees(struct list_head *list)
 {
 	mutex_lock(&audit_cmd_mutex);
@@ -860,9 +812,6 @@
 	mutex_unlock(&audit_cmd_mutex);
 }
 
-/*
- *  Here comes the stuff asynchronous to auditctl operations
- */
 
 static void evict_chunk(struct audit_chunk *chunk)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/audit_watch.c monarudo-jb-3.4.10-e22f38b/kernel/audit_watch.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/audit_watch.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/audit_watch.c	2013-08-01 23:37:51.000000000 -0600
@@ -32,37 +32,24 @@
 #include <linux/security.h>
 #include "audit.h"
 
-/*
- * Reference counting:
- *
- * audit_parent: lifetime is from audit_init_parent() to receipt of an FS_IGNORED
- * 	event.  Each audit_watch holds a reference to its associated parent.
- *
- * audit_watch: if added to lists, lifetime is from audit_init_watch() to
- * 	audit_remove_watch().  Additionally, an audit_watch may exist
- * 	temporarily to assist in searching existing filter data.  Each
- * 	audit_krule holds a reference to its associated watch.
- */
 
 struct audit_watch {
-	atomic_t		count;	/* reference count */
-	dev_t			dev;	/* associated superblock device */
-	char			*path;	/* insertion path */
-	unsigned long		ino;	/* associated inode number */
-	struct audit_parent	*parent; /* associated parent */
-	struct list_head	wlist;	/* entry in parent->watches list */
-	struct list_head	rules;	/* anchor for krule->rlist */
+	atomic_t		count;	
+	dev_t			dev;	
+	char			*path;	
+	unsigned long		ino;	
+	struct audit_parent	*parent; 
+	struct list_head	wlist;	
+	struct list_head	rules;	
 };
 
 struct audit_parent {
-	struct list_head	watches; /* anchor for audit_watch->wlist */
-	struct fsnotify_mark mark; /* fsnotify mark on the inode */
+	struct list_head	watches; 
+	struct fsnotify_mark mark; 
 };
 
-/* fsnotify handle. */
 static struct fsnotify_group *audit_watch_group;
 
-/* fsnotify events we care about. */
 #define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\
 			FS_MOVE_SELF | FS_EVENT_ON_CHILD)
 
@@ -92,10 +79,6 @@
 		fsnotify_put_mark(&parent->mark);
 }
 
-/*
- * Find and return the audit_parent on the given inode.  If found a reference
- * is taken on this parent.
- */
 static inline struct audit_parent *audit_find_parent(struct inode *inode)
 {
 	struct audit_parent *parent = NULL;
@@ -128,7 +111,7 @@
 	list_del(&watch->wlist);
 	audit_put_parent(watch->parent);
 	watch->parent = NULL;
-	audit_put_watch(watch); /* match initial get */
+	audit_put_watch(watch); 
 }
 
 char *audit_watch_path(struct audit_watch *watch)
@@ -143,7 +126,6 @@
 		(watch->dev == dev);
 }
 
-/* Initialize a parent watch entry. */
 static struct audit_parent *audit_init_parent(struct path *path)
 {
 	struct inode *inode = path->dentry->d_inode;
@@ -167,7 +149,6 @@
 	return parent;
 }
 
-/* Initialize a watch entry. */
 static struct audit_watch *audit_init_watch(char *path)
 {
 	struct audit_watch *watch;
@@ -185,7 +166,6 @@
 	return watch;
 }
 
-/* Translate a watch string to kernel respresentation. */
 int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)
 {
 	struct audit_watch *watch;
@@ -209,8 +189,6 @@
 	return 0;
 }
 
-/* Duplicate the given audit watch.  The new watch's rules list is initialized
- * to an empty list and wlist is undefined. */
 static struct audit_watch *audit_dupe_watch(struct audit_watch *old)
 {
 	char *path;
@@ -252,7 +230,6 @@
 	}
 }
 
-/* Update inode info in audit rules based on filesystem event. */
 static void audit_update_watch(struct audit_parent *parent,
 			       const char *dname, dev_t dev,
 			       unsigned long ino, unsigned invalidating)
@@ -262,19 +239,13 @@
 	struct audit_entry *oentry, *nentry;
 
 	mutex_lock(&audit_filter_mutex);
-	/* Run all of the watches on this parent looking for the one that
-	 * matches the given dname */
 	list_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {
 		if (audit_compare_dname_path(dname, owatch->path, NULL))
 			continue;
 
-		/* If the update involves invalidating rules, do the inode-based
-		 * filtering now, so we don't omit records. */
 		if (invalidating && !audit_dummy_context())
 			audit_filter_inodes(current, current->audit_context);
 
-		/* updating ino will likely change which audit_hash_list we
-		 * are on so we need a new watch for the new list */
 		nwatch = audit_dupe_watch(owatch);
 		if (IS_ERR(nwatch)) {
 			mutex_unlock(&audit_filter_mutex);
@@ -297,11 +268,6 @@
 			} else {
 				int h = audit_hash_ino((u32)ino);
 
-				/*
-				 * nentry->rule.watch == oentry->rule.watch so
-				 * we must drop that reference and set it to our
-				 * new watch.
-				 */
 				audit_put_watch(nentry->rule.watch);
 				audit_get_watch(nwatch);
 				nentry->rule.watch = nwatch;
@@ -317,7 +283,7 @@
 		}
 
 		audit_remove_watch(owatch);
-		goto add_watch_to_parent; /* event applies to a single watch */
+		goto add_watch_to_parent; 
 	}
 	mutex_unlock(&audit_filter_mutex);
 	return;
@@ -328,7 +294,6 @@
 	return;
 }
 
-/* Remove all watches & rules associated with a parent that is going away. */
 static void audit_remove_parent_watches(struct audit_parent *parent)
 {
 	struct audit_watch *w, *nextw;
@@ -352,7 +317,6 @@
 	fsnotify_destroy_mark(&parent->mark);
 }
 
-/* Get path information necessary for adding watches. */
 static int audit_get_nd(struct audit_watch *watch, struct path *parent)
 {
 	struct nameidata nd;
@@ -376,7 +340,7 @@
 		return PTR_ERR(d);
 	}
 	if (d->d_inode) {
-		/* update watch filter fields */
+		
 		watch->dev = d->d_inode->i_sb->s_dev;
 		watch->ino = d->d_inode->i_ino;
 	}
@@ -387,8 +351,6 @@
 	return 0;
 }
 
-/* Associate the given rule with an existing parent.
- * Caller must hold audit_filter_mutex. */
 static void audit_add_to_parent(struct audit_krule *krule,
 				struct audit_parent *parent)
 {
@@ -403,7 +365,7 @@
 
 		watch_found = 1;
 
-		/* put krule's and initial refs to temporary watch */
+		
 		audit_put_watch(watch);
 		audit_put_watch(watch);
 
@@ -421,8 +383,6 @@
 	list_add(&krule->rlist, &watch->rules);
 }
 
-/* Find a matching watch entry, or add this one.
- * Caller must hold audit_filter_mutex. */
 int audit_add_watch(struct audit_krule *krule, struct list_head **list)
 {
 	struct audit_watch *watch = krule->watch;
@@ -432,16 +392,16 @@
 
 	mutex_unlock(&audit_filter_mutex);
 
-	/* Avoid calling path_lookup under audit_filter_mutex. */
+	
 	ret = audit_get_nd(watch, &parent_path);
 
-	/* caller expects mutex locked */
+	
 	mutex_lock(&audit_filter_mutex);
 
 	if (ret)
 		return ret;
 
-	/* either find an old parent or attach a new one */
+	
 	parent = audit_find_parent(parent_path.dentry->d_inode);
 	if (!parent) {
 		parent = audit_init_parent(&parent_path);
@@ -453,7 +413,7 @@
 
 	audit_add_to_parent(krule, parent);
 
-	/* match get in audit_find_parent or audit_init_parent */
+	
 	audit_put_parent(parent);
 
 	h = audit_hash_ino((u32)watch->ino);
@@ -489,7 +449,6 @@
        return true;
 }
 
-/* Update watch data in audit rules based on fsnotify events. */
 static int audit_watch_handle_event(struct fsnotify_group *group,
 				    struct fsnotify_mark *inode_mark,
 				    struct fsnotify_mark *vfsmount_mark,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/events/core.c monarudo-jb-3.4.10-e22f38b/kernel/events/core.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/events/core.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/events/core.c	2013-08-01 23:37:50.000000000 -0600
@@ -4271,7 +4271,7 @@
 
 static int perf_swevent_init(struct perf_event *event)
 {
-	int event_id = event->attr.config;
+	u64 event_id = event->attr.config;
 
 	if (event->attr.type != PERF_TYPE_SOFTWARE)
 		return -ENOENT;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/module.c monarudo-jb-3.4.10-e22f38b/kernel/module.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/module.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/module.c	2012-08-26 16:02:10.000000000 -0600
@@ -66,34 +66,54 @@
 #define ARCH_SHF_SMALL 0
 #endif
 
+/*
+ * Modules' sections will be aligned on page boundaries
+ * to ensure complete separation of code and data, but
+ * only when CONFIG_DEBUG_SET_MODULE_RONX=y
+ */
 #ifdef CONFIG_DEBUG_SET_MODULE_RONX
 # define debug_align(X) ALIGN(X, PAGE_SIZE)
 #else
 # define debug_align(X) (X)
 #endif
 
+/*
+ * Given BASE and SIZE this macro calculates the number of pages the
+ * memory regions occupies
+ */
 #define MOD_NUMBER_OF_PAGES(BASE, SIZE) (((SIZE) > 0) ?		\
 		(PFN_DOWN((unsigned long)(BASE) + (SIZE) - 1) -	\
 			 PFN_DOWN((unsigned long)BASE) + 1)	\
 		: (0UL))
 
+/* If this is set, the section belongs in the init part of the module */
 #define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
 
+/*
+ * Mutex protects:
+ * 1) List of modules (also safely readable with preempt_disable),
+ * 2) module_use links,
+ * 3) module_addr_min/module_addr_max.
+ * (delete uses stop_machine/add uses RCU list operations). */
 DEFINE_MUTEX(module_mutex);
 EXPORT_SYMBOL_GPL(module_mutex);
 static LIST_HEAD(modules);
 #ifdef CONFIG_KGDB_KDB
-struct list_head *kdb_modules = &modules; 
-#endif 
+struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
+#endif /* CONFIG_KGDB_KDB */
 
 
+/* Block module loading/unloading? */
 int modules_disabled = 0;
 core_param(nomodule, modules_disabled, bint, 0);
 
+/* Waiting for a module to finish initializing? */
 static DECLARE_WAIT_QUEUE_HEAD(module_wq);
 
 static BLOCKING_NOTIFIER_HEAD(module_notify_list);
 
+/* Bounds of module allocation, for speeding __module_address.
+ * Protected by module_mutex. */
 static unsigned long module_addr_min = -1UL, module_addr_max = 0;
 
 int register_module_notifier(struct notifier_block * nb)
@@ -121,6 +141,8 @@
 	} index;
 };
 
+/* We require a truly strong try_module_get(): 0 means failure due to
+   ongoing or failed initialization etc. */
 static inline int strong_try_module_get(struct module *mod)
 {
 	if (mod && mod->state == MODULE_STATE_COMING)
@@ -137,6 +159,10 @@
 	mod->taints |= (1U << flag);
 }
 
+/*
+ * A thread that wants to hold a reference to a module only while it
+ * is running can call this to safely exit.  nfsd and lockd use this.
+ */
 void __module_put_and_exit(struct module *mod, long code)
 {
 	module_put(mod);
@@ -144,13 +170,14 @@
 }
 EXPORT_SYMBOL(__module_put_and_exit);
 
+/* Find a module section: 0 means not found. */
 static unsigned int find_sec(const struct load_info *info, const char *name)
 {
 	unsigned int i;
 
 	for (i = 1; i < info->hdr->e_shnum; i++) {
 		Elf_Shdr *shdr = &info->sechdrs[i];
-		
+		/* Alloc bit cleared means "ignore it." */
 		if ((shdr->sh_flags & SHF_ALLOC)
 		    && strcmp(info->secstrings + shdr->sh_name, name) == 0)
 			return i;
@@ -158,12 +185,14 @@
 	return 0;
 }
 
+/* Find a module section, or NULL. */
 static void *section_addr(const struct load_info *info, const char *name)
 {
-	
+	/* Section 0 has sh_addr 0. */
 	return (void *)info->sechdrs[find_sec(info, name)].sh_addr;
 }
 
+/* Find a module section, or NULL.  Fill in number of "objects" in section. */
 static void *section_objs(const struct load_info *info,
 			  const char *name,
 			  size_t object_size,
@@ -171,11 +200,12 @@
 {
 	unsigned int sec = find_sec(info, name);
 
-	
+	/* Section 0 has sh_addr 0 and sh_size 0. */
 	*num = info->sechdrs[sec].sh_size / object_size;
 	return (void *)info->sechdrs[sec].sh_addr;
 }
 
+/* Provided by the linker */
 extern const struct kernel_symbol __start___ksymtab[];
 extern const struct kernel_symbol __stop___ksymtab[];
 extern const struct kernel_symbol __start___ksymtab_gpl[];
@@ -218,6 +248,7 @@
 	return false;
 }
 
+/* Returns true as soon as fn returns true, otherwise false. */
 bool each_symbol_section(bool (*fn)(const struct symsearch *arr,
 				    struct module *owner,
 				    void *data),
@@ -277,12 +308,12 @@
 EXPORT_SYMBOL_GPL(each_symbol_section);
 
 struct find_symbol_arg {
-	
+	/* Input */
 	const char *name;
 	bool gplok;
 	bool warn;
 
-	
+	/* Output */
 	struct module *owner;
 	const unsigned long *crc;
 	const struct kernel_symbol *sym;
@@ -351,6 +382,8 @@
 	return false;
 }
 
+/* Find a symbol and return it, along with, (optional) crc and
+ * (optional) module which owns it.  Needs preempt disabled or module_mutex. */
 const struct kernel_symbol *find_symbol(const char *name,
 					struct module **owner,
 					const unsigned long **crc,
@@ -376,6 +409,7 @@
 }
 EXPORT_SYMBOL_GPL(find_symbol);
 
+/* Search for module by name: must hold module_mutex. */
 struct module *find_module(const char *name)
 {
 	struct module *mod;
@@ -434,6 +468,15 @@
 		memcpy(per_cpu_ptr(mod->percpu, cpu), from, size);
 }
 
+/**
+ * is_module_percpu_address - test whether address is from module static percpu
+ * @addr: address to test
+ *
+ * Test whether @addr belongs to module static percpu area.
+ *
+ * RETURNS:
+ * %true if @addr is from module static percpu area
+ */
 bool is_module_percpu_address(unsigned long addr)
 {
 	struct module *mod;
@@ -459,7 +502,7 @@
 	return false;
 }
 
-#else 
+#else /* ... !CONFIG_SMP */
 
 static inline void __percpu *mod_percpu(struct module *mod)
 {
@@ -480,7 +523,7 @@
 static inline void percpu_modcopy(struct module *mod,
 				  const void *from, unsigned long size)
 {
-	
+	/* pcpusec should be 0, and size of that section should be 0. */
 	BUG_ON(size != 0);
 }
 bool is_module_percpu_address(unsigned long addr)
@@ -488,7 +531,7 @@
 	return false;
 }
 
-#endif 
+#endif /* CONFIG_SMP */
 
 #define MODINFO_ATTR(field)	\
 static void setup_modinfo_##field(struct module *mod, const char *s)  \
@@ -526,6 +569,7 @@
 
 EXPORT_TRACEPOINT_SYMBOL(module_get);
 
+/* Init the unload section of the module. */
 static int module_unload_init(struct module *mod)
 {
 	mod->refptr = alloc_percpu(struct module_ref);
@@ -535,14 +579,15 @@
 	INIT_LIST_HEAD(&mod->source_list);
 	INIT_LIST_HEAD(&mod->target_list);
 
-	
+	/* Hold reference count during initialization. */
 	__this_cpu_write(mod->refptr->incs, 1);
-	
+	/* Backwards compatibility macros put refcount during init. */
 	mod->waiter = current;
 
 	return 0;
 }
 
+/* Does a already use b? */
 static int already_uses(struct module *a, struct module *b)
 {
 	struct module_use *use;
@@ -557,6 +602,13 @@
 	return 0;
 }
 
+/*
+ * Module a uses b
+ *  - we add 'a' as a "source", 'b' as a "target" of module use
+ *  - the module_use is added to the list of 'b' sources (so
+ *    'b' can walk the list to see who sourced them), and of 'a'
+ *    targets (so 'a' can see what modules it targets).
+ */
 static int add_module_usage(struct module *a, struct module *b)
 {
 	struct module_use *use;
@@ -575,6 +627,7 @@
 	return 0;
 }
 
+/* Module a uses b: caller needs module_mutex() */
 int ref_module(struct module *a, struct module *b)
 {
 	int err;
@@ -582,7 +635,7 @@
 	if (b == NULL || already_uses(a, b))
 		return 0;
 
-	
+	/* If module isn't available, we fail. */
 	err = strong_try_module_get(b);
 	if (err)
 		return err;
@@ -596,6 +649,7 @@
 }
 EXPORT_SYMBOL_GPL(ref_module);
 
+/* Clear the unload stuff of the module. */
 static void module_unload_free(struct module *mod)
 {
 	struct module_use *use, *tmp;
@@ -627,7 +681,7 @@
 {
 	return 0;
 }
-#endif 
+#endif /* CONFIG_MODULE_FORCE_UNLOAD */
 
 struct stopref
 {
@@ -636,17 +690,18 @@
 	int *forced;
 };
 
+/* Whole machine is stopped with interrupts off when this runs. */
 static int __try_stop_module(void *_sref)
 {
 	struct stopref *sref = _sref;
 
-	
+	/* If it's not unused, quit unless we're forcing. */
 	if (module_refcount(sref->mod) != 0) {
 		if (!(*sref->forced = try_force_unload(sref->flags)))
 			return -EWOULDBLOCK;
 	}
 
-	
+	/* Mark it as dying. */
 	sref->mod->state = MODULE_STATE_GOING;
 	return 0;
 }
@@ -658,7 +713,7 @@
 
 		return stop_machine(__try_stop_module, &sref, NULL);
 	} else {
-		
+		/* We don't need to stop the machine for this. */
 		mod->state = MODULE_STATE_GOING;
 		synchronize_sched();
 		return 0;
@@ -672,6 +727,19 @@
 
 	for_each_possible_cpu(cpu)
 		decs += per_cpu_ptr(mod->refptr, cpu)->decs;
+	/*
+	 * ensure the incs are added up after the decs.
+	 * module_put ensures incs are visible before decs with smp_wmb.
+	 *
+	 * This 2-count scheme avoids the situation where the refcount
+	 * for CPU0 is read, then CPU0 increments the module refcount,
+	 * then CPU1 drops that refcount, then the refcount for CPU1 is
+	 * read. We would record a decrement but not its corresponding
+	 * increment so we would see a low count (disaster).
+	 *
+	 * Rare situation? But module_refcount can be preempted, and we
+	 * might be tallying up 4096+ CPUs. So it is not impossible.
+	 */
 	smp_rmb();
 	for_each_possible_cpu(cpu)
 		incs += per_cpu_ptr(mod->refptr, cpu)->incs;
@@ -679,11 +747,12 @@
 }
 EXPORT_SYMBOL(module_refcount);
 
+/* This exists whether we can unload or not */
 static void free_module(struct module *mod);
 
 static void wait_for_zero_refcount(struct module *mod)
 {
-	
+	/* Since we might sleep for some time, release the mutex first */
 	mutex_unlock(&module_mutex);
 	for (;;) {
 		pr_debug("Looking at refcount...\n");
@@ -720,49 +789,51 @@
 	}
 
 	if (!list_empty(&mod->source_list)) {
-		
+		/* Other modules depend on us: get rid of them first. */
 		ret = -EWOULDBLOCK;
 		goto out;
 	}
 
-	
+	/* Doing init or already dying? */
 	if (mod->state != MODULE_STATE_LIVE) {
+		/* FIXME: if (force), slam module count and wake up
+                   waiter --RR */
 		pr_debug("%s already dying\n", mod->name);
 		ret = -EBUSY;
 		goto out;
 	}
 
-	
+	/* If it has an init func, it must have an exit func to unload */
 	if (mod->init && !mod->exit) {
 		forced = try_force_unload(flags);
 		if (!forced) {
-			
+			/* This module can't be removed */
 			ret = -EBUSY;
 			goto out;
 		}
 	}
 
-	
+	/* Set this up before setting mod->state */
 	mod->waiter = current;
 
-	
+	/* Stop the machine so refcounts can't move and disable module. */
 	ret = try_stop_module(mod, flags, &forced);
 	if (ret != 0)
 		goto out;
 
-	
+	/* Never wait if forced. */
 	if (!forced && module_refcount(mod) != 0)
 		wait_for_zero_refcount(mod);
 
 	mutex_unlock(&module_mutex);
-	
+	/* Final destruction now no one is using it. */
 	if (mod->exit != NULL)
 		mod->exit();
 	blocking_notifier_call_chain(&module_notify_list,
 				     MODULE_STATE_GOING, mod);
 	async_synchronize_full();
 
-	
+	/* Store the name of the last unloaded module for diagnostic purposes */
 	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));
 
 	free_module(mod);
@@ -779,6 +850,8 @@
 
 	seq_printf(m, " %lu ", module_refcount(mod));
 
+	/* Always include a trailing , so userspace can differentiate
+           between this and the old multi-field proc format. */
 	list_for_each_entry(use, &mod->source_list, source_list) {
 		printed_something = 1;
 		seq_printf(m, "%s,", use->source->name);
@@ -805,6 +878,7 @@
 }
 EXPORT_SYMBOL(__symbol_put);
 
+/* Note this assumes addr is a function, which it currently always is. */
 void symbol_put_addr(void *addr)
 {
 	struct module *modaddr;
@@ -813,6 +887,8 @@
 	if (core_kernel_text(a))
 		return;
 
+	/* module_text_address is safe here: we're supposed to have reference
+	 * to module from symbol_get, so it can't go away. */
 	modaddr = __module_text_address(a);
 	BUG_ON(!modaddr);
 	module_put(modaddr);
@@ -862,11 +938,11 @@
 {
 	if (module) {
 		preempt_disable();
-		smp_wmb(); 
+		smp_wmb(); /* see comment in module_refcount */
 		__this_cpu_inc(module->refptr->decs);
 
 		trace_module_put(module, _RET_IP_);
-		
+		/* Maybe they're waiting for us to drop reference? */
 		if (unlikely(!module_is_live(module)))
 			wake_up_process(module->waiter);
 		preempt_enable();
@@ -874,10 +950,10 @@
 }
 EXPORT_SYMBOL(module_put);
 
-#else 
+#else /* !CONFIG_MODULE_UNLOAD */
 static inline void print_unload_info(struct seq_file *m, struct module *mod)
 {
-	
+	/* We don't know the usage count, or what modules are using. */
 	seq_printf(m, " - -");
 }
 
@@ -895,7 +971,7 @@
 {
 	return 0;
 }
-#endif 
+#endif /* CONFIG_MODULE_UNLOAD */
 
 static size_t module_flags_taint(struct module *mod, char *buf)
 {
@@ -909,6 +985,11 @@
 		buf[l++] = 'F';
 	if (mod->taints & (1 << TAINT_CRAP))
 		buf[l++] = 'C';
+	/*
+	 * TAINT_FORCED_RMMOD: could be added.
+	 * TAINT_UNSAFE_SMP, TAINT_MACHINE_CHECK, TAINT_BAD_PAGE don't
+	 * apply to modules.
+	 */
 	return l;
 }
 
@@ -1009,6 +1090,7 @@
 }
 
 #ifdef CONFIG_MODVERSIONS
+/* If the arch applies (non-zero) relocations to kernel kcrctab, unapply it. */
 static unsigned long maybe_relocated(unsigned long crc,
 				     const struct module *crc_owner)
 {
@@ -1029,11 +1111,11 @@
 	unsigned int i, num_versions;
 	struct modversion_info *versions;
 
-	
+	/* Exporting module didn't supply crcs?  OK, we're already tainted. */
 	if (!crc)
 		return 1;
 
-	
+	/* No versions at all?  modprobe --force does this. */
 	if (versindex == 0)
 		return try_to_force_load(mod, symname) == 0;
 
@@ -1068,6 +1150,8 @@
 {
 	const unsigned long *crc;
 
+	/* Since this should be found in kernel (which can't be removed),
+	 * no locking is necessary. */
 	if (!find_symbol(MODULE_SYMBOL_PREFIX "module_layout", NULL,
 			 &crc, true, false))
 		BUG();
@@ -1075,6 +1159,7 @@
 			     NULL);
 }
 
+/* First part is kernel version, which we ignore if module has crcs. */
 static inline int same_magic(const char *amagic, const char *bmagic,
 			     bool has_crcs)
 {
@@ -1107,8 +1192,9 @@
 {
 	return strcmp(amagic, bmagic) == 0;
 }
-#endif 
+#endif /* CONFIG_MODVERSIONS */
 
+/* Resolve a symbol for this module.  I.e. if we find one, record usage. */
 static const struct kernel_symbol *resolve_symbol(struct module *mod,
 						  const struct load_info *info,
 						  const char *name,
@@ -1138,7 +1224,7 @@
 	}
 
 getname:
-	
+	/* We must make copy under the lock if we failed to get ref. */
 	strncpy(ownername, module_name(owner), MODULE_NAME_LEN);
 unlock:
 	mutex_unlock(&module_mutex);
@@ -1163,6 +1249,10 @@
 	return ksym;
 }
 
+/*
+ * /sys/module/foo/sections stuff
+ * J. Corbet <corbet@lwn.net>
+ */
 #ifdef CONFIG_SYSFS
 
 #ifdef CONFIG_KALLSYMS
@@ -1209,7 +1299,7 @@
 	struct module_sect_attr *sattr;
 	struct attribute **gattr;
 
-	
+	/* Count loaded sections and allocate structures */
 	for (i = 0; i < info->hdr->e_shnum; i++)
 		if (!sect_empty(&info->sechdrs[i]))
 			nloaded++;
@@ -1221,7 +1311,7 @@
 	if (sect_attrs == NULL)
 		return;
 
-	
+	/* Setup section attributes. */
 	sect_attrs->grp.name = "sections";
 	sect_attrs->grp.attrs = (void *)sect_attrs + size[0];
 
@@ -1261,11 +1351,16 @@
 	if (mod->sect_attrs) {
 		sysfs_remove_group(&mod->mkobj.kobj,
 				   &mod->sect_attrs->grp);
+		/* We are positive that no one is using any sect attrs
+		 * at this point.  Deallocate immediately. */
 		free_sect_attrs(mod->sect_attrs);
 		mod->sect_attrs = NULL;
 	}
 }
 
+/*
+ * /sys/module/foo/notes/.section.name gives contents of SHT_NOTE sections.
+ */
 
 struct module_notes_attrs {
 	struct kobject *dir;
@@ -1277,6 +1372,9 @@
 				 struct bin_attribute *bin_attr,
 				 char *buf, loff_t pos, size_t count)
 {
+	/*
+	 * The caller checked the pos and count against our size.
+	 */
 	memcpy(buf, bin_attr->private + pos, count);
 	return count;
 }
@@ -1299,11 +1397,11 @@
 	struct module_notes_attrs *notes_attrs;
 	struct bin_attribute *nattr;
 
-	
+	/* failed to create section attributes, so can't create notes */
 	if (!mod->sect_attrs)
 		return;
 
-	
+	/* Count notes sections and allocate structures.  */
 	notes = 0;
 	for (i = 0; i < info->hdr->e_shnum; i++)
 		if (!sect_empty(&info->sechdrs[i]) &&
@@ -1377,7 +1475,7 @@
 static inline void remove_notes_attrs(struct module *mod)
 {
 }
-#endif 
+#endif /* CONFIG_KALLSYMS */
 
 static void add_usage_links(struct module *mod)
 {
@@ -1438,7 +1536,7 @@
 	int i;
 
 	for (i = 0; (attr = &mod->modinfo_attrs[i]); i++) {
-		
+		/* pick a field to test for end of list */
 		if (!attr->attr.name)
 			break;
 		sysfs_remove_file(&mod->mkobj.kobj,&attr->attr);
@@ -1477,7 +1575,7 @@
 	if (err)
 		kobject_put(&mod->mkobj.kobj);
 
-	
+	/* delay uevent until full sysfs population */
 out:
 	return err;
 }
@@ -1531,7 +1629,7 @@
 	kobject_put(&mod->mkobj.kobj);
 }
 
-#else 
+#else /* !CONFIG_SYSFS */
 
 static int mod_sysfs_setup(struct module *mod,
 			   const struct load_info *info,
@@ -1553,7 +1651,7 @@
 {
 }
 
-#endif 
+#endif /* CONFIG_SYSFS */
 
 static void mod_sysfs_teardown(struct module *mod)
 {
@@ -1565,6 +1663,10 @@
 	mod_sysfs_fini(mod);
 }
 
+/*
+ * unlink the module with the whole machine is stopped with interrupts off
+ * - this defends against kallsyms not taking locks
+ */
 static int __unlink_module(void *_mod)
 {
 	struct module *mod = _mod;
@@ -1574,6 +1676,10 @@
 }
 
 #ifdef CONFIG_DEBUG_SET_MODULE_RONX
+/*
+ * LKM RO/NX protection: protect module's text/ro-data
+ * from modification and any data from execution.
+ */
 void set_page_attributes(void *start, void *end, int (*set)(unsigned long start, int num_pages))
 {
 	unsigned long begin_pfn = PFN_DOWN((unsigned long)start);
@@ -1588,13 +1694,23 @@
 			unsigned long ro_size,
 			unsigned long total_size)
 {
-	
+	/* begin and end PFNs of the current subsection */
 	unsigned long begin_pfn;
 	unsigned long end_pfn;
 
+	/*
+	 * Set RO for module text and RO-data:
+	 * - Always protect first page.
+	 * - Do not protect last partial page.
+	 */
 	if (ro_size > 0)
 		set_page_attributes(base, base + ro_size, set_memory_ro);
 
+	/*
+	 * Set NX permissions for module data:
+	 * - Do not protect first partial page.
+	 * - Always protect last page.
+	 */
 	if (total_size > text_size) {
 		begin_pfn = PFN_UP((unsigned long)base + text_size);
 		end_pfn = PFN_UP((unsigned long)base + total_size);
@@ -1623,6 +1739,7 @@
 		set_memory_rw);
 }
 
+/* Iterate through all modules and set each module's text as RW */
 void set_all_modules_text_rw(void)
 {
 	struct module *mod;
@@ -1643,6 +1760,7 @@
 	mutex_unlock(&module_mutex);
 }
 
+/* Iterate through all modules and set each module's text as RO */
 void set_all_modules_text_ro(void)
 {
 	struct module *mod;
@@ -1677,38 +1795,39 @@
 {
 }
 
+/* Free a module, remove from lists, etc. */
 static void free_module(struct module *mod)
 {
 	trace_module_free(mod);
 
-	
+	/* Delete from various lists */
 	mutex_lock(&module_mutex);
 	stop_machine(__unlink_module, mod, NULL);
 	mutex_unlock(&module_mutex);
 	mod_sysfs_teardown(mod);
 
-	
+	/* Remove dynamic debug info */
 	ddebug_remove_module(mod->name);
 
-	
+	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
 
-	
+	/* Module unload stuff */
 	module_unload_free(mod);
 
-	
+	/* Free any allocated parameters. */
 	destroy_params(mod->kp, mod->num_kp);
 
-	
+	/* This may be NULL, but that's OK */
 	unset_module_init_ro_nx(mod);
 	module_free(mod, mod->module_init);
 	kfree(mod->args);
 	percpu_modfree(mod);
 
-	
+	/* Free lock-classes: */
 	lockdep_free_key_range(mod->module_core, mod->core_size);
 
-	
+	/* Finally, free the core (containing the module structure) */
 	unset_module_core_ro_nx(mod);
 	module_free(mod, mod->module_core);
 
@@ -1732,6 +1851,12 @@
 }
 EXPORT_SYMBOL_GPL(__symbol_get);
 
+/*
+ * Ensure that an exported symbol [global namespace] does not already exist
+ * in the kernel or in some other module's exported symbol table.
+ *
+ * You must hold the module_mutex.
+ */
 static int verify_export_symbols(struct module *mod)
 {
 	unsigned int i;
@@ -1764,6 +1889,7 @@
 	return 0;
 }
 
+/* Change all symbols so that st_value encodes the pointer directly. */
 static int simplify_symbols(struct module *mod, const struct load_info *info)
 {
 	Elf_Shdr *symsec = &info->sechdrs[info->index.sym];
@@ -1778,6 +1904,8 @@
 
 		switch (sym[i].st_shndx) {
 		case SHN_COMMON:
+			/* We compiled with -fno-common.  These are not
+			   supposed to happen.  */
 			pr_debug("Common symbol: %s\n", name);
 			printk("%s: please compile with -fno-common\n",
 			       mod->name);
@@ -1785,20 +1913,20 @@
 			break;
 
 		case SHN_ABS:
-			
+			/* Don't need to do anything */
 			pr_debug("Absolute symbol: 0x%08lx\n",
 			       (long)sym[i].st_value);
 			break;
 
 		case SHN_UNDEF:
 			ksym = resolve_symbol_wait(mod, info, name);
-			
+			/* Ok if resolved.  */
 			if (ksym && !IS_ERR(ksym)) {
 				sym[i].st_value = ksym->value;
 				break;
 			}
 
-			
+			/* Ok if weak.  */
 			if (!ksym && ELF_ST_BIND(sym[i].st_info) == STB_WEAK)
 				break;
 
@@ -1808,7 +1936,7 @@
 			break;
 
 		default:
-			
+			/* Divert to percpu allocation if a percpu var. */
 			if (sym[i].st_shndx == info->index.pcpu)
 				secbase = (unsigned long)mod_percpu(mod);
 			else
@@ -1846,15 +1974,15 @@
 	unsigned int i;
 	int err = 0;
 
-	
+	/* Now do relocations. */
 	for (i = 1; i < info->hdr->e_shnum; i++) {
 		unsigned int infosec = info->sechdrs[i].sh_info;
 
-		
+		/* Not a valid relocation section? */
 		if (infosec >= info->hdr->e_shnum)
 			continue;
 
-		
+		/* Don't bother with non-allocated sections */
 		if (!(info->sechdrs[infosec].sh_flags & SHF_ALLOC))
 			continue;
 
@@ -1870,13 +1998,15 @@
 	return err;
 }
 
+/* Additional bytes needed by arch in front of individual sections */
 unsigned int __weak arch_mod_section_prepend(struct module *mod,
 					     unsigned int section)
 {
-	
+	/* default implementation just returns zero */
 	return 0;
 }
 
+/* Update size with this section: return offset. */
 static long get_offset(struct module *mod, unsigned int *size,
 		       Elf_Shdr *sechdr, unsigned int section)
 {
@@ -1888,9 +2018,16 @@
 	return ret;
 }
 
+/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld
+   might -- code, read-only data, read-write data, small data.  Tally
+   sizes, and place the offsets into sh_entsize fields: high bit means it
+   belongs in init. */
 static void layout_sections(struct module *mod, struct load_info *info)
 {
 	static unsigned long const masks[][2] = {
+		/* NOTE: all executable code must be the first section
+		 * in this array; otherwise modify the text_size
+		 * finder in the two loops below */
 		{ SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL },
 		{ SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL },
 		{ SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL },
@@ -1916,15 +2053,15 @@
 			pr_debug("\t%s\n", sname);
 		}
 		switch (m) {
-		case 0: 
+		case 0: /* executable */
 			mod->core_size = debug_align(mod->core_size);
 			mod->core_text_size = mod->core_size;
 			break;
-		case 1: 
+		case 1: /* RO: text and ro-data */
 			mod->core_size = debug_align(mod->core_size);
 			mod->core_ro_size = mod->core_size;
 			break;
-		case 3: 
+		case 3: /* whole core */
 			mod->core_size = debug_align(mod->core_size);
 			break;
 		}
@@ -1946,15 +2083,15 @@
 			pr_debug("\t%s\n", sname);
 		}
 		switch (m) {
-		case 0: 
+		case 0: /* executable */
 			mod->init_size = debug_align(mod->init_size);
 			mod->init_text_size = mod->init_size;
 			break;
-		case 1: 
+		case 1: /* RO: text and ro-data */
 			mod->init_size = debug_align(mod->init_size);
 			mod->init_ro_size = mod->init_size;
 			break;
-		case 3: 
+		case 3: /* whole init */
 			mod->init_size = debug_align(mod->init_size);
 			break;
 		}
@@ -1974,16 +2111,17 @@
 	}
 }
 
+/* Parse tag=value strings from .modinfo section */
 static char *next_string(char *string, unsigned long *secsize)
 {
-	
+	/* Skip non-zero chars */
 	while (string[0]) {
 		string++;
 		if ((*secsize)-- <= 1)
 			return NULL;
 	}
 
-	
+	/* Skip any zero padding. */
 	while (!string[0]) {
 		string++;
 		if ((*secsize)-- <= 1)
@@ -2030,6 +2168,7 @@
 
 #ifdef CONFIG_KALLSYMS
 
+/* lookup symbol in given range of kernel_symbols */
 static const struct kernel_symbol *lookup_symbol(const char *name,
 	const struct kernel_symbol *start,
 	const struct kernel_symbol *stop)
@@ -2049,6 +2188,7 @@
 	return ks != NULL && ks->value == value;
 }
 
+/* As per nm */
 static char elf_type(const Elf_Sym *sym, const struct load_info *info)
 {
 	const Elf_Shdr *sechdrs = info->sechdrs;
@@ -2110,6 +2250,13 @@
 	return true;
 }
 
+/*
+ * We only allocate and copy the strings needed by the parts of symtab
+ * we keep.  This is simple, but has the effect of making multiple
+ * copies of duplicates.  We could be more sophisticated, see
+ * linux-kernel thread starting with
+ * <73defb5e4bca04a6431392cc341112b1@localhost>.
+ */
 static void layout_symtab(struct module *mod, struct load_info *info)
 {
 	Elf_Shdr *symsect = info->sechdrs + info->index.sym;
@@ -2117,7 +2264,7 @@
 	const Elf_Sym *src;
 	unsigned int i, nsrc, ndst, strtab_size;
 
-	
+	/* Put symbol section at end of init part of module. */
 	symsect->sh_flags |= SHF_ALLOC;
 	symsect->sh_entsize = get_offset(mod, &mod->init_size, symsect,
 					 info->index.sym) | INIT_OFFSET_MASK;
@@ -2126,19 +2273,19 @@
 	src = (void *)info->hdr + symsect->sh_offset;
 	nsrc = symsect->sh_size / sizeof(*src);
 
-	
+	/* Compute total space required for the core symbols' strtab. */
 	for (ndst = i = strtab_size = 1; i < nsrc; ++i, ++src)
 		if (is_core_symbol(src, info->sechdrs, info->hdr->e_shnum)) {
 			strtab_size += strlen(&info->strtab[src->st_name]) + 1;
 			ndst++;
 		}
 
-	
+	/* Append room for core symbols at end of core part. */
 	info->symoffs = ALIGN(mod->core_size, symsect->sh_addralign ?: 1);
 	info->stroffs = mod->core_size = info->symoffs + ndst * sizeof(Elf_Sym);
 	mod->core_size += strtab_size;
 
-	
+	/* Put string table section at end of init part of module. */
 	strsect->sh_flags |= SHF_ALLOC;
 	strsect->sh_entsize = get_offset(mod, &mod->init_size, strsect,
 					 info->index.str) | INIT_OFFSET_MASK;
@@ -2155,10 +2302,10 @@
 
 	mod->symtab = (void *)symsec->sh_addr;
 	mod->num_symtab = symsec->sh_size / sizeof(Elf_Sym);
-	
+	/* Make sure we get permanent strtab: don't use info->strtab. */
 	mod->strtab = (void *)info->sechdrs[info->index.str].sh_addr;
 
-	
+	/* Set types up while we still have access to sections. */
 	for (i = 0; i < mod->num_symtab; i++)
 		mod->symtab[i].st_info = elf_type(&mod->symtab[i], info);
 
@@ -2185,7 +2332,7 @@
 static void add_kallsyms(struct module *mod, const struct load_info *info)
 {
 }
-#endif 
+#endif /* CONFIG_KALLSYMS */
 
 static void dynamic_debug_setup(struct _ddebug *debug, unsigned int num)
 {
@@ -2215,7 +2362,7 @@
 
 	if (ret) {
 		mutex_lock(&module_mutex);
-		
+		/* Update module bounds. */
 		if ((unsigned long)ret < module_addr_min)
 			module_addr_min = (unsigned long)ret;
 		if ((unsigned long)ret + size > module_addr_max)
@@ -2231,7 +2378,7 @@
 {
 	unsigned int i;
 
-	
+	/* only scan the sections containing data */
 	kmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL);
 
 	for (i = 1; i < info->hdr->e_shnum; i++) {
@@ -2252,6 +2399,7 @@
 }
 #endif
 
+/* Sets info->hdr and info->len. */
 static int copy_and_check(struct load_info *info,
 			  const void __user *umod, unsigned long len,
 			  const char __user *uargs)
@@ -2262,7 +2410,7 @@
 	if (len < sizeof(*hdr))
 		return -ENOEXEC;
 
-	
+	/* Suck in entire file: we'll want most of it. */
 	if ((hdr = vmalloc(len)) == NULL)
 		return -ENOMEM;
 
@@ -2271,6 +2419,8 @@
 		goto free_hdr;
 	}
 
+	/* Sanity checks against insmoding binaries or wrong arch,
+	   weird elf version */
 	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0
 	    || hdr->e_type != ET_REL
 	    || !elf_check_arch(hdr)
@@ -2302,7 +2452,7 @@
 {
 	unsigned int i;
 
-	
+	/* This should always be true, but let's be sure. */
 	info->sechdrs[0].sh_addr = 0;
 
 	for (i = 1; i < info->hdr->e_shnum; i++) {
@@ -2314,16 +2464,18 @@
 			return -ENOEXEC;
 		}
 
+		/* Mark all sections sh_addr with their address in the
+		   temporary image. */
 		shdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;
 
 #ifndef CONFIG_MODULE_UNLOAD
-		
+		/* Don't load .exit sections */
 		if (strstarts(info->secstrings+shdr->sh_name, ".exit"))
 			shdr->sh_flags &= ~(unsigned long)SHF_ALLOC;
 #endif
 	}
 
-	
+	/* Track but don't keep modinfo and version sections. */
 	info->index.vers = find_sec(info, "__versions");
 	info->index.info = find_sec(info, ".modinfo");
 	info->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;
@@ -2331,13 +2483,21 @@
 	return 0;
 }
 
+/*
+ * Set up our basic convenience variables (pointers to section headers,
+ * search for module section index etc), and do some basic section
+ * verification.
+ *
+ * Return the temporary module pointer (we'll replace it with the final
+ * one when we move the module sections around).
+ */
 static struct module *setup_load_info(struct load_info *info)
 {
 	unsigned int i;
 	int err;
 	struct module *mod;
 
-	
+	/* Set up the convenience variables */
 	info->sechdrs = (void *)info->hdr + info->hdr->e_shoff;
 	info->secstrings = (void *)info->hdr
 		+ info->sechdrs[info->hdr->e_shstrndx].sh_offset;
@@ -2346,7 +2506,7 @@
 	if (err)
 		return ERR_PTR(err);
 
-	
+	/* Find internal symbols and strings. */
 	for (i = 1; i < info->hdr->e_shnum; i++) {
 		if (info->sechdrs[i].sh_type == SHT_SYMTAB) {
 			info->index.sym = i;
@@ -2362,7 +2522,7 @@
 		printk(KERN_WARNING "No module found in object\n");
 		return ERR_PTR(-ENOEXEC);
 	}
-	
+	/* This is temporary: point mod into copy of data. */
 	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 
 	if (info->index.sym == 0) {
@@ -2373,7 +2533,7 @@
 
 	info->index.pcpu = find_pcpusec(info);
 
-	
+	/* Check module struct version now, before we try to use module. */
 	if (!check_modstruct_version(info->sechdrs, info->index.vers, mod))
 		return ERR_PTR(-ENOEXEC);
 
@@ -2385,7 +2545,7 @@
 	const char *modmagic = get_modinfo(info, "vermagic");
 	int err;
 
-	
+	/* This is allowed: modprobe --force will invalidate it. */
 	if (!modmagic) {
 		err = try_to_force_load(mod, "bad vermagic");
 		if (err)
@@ -2458,6 +2618,10 @@
 	mod->trace_events = section_objs(info, "_ftrace_events",
 					 sizeof(*mod->trace_events),
 					 &mod->num_trace_events);
+	/*
+	 * This section contains pointers to allocated objects in the trace
+	 * code and not scanning it leads to false positives.
+	 */
 	kmemleak_scan_area(mod->trace_events, sizeof(*mod->trace_events) *
 			   mod->num_trace_events, GFP_KERNEL);
 #endif
@@ -2465,12 +2629,16 @@
 	mod->trace_bprintk_fmt_start = section_objs(info, "__trace_printk_fmt",
 					 sizeof(*mod->trace_bprintk_fmt_start),
 					 &mod->num_trace_bprintk_fmt);
+	/*
+	 * This section contains pointers to allocated objects in the trace
+	 * code and not scanning it leads to false positives.
+	 */
 	kmemleak_scan_area(mod->trace_bprintk_fmt_start,
 			   sizeof(*mod->trace_bprintk_fmt_start) *
 			   mod->num_trace_bprintk_fmt, GFP_KERNEL);
 #endif
 #ifdef CONFIG_FTRACE_MCOUNT_RECORD
-	
+	/* sechdrs[0].sh_size is always zero */
 	mod->ftrace_callsites = section_objs(info, "__mcount_loc",
 					     sizeof(*mod->ftrace_callsites),
 					     &mod->num_ftrace_callsites);
@@ -2492,8 +2660,13 @@
 	int i;
 	void *ptr;
 
-	
+	/* Do the allocs. */
 	ptr = module_alloc_update_bounds(mod->core_size);
+	/*
+	 * The pointer to this block is stored in the module structure
+	 * which is inside the block. Just mark it as not being a
+	 * leak.
+	 */
 	kmemleak_not_leak(ptr);
 	if (!ptr)
 		return -ENOMEM;
@@ -2502,6 +2675,12 @@
 	mod->module_core = ptr;
 
 	ptr = module_alloc_update_bounds(mod->init_size);
+	/*
+	 * The pointer to this block is stored in the module structure
+	 * which is inside the block. This block doesn't need to be
+	 * scanned as it contains data and code that will be freed
+	 * after the module is initialized.
+	 */
 	kmemleak_ignore(ptr);
 	if (!ptr && mod->init_size) {
 		module_free(mod, mod->module_core);
@@ -2510,7 +2689,7 @@
 	memset(ptr, 0, mod->init_size);
 	mod->module_init = ptr;
 
-	
+	/* Transfer each section which specifies SHF_ALLOC */
 	pr_debug("final section addresses:\n");
 	for (i = 0; i < info->hdr->e_shnum; i++) {
 		void *dest;
@@ -2527,7 +2706,7 @@
 
 		if (shdr->sh_type != SHT_NOBITS)
 			memcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);
-		
+		/* Update sh_addr to point to copy in image. */
 		shdr->sh_addr = (unsigned long)dest;
 		pr_debug("\t0x%lx %s\n",
 			 (long)shdr->sh_addr, info->secstrings + shdr->sh_name);
@@ -2570,10 +2749,15 @@
 {
 	mm_segment_t old_fs;
 
-	
+	/* flush the icache in correct context */
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
 
+	/*
+	 * Flush the instruction cache, since we've played with text.
+	 * Do it before processing of module parameters, so the module
+	 * can provide parameter accessor functions of its own.
+	 */
 	if (mod->module_init)
 		flush_icache_range((unsigned long)mod->module_init,
 				   (unsigned long)mod->module_init
@@ -2594,7 +2778,7 @@
 
 static struct module *layout_and_allocate(struct load_info *info)
 {
-	
+	/* Module within temporary copy. */
 	struct module *mod;
 	Elf_Shdr *pcpusec;
 	int err;
@@ -2607,7 +2791,7 @@
 	if (err)
 		return ERR_PTR(err);
 
-	
+	/* Allow arches to frob section contents and sizes.  */
 	err = module_frob_arch_sections(info->hdr, info->sechdrs,
 					info->secstrings, mod);
 	if (err < 0)
@@ -2615,7 +2799,7 @@
 
 	pcpusec = &info->sechdrs[info->index.pcpu];
 	if (pcpusec->sh_size) {
-		
+		/* We have a special allocation for this section. */
 		err = percpu_modalloc(mod,
 				      pcpusec->sh_size, pcpusec->sh_addralign);
 		if (err)
@@ -2623,15 +2807,18 @@
 		pcpusec->sh_flags &= ~(unsigned long)SHF_ALLOC;
 	}
 
+	/* Determine total sizes, and put offsets in sh_entsize.  For now
+	   this is done generically; there doesn't appear to be any
+	   special cases for the architectures. */
 	layout_sections(mod, info);
 	layout_symtab(mod, info);
 
-	
+	/* Allocate and move to the final place */
 	err = move_module(mod, info);
 	if (err)
 		goto free_percpu;
 
-	
+	/* Module has been copied to its final place now: return it. */
 	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 	kmemleak_load_module(mod, info);
 	return mod;
@@ -2642,6 +2829,7 @@
 	return ERR_PTR(err);
 }
 
+/* mod is no longer valid after this! */
 static void module_deallocate(struct module *mod, struct load_info *info)
 {
 	percpu_modfree(mod);
@@ -2658,20 +2846,22 @@
 
 static int post_relocation(struct module *mod, const struct load_info *info)
 {
-	
+	/* Sort exception table now relocations are done. */
 	sort_extable(mod->extable, mod->extable + mod->num_exentries);
 
-	
+	/* Copy relocated percpu area over. */
 	percpu_modcopy(mod, (void *)info->sechdrs[info->index.pcpu].sh_addr,
 		       info->sechdrs[info->index.pcpu].sh_size);
 
-	
+	/* Setup kallsyms-specific fields. */
 	add_kallsyms(mod, info);
 
-	
+	/* Arch-specific module finalizing. */
 	return module_finalize(info->hdr, info->sechdrs, mod);
 }
 
+/* Allocate and load the module: note that size of section 0 is always
+   zero, and we rely on this for optional sections. */
 static struct module *load_module(void __user *umod,
 				  unsigned long len,
 				  const char __user *uargs)
@@ -2683,33 +2873,35 @@
 	pr_debug("load_module: umod=%p, len=%lu, uargs=%p\n",
 	       umod, len, uargs);
 
-	
+	/* Copy in the blobs from userspace, check they are vaguely sane. */
 	err = copy_and_check(&info, umod, len, uargs);
 	if (err)
 		return ERR_PTR(err);
 
-	
+	/* Figure out module layout, and allocate all the memory. */
 	mod = layout_and_allocate(&info);
 	if (IS_ERR(mod)) {
 		err = PTR_ERR(mod);
 		goto free_copy;
 	}
 
-	
+	/* Now module is in final location, initialize linked lists, etc. */
 	err = module_unload_init(mod);
 	if (err)
 		goto free_module;
 
+	/* Now we've got everything in the final locations, we can
+	 * find optional sections. */
 	find_module_sections(mod, &info);
 
 	err = check_module_license_and_versions(mod);
 	if (err)
 		goto free_unload;
 
-	
+	/* Set up MODINFO_ATTR fields */
 	setup_modinfo(mod, &info);
 
-	
+	/* Fix up syms, so that st_value is a pointer to location. */
 	err = simplify_symbols(mod, &info);
 	if (err < 0)
 		goto free_modinfo;
@@ -2724,26 +2916,33 @@
 
 	flush_module_icache(mod);
 
-	
+	/* Now copy in args */
 	mod->args = strndup_user(uargs, ~0UL >> 1);
 	if (IS_ERR(mod->args)) {
 		err = PTR_ERR(mod->args);
 		goto free_arch_cleanup;
 	}
 
-	
+	/* Mark state as coming so strong_try_module_get() ignores us. */
 	mod->state = MODULE_STATE_COMING;
 
+	/* Now sew it into the lists so we can get lockdep and oops
+	 * info during argument parsing.  No one should access us, since
+	 * strong_try_module_get() will fail.
+	 * lockdep/oops can run asynchronous, so use the RCU list insertion
+	 * function to insert in a way safe to concurrent readers.
+	 * The mutex protects against concurrent writers.
+	 */
 	mutex_lock(&module_mutex);
 	if (find_module(mod->name)) {
 		err = -EEXIST;
 		goto unlock;
 	}
 
-	
+	/* This has to be done once we're sure module name is unique. */
 	dynamic_debug_setup(info.debug, info.num_debug);
 
-	
+	/* Find duplicate symbols */
 	err = verify_export_symbols(mod);
 	if (err < 0)
 		goto ddebug;
@@ -2752,27 +2951,27 @@
 	list_add_rcu(&mod->list, &modules);
 	mutex_unlock(&module_mutex);
 
-	
+	/* Module is ready to execute: parsing args may do that. */
 	err = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
 			 -32768, 32767, NULL);
 	if (err < 0)
 		goto unlink;
 
-	
+	/* Link in to syfs. */
 	err = mod_sysfs_setup(mod, &info, mod->kp, mod->num_kp);
 	if (err < 0)
 		goto unlink;
 
-	
+	/* Get rid of temporary copy. */
 	free_copy(&info);
 
-	
+	/* Done! */
 	trace_module_load(mod);
 	return mod;
 
  unlink:
 	mutex_lock(&module_mutex);
-	
+	/* Unlink carefully: kallsyms could be walking list. */
 	list_del_rcu(&mod->list);
 	module_bug_cleanup(mod);
 
@@ -2795,6 +2994,7 @@
 	return ERR_PTR(err);
 }
 
+/* Call module constructors. */
 static void do_mod_ctors(struct module *mod)
 {
 #ifdef CONFIG_CONSTRUCTORS
@@ -2805,17 +3005,18 @@
 #endif
 }
 
+/* This is where the real work happens */
 SYSCALL_DEFINE3(init_module, void __user *, umod,
 		unsigned long, len, const char __user *, uargs)
 {
 	struct module *mod;
 	int ret = 0;
 
-	
+	/* Must have permission */
 	if (!capable(CAP_SYS_MODULE) || modules_disabled)
 		return -EPERM;
 
-	
+	/* Do all the hard work */
 	mod = load_module(umod, len, uargs);
 	if (IS_ERR(mod))
 		return PTR_ERR(mod);
@@ -2823,23 +3024,25 @@
 	blocking_notifier_call_chain(&module_notify_list,
 			MODULE_STATE_COMING, mod);
 
-	
+	/* Set RO and NX regions for core */
 	set_section_ro_nx(mod->module_core,
 				mod->core_text_size,
 				mod->core_ro_size,
 				mod->core_size);
 
-	
+	/* Set RO and NX regions for init */
 	set_section_ro_nx(mod->module_init,
 				mod->init_text_size,
 				mod->init_ro_size,
 				mod->init_size);
 
 	do_mod_ctors(mod);
-	
+	/* Start the module */
 	if (mod->init != NULL)
 		ret = do_one_initcall(mod->init);
 	if (ret < 0) {
+		/* Init routine failed: abort.  Try to protect us from
+                   buggy refcounters. */
 		mod->state = MODULE_STATE_GOING;
 		synchronize_sched();
 		module_put(mod);
@@ -2858,17 +3061,17 @@
 		dump_stack();
 	}
 
-	
+	/* Now it's a first class citizen!  Wake up anyone waiting for it. */
 	mod->state = MODULE_STATE_LIVE;
 	wake_up(&module_wq);
 	blocking_notifier_call_chain(&module_notify_list,
 				     MODULE_STATE_LIVE, mod);
 
-	
+	/* We need to finish all async code before the module init sequence is done */
 	async_synchronize_full();
 
 	mutex_lock(&module_mutex);
-	
+	/* Drop initial reference. */
 	module_put(mod);
 	trim_init_extable(mod);
 #ifdef CONFIG_KALLSYMS
@@ -2893,6 +3096,10 @@
 }
 
 #ifdef CONFIG_KALLSYMS
+/*
+ * This ignores the intensely annoying "mapping symbols" found
+ * in ARM ELF files: $a, $t and $d.
+ */
 static inline int is_arm_mapping_symbol(const char *str)
 {
 	return str[0] == '$' && strchr("atd", str[1])
@@ -2907,16 +3114,20 @@
 	unsigned int i, best = 0;
 	unsigned long nextval;
 
-	
+	/* At worse, next value is at end of module */
 	if (within_module_init(addr, mod))
 		nextval = (unsigned long)mod->module_init+mod->init_text_size;
 	else
 		nextval = (unsigned long)mod->module_core+mod->core_text_size;
 
+	/* Scan for closest preceding symbol, and next symbol. (ELF
+	   starts real symbols at 1). */
 	for (i = 1; i < mod->num_symtab; i++) {
 		if (mod->symtab[i].st_shndx == SHN_UNDEF)
 			continue;
 
+		/* We ignore unnamed symbols: they're uninformative
+		 * and inserted at a whim. */
 		if (mod->symtab[i].st_value <= addr
 		    && mod->symtab[i].st_value > mod->symtab[best].st_value
 		    && *(mod->strtab + mod->symtab[i].st_name) != '\0'
@@ -2939,6 +3150,8 @@
 	return mod->strtab + mod->symtab[best].st_name;
 }
 
+/* For kallsyms to ask for address resolution.  NULL means not found.  Careful
+ * not to lock to avoid deadlock on oopses, simply disable preemption. */
 const char *module_address_lookup(unsigned long addr,
 			    unsigned long *size,
 			    unsigned long *offset,
@@ -2958,7 +3171,7 @@
 			break;
 		}
 	}
-	
+	/* Make a copy in here where it's safe */
 	if (ret) {
 		strncpy(namebuf, ret, KSYM_NAME_LEN - 1);
 		ret = namebuf;
@@ -3051,13 +3264,14 @@
 	return 0;
 }
 
+/* Look for this name: can be of form module:name. */
 unsigned long module_kallsyms_lookup_name(const char *name)
 {
 	struct module *mod;
 	char *colon;
 	unsigned long ret = 0;
 
-	
+	/* Don't lock: we're in enough trouble already. */
 	preempt_disable();
 	if ((colon = strchr(name, ':')) != NULL) {
 		*colon = '\0';
@@ -3091,7 +3305,7 @@
 	}
 	return 0;
 }
-#endif 
+#endif /* CONFIG_KALLSYMS */
 
 static char *module_flags(struct module *mod, char *buf)
 {
@@ -3102,10 +3316,10 @@
 	    mod->state == MODULE_STATE_COMING) {
 		buf[bx++] = '(';
 		bx += module_flags_taint(mod, buf + bx);
-		
+		/* Show a - for module-is-being-unloaded */
 		if (mod->state == MODULE_STATE_GOING)
 			buf[bx++] = '-';
-		
+		/* Show a + for module-is-being-loaded */
 		if (mod->state == MODULE_STATE_COMING)
 			buf[bx++] = '+';
 		buf[bx++] = ')';
@@ -3116,6 +3330,7 @@
 }
 
 #ifdef CONFIG_PROC_FS
+/* Called by the /proc file system to return a list of modules. */
 static void *m_start(struct seq_file *m, loff_t *pos)
 {
 	mutex_lock(&module_mutex);
@@ -3141,15 +3356,15 @@
 		   mod->name, mod->init_size + mod->core_size);
 	print_unload_info(m, mod);
 
-	
+	/* Informative for users. */
 	seq_printf(m, " %s",
 		   mod->state == MODULE_STATE_GOING ? "Unloading":
 		   mod->state == MODULE_STATE_COMING ? "Loading":
 		   "Live");
-	
+	/* Used by oprofile and other similar tools. */
 	seq_printf(m, " 0x%pK", mod->module_core);
 
-	
+	/* Taints info */
 	if (mod->taints)
 		seq_printf(m, " %s", module_flags(mod, buf));
 
@@ -3157,6 +3372,11 @@
 	return 0;
 }
 
+/* Format: modulename size refcount deps address
+
+   Where refcount is a number or -, and deps is a comma-separated list
+   of depends or -.
+*/
 static const struct seq_operations modules_op = {
 	.start	= m_start,
 	.next	= m_next,
@@ -3184,6 +3404,7 @@
 module_init(proc_modules_init);
 #endif
 
+/* Given an address, look for it in the module exception tables. */
 const struct exception_table_entry *search_module_extables(unsigned long addr)
 {
 	const struct exception_table_entry *e = NULL;
@@ -3202,9 +3423,18 @@
 	}
 	preempt_enable();
 
+	/* Now, if we found one, we are running inside it now, hence
+	   we cannot unload the module, hence no refcnt needed. */
 	return e;
 }
 
+/*
+ * is_module_address - is this address inside a module?
+ * @addr: the address to check.
+ *
+ * See is_module_text_address() if you simply want to see if the address
+ * is code (not data).
+ */
 bool is_module_address(unsigned long addr)
 {
 	bool ret;
@@ -3216,6 +3446,13 @@
 	return ret;
 }
 
+/*
+ * __module_address - get the module which contains an address.
+ * @addr: the address.
+ *
+ * Must be called with preempt disabled or module mutex held so that
+ * module doesn't get freed during this.
+ */
 struct module *__module_address(unsigned long addr)
 {
 	struct module *mod;
@@ -3231,6 +3468,14 @@
 }
 EXPORT_SYMBOL_GPL(__module_address);
 
+/*
+ * is_module_text_address - is this address inside module code?
+ * @addr: the address to check.
+ *
+ * See is_module_address() if you simply want to see if the address is
+ * anywhere in a module.  See kernel_text_address() for testing if an
+ * address corresponds to kernel or module code.
+ */
 bool is_module_text_address(unsigned long addr)
 {
 	bool ret;
@@ -3242,11 +3487,18 @@
 	return ret;
 }
 
+/*
+ * __module_text_address - get the module whose code contains an address.
+ * @addr: the address.
+ *
+ * Must be called with preempt disabled or module mutex held so that
+ * module doesn't get freed during this.
+ */
 struct module *__module_text_address(unsigned long addr)
 {
 	struct module *mod = __module_address(addr);
 	if (mod) {
-		
+		/* Make sure it's within the text section. */
 		if (!within(addr, mod->module_init, mod->init_text_size)
 		    && !within(addr, mod->module_core, mod->core_text_size))
 			mod = NULL;
@@ -3255,13 +3507,14 @@
 }
 EXPORT_SYMBOL_GPL(__module_text_address);
 
+/* Don't grab lock, we're oopsing. */
 void print_modules(void)
 {
 	struct module *mod;
 	char buf[8];
 
 	printk(KERN_DEFAULT "Modules linked in:");
-	
+	/* Most callers should already have preempt disabled, but make sure */
 	preempt_disable();
 	list_for_each_entry_rcu(mod, &modules, list)
 		printk(" %s%s", mod->name, module_flags(mod, buf));
@@ -3272,6 +3525,8 @@
 }
 
 #ifdef CONFIG_MODVERSIONS
+/* Generate the signature for all relevant module structures here.
+ * If these change, we don't want to try to parse the module. */
 void module_layout(struct module *mod,
 		   struct modversion_info *ver,
 		   struct kernel_param *kp,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/power/htc_pnpmgr.c monarudo-jb-3.4.10-e22f38b/kernel/power/htc_pnpmgr.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/power/htc_pnpmgr.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/power/htc_pnpmgr.c	2013-08-01 23:37:51.000000000 -0600
@@ -27,6 +27,7 @@
 static struct kobject *apps_kobj;
 static struct kobject *pnpmgr_kobj;
 static struct kobject *adaptive_policy_kobj;
+static struct kobject *sysinfo_kobj;
 static struct kobject *battery_kobj;
 
 #define define_string_show(_name, str_buf)				\
@@ -91,16 +92,16 @@
 define_string_store(media_mode, media_mode_buf, null_cb);
 power_attr(media_mode);
 
-static int thermal_c0_value;
+static int thermal_c0_value = 9999999;
 #if (CONFIG_NR_CPUS >= 2)
-static int thermal_c1_value;
+static int thermal_c1_value = 9999999;
 #if (CONFIG_NR_CPUS == 4)
-static int thermal_c2_value;
-static int thermal_c3_value;
+static int thermal_c2_value = 9999999;
+static int thermal_c3_value = 9999999;
 #endif
 #endif
-static int thermal_final_value;
-static int thermal_g0_value;
+static int thermal_final_value = 9999999;
+static int thermal_g0_value = 999999999;
 static int thermal_batt_value;
 static int data_throttling_value;
 
@@ -135,6 +136,22 @@
 define_int_store(thermal_batt, thermal_batt_value, null_cb);
 power_attr(thermal_batt);
 
+static unsigned int info_gpu_max_clk = 400000000;
+void set_gpu_clk(unsigned int value)
+{
+        info_gpu_max_clk = value;
+}
+
+ssize_t
+gpu_max_clk_show(struct kobject *kobj, struct kobj_attribute *attr,
+                char *buf)
+{
+       int ret = 0;
+        ret = sprintf(buf, "%u", info_gpu_max_clk);
+        return ret;
+}
+power_ro_attr(gpu_max_clk);
+
 define_int_show(pause_dt, data_throttling_value);
 define_int_store(pause_dt, data_throttling_value, null_cb);
 power_attr(pause_dt);
@@ -347,6 +364,11 @@
 	NULL,
 };
 
+static struct attribute *sysinfo_g[] = {
+       &gpu_max_clk_attr.attr,
+       NULL,
+};
+
 static struct attribute *battery_g[] = {
 	&charging_enabled_attr.attr,
 	NULL,
@@ -368,10 +390,36 @@
 	.attrs = apps_g,
 };
 
+static struct attribute_group sysinfo_attr_group = {
+       .attrs = sysinfo_g,
+};
+
 static struct attribute_group battery_attr_group = {
 	.attrs = battery_g,
 };
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int __cpuinit cpu_hotplug_callback(struct notifier_block *nfb, unsigned long action, void *hcpu)
+{
+	switch (action) {
+		
+		case CPU_ONLINE:
+		case CPU_ONLINE_FROZEN:
+			sysfs_notify(hotplug_kobj, NULL, "cpu_hotplug");
+			break;
+		case CPU_DEAD:
+		case CPU_DEAD_FROZEN:
+			break;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __refdata cpu_hotplug_notifier = {
+	.notifier_call = cpu_hotplug_callback,
+	.priority = -10, 
+};
+#endif
+
 static unsigned int slack_time_ms;
 static unsigned int step_time_ms;
 static unsigned int max_powersave_bias;
@@ -443,10 +491,11 @@
 	hotplug_kobj = kobject_create_and_add("hotplug", pnpmgr_kobj);
 	thermal_kobj = kobject_create_and_add("thermal", pnpmgr_kobj);
 	apps_kobj = kobject_create_and_add("apps", pnpmgr_kobj);
+	sysinfo_kobj = kobject_create_and_add("sysinfo", pnpmgr_kobj);
 	battery_kobj = kobject_create_and_add("battery", pnpmgr_kobj);
 	adaptive_policy_kobj = kobject_create_and_add("adaptive_policy", power_kobj);
 
-	if (!cpufreq_kobj || !hotplug_kobj || !thermal_kobj || !apps_kobj || !battery_kobj || !adaptive_policy_kobj) {
+	if (!cpufreq_kobj || !hotplug_kobj || !thermal_kobj || !apps_kobj || !sysinfo_kobj || !battery_kobj || !adaptive_policy_kobj) {
 		pr_err("%s: Can not allocate enough memory.\n", __func__);
 		return -ENOMEM;
 	}
@@ -455,6 +504,7 @@
 	ret |= sysfs_create_group(hotplug_kobj, &hotplug_attr_group);
 	ret |= sysfs_create_group(thermal_kobj, &thermal_attr_group);
 	ret |= sysfs_create_group(apps_kobj, &apps_attr_group);
+	ret |= sysfs_create_group(sysinfo_kobj, &sysinfo_attr_group);
 	ret |= sysfs_create_group(battery_kobj, &battery_attr_group);
 	ret |= sysfs_create_group(adaptive_policy_kobj, &adaptive_attr_group);
 
@@ -463,6 +513,10 @@
 		return ret;
 	}
 
+#ifdef CONFIG_HOTPLUG_CPU
+	register_hotcpu_notifier(&cpu_hotplug_notifier);
+#endif
+
 	return 0;
 }
 
@@ -472,8 +526,12 @@
 	sysfs_remove_group(hotplug_kobj, &hotplug_attr_group);
 	sysfs_remove_group(thermal_kobj, &thermal_attr_group);
 	sysfs_remove_group(apps_kobj, &apps_attr_group);
+	sysfs_remove_group(sysinfo_kobj, &sysinfo_attr_group);
 	sysfs_remove_group(battery_kobj, &battery_attr_group);
 	sysfs_remove_group(adaptive_policy_kobj, &adaptive_attr_group);
+#ifdef CONFIG_HOTPLUG_CPU
+	unregister_hotcpu_notifier(&cpu_hotplug_notifier);
+#endif
 }
 
 module_init(pnpmgr_init);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/signal.c monarudo-jb-3.4.10-e22f38b/kernel/signal.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/signal.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/signal.c	2013-08-01 23:37:51.000000000 -0600
@@ -377,6 +377,9 @@
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
+#ifdef __ARCH_HAS_SA_RESTORER
+		ka->sa.sa_restorer = NULL;
+#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/kernel/sys.c monarudo-jb-3.4.10-e22f38b/kernel/sys.c
--- monarudo-jb-crc-3.4.10-7edee3c/kernel/sys.c	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/kernel/sys.c	2013-08-01 23:37:52.000000000 -0600
@@ -1015,15 +1015,16 @@
 #define override_architecture(name)	0
 #endif
 
-static int override_release(char __user *release, int len)
+static int override_release(char __user *release, size_t len)
 {
 	int ret = 0;
-	char buf[65];
 
 	if (current->personality & UNAME26) {
-		char *rest = UTS_RELEASE;
+		const char *rest = UTS_RELEASE;
+		char buf[65] = { 0 };
 		int ndots = 0;
 		unsigned v;
+		size_t copy;
 
 		while (*rest) {
 			if (*rest == '.' && ++ndots >= 3)
@@ -1033,8 +1034,9 @@
 			rest++;
 		}
 		v = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;
-		snprintf(buf, len, "2.6.%u%s", v, rest);
-		ret = copy_to_user(release, buf, len);
+		copy = clamp_t(size_t, len, 1, sizeof(buf));
+		copy = scnprintf(buf, copy, "2.6.%u%s", v, rest);
+		ret = copy_to_user(release, buf, copy + 1);
 	}
 	return ret;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/mm/page_alloc.c monarudo-jb-3.4.10-e22f38b/mm/page_alloc.c
--- monarudo-jb-crc-3.4.10-7edee3c/mm/page_alloc.c	2013-06-24 02:50:44.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/mm/page_alloc.c	2013-08-01 23:37:59.000000000 -0600
@@ -1617,7 +1617,8 @@
 {
 	struct page *page;
 
-	if (!order || (gfp_mask & __GFP_NO_COMPACT))
+	if (!order || (gfp_mask & __GFP_NO_COMPACT) ||
+		(order > PAGE_ALLOC_COSTLY_ORDER))
 		return NULL;
 
 	if (compaction_deferred(preferred_zone, order)) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/core/fib_rules.c monarudo-jb-3.4.10-e22f38b/net/core/fib_rules.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/core/fib_rules.c	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/core/fib_rules.c	2013-08-01 23:37:47.000000000 -0600
@@ -17,7 +17,9 @@
 #include <net/sock.h>
 #include <net/fib_rules.h>
 
+#ifdef CONFIG_MODULES
 #define FIB_RULE_DEBUG 1
+#endif
 
 int fib_default_rule_add(struct fib_rules_ops *ops,
 			 u32 pref, u32 table, u32 flags)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/fib_frontend.c monarudo-jb-3.4.10-e22f38b/net/ipv4/fib_frontend.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/fib_frontend.c	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/ipv4/fib_frontend.c	2013-08-01 23:37:47.000000000 -0600
@@ -45,7 +45,9 @@
 #include <net/rtnetlink.h>
 #include <net/xfrm.h>
 
+#ifdef CONFIG_MODULES
 #define FIB_IPTABLES_DEBUG 1
+#endif
 
 
 #ifndef CONFIG_IP_MULTIPLE_TABLES
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/icmp.c monarudo-jb-3.4.10-e22f38b/net/ipv4/icmp.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/icmp.c	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/ipv4/icmp.c	2013-08-01 23:37:48.000000000 -0600
@@ -97,6 +97,7 @@
 #include <net/inet_common.h>
 
 
+
 struct icmp_bxm {
 	struct sk_buff *skb;
 	int offset;
@@ -867,6 +868,7 @@
 
 	icmp_pointers[icmph->type].handler(skb);
 
+
 drop:
 	kfree_skb(skb);
 	return 0;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/inet_hashtables.c monarudo-jb-3.4.10-e22f38b/net/ipv4/inet_hashtables.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/inet_hashtables.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/ipv4/inet_hashtables.c	2013-08-01 23:37:48.000000000 -0600
@@ -76,6 +76,16 @@
 
 	spin_lock(&head->lock);
 	tb = inet_csk(sk)->icsk_bind_hash;
+
+	if ((!tb) || (IS_ERR(tb))) {
+			printk(KERN_DEBUG "[NET][WARN] tb is illegal in %s \n", __func__);
+			__sk_del_bind_node(sk);
+			inet_csk(sk)->icsk_bind_hash = NULL;
+			inet_sk(sk)->inet_num = 0;
+			spin_unlock(&head->lock);
+			return;
+	}
+
 	__sk_del_bind_node(sk);
 	tb->num_owners--;
 	inet_csk(sk)->icsk_bind_hash = NULL;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/netfilter/iptable_security.c monarudo-jb-3.4.10-e22f38b/net/ipv4/netfilter/iptable_security.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/netfilter/iptable_security.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/ipv4/netfilter/iptable_security.c	2013-08-01 23:37:48.000000000 -0600
@@ -47,7 +47,7 @@
 	if (hook == NF_INET_LOCAL_OUT &&
 	    (skb->len < sizeof(struct iphdr) ||
 	     ip_hdrlen(skb) < sizeof(struct iphdr)))
-		/* Somebody is playing with raw sockets. */
+		
 		return NF_ACCEPT;
 
 	net = dev_net((in != NULL) ? in : out);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/tcp_output.c monarudo-jb-3.4.10-e22f38b/net/ipv4/tcp_output.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/ipv4/tcp_output.c	2013-06-24 02:50:41.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/ipv4/tcp_output.c	2013-08-01 23:37:47.000000000 -0600
@@ -166,9 +166,6 @@
 	}
 
 	
-	*rcv_wnd = 65535;
-
-	
 	(*window_clamp) = min(65535U << (*rcv_wscale), *window_clamp);
 }
 EXPORT_SYMBOL(tcp_select_initial_window);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_CONNSECMARK.c monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_CONNSECMARK.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_CONNSECMARK.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_CONNSECMARK.c	2013-08-01 23:37:49.000000000 -0600
@@ -29,10 +29,6 @@
 MODULE_ALIAS("ipt_CONNSECMARK");
 MODULE_ALIAS("ip6t_CONNSECMARK");
 
-/*
- * If the packet has a security mark and the connection does not, copy
- * the security mark from the packet to the connection.
- */
 static void secmark_save(const struct sk_buff *skb)
 {
 	if (skb->secmark) {
@@ -47,10 +43,6 @@
 	}
 }
 
-/*
- * If packet has no security mark, and the connection does, restore the
- * security mark from the connection to the packet.
- */
 static void secmark_restore(struct sk_buff *skb)
 {
 	if (!skb->secmark) {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_LOG.c monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_LOG.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_LOG.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_LOG.c	2013-08-01 23:37:49.000000000 -0600
@@ -413,9 +413,23 @@
 		const unsigned char *p = skb_mac_header(skb);
 		unsigned int i;
 
+#ifdef CONFIG_HTC_NETWORK_MODIFY
+		sb_add(m, "**");
+		p++;
+#else
 		sb_add(m, "%02x", *p++);
-		for (i = 1; i < dev->hard_header_len; i++, p++)
+#endif
+
+		for (i = 1; i < dev->hard_header_len; i++, p++) {
+#ifdef CONFIG_HTC_NETWORK_MODIFY
+			if(i<6)
+				sb_add(m, ":**");
+			else
+				sb_add(m, ":%02x", *p);
+#else
 			sb_add(m, ":%02x", *p);
+#endif
+		}
 	}
 	sb_add(m, " ");
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid.c monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid.c	2013-08-01 23:37:49.000000000 -0600
@@ -133,24 +133,6 @@
 	counters->bpc[set][direction][ifs_proto].packets += packets;
 }
 
-static inline uint64_t dc_sum_bytes(struct data_counters *counters,
-				    int set,
-				    enum ifs_tx_rx direction)
-{
-	return counters->bpc[set][direction][IFS_TCP].bytes
-		+ counters->bpc[set][direction][IFS_UDP].bytes
-		+ counters->bpc[set][direction][IFS_PROTO_OTHER].bytes;
-}
-
-static inline uint64_t dc_sum_packets(struct data_counters *counters,
-				      int set,
-				      enum ifs_tx_rx direction)
-{
-	return counters->bpc[set][direction][IFS_TCP].packets
-		+ counters->bpc[set][direction][IFS_UDP].packets
-		+ counters->bpc[set][direction][IFS_PROTO_OTHER].packets;
-}
-
 static struct tag_node *tag_node_tree_search(struct rb_root *root, tag_t tag)
 {
 	struct rb_node *node = root->rb_node;
@@ -632,6 +614,52 @@
 	return iface_entry;
 }
 
+static int pp_iface_stat_line(bool header, char *outp,
+			      int char_count, struct iface_stat *iface_entry)
+{
+	int len;
+	if (header) {
+		len = snprintf(outp, char_count,
+			       "ifname "
+			       "total_skb_rx_bytes total_skb_rx_packets "
+			       "total_skb_tx_bytes total_skb_tx_packets "
+			       "rx_tcp_bytes rx_tcp_packets "
+			       "rx_udp_bytes rx_udp_packets "
+			       "rx_other_bytes rx_other_packets "
+			       "tx_tcp_bytes tx_tcp_packets "
+			       "tx_udp_bytes tx_udp_packets "
+			       "tx_other_bytes tx_other_packets\n"
+			);
+	} else {
+		struct data_counters *cnts;
+		int cnt_set = 0;   
+		cnts = &iface_entry->totals_via_skb;
+		len = snprintf(
+			outp, char_count,
+			"%s "
+			"%llu %llu %llu %llu %llu %llu %llu %llu "
+			"%llu %llu %llu %llu %llu %llu %llu %llu\n",
+			iface_entry->ifname,
+			dc_sum_bytes(cnts, cnt_set, IFS_RX),
+			dc_sum_packets(cnts, cnt_set, IFS_RX),
+			dc_sum_bytes(cnts, cnt_set, IFS_TX),
+			dc_sum_packets(cnts, cnt_set, IFS_TX),
+			cnts->bpc[cnt_set][IFS_RX][IFS_TCP].bytes,
+			cnts->bpc[cnt_set][IFS_RX][IFS_TCP].packets,
+			cnts->bpc[cnt_set][IFS_RX][IFS_UDP].bytes,
+			cnts->bpc[cnt_set][IFS_RX][IFS_UDP].packets,
+			cnts->bpc[cnt_set][IFS_RX][IFS_PROTO_OTHER].bytes,
+			cnts->bpc[cnt_set][IFS_RX][IFS_PROTO_OTHER].packets,
+			cnts->bpc[cnt_set][IFS_TX][IFS_TCP].bytes,
+			cnts->bpc[cnt_set][IFS_TX][IFS_TCP].packets,
+			cnts->bpc[cnt_set][IFS_TX][IFS_UDP].bytes,
+			cnts->bpc[cnt_set][IFS_TX][IFS_UDP].packets,
+			cnts->bpc[cnt_set][IFS_TX][IFS_PROTO_OTHER].bytes,
+			cnts->bpc[cnt_set][IFS_TX][IFS_PROTO_OTHER].packets);
+	}
+	return len;
+}
+
 static int iface_stat_fmt_proc_read(char *page, char **num_items_returned,
 				    off_t items_to_skip, int char_count,
 				    int *eof, void *data)
@@ -661,11 +689,7 @@
 		return 0;
 
 	if (fmt == 2 && item_index++ >= items_to_skip) {
-		len = snprintf(outp, char_count,
-			       "ifname "
-			       "total_skb_rx_bytes total_skb_rx_packets "
-			       "total_skb_tx_bytes total_skb_tx_packets\n"
-			);
+		len = pp_iface_stat_line(true, outp, char_count, NULL);
 		if (len >= char_count) {
 			*outp = '\0';
 			return outp - page;
@@ -702,16 +726,8 @@
 				stats->tx_bytes, stats->tx_packets
 				);
 		} else {
-			len = snprintf(
-				outp, char_count,
-				"%s "
-				"%llu %llu %llu %llu\n",
-				iface_entry->ifname,
-				iface_entry->totals_via_skb[IFS_RX].bytes,
-				iface_entry->totals_via_skb[IFS_RX].packets,
-				iface_entry->totals_via_skb[IFS_TX].bytes,
-				iface_entry->totals_via_skb[IFS_TX].packets
-				);
+			len = pp_iface_stat_line(false, outp, char_count,
+						 iface_entry);
 		}
 		if (len >= char_count) {
 			spin_unlock_bh(&iface_stat_list_lock);
@@ -914,18 +930,13 @@
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
-		bool activate = !ipv4_is_loopback(ipaddr);
 		IF_DEBUG("qtaguid: iface_stat: create(%s): entry=%p\n",
 			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
-		_iface_stat_set_active(entry, net_dev, activate);
+		_iface_stat_set_active(entry, net_dev, true);
 		IF_DEBUG("qtaguid: %s(%s): "
 			 "tracking now %d on ip=%pI4\n", __func__,
-			 entry->ifname, activate, &ipaddr);
-		goto done_unlock_put;
-	} else if (ipv4_is_loopback(ipaddr)) {
-		IF_DEBUG("qtaguid: iface_stat: create(%s): "
-			 "ignore loopback dev. ip=%pI4\n", ifname, &ipaddr);
+			 entry->ifname, true, &ipaddr);
 		goto done_unlock_put;
 	}
 
@@ -976,19 +987,13 @@
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
-		bool activate = !(addr_type & IPV6_ADDR_LOOPBACK);
 		IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
 			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
-		_iface_stat_set_active(entry, net_dev, activate);
+		_iface_stat_set_active(entry, net_dev, true);
 		IF_DEBUG("qtaguid: %s(%s): "
 			 "tracking now %d on ip=%pI6c\n", __func__,
-			 entry->ifname, activate, &ifa->addr);
-		goto done_unlock_put;
-	} else if (addr_type & IPV6_ADDR_LOOPBACK) {
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "ignore loopback dev. ip=%pI6c\n", __func__,
-			 ifname, &ifa->addr);
+			 entry->ifname, true, &ifa->addr);
 		goto done_unlock_put;
 	}
 
@@ -1116,6 +1121,7 @@
 	const struct net_device *el_dev;
 	enum ifs_tx_rx direction = par->in ? IFS_RX : IFS_TX;
 	int bytes = skb->len;
+	int proto;
 
 	if (!skb->dev) {
 		MT_DEBUG("qtaguid[%d]: no skb->dev\n", par->hooknum);
@@ -1141,7 +1147,7 @@
 		       par->hooknum, __func__);
 		BUG();
 	} else {
-		int proto = ipx_proto(skb, par);
+		proto = ipx_proto(skb, par);
 		MT_DEBUG("qtaguid[%d]: dev name=%s type=%d fam=%d proto=%d\n",
 			 par->hooknum, el_dev->name, el_dev->type,
 			 par->family, proto);
@@ -1159,8 +1165,8 @@
 	IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
 		 el_dev->name, entry);
 
-	entry->totals_via_skb[direction].bytes += bytes;
-	entry->totals_via_skb[direction].packets++;
+	data_counters_update(&entry->totals_via_skb, 0, direction, proto,
+			     bytes);
 	spin_unlock_bh(&iface_stat_list_lock);
 }
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid_internal.h monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid_internal.h
--- monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid_internal.h	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid_internal.h	2013-08-01 23:37:49.000000000 -0600
@@ -127,6 +127,25 @@
 	struct byte_packet_counters bpc[IFS_MAX_COUNTER_SETS][IFS_MAX_DIRECTIONS][IFS_MAX_PROTOS];
 };
 
+static inline uint64_t dc_sum_bytes(struct data_counters *counters,
+				    int set,
+				    enum ifs_tx_rx direction)
+{
+	return counters->bpc[set][direction][IFS_TCP].bytes
+		+ counters->bpc[set][direction][IFS_UDP].bytes
+		+ counters->bpc[set][direction][IFS_PROTO_OTHER].bytes;
+}
+
+static inline uint64_t dc_sum_packets(struct data_counters *counters,
+				      int set,
+				      enum ifs_tx_rx direction)
+{
+	return counters->bpc[set][direction][IFS_TCP].packets
+		+ counters->bpc[set][direction][IFS_UDP].packets
+		+ counters->bpc[set][direction][IFS_PROTO_OTHER].packets;
+}
+
+
 struct tag_node {
 	struct rb_node node;
 	tag_t tag;
@@ -146,7 +165,7 @@
 	struct net_device *net_dev;
 
 	struct byte_packet_counters totals_via_dev[IFS_MAX_DIRECTIONS];
-	struct byte_packet_counters totals_via_skb[IFS_MAX_DIRECTIONS];
+	struct data_counters totals_via_skb;
 	struct byte_packet_counters last_known[IFS_MAX_DIRECTIONS];
 	
 	bool last_known_valid;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid_print.c monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid_print.c
--- monarudo-jb-crc-3.4.10-7edee3c/net/netfilter/xt_qtaguid_print.c	2013-06-24 02:50:42.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/net/netfilter/xt_qtaguid_print.c	2013-08-01 23:37:49.000000000 -0600
@@ -170,9 +170,10 @@
 char *pp_iface_stat(struct iface_stat *is)
 {
 	char *res;
-	if (!is)
+	if (!is) {
 		res = kasprintf(GFP_ATOMIC, "iface_stat@null{}");
-	else
+	} else {
+		struct data_counters *cnts = &is->totals_via_skb;
 		res = kasprintf(GFP_ATOMIC, "iface_stat@%p{"
 				"list=list_head{...}, "
 				"ifname=%s, "
@@ -199,10 +200,10 @@
 				is->totals_via_dev[IFS_RX].packets,
 				is->totals_via_dev[IFS_TX].bytes,
 				is->totals_via_dev[IFS_TX].packets,
-				is->totals_via_skb[IFS_RX].bytes,
-				is->totals_via_skb[IFS_RX].packets,
-				is->totals_via_skb[IFS_TX].bytes,
-				is->totals_via_skb[IFS_TX].packets,
+				dc_sum_bytes(cnts, 0, IFS_RX),
+				dc_sum_packets(cnts, 0, IFS_RX),
+				dc_sum_bytes(cnts, 0, IFS_TX),
+				dc_sum_packets(cnts, 0, IFS_TX),
 				is->last_known_valid,
 				is->last_known[IFS_RX].bytes,
 				is->last_known[IFS_RX].packets,
@@ -211,6 +212,7 @@
 				is->active,
 				is->net_dev,
 				is->proc_ptr);
+	}
 	_bug_on_err_or_null(res);
 	return res;
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/scripts/gcc-wrapper.py monarudo-jb-3.4.10-e22f38b/scripts/gcc-wrapper.py
--- monarudo-jb-crc-3.4.10-7edee3c/scripts/gcc-wrapper.py	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/scripts/gcc-wrapper.py	2013-08-01 23:38:05.000000000 -0600
@@ -41,8 +41,14 @@
 
 allowed_warnings = set([
     "alignment.c:327",
+    "inet_hashtables.h:356",
     "mmu.c:602",
     "return_address.c:62",
+    "swab.h:49",
+    "xc4000.c:1049",
+    "xc4000.c:1063",
+    "xt_socket.c:161",
+    "xt_socket.c:307",
  ])
 
 # Capture the name of the object file, can find it.
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/capability.c monarudo-jb-3.4.10-e22f38b/security/capability.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/capability.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/capability.c	2013-08-01 23:38:04.000000000 -0600
@@ -12,6 +12,26 @@
 
 #include <linux/security.h>
 
+static int cap_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static int cap_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static int cap_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static int cap_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return 0;
+}
+
 static int cap_syslog(int type)
 {
 	return 0;
@@ -717,7 +737,7 @@
 {
 	return 0;
 }
-#endif	/* CONFIG_SECURITY_NETWORK */
+#endif	
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 static int cap_xfrm_policy_alloc_security(struct xfrm_sec_ctx **ctxp,
@@ -774,7 +794,7 @@
 	return 0;
 }
 
-#endif /* CONFIG_SECURITY_NETWORK_XFRM */
+#endif 
 static void cap_d_instantiate(struct dentry *dentry, struct inode *inode)
 {
 }
@@ -842,7 +862,7 @@
 	return 0;
 }
 
-#endif /* CONFIG_KEYS */
+#endif 
 
 #ifdef CONFIG_AUDIT
 static int cap_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
@@ -864,7 +884,7 @@
 static void cap_audit_rule_free(void *lsmrule)
 {
 }
-#endif /* CONFIG_AUDIT */
+#endif 
 
 #define set_to_cap_if_null(ops, function)				\
 	do {								\
@@ -877,6 +897,10 @@
 
 void __init security_fixup_ops(struct security_operations *ops)
 {
+	set_to_cap_if_null(ops, binder_set_context_mgr);
+	set_to_cap_if_null(ops, binder_transaction);
+	set_to_cap_if_null(ops, binder_transfer_binder);
+	set_to_cap_if_null(ops, binder_transfer_file);
 	set_to_cap_if_null(ops, ptrace_access_check);
 	set_to_cap_if_null(ops, ptrace_traceme);
 	set_to_cap_if_null(ops, capget);
@@ -1046,7 +1070,7 @@
 	set_to_cap_if_null(ops, tun_dev_create);
 	set_to_cap_if_null(ops, tun_dev_post_create);
 	set_to_cap_if_null(ops, tun_dev_attach);
-#endif	/* CONFIG_SECURITY_NETWORK */
+#endif	
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 	set_to_cap_if_null(ops, xfrm_policy_alloc_security);
 	set_to_cap_if_null(ops, xfrm_policy_clone_security);
@@ -1058,13 +1082,13 @@
 	set_to_cap_if_null(ops, xfrm_policy_lookup);
 	set_to_cap_if_null(ops, xfrm_state_pol_flow_match);
 	set_to_cap_if_null(ops, xfrm_decode_session);
-#endif	/* CONFIG_SECURITY_NETWORK_XFRM */
+#endif	
 #ifdef CONFIG_KEYS
 	set_to_cap_if_null(ops, key_alloc);
 	set_to_cap_if_null(ops, key_free);
 	set_to_cap_if_null(ops, key_permission);
 	set_to_cap_if_null(ops, key_getsecurity);
-#endif	/* CONFIG_KEYS */
+#endif	
 #ifdef CONFIG_AUDIT
 	set_to_cap_if_null(ops, audit_rule_init);
 	set_to_cap_if_null(ops, audit_rule_known);
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/lsm_audit.c monarudo-jb-3.4.10-e22f38b/security/lsm_audit.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/lsm_audit.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/lsm_audit.c	2013-08-01 23:38:04.000000000 -0600
@@ -31,14 +31,6 @@
 #include <linux/sctp.h>
 #include <linux/lsm_audit.h>
 
-/**
- * ipv4_skb_to_auditdata : fill auditdata from skb
- * @skb : the skb
- * @ad : the audit data to fill
- * @proto : the layer 4 protocol
- *
- * return  0 on success
- */
 int ipv4_skb_to_auditdata(struct sk_buff *skb,
 		struct common_audit_data *ad, u8 *proto)
 {
@@ -54,7 +46,7 @@
 
 	if (proto)
 		*proto = ih->protocol;
-	/* non initial fragment */
+	
 	if (ntohs(ih->frag_off) & IP_OFFSET)
 		return 0;
 
@@ -100,14 +92,6 @@
 	return ret;
 }
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
-/**
- * ipv6_skb_to_auditdata : fill auditdata from skb
- * @skb : the skb
- * @ad : the audit data to fill
- * @proto : the layer 4 protocol
- *
- * return  0 on success
- */
 int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		struct common_audit_data *ad, u8 *proto)
 {
@@ -122,8 +106,6 @@
 	ad->u.net->v6info.saddr = ip6->saddr;
 	ad->u.net->v6info.daddr = ip6->daddr;
 	ret = 0;
-	/* IPv6 can have several extension header before the Transport header
-	 * skip them */
 	offset = skb_network_offset(skb);
 	offset += sizeof(*ip6);
 	nexthdr = ip6->nexthdr;
@@ -203,11 +185,6 @@
 		audit_log_format(ab, " %s=%d", name2, ntohs(port));
 }
 
-/**
- * dump_common_audit_data - helper to dump common audit data
- * @a : common audit data
- *
- */
 static void dump_common_audit_data(struct audit_buffer *ab,
 				   struct common_audit_data *a)
 {
@@ -351,7 +328,7 @@
 		if (a->u.net->netif > 0) {
 			struct net_device *dev;
 
-			/* NOTE: we always use init's namespace */
+			
 			dev = dev_get_by_index(&init_net, a->u.net->netif);
 			if (dev) {
 				audit_log_format(ab, " netif=%s", dev->name);
@@ -372,18 +349,9 @@
 		audit_log_format(ab, " kmod=");
 		audit_log_untrustedstring(ab, a->u.kmod_name);
 		break;
-	} /* switch (a->type) */
+	} 
 }
 
-/**
- * common_lsm_audit - generic LSM auditing function
- * @a:  auxiliary audit data
- * @pre_audit: lsm-specific pre-audit callback
- * @post_audit: lsm-specific post-audit callback
- *
- * setup the audit buffer for common security information
- * uses callback to print LSM specific information
- */
 void common_lsm_audit(struct common_audit_data *a,
 	void (*pre_audit)(struct audit_buffer *, void *),
 	void (*post_audit)(struct audit_buffer *, void *))
@@ -392,7 +360,7 @@
 
 	if (a == NULL)
 		return;
-	/* we use GFP_ATOMIC so we won't sleep */
+	
 	ab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_AVC);
 
 	if (ab == NULL)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/security.c monarudo-jb-3.4.10-e22f38b/security/security.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/security.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/security.c	2013-08-01 23:38:04.000000000 -0600
@@ -24,7 +24,6 @@
 
 #define MAX_LSM_EVM_XATTR	2
 
-/* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
@@ -35,7 +34,7 @@
 
 static inline int __init verify(struct security_operations *ops)
 {
-	/* verify the security_operations structure exists */
+	
 	if (!ops)
 		return -EINVAL;
 	security_fixup_ops(ops);
@@ -52,11 +51,6 @@
 	}
 }
 
-/**
- * security_init - initializes the security framework
- *
- * This should be called early in the kernel initialization sequence.
- */
 int __init security_init(void)
 {
 	printk(KERN_INFO "Security Framework initialized\n");
@@ -73,7 +67,6 @@
 	security_ops = &default_security_ops;
 }
 
-/* Save user chosen LSM */
 static int __init choose_lsm(char *str)
 {
 	strncpy(chosen_lsm, str, SECURITY_NAME_MAX);
@@ -81,37 +74,11 @@
 }
 __setup("security=", choose_lsm);
 
-/**
- * security_module_enable - Load given security module on boot ?
- * @ops: a pointer to the struct security_operations that is to be checked.
- *
- * Each LSM must pass this method before registering its own operations
- * to avoid security registration races. This method may also be used
- * to check if your LSM is currently loaded during kernel initialization.
- *
- * Return true if:
- *	-The passed LSM is the one chosen by user at boot time,
- *	-or the passed LSM is configured as the default and the user did not
- *	 choose an alternate LSM at boot time.
- * Otherwise, return false.
- */
 int __init security_module_enable(struct security_operations *ops)
 {
 	return !strcmp(ops->name, chosen_lsm);
 }
 
-/**
- * register_security - registers a security framework with the kernel
- * @ops: a pointer to the struct security_options that is to be registered
- *
- * This function allows a security module to register itself with the
- * kernel security subsystem.  Some rudimentary checking is done on the @ops
- * value passed to this function. You'll need to check first if your LSM
- * is allowed to register its @ops by calling security_module_enable(@ops).
- *
- * If there is already a security module registered with the kernel,
- * an error will be returned.  Otherwise %0 is returned on success.
- */
 int __init register_security(struct security_operations *ops)
 {
 	if (verify(ops)) {
@@ -128,7 +95,26 @@
 	return 0;
 }
 
-/* Security operations */
+
+int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return security_ops->binder_set_context_mgr(mgr);
+}
+
+int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return security_ops->binder_transaction(from, to);
+}
+
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return security_ops->binder_transfer_binder(from, to);
+}
+
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return security_ops->binder_transfer_file(from, to, file);
+}
 
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
@@ -1193,7 +1179,7 @@
 }
 EXPORT_SYMBOL(security_tun_dev_attach);
 
-#endif	/* CONFIG_SECURITY_NETWORK */
+#endif	
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 
@@ -1231,10 +1217,6 @@
 {
 	if (!polsec)
 		return 0;
-	/*
-	 * We want the context to be taken from secid which is usually
-	 * from the sock.
-	 */
 	return security_ops->xfrm_state_alloc_security(x, NULL, secid);
 }
 
@@ -1274,7 +1256,7 @@
 }
 EXPORT_SYMBOL(security_skb_classify_flow);
 
-#endif	/* CONFIG_SECURITY_NETWORK_XFRM */
+#endif	
 
 #ifdef CONFIG_KEYS
 
@@ -1300,7 +1282,7 @@
 	return security_ops->key_getsecurity(key, _buffer);
 }
 
-#endif	/* CONFIG_KEYS */
+#endif	
 
 #ifdef CONFIG_AUDIT
 
@@ -1325,4 +1307,4 @@
 	return security_ops->audit_rule_match(secid, field, op, lsmrule, actx);
 }
 
-#endif /* CONFIG_AUDIT */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/avc.c monarudo-jb-3.4.10-e22f38b/security/selinux/avc.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/avc.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/avc.c	2013-08-01 23:38:04.000000000 -0600
@@ -52,16 +52,16 @@
 
 struct avc_node {
 	struct avc_entry	ae;
-	struct hlist_node	list; /* anchored in avc_cache->slots[i] */
+	struct hlist_node	list; 
 	struct rcu_head		rhead;
 };
 
 struct avc_cache {
-	struct hlist_head	slots[AVC_CACHE_SLOTS]; /* head for avc_node->list */
-	spinlock_t		slots_lock[AVC_CACHE_SLOTS]; /* lock for writes */
-	atomic_t		lru_hint;	/* LRU hint for reclaim scan */
+	struct hlist_head	slots[AVC_CACHE_SLOTS]; 
+	spinlock_t		slots_lock[AVC_CACHE_SLOTS]; 
+	atomic_t		lru_hint;	
 	atomic_t		active_nodes;
-	u32			latest_notif;	/* latest revocation notification */
+	u32			latest_notif;	
 };
 
 struct avc_callback_node {
@@ -76,7 +76,6 @@
 	struct avc_callback_node *next;
 };
 
-/* Exported via selinufs */
 unsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;
 
 #ifdef CONFIG_SECURITY_SELINUX_AVC_STATS
@@ -92,11 +91,6 @@
 	return (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);
 }
 
-/**
- * avc_dump_av - Display an access vector in human-readable form.
- * @tclass: target security class
- * @av: access vector
- */
 static void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)
 {
 	const char **perms;
@@ -127,12 +121,6 @@
 	audit_log_format(ab, " }");
 }
 
-/**
- * avc_dump_query - Display a SID pair and a class in human-readable form.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- */
 static void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)
 {
 	int rc;
@@ -159,11 +147,6 @@
 	audit_log_format(ab, " tclass=%s", secclass_map[tclass-1].name);
 }
 
-/**
- * avc_init - Initialize the AVC.
- *
- * Initialize the access vector cache.
- */
 void __init avc_init(void)
 {
 	int i;
@@ -323,18 +306,6 @@
 	return ret;
 }
 
-/**
- * avc_lookup - Look up an AVC entry.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- *
- * Look up an AVC entry that is valid for the
- * (@ssid, @tsid), interpreting the permissions
- * based on @tclass.  If a valid AVC entry exists,
- * then this function returns the avc_node.
- * Otherwise, this function returns NULL.
- */
 static struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)
 {
 	struct avc_node *node;
@@ -371,23 +342,6 @@
 	return ret;
 }
 
-/**
- * avc_insert - Insert an AVC entry.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @avd: resulting av decision
- *
- * Insert an AVC entry for the SID pair
- * (@ssid, @tsid) and class @tclass.
- * The access vectors and the sequence number are
- * normally provided by the security server in
- * response to a security_compute_av() call.  If the
- * sequence number @avd->seqno is not less than the latest
- * revocation notification, then the function copies
- * the access vectors into a cache entry, returns
- * avc_node inserted. Otherwise, this function returns NULL.
- */
 static struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)
 {
 	struct avc_node *pos, *node = NULL;
@@ -426,12 +380,6 @@
 	return node;
 }
 
-/**
- * avc_audit_pre_callback - SELinux specific information
- * will be called by generic audit code
- * @ab: the audit buffer
- * @a: audit_data
- */
 static void avc_audit_pre_callback(struct audit_buffer *ab, void *a)
 {
 	struct common_audit_data *ad = a;
@@ -442,12 +390,6 @@
 	audit_log_format(ab, " for ");
 }
 
-/**
- * avc_audit_post_callback - SELinux specific information
- * will be called by generic audit code
- * @ab: the audit buffer
- * @a: audit_data
- */
 static void avc_audit_post_callback(struct audit_buffer *ab, void *a)
 {
 	struct common_audit_data *ad = a;
@@ -457,7 +399,6 @@
 			   ad->selinux_audit_data->slad->tclass);
 }
 
-/* This is the slow part of avc audit with big stack footprint */
 static noinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,
 		u32 requested, u32 audited, u32 denied,
 		struct common_audit_data *a,
@@ -473,13 +414,6 @@
 		a->selinux_audit_data = &sad;
 	}
 
-	/*
-	 * When in a RCU walk do the audit on the RCU retry.  This is because
-	 * the collection of the dname in an inode audit message is not RCU
-	 * safe.  Note this may drop some audits when the situation changes
-	 * during retry. However this is logically just as if the operation
-	 * happened a little later.
-	 */
 	if ((a->type == LSM_AUDIT_DATA_INODE) &&
 	    (flags & MAY_NOT_BLOCK))
 		return -ECHILD;
@@ -496,26 +430,6 @@
 	return 0;
 }
 
-/**
- * avc_audit - Audit the granting or denial of permissions.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @requested: requested permissions
- * @avd: access vector decisions
- * @result: result from avc_has_perm_noaudit
- * @a:  auxiliary audit data
- * @flags: VFS walk flags
- *
- * Audit the granting or denial of permissions in accordance
- * with the policy.  This function is typically called by
- * avc_has_perm() after a permission check, but can also be
- * called directly by callers who use avc_has_perm_noaudit()
- * in order to separate the permission check from the auditing.
- * For example, this separation is useful when the permission check must
- * be performed under a lock, to allow the lock to be released
- * before calling the auditing code.
- */
 inline int avc_audit(u32 ssid, u32 tsid,
 	       u16 tclass, u32 requested,
 	       struct av_decision *avd, int result, struct common_audit_data *a,
@@ -525,22 +439,6 @@
 	denied = requested & ~avd->allowed;
 	if (unlikely(denied)) {
 		audited = denied & avd->auditdeny;
-		/*
-		 * a->selinux_audit_data->auditdeny is TRICKY!  Setting a bit in
-		 * this field means that ANY denials should NOT be audited if
-		 * the policy contains an explicit dontaudit rule for that
-		 * permission.  Take notice that this is unrelated to the
-		 * actual permissions that were denied.  As an example lets
-		 * assume:
-		 *
-		 * denied == READ
-		 * avd.auditdeny & ACCESS == 0 (not set means explicit rule)
-		 * selinux_audit_data->auditdeny & ACCESS == 1
-		 *
-		 * We will NOT audit the denial even though the denied
-		 * permission was READ and the auditdeny checks were for
-		 * ACCESS
-		 */
 		if (a &&
 		    a->selinux_audit_data->auditdeny &&
 		    !(a->selinux_audit_data->auditdeny & avd->auditdeny))
@@ -557,21 +455,6 @@
 		a, flags);
 }
 
-/**
- * avc_add_callback - Register a callback for security events.
- * @callback: callback function
- * @events: security events
- * @ssid: source security identifier or %SECSID_WILD
- * @tsid: target security identifier or %SECSID_WILD
- * @tclass: target security class
- * @perms: permissions
- *
- * Register a callback function for events in the set @events
- * related to the SID pair (@ssid, @tsid) 
- * and the permissions @perms, interpreting
- * @perms based on @tclass.  Returns %0 on success or
- * -%ENOMEM if insufficient memory exists to add the callback.
- */
 int avc_add_callback(int (*callback)(u32 event, u32 ssid, u32 tsid,
 				     u16 tclass, u32 perms,
 				     u32 *out_retained),
@@ -603,18 +486,6 @@
 	return (x == y || x == SECSID_WILD || y == SECSID_WILD);
 }
 
-/**
- * avc_update_node Update an AVC entry
- * @event : Updating event
- * @perms : Permission mask bits
- * @ssid,@tsid,@tclass : identifier of an AVC entry
- * @seqno : sequence number when decision was made
- *
- * if a valid AVC entry doesn't exist,this function returns -ENOENT.
- * if kmalloc() called internal returns NULL, this function returns -ENOMEM.
- * otherwise, this function updates the AVC entry. The original AVC-entry object
- * will release later by RCU.
- */
 static int avc_update_node(u32 event, u32 perms, u32 ssid, u32 tsid, u16 tclass,
 			   u32 seqno)
 {
@@ -631,7 +502,7 @@
 		goto out;
 	}
 
-	/* Lock the target slot */
+	
 	hvalue = avc_hash(ssid, tsid, tclass);
 
 	head = &avc_cache.slots[hvalue];
@@ -655,9 +526,6 @@
 		goto out_unlock;
 	}
 
-	/*
-	 * Copy and replace original node.
-	 */
 
 	avc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);
 
@@ -689,9 +557,6 @@
 	return rc;
 }
 
-/**
- * avc_flush - Flush the cache
- */
 static void avc_flush(void)
 {
 	struct hlist_head *head;
@@ -706,10 +571,6 @@
 		lock = &avc_cache.slots_lock[i];
 
 		spin_lock_irqsave(lock, flag);
-		/*
-		 * With preemptable RCU, the outer spinlock does not
-		 * prevent RCU grace periods from ending.
-		 */
 		rcu_read_lock();
 		hlist_for_each_entry(node, next, head, list)
 			avc_node_delete(node);
@@ -718,10 +579,6 @@
 	}
 }
 
-/**
- * avc_ss_reset - Flush the cache and revalidate migrated permissions.
- * @seqno: policy sequence number
- */
 int avc_ss_reset(u32 seqno)
 {
 	struct avc_callback_node *c;
@@ -733,8 +590,6 @@
 		if (c->events & AVC_CALLBACK_RESET) {
 			tmprc = c->callback(AVC_CALLBACK_RESET,
 					    0, 0, 0, 0, NULL);
-			/* save the first error encountered for the return
-			   value and continue processing the callbacks */
 			if (!rc)
 				rc = tmprc;
 		}
@@ -744,15 +599,6 @@
 	return rc;
 }
 
-/*
- * Slow-path helper function for avc_has_perm_noaudit,
- * when the avc_node lookup fails. We get called with
- * the RCU read lock held, and need to return with it
- * still held, but drop if for the security compute.
- *
- * Don't inline this, since it's the slow-path and just
- * results in a bigger stack frame.
- */
 static noinline struct avc_node *avc_compute_av(u32 ssid, u32 tsid,
 			 u16 tclass, struct av_decision *avd)
 {
@@ -779,26 +625,6 @@
 }
 
 
-/**
- * avc_has_perm_noaudit - Check permissions but perform no auditing.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @requested: requested permissions, interpreted based on @tclass
- * @flags:  AVC_STRICT or 0
- * @avd: access vector decisions
- *
- * Check the AVC to determine whether the @requested permissions are granted
- * for the SID pair (@ssid, @tsid), interpreting the permissions
- * based on @tclass, and call the security server on a cache miss to obtain
- * a new decision and add it to the cache.  Return a copy of the decisions
- * in @avd.  Return %0 if all @requested permissions are granted,
- * -%EACCES if any permissions are denied, or another -errno upon
- * other errors.  This function is typically called by avc_has_perm(),
- * but may also be called directly to separate permission checking from
- * auditing, e.g. in cases where a lock must be held for the check but
- * should be released for the auditing.
- */
 inline int avc_has_perm_noaudit(u32 ssid, u32 tsid,
 			 u16 tclass, u32 requested,
 			 unsigned flags,
@@ -828,23 +654,6 @@
 	return rc;
 }
 
-/**
- * avc_has_perm - Check permissions and perform any appropriate auditing.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @requested: requested permissions, interpreted based on @tclass
- * @auditdata: auxiliary audit data
- * @flags: VFS walk flags
- *
- * Check the AVC to determine whether the @requested permissions are granted
- * for the SID pair (@ssid, @tsid), interpreting the permissions
- * based on @tclass, and call the security server on a cache miss to obtain
- * a new decision and add it to the cache.  Audit the granting or denial of
- * permissions in accordance with the policy.  Return %0 if all @requested
- * permissions are granted, -%EACCES if any permissions are denied, or
- * another -errno upon other errors.
- */
 int avc_has_perm_flags(u32 ssid, u32 tsid, u16 tclass,
 		       u32 requested, struct common_audit_data *auditdata,
 		       unsigned flags)
@@ -868,19 +677,8 @@
 
 void avc_disable(void)
 {
-	/*
-	 * If you are looking at this because you have realized that we are
-	 * not destroying the avc_node_cachep it might be easy to fix, but
-	 * I don't know the memory barrier semantics well enough to know.  It's
-	 * possible that some other task dereferenced security_ops when
-	 * it still pointed to selinux operations.  If that is the case it's
-	 * possible that it is about to use the avc and is about to need the
-	 * avc_node_cachep.  I know I could wrap the security.c security_ops call
-	 * in an rcu_lock, but seriously, it's not worth it.  Instead I just flush
-	 * the cache and get that memory back.
-	 */
 	if (avc_node_cachep) {
 		avc_flush();
-		/* kmem_cache_destroy(avc_node_cachep); */
+		
 	}
 }
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/hooks.c monarudo-jb-3.4.10-e22f38b/security/selinux/hooks.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/hooks.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/hooks.c	2013-08-01 23:38:04.000000000 -0600
@@ -50,8 +50,8 @@
 #include <linux/netfilter_ipv6.h>
 #include <linux/tty.h>
 #include <net/icmp.h>
-#include <net/ip.h>		/* for local_port_range[] */
-#include <net/tcp.h>		/* struct or_callable used in sock_rcv_skb */
+#include <net/ip.h>		
+#include <net/tcp.h>		
 #include <net/net_namespace.h>
 #include <net/netlabel.h>
 #include <linux/uaccess.h>
@@ -59,14 +59,14 @@
 #include <linux/atomic.h>
 #include <linux/bitops.h>
 #include <linux/interrupt.h>
-#include <linux/netdevice.h>	/* for network interface checks */
+#include <linux/netdevice.h>	
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <linux/dccp.h>
 #include <linux/quota.h>
-#include <linux/un.h>		/* for Unix socket types */
-#include <net/af_unix.h>	/* for Unix socket types */
+#include <linux/un.h>		
+#include <net/af_unix.h>	
 #include <linux/parser.h>
 #include <linux/nfs_mount.h>
 #include <net/ipv6.h>
@@ -97,7 +97,6 @@
 
 extern struct security_operations *security_ops;
 
-/* SECMARK reference count */
 static atomic_t selinux_secmark_refcount = ATOMIC_INIT(0);
 
 #ifdef CONFIG_SECURITY_SELINUX_DEVELOP
@@ -130,24 +129,11 @@
 
 static struct kmem_cache *sel_inode_cache;
 
-/**
- * selinux_secmark_enabled - Check to see if SECMARK is currently enabled
- *
- * Description:
- * This function checks the SECMARK reference counter to see if any SECMARK
- * targets are currently configured, if the reference counter is greater than
- * zero SECMARK is considered to be enabled.  Returns true (1) if SECMARK is
- * enabled, false (0) if SECMARK is disabled.
- *
- */
 static int selinux_secmark_enabled(void)
 {
 	return (atomic_read(&selinux_secmark_refcount) > 0);
 }
 
-/*
- * initialise the security for the init task
- */
 static void cred_init_security(void)
 {
 	struct cred *cred = (struct cred *) current->real_cred;
@@ -161,9 +147,6 @@
 	cred->security = tsec;
 }
 
-/*
- * get the security ID of a set of credentials
- */
 static inline u32 cred_sid(const struct cred *cred)
 {
 	const struct task_security_struct *tsec;
@@ -172,9 +155,6 @@
 	return tsec->sid;
 }
 
-/*
- * get the objective security ID of a task
- */
 static inline u32 task_sid(const struct task_struct *task)
 {
 	u32 sid;
@@ -185,9 +165,6 @@
 	return sid;
 }
 
-/*
- * get the subjective security ID of the current task
- */
 static inline u32 current_sid(void)
 {
 	const struct task_security_struct *tsec = current_security();
@@ -195,7 +172,6 @@
 	return tsec->sid;
 }
 
-/* Allocate and free functions for each kind of security blob. */
 
 static int inode_alloc_security(struct inode *inode)
 {
@@ -281,7 +257,6 @@
 	kfree(sbsec);
 }
 
-/* The file system's label must be initialized prior to use. */
 
 static const char *labeling_behaviors[6] = {
 	"uses xattr",
@@ -360,11 +335,6 @@
 	int rc = 0;
 
 	if (sbsec->behavior == SECURITY_FS_USE_XATTR) {
-		/* Make sure that the xattr handler exists and that no
-		   error other than -ENODATA is returned by getxattr on
-		   the root directory.  -ENODATA is ok, as this may be
-		   the first boot of the SELinux kernel before we have
-		   assigned xattr values to the filesystem. */
 		if (!root_inode->i_op->getxattr) {
 			printk(KERN_WARNING "SELinux: (dev %s, type %s) has no "
 			       "xattr support\n", sb->s_id, sb->s_type->name);
@@ -401,17 +371,13 @@
 	    sbsec->behavior > ARRAY_SIZE(labeling_behaviors))
 		sbsec->flags &= ~SE_SBLABELSUPP;
 
-	/* Special handling for sysfs. Is genfs but also has setxattr handler*/
+	
 	if (strncmp(sb->s_type->name, "sysfs", sizeof("sysfs")) == 0)
 		sbsec->flags |= SE_SBLABELSUPP;
 
-	/* Initialize the root inode. */
+	
 	rc = inode_doinit_with_dentry(root_inode, root);
 
-	/* Initialize any other inodes associated with the superblock, e.g.
-	   inodes created prior to initial policy load or inodes created
-	   during get_sb by a pseudo filesystem that directly
-	   populates itself. */
 	spin_lock(&sbsec->isec_lock);
 next_inode:
 	if (!list_empty(&sbsec->isec_head)) {
@@ -435,11 +401,6 @@
 	return rc;
 }
 
-/*
- * This function should allow an FS to ask what it's mount security
- * options were so it can use those later for submounts, displaying
- * mount options, or whatever.
- */
 static int selinux_get_mnt_opts(const struct super_block *sb,
 				struct security_mnt_opts *opts)
 {
@@ -458,13 +419,13 @@
 		return -EINVAL;
 
 	tmp = sbsec->flags & SE_MNTMASK;
-	/* count the number of mount options for this sb */
+	
 	for (i = 0; i < 8; i++) {
 		if (tmp & 0x01)
 			opts->num_mnt_opts++;
 		tmp >>= 1;
 	}
-	/* Check if the Label support flag is set */
+	
 	if (sbsec->flags & SE_SBLABELSUPP)
 		opts->num_mnt_opts++;
 
@@ -531,25 +492,18 @@
 {
 	char mnt_flags = sbsec->flags & SE_MNTMASK;
 
-	/* check if the old mount command had the same options */
+	
 	if (sbsec->flags & SE_SBINITIALIZED)
 		if (!(sbsec->flags & flag) ||
 		    (old_sid != new_sid))
 			return 1;
 
-	/* check if we were passed the same options twice,
-	 * aka someone passed context=a,context=b
-	 */
 	if (!(sbsec->flags & SE_SBINITIALIZED))
 		if (mnt_flags & flag)
 			return 1;
 	return 0;
 }
 
-/*
- * Allow filesystems with binary mount data to explicitly set mount point
- * labeling information.
- */
 static int selinux_set_mnt_opts(struct super_block *sb,
 				struct security_mnt_opts *opts)
 {
@@ -569,9 +523,6 @@
 
 	if (!ss_initialized) {
 		if (!num_opts) {
-			/* Defer initialization until selinux_complete_init,
-			   after the initial policy is loaded and the security
-			   server is ready to handle calls. */
 			goto out;
 		}
 		rc = -EINVAL;
@@ -580,26 +531,10 @@
 		goto out;
 	}
 
-	/*
-	 * Binary mount data FS will come through this function twice.  Once
-	 * from an explicit call and once from the generic calls from the vfs.
-	 * Since the generic VFS calls will not contain any security mount data
-	 * we need to skip the double mount verification.
-	 *
-	 * This does open a hole in which we will not notice if the first
-	 * mount using this sb set explict options and a second mount using
-	 * this sb does not set any security options.  (The first options
-	 * will be used for both mounts)
-	 */
 	if ((sbsec->flags & SE_SBINITIALIZED) && (sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)
 	    && (num_opts == 0))
 		goto out;
 
-	/*
-	 * parse the mount options, check if they are valid sids.
-	 * also check if someone is trying to mount the same sb more
-	 * than once with different security options.
-	 */
 	for (i = 0; i < num_opts; i++) {
 		u32 sid;
 
@@ -659,7 +594,7 @@
 	}
 
 	if (sbsec->flags & SE_SBINITIALIZED) {
-		/* previously mounted with options, but not on this attempt? */
+		
 		if ((sbsec->flags & SE_MNTMASK) && !num_opts)
 			goto out_double_mount;
 		rc = 0;
@@ -669,7 +604,7 @@
 	if (strcmp(sb->s_type->name, "proc") == 0)
 		sbsec->flags |= SE_SBPROC;
 
-	/* Determine the labeling behavior to use for this filesystem type. */
+	
 	rc = security_fs_use((sbsec->flags & SE_SBPROC) ? "proc" : sb->s_type->name, &sbsec->behavior, &sbsec->sid);
 	if (rc) {
 		printk(KERN_WARNING "%s: security_fs_use(%s) returned %d\n",
@@ -677,7 +612,7 @@
 		goto out;
 	}
 
-	/* sets the context of the superblock for the fs being mounted. */
+	
 	if (fscontext_sid) {
 		rc = may_context_mount_sb_relabel(fscontext_sid, sbsec, cred);
 		if (rc)
@@ -686,11 +621,6 @@
 		sbsec->sid = fscontext_sid;
 	}
 
-	/*
-	 * Switch to using mount point labeling behavior.
-	 * sets the label used on all file below the mountpoint, and will set
-	 * the superblock context if not already set.
-	 */
 	if (context_sid) {
 		if (!fscontext_sid) {
 			rc = may_context_mount_sb_relabel(context_sid, sbsec,
@@ -760,17 +690,13 @@
 	int set_context =	(oldsbsec->flags & CONTEXT_MNT);
 	int set_rootcontext =	(oldsbsec->flags & ROOTCONTEXT_MNT);
 
-	/*
-	 * if the parent was able to be mounted it clearly had no special lsm
-	 * mount options.  thus we can safely deal with this superblock later
-	 */
 	if (!ss_initialized)
 		return;
 
-	/* how can we clone if the old one wasn't set up?? */
+	
 	BUG_ON(!(oldsbsec->flags & SE_SBINITIALIZED));
 
-	/* if fs is reusing a sb, just let its options stand... */
+	
 	if (newsbsec->flags & SE_SBINITIALIZED)
 		return;
 
@@ -817,7 +743,7 @@
 
 	opts->num_mnt_opts = 0;
 
-	/* Standard string-based options. */
+	
 	while ((p = strsep(&options, "|")) != NULL) {
 		int token;
 		substring_t args[MAX_OPT_ARGS];
@@ -927,9 +853,6 @@
 	kfree(rootcontext);
 	return rc;
 }
-/*
- * string mount options parsing and call set the sbsec
- */
 static int superblock_doinit(struct super_block *sb, void *data)
 {
 	int rc = 0;
@@ -990,7 +913,7 @@
 			BUG();
 			return;
 		};
-		/* we need a comma before each option */
+		
 		seq_putc(m, ',');
 		seq_puts(m, prefix);
 		if (has_comma)
@@ -1008,7 +931,7 @@
 
 	rc = selinux_get_mnt_opts(sb, &opts);
 	if (rc) {
-		/* before policy load we may get EINVAL, don't show anything */
+		
 		if (rc == -EINVAL)
 			rc = 0;
 		return rc;
@@ -1137,9 +1060,6 @@
 	if (IS_ERR(path))
 		rc = PTR_ERR(path);
 	else {
-		/* each process gets a /proc/PID/ entry. Strip off the
-		 * PID part to get a valid selinux labeling.
-		 * e.g. /proc/1/net/rpc/nfs -> /net/rpc/nfs */
 		while (path[1] >= '0' && path[1] <= '9') {
 			path[1] = '/';
 			path++;
@@ -1158,7 +1078,6 @@
 }
 #endif
 
-/* The inode's security attributes must be initialized before first use. */
 static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry)
 {
 	struct superblock_security_struct *sbsec = NULL;
@@ -1179,9 +1098,6 @@
 
 	sbsec = inode->i_sb->s_security;
 	if (!(sbsec->flags & SE_SBINITIALIZED)) {
-		/* Defer initialization until selinux_complete_init,
-		   after the initial policy is loaded and the security
-		   server is ready to handle calls. */
 		spin_lock(&sbsec->isec_lock);
 		if (list_empty(&isec->list))
 			list_add(&isec->list, &sbsec->isec_head);
@@ -1196,25 +1112,14 @@
 			break;
 		}
 
-		/* Need a dentry, since the xattr API requires one.
-		   Life would be simpler if we could just pass the inode. */
 		if (opt_dentry) {
-			/* Called from d_instantiate or d_splice_alias. */
+			
 			dentry = dget(opt_dentry);
 		} else {
-			/* Called from selinux_complete_init, try to find a dentry. */
+			
 			dentry = d_find_alias(inode);
 		}
 		if (!dentry) {
-			/*
-			 * this is can be hit on boot when a file is accessed
-			 * before the policy is loaded.  When we load policy we
-			 * may find inodes that have no dentry on the
-			 * sbsec->isec_head list.  No reason to complain as these
-			 * will get fixed up the next time we go through
-			 * inode_doinit with a dentry, before these inodes could
-			 * be used again by userspace.
-			 */
 			goto out_unlock;
 		}
 
@@ -1231,7 +1136,7 @@
 		if (rc == -ERANGE) {
 			kfree(context);
 
-			/* Need a larger buffer.  Query for the right size. */
+			
 			rc = inode->i_op->getxattr(dentry, XATTR_NAME_SELINUX,
 						   NULL, 0);
 			if (rc < 0) {
@@ -1259,7 +1164,7 @@
 				kfree(context);
 				goto out_unlock;
 			}
-			/* Map ENODATA to the default file SID */
+			
 			sid = sbsec->def_sid;
 			rc = 0;
 		} else {
@@ -1281,7 +1186,7 @@
 					       __func__, context, -rc, dev, ino);
 				}
 				kfree(context);
-				/* Leave with the unlabeled SID */
+				
 				rc = 0;
 				break;
 			}
@@ -1293,10 +1198,10 @@
 		isec->sid = isec->task_sid;
 		break;
 	case SECURITY_FS_USE_TRANS:
-		/* Default to the fs SID. */
+		
 		isec->sid = sbsec->sid;
 
-		/* Try to obtain a transition SID. */
+		
 		isec->sclass = inode_mode_to_security_class(inode->i_mode);
 		rc = security_transition_sid(isec->task_sid, sbsec->sid,
 					     isec->sclass, NULL, &sid);
@@ -1308,7 +1213,7 @@
 		isec->sid = sbsec->mntpoint_sid;
 		break;
 	default:
-		/* Default to the fs superblock SID. */
+		
 		isec->sid = sbsec->sid;
 
 		if ((sbsec->flags & SE_SBPROC) && !S_ISLNK(inode->i_mode)) {
@@ -1335,26 +1240,25 @@
 	return rc;
 }
 
-/* Convert a Linux signal to an access vector. */
 static inline u32 signal_to_av(int sig)
 {
 	u32 perm = 0;
 
 	switch (sig) {
 	case SIGCHLD:
-		/* Commonly granted from child to parent. */
+		
 		perm = PROCESS__SIGCHLD;
 		break;
 	case SIGKILL:
-		/* Cannot be caught or ignored */
+		
 		perm = PROCESS__SIGKILL;
 		break;
 	case SIGSTOP:
-		/* Cannot be caught or ignored */
+		
 		perm = PROCESS__SIGSTOP;
 		break;
 	default:
-		/* All other signals. */
+		
 		perm = PROCESS__SIGNAL;
 		break;
 	}
@@ -1362,10 +1266,6 @@
 	return perm;
 }
 
-/*
- * Check permission between a pair of credentials
- * fork check, ptrace check, etc.
- */
 static int cred_has_perm(const struct cred *actor,
 			 const struct cred *target,
 			 u32 perms)
@@ -1375,12 +1275,6 @@
 	return avc_has_perm(asid, tsid, SECCLASS_PROCESS, perms, NULL);
 }
 
-/*
- * Check permission between a pair of tasks, e.g. signal checks,
- * fork check, ptrace check, etc.
- * tsk1 is the actor and tsk2 is the target
- * - this uses the default subjective creds of tsk1
- */
 static int task_has_perm(const struct task_struct *tsk1,
 			 const struct task_struct *tsk2,
 			 u32 perms)
@@ -1395,12 +1289,6 @@
 	return avc_has_perm(sid1, sid2, SECCLASS_PROCESS, perms, NULL);
 }
 
-/*
- * Check permission between current and another task, e.g. signal checks,
- * fork check, ptrace check, etc.
- * current is the actor and tsk2 is the target
- * - this uses current's subjective creds
- */
 static int current_has_perm(const struct task_struct *tsk,
 			    u32 perms)
 {
@@ -1415,7 +1303,6 @@
 #error Fix SELinux to handle capabilities > 63.
 #endif
 
-/* Check whether a task is allowed to use a capability. */
 static int cred_has_capability(const struct cred *cred,
 			       int cap, int audit)
 {
@@ -1455,7 +1342,6 @@
 	return rc;
 }
 
-/* Check whether a task is allowed to use a system operation. */
 static int task_has_system(struct task_struct *tsk,
 			   u32 perms)
 {
@@ -1465,9 +1351,6 @@
 			    SECCLASS_SYSTEM, perms, NULL);
 }
 
-/* Check whether a task has a particular permission to an inode.
-   The 'adp' parameter is optional and allows other audit
-   data to be passed (e.g. the dentry). */
 static int inode_has_perm(const struct cred *cred,
 			  struct inode *inode,
 			  u32 perms,
@@ -1485,6 +1368,11 @@
 	sid = cred_sid(cred);
 	isec = inode->i_security;
 
+	if (unlikely(isec == NULL)) {
+		printk(KERN_WARNING "SELinux: inode->i_security is NULL, return 0 to aovid access isec this NULL pointer");
+		return 0;
+	}
+
 	return avc_has_perm_flags(sid, isec->sid, isec->sclass, perms, adp, flags);
 }
 
@@ -1502,9 +1390,6 @@
 	return inode_has_perm(cred, inode, perms, &ad, flags);
 }
 
-/* Same as inode_has_perm, but pass explicit audit data containing
-   the dentry to help the auditing code to more easily generate the
-   pathname if needed. */
 static inline int dentry_has_perm(const struct cred *cred,
 				  struct dentry *dentry,
 				  u32 av)
@@ -1519,9 +1404,6 @@
 	return inode_has_perm(cred, inode, av, &ad, 0);
 }
 
-/* Same as inode_has_perm, but pass explicit audit data containing
-   the path to help the auditing code to more easily generate the
-   pathname if needed. */
 static inline int path_has_perm(const struct cred *cred,
 				struct path *path,
 				u32 av)
@@ -1536,14 +1418,6 @@
 	return inode_has_perm(cred, inode, av, &ad, 0);
 }
 
-/* Check whether a task can use an open file descriptor to
-   access an inode in a given way.  Check access to the
-   descriptor itself, and then use dentry_has_perm to
-   check a particular permission to the file.
-   Access to the descriptor is implicitly granted if it
-   has the same SID as the process.  If av is zero, then
-   access to the file is not checked, e.g. for cases
-   where only the descriptor is affected like seek. */
 static int file_has_perm(const struct cred *cred,
 			 struct file *file,
 			 u32 av)
@@ -1568,7 +1442,7 @@
 			goto out;
 	}
 
-	/* av is zero if only checking access to the descriptor. */
+	
 	rc = 0;
 	if (av)
 		rc = inode_has_perm(cred, inode, av, &ad, 0);
@@ -1577,7 +1451,6 @@
 	return rc;
 }
 
-/* Check whether a task can create a file. */
 static int may_create(struct inode *dir,
 		      struct dentry *dentry,
 		      u16 tclass)
@@ -1622,7 +1495,6 @@
 			    FILESYSTEM__ASSOCIATE, &ad);
 }
 
-/* Check whether a task can create a key. */
 static int may_create_key(u32 ksid,
 			  struct task_struct *ctx)
 {
@@ -1635,7 +1507,6 @@
 #define MAY_UNLINK	1
 #define MAY_RMDIR	2
 
-/* Check whether a task can link, unlink, or rmdir a file/directory. */
 static int may_link(struct inode *dir,
 		    struct dentry *dentry,
 		    int kind)
@@ -1738,7 +1609,6 @@
 	return 0;
 }
 
-/* Check whether a task can perform a filesystem operation. */
 static int superblock_has_perm(const struct cred *cred,
 			       struct super_block *sb,
 			       u32 perms,
@@ -1751,7 +1621,6 @@
 	return avc_has_perm(sid, sbsec->sid, SECCLASS_FILESYSTEM, perms, ad);
 }
 
-/* Convert a Linux mode and permission mask to an access vector. */
 static inline u32 file_mask_to_av(int mode, int mask)
 {
 	u32 av = 0;
@@ -1779,7 +1648,6 @@
 	return av;
 }
 
-/* Convert a Linux file to an access vector. */
 static inline u32 file_to_av(struct file *file)
 {
 	u32 av = 0;
@@ -1793,19 +1661,12 @@
 			av |= FILE__WRITE;
 	}
 	if (!av) {
-		/*
-		 * Special file opened with flags 3 for ioctl-only use.
-		 */
 		av = FILE__IOCTL;
 	}
 
 	return av;
 }
 
-/*
- * Convert a file to an access vector and include the correct open
- * open permission.
- */
 static inline u32 open_file_to_av(struct file *file)
 {
 	u32 av = file_to_av(file);
@@ -1816,7 +1677,67 @@
 	return av;
 }
 
-/* Hook functions begin here. */
+
+static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+{
+	u32 mysid = current_sid();
+	u32 mgrsid = task_sid(mgr);
+
+	return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER, BINDER__SET_CONTEXT_MGR, NULL);
+}
+
+static int selinux_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	u32 mysid = current_sid();
+	u32 fromsid = task_sid(from);
+	u32 tosid = task_sid(to);
+	int rc;
+
+	if (mysid != fromsid) {
+		rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER, BINDER__IMPERSONATE, NULL);
+		if (rc)
+			return rc;
+	}
+
+	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL, NULL);
+}
+
+static int selinux_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	u32 fromsid = task_sid(from);
+	u32 tosid = task_sid(to);
+	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER, NULL);
+}
+
+static int selinux_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	u32 sid = task_sid(to);
+	struct file_security_struct *fsec = file->f_security;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	struct common_audit_data ad;
+	struct selinux_audit_data sad = {0,};
+	int rc;
+
+	COMMON_AUDIT_DATA_INIT(&ad, PATH);
+	ad.u.path = file->f_path;
+	ad.selinux_audit_data = &sad;
+
+	if (sid != fsec->sid) {
+		rc = avc_has_perm(sid, fsec->sid,
+				  SECCLASS_FD,
+				  FD__USE,
+				  &ad);
+		if (rc)
+			return rc;
+	}
+
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+
+	return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+			    &ad);
+}
 
 static int selinux_ptrace_access_check(struct task_struct *child,
 				     unsigned int mode)
@@ -1874,15 +1795,6 @@
 	return cred_has_perm(old, new, PROCESS__SETCAP);
 }
 
-/*
- * (This comment used to live with the selinux_task_setuid hook,
- * which was removed).
- *
- * Since setuid only affects the current process, and since the SELinux
- * controls are not based on the Linux identity attributes, SELinux does not
- * need to control this operation.  However, SELinux does control the use of
- * the CAP_SETUID and CAP_SETGID capabilities using the capable hook.
- */
 
 static int selinux_capable(const struct cred *cred, struct user_namespace *ns,
 			   int cap, int audit)
@@ -1918,7 +1830,7 @@
 		rc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAGET, NULL);
 		break;
 	default:
-		rc = 0;  /* let the kernel handle invalid cmds */
+		rc = 0;  
 		break;
 	}
 	return rc;
@@ -1936,21 +1848,21 @@
 	int rc;
 
 	switch (type) {
-	case SYSLOG_ACTION_READ_ALL:	/* Read last kernel messages */
-	case SYSLOG_ACTION_SIZE_BUFFER:	/* Return size of the log buffer */
+	case SYSLOG_ACTION_READ_ALL:	
+	case SYSLOG_ACTION_SIZE_BUFFER:	
 		rc = task_has_system(current, SYSTEM__SYSLOG_READ);
 		break;
-	case SYSLOG_ACTION_CONSOLE_OFF:	/* Disable logging to console */
-	case SYSLOG_ACTION_CONSOLE_ON:	/* Enable logging to console */
-	/* Set level of messages printed to console */
+	case SYSLOG_ACTION_CONSOLE_OFF:	
+	case SYSLOG_ACTION_CONSOLE_ON:	
+	
 	case SYSLOG_ACTION_CONSOLE_LEVEL:
 		rc = task_has_system(current, SYSTEM__SYSLOG_CONSOLE);
 		break;
-	case SYSLOG_ACTION_CLOSE:	/* Close log */
-	case SYSLOG_ACTION_OPEN:	/* Open log */
-	case SYSLOG_ACTION_READ:	/* Read from log */
-	case SYSLOG_ACTION_READ_CLEAR:	/* Read/clear last kernel messages */
-	case SYSLOG_ACTION_CLEAR:	/* Clear ring buffer */
+	case SYSLOG_ACTION_CLOSE:	
+	case SYSLOG_ACTION_OPEN:	
+	case SYSLOG_ACTION_READ:	
+	case SYSLOG_ACTION_READ_CLEAR:	
+	case SYSLOG_ACTION_CLEAR:	
 	default:
 		rc = task_has_system(current, SYSTEM__SYSLOG_MOD);
 		break;
@@ -1958,14 +1870,6 @@
 	return rc;
 }
 
-/*
- * Check that a process has enough memory to allocate a new virtual
- * mapping. 0 means there is enough memory for the allocation to
- * succeed and -ENOMEM implies there is not.
- *
- * Do not audit the selinux permission check, as this is applied to all
- * processes that allocate mappings.
- */
 static int selinux_vm_enough_memory(struct mm_struct *mm, long pages)
 {
 	int rc, cap_sys_admin = 0;
@@ -1978,7 +1882,6 @@
 	return __vm_enough_memory(mm, pages, cap_sys_admin);
 }
 
-/* binprm security operations */
 
 static int selinux_bprm_set_creds(struct linux_binprm *bprm)
 {
@@ -1994,8 +1897,6 @@
 	if (rc)
 		return rc;
 
-	/* SELinux context only depends on initial program or script and not
-	 * the script interpreter */
 	if (bprm->cred_prepared)
 		return 0;
 
@@ -2003,21 +1904,21 @@
 	new_tsec = bprm->cred->security;
 	isec = inode->i_security;
 
-	/* Default to the current task SID. */
+	
 	new_tsec->sid = old_tsec->sid;
 	new_tsec->osid = old_tsec->sid;
 
-	/* Reset fs, key, and sock SIDs on execve. */
+	
 	new_tsec->create_sid = 0;
 	new_tsec->keycreate_sid = 0;
 	new_tsec->sockcreate_sid = 0;
 
 	if (old_tsec->exec_sid) {
 		new_tsec->sid = old_tsec->exec_sid;
-		/* Reset exec SID on execve. */
+		
 		new_tsec->exec_sid = 0;
 	} else {
-		/* Check for a default transition on this program. */
+		
 		rc = security_transition_sid(old_tsec->sid, isec->sid,
 					     SECCLASS_PROCESS, NULL,
 					     &new_tsec->sid);
@@ -2038,7 +1939,7 @@
 		if (rc)
 			return rc;
 	} else {
-		/* Check permissions for the transition. */
+		
 		rc = avc_has_perm(old_tsec->sid, new_tsec->sid,
 				  SECCLASS_PROCESS, PROCESS__TRANSITION, &ad);
 		if (rc)
@@ -2049,7 +1950,7 @@
 		if (rc)
 			return rc;
 
-		/* Check for shared state */
+		
 		if (bprm->unsafe & LSM_UNSAFE_SHARE) {
 			rc = avc_has_perm(old_tsec->sid, new_tsec->sid,
 					  SECCLASS_PROCESS, PROCESS__SHARE,
@@ -2058,8 +1959,6 @@
 				return -EPERM;
 		}
 
-		/* Make sure that anyone attempting to ptrace over a task that
-		 * changes its SID has the appropriate permit */
 		if (bprm->unsafe &
 		    (LSM_UNSAFE_PTRACE | LSM_UNSAFE_PTRACE_CAP)) {
 			struct task_struct *tracer;
@@ -2083,7 +1982,7 @@
 			}
 		}
 
-		/* Clear any possibly unsafe personality bits on exec: */
+		
 		bprm->per_clear |= PER_CLEAR_ON_SETID;
 	}
 
@@ -2100,9 +1999,6 @@
 	osid = tsec->osid;
 
 	if (osid != sid) {
-		/* Enable secure mode for SIDs transitions unless
-		   the noatsecure permission is granted between
-		   the two SIDs, i.e. ahp returns 0. */
 		atsecure = avc_has_perm(osid, sid,
 					SECCLASS_PROCESS,
 					PROCESS__NOATSECURE, NULL);
@@ -2111,7 +2007,6 @@
 	return (atsecure || cap_bprm_secureexec(bprm));
 }
 
-/* Derived from fs/exec.c:flush_old_files. */
 static inline void flush_unauthorized_files(const struct cred *cred,
 					    struct files_struct *files)
 {
@@ -2130,11 +2025,6 @@
 			struct tty_file_private *file_priv;
 			struct inode *inode;
 
-			/* Revalidate access to controlling tty.
-			   Use inode_has_perm on the tty inode directly rather
-			   than using file_has_perm, as this particular open
-			   file may belong to another process and we are only
-			   interested in the inode-based check here. */
 			file_priv = list_first_entry(&tty->tty_files,
 						struct tty_file_private, list);
 			file = file_priv->file;
@@ -2147,11 +2037,11 @@
 		spin_unlock(&tty_files_lock);
 		tty_kref_put(tty);
 	}
-	/* Reset controlling tty. */
+	
 	if (drop_tty)
 		no_tty();
 
-	/* Revalidate access to inherited open files. */
+	
 
 	COMMON_AUDIT_DATA_INIT(&ad, INODE);
 	ad.selinux_audit_data = &sad;
@@ -2211,9 +2101,6 @@
 	spin_unlock(&files->file_lock);
 }
 
-/*
- * Prepare a process for imminent new credential changes due to exec
- */
 static void selinux_bprm_committing_creds(struct linux_binprm *bprm)
 {
 	struct task_security_struct *new_tsec;
@@ -2224,26 +2111,16 @@
 	if (new_tsec->sid == new_tsec->osid)
 		return;
 
-	/* Close files for which the new task SID is not authorized. */
+	
 	flush_unauthorized_files(bprm->cred, current->files);
 
-	/* Always clear parent death signal on SID transitions. */
+	
 	current->pdeath_signal = 0;
 
-	/* Check whether the new SID can inherit resource limits from the old
-	 * SID.  If not, reset all soft limits to the lower of the current
-	 * task's hard limit and the init task's soft limit.
-	 *
-	 * Note that the setting of hard limits (even to lower them) can be
-	 * controlled by the setrlimit check.  The inclusion of the init task's
-	 * soft limit into the computation is to avoid resetting soft limits
-	 * higher than the default soft limit for cases where the default is
-	 * lower than the hard limit, e.g. RLIMIT_CORE or RLIMIT_STACK.
-	 */
 	rc = avc_has_perm(new_tsec->osid, new_tsec->sid, SECCLASS_PROCESS,
 			  PROCESS__RLIMITINH, NULL);
 	if (rc) {
-		/* protect against do_prlimit() */
+		
 		task_lock(current);
 		for (i = 0; i < RLIM_NLIMITS; i++) {
 			rlim = current->signal->rlim + i;
@@ -2255,10 +2132,6 @@
 	}
 }
 
-/*
- * Clean up the process immediately after the installation of new credentials
- * due to exec
- */
 static void selinux_bprm_committed_creds(struct linux_binprm *bprm)
 {
 	const struct task_security_struct *tsec = current_security();
@@ -2272,13 +2145,6 @@
 	if (sid == osid)
 		return;
 
-	/* Check whether the new SID can inherit signal state from the old SID.
-	 * If not, clear itimers to avoid subsequent signal generation and
-	 * flush and unblock signals.
-	 *
-	 * This must occur _after_ the task SID has been updated so that any
-	 * kill done after the flush will be checked against the new SID.
-	 */
 	rc = avc_has_perm(osid, sid, SECCLASS_PROCESS, PROCESS__SIGINH, NULL);
 	if (rc) {
 		memset(&itimer, 0, sizeof itimer);
@@ -2293,14 +2159,11 @@
 		spin_unlock_irq(&current->sighand->siglock);
 	}
 
-	/* Wake up the parent if it is waiting so that it can recheck
-	 * wait permission to the new task SID. */
 	read_lock(&tasklist_lock);
 	__wake_up_parent(current, current->real_parent);
 	read_unlock(&tasklist_lock);
 }
 
-/* superblock security operations */
 
 static int selinux_sb_alloc_security(struct super_block *sb)
 {
@@ -2499,7 +2362,7 @@
 	if (rc)
 		return rc;
 
-	/* Allow all mounts performed by the kernel */
+	
 	if (flags & MS_KERNMOUNT)
 		return 0;
 
@@ -2544,7 +2407,6 @@
 				   FILESYSTEM__UNMOUNT, NULL);
 }
 
-/* inode security operations */
 
 static int selinux_inode_alloc_security(struct inode *inode)
 {
@@ -2590,7 +2452,7 @@
 		}
 	}
 
-	/* Possibly defer initialization to selinux_complete_init. */
+	
 	if (sbsec->flags & SE_SBINITIALIZED) {
 		struct inode_security_struct *isec = inode->i_security;
 		isec->sclass = inode_mode_to_security_class(inode->i_mode);
@@ -2688,7 +2550,7 @@
 	from_access = mask & MAY_ACCESS;
 	mask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);
 
-	/* No permission to check.  Existence test. */
+	
 	if (!mask)
 		return 0;
 
@@ -2709,7 +2571,7 @@
 	const struct cred *cred = current_cred();
 	unsigned int ia_valid = iattr->ia_valid;
 
-	/* ATTR_FORCE is just used for ATTR_KILL_S[UG]ID. */
+	
 	if (ia_valid & ATTR_FORCE) {
 		ia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_MODE |
 			      ATTR_FORCE);
@@ -2745,14 +2607,10 @@
 			if (!capable(CAP_SETFCAP))
 				return -EPERM;
 		} else if (!capable(CAP_SYS_ADMIN)) {
-			/* A different attribute in the security namespace.
-			   Restrict to administrator. */
 			return -EPERM;
 		}
 	}
 
-	/* Not an attribute we recognize, so just check the
-	   ordinary setattr permission. */
 	return dentry_has_perm(cred, dentry, FILE__SETATTR);
 }
 
@@ -2822,7 +2680,7 @@
 	int rc;
 
 	if (strcmp(name, XATTR_NAME_SELINUX)) {
-		/* Not an attribute we recognize, so nothing to do. */
+		
 		return;
 	}
 
@@ -2857,16 +2715,9 @@
 	if (strcmp(name, XATTR_NAME_SELINUX))
 		return selinux_inode_setotherxattr(dentry, name);
 
-	/* No one is allowed to remove a SELinux security label.
-	   You can change the label, but all data must be labeled. */
 	return -EACCES;
 }
 
-/*
- * Copy the inode security context value to the user.
- *
- * Permission check is handled by selinux_inode_getxattr hook.
- */
 static int selinux_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
 {
 	u32 size;
@@ -2877,15 +2728,6 @@
 	if (strcmp(name, XATTR_SELINUX_SUFFIX))
 		return -EOPNOTSUPP;
 
-	/*
-	 * If the caller has CAP_MAC_ADMIN, then get the raw context
-	 * value even if it is not defined by current policy; otherwise,
-	 * use the in-core value under current policy.
-	 * Use the non-auditing forms of the permission checks since
-	 * getxattr may be called by unprivileged processes commonly
-	 * and lack of permission just means that we fall back to the
-	 * in-core context value, not a denial.
-	 */
 	error = selinux_capable(current_cred(), &init_user_ns, CAP_MAC_ADMIN,
 				SECURITY_CAP_NOAUDIT);
 	if (!error)
@@ -2941,14 +2783,13 @@
 	*secid = isec->sid;
 }
 
-/* file security operations */
 
 static int selinux_revalidate_file_permission(struct file *file, int mask)
 {
 	const struct cred *cred = current_cred();
 	struct inode *inode = file->f_path.dentry->d_inode;
 
-	/* file_mask_to_av won't add FILE__WRITE if MAY_APPEND is set */
+	
 	if ((file->f_flags & O_APPEND) && (mask & MAY_WRITE))
 		mask |= MAY_APPEND;
 
@@ -2964,12 +2805,12 @@
 	u32 sid = current_sid();
 
 	if (!mask)
-		/* No permission to check.  Existence test. */
+		
 		return 0;
 
 	if (sid == fsec->sid && fsec->isid == isec->sid &&
 	    fsec->pseqno == avc_policy_seqno())
-		/* No change since dentry_open check. */
+		
 		return 0;
 
 	return selinux_revalidate_file_permission(file, mask);
@@ -2993,26 +2834,26 @@
 
 	switch (cmd) {
 	case FIONREAD:
-	/* fall through */
+	
 	case FIBMAP:
-	/* fall through */
+	
 	case FIGETBSZ:
-	/* fall through */
+	
 	case FS_IOC_GETFLAGS:
-	/* fall through */
+	
 	case FS_IOC_GETVERSION:
 		error = file_has_perm(cred, file, FILE__GETATTR);
 		break;
 
 	case FS_IOC_SETFLAGS:
-	/* fall through */
+	
 	case FS_IOC_SETVERSION:
 		error = file_has_perm(cred, file, FILE__SETATTR);
 		break;
 
-	/* sys_ioctl() checks */
+	
 	case FIONBIO:
-	/* fall through */
+	
 	case FIOASYNC:
 		error = file_has_perm(cred, file, 0);
 		break;
@@ -3023,9 +2864,6 @@
 					    SECURITY_CAP_AUDIT);
 		break;
 
-	/* default case assumes that the command will go
-	 * to the file's ioctl() function.
-	 */
 	default:
 		error = file_has_perm(cred, file, FILE__IOCTL);
 	}
@@ -3041,21 +2879,16 @@
 
 	if (default_noexec &&
 	    (prot & PROT_EXEC) && (!file || (!shared && (prot & PROT_WRITE)))) {
-		/*
-		 * We are making executable an anonymous mapping or a
-		 * private file mapping that will also be writable.
-		 * This has an additional check.
-		 */
 		rc = cred_has_perm(cred, cred, PROCESS__EXECMEM);
 		if (rc)
 			goto error;
 	}
 
 	if (file) {
-		/* read access is always possible with a mapping */
+		
 		u32 av = FILE__READ;
 
-		/* write access only matters if the mapping is shared */
+		
 		if (shared && (prot & PROT_WRITE))
 			av |= FILE__WRITE;
 
@@ -3076,12 +2909,6 @@
 	int rc = 0;
 	u32 sid = current_sid();
 
-	/*
-	 * notice that we are intentionally putting the SELinux check before
-	 * the secondary cap_file_mmap check.  This is such a likely attempt
-	 * at bad behaviour/exploit that we always want to get the AVC, even
-	 * if DAC would have also denied the operation.
-	 */
 	if (addr < CONFIG_LSM_MMAP_MIN_ADDR) {
 		rc = avc_has_perm(sid, sid, SECCLASS_MEMPROTECT,
 				  MEMPROTECT__MMAP_ZERO, NULL);
@@ -3089,7 +2916,7 @@
 			return rc;
 	}
 
-	/* do DAC check on address space usage */
+	
 	rc = cap_file_mmap(file, reqprot, prot, flags, addr, addr_only);
 	if (rc || addr_only)
 		return rc;
@@ -3161,13 +2988,13 @@
 			err = file_has_perm(cred, file, FILE__WRITE);
 			break;
 		}
-		/* fall through */
+		
 	case F_SETOWN:
 	case F_SETSIG:
 	case F_GETFL:
 	case F_GETOWN:
 	case F_GETSIG:
-		/* Just check FD__USE permission */
+		
 		err = file_has_perm(cred, file, 0);
 		break;
 	case F_GETLK:
@@ -3207,13 +3034,13 @@
 	u32 perm;
 	struct file_security_struct *fsec;
 
-	/* struct fown_struct is never outside the context of a struct file */
+	
 	file = container_of(fown, struct file, f_owner);
 
 	fsec = file->f_security;
 
 	if (!signum)
-		perm = signal_to_av(SIGIO); /* as per send_sigio_to_task */
+		perm = signal_to_av(SIGIO); 
 	else
 		perm = signal_to_av(signum);
 
@@ -3237,36 +3064,17 @@
 	inode = file->f_path.dentry->d_inode;
 	fsec = file->f_security;
 	isec = inode->i_security;
-	/*
-	 * Save inode label and policy sequence number
-	 * at open-time so that selinux_file_permission
-	 * can determine whether revalidation is necessary.
-	 * Task label is already saved in the file security
-	 * struct as its SID.
-	 */
 	fsec->isid = isec->sid;
 	fsec->pseqno = avc_policy_seqno();
-	/*
-	 * Since the inode label or policy seqno may have changed
-	 * between the selinux_inode_permission check and the saving
-	 * of state above, recheck that access is still permitted.
-	 * Otherwise, access might never be revalidated against the
-	 * new inode label or new policy.
-	 * This check is not redundant - do not remove.
-	 */
 	return inode_has_perm_noadp(cred, inode, open_file_to_av(file), 0);
 }
 
-/* task security operations */
 
 static int selinux_task_create(unsigned long clone_flags)
 {
 	return current_has_perm(current, PROCESS__FORK);
 }
 
-/*
- * allocate the SELinux part of blank credentials
- */
 static int selinux_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	struct task_security_struct *tsec;
@@ -3279,25 +3087,15 @@
 	return 0;
 }
 
-/*
- * detach and free the LSM part of a set of credentials
- */
 static void selinux_cred_free(struct cred *cred)
 {
 	struct task_security_struct *tsec = cred->security;
 
-	/*
-	 * cred->security == NULL if security_cred_alloc_blank() or
-	 * security_prepare_creds() returned an error.
-	 */
 	BUG_ON(cred->security && (unsigned long) cred->security < PAGE_SIZE);
 	cred->security = (void *) 0x7UL;
 	kfree(tsec);
 }
 
-/*
- * prepare a new set of credentials for modification
- */
 static int selinux_cred_prepare(struct cred *new, const struct cred *old,
 				gfp_t gfp)
 {
@@ -3314,9 +3112,6 @@
 	return 0;
 }
 
-/*
- * transfer the SELinux data to a blank set of creds
- */
 static void selinux_cred_transfer(struct cred *new, const struct cred *old)
 {
 	const struct task_security_struct *old_tsec = old->security;
@@ -3325,10 +3120,6 @@
 	*tsec = *old_tsec;
 }
 
-/*
- * set the security data for a kernel service
- * - all the creation contexts are set to unlabelled
- */
 static int selinux_kernel_act_as(struct cred *new, u32 secid)
 {
 	struct task_security_struct *tsec = new->security;
@@ -3348,10 +3139,6 @@
 	return ret;
 }
 
-/*
- * set the file creation context in a security record to the same as the
- * objective context of the specified inode
- */
 static int selinux_kernel_create_files_as(struct cred *new, struct inode *inode)
 {
 	struct inode_security_struct *isec = inode->i_security;
@@ -3437,10 +3224,6 @@
 {
 	struct rlimit *old_rlim = p->signal->rlim + resource;
 
-	/* Control the ability to change the hard limit (whether
-	   lowering or raising it), so that the hard limit can
-	   later be used as a safe reset point for the soft limit
-	   upon context transitions.  See selinux_bprm_committing_creds. */
 	if (old_rlim->rlim_max != new_rlim->rlim_max)
 		return current_has_perm(p, PROCESS__SETRLIMIT);
 
@@ -3475,7 +3258,7 @@
 	int rc;
 
 	if (!sig)
-		perm = PROCESS__SIGNULL; /* null signal; existence test */
+		perm = PROCESS__SIGNULL; 
 	else
 		perm = signal_to_av(sig);
 	if (secid)
@@ -3501,7 +3284,6 @@
 	isec->initialized = 1;
 }
 
-/* Returns error only if unable to parse addresses */
 static int selinux_parse_skb_ipv4(struct sk_buff *skb,
 			struct common_audit_data *ad, u8 *proto)
 {
@@ -3582,7 +3364,6 @@
 
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 
-/* Returns error only if unable to parse addresses */
 static int selinux_parse_skb_ipv6(struct sk_buff *skb,
 			struct common_audit_data *ad, u8 *proto)
 {
@@ -3646,7 +3427,7 @@
 		break;
 	}
 
-	/* includes fragments */
+	
 	default:
 		break;
 	}
@@ -3654,7 +3435,7 @@
 	return ret;
 }
 
-#endif /* IPV6 */
+#endif 
 
 static int selinux_parse_skb(struct sk_buff *skb, struct common_audit_data *ad,
 			     char **_addrp, int src, u8 *proto)
@@ -3679,7 +3460,7 @@
 		addrp = (char *)(src ? &ad->u.net->v6info.saddr :
 				       &ad->u.net->v6info.daddr);
 		goto okay;
-#endif	/* IPV6 */
+#endif	
 	default:
 		addrp = NULL;
 		goto okay;
@@ -3697,21 +3478,6 @@
 	return 0;
 }
 
-/**
- * selinux_skb_peerlbl_sid - Determine the peer label of a packet
- * @skb: the packet
- * @family: protocol family
- * @sid: the packet's peer label SID
- *
- * Description:
- * Check the various different forms of network peer labeling and determine
- * the peer label/SID for the packet; most of the magic actually occurs in
- * the security server function security_net_peersid_cmp().  The function
- * returns zero if the value in @sid is valid (although it may be SECSID_NULL)
- * or -EACCES if @sid is invalid due to inconsistencies with the different
- * peer labels.
- *
- */
 static int selinux_skb_peerlbl_sid(struct sk_buff *skb, u16 family, u32 *sid)
 {
 	int err;
@@ -3733,7 +3499,6 @@
 	return 0;
 }
 
-/* socket security operations */
 
 static int socket_sockcreate_sid(const struct task_security_struct *tsec,
 				 u16 secclass, u32 *socksid)
@@ -3815,9 +3580,6 @@
 	return err;
 }
 
-/* Range of port numbers used to automatically bind.
-   Need to determine whether we should perform a name_bind
-   permission check between the socket and the port number. */
 
 static int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
@@ -3829,11 +3591,6 @@
 	if (err)
 		goto out;
 
-	/*
-	 * If PF_INET or PF_INET6, check name_bind permission for the port.
-	 * Multiple address binding for SCTP is not supported yet: we just
-	 * check the first address now.
-	 */
 	family = sk->sk_family;
 	if (family == PF_INET || family == PF_INET6) {
 		char *addrp;
@@ -3931,9 +3688,6 @@
 	if (err)
 		return err;
 
-	/*
-	 * If a TCP or DCCP socket, check name_connect permission for the port.
-	 */
 	if (sksec->sclass == SECCLASS_TCP_SOCKET ||
 	    sksec->sclass == SECCLASS_DCCP_SOCKET) {
 		struct common_audit_data ad;
@@ -4071,14 +3825,14 @@
 	if (err)
 		return err;
 
-	/* server child socket */
+	
 	sksec_new->peer_sid = sksec_sock->sid;
 	err = security_sid_mls_copy(sksec_other->sid, sksec_sock->sid,
 				    &sksec_new->sid);
 	if (err)
 		return err;
 
-	/* connecting socket */
+	
 	sksec_sock->peer_sid = sksec_new->sid;
 
 	return 0;
@@ -4176,14 +3930,10 @@
 	if (family != PF_INET && family != PF_INET6)
 		return 0;
 
-	/* Handle mapped IPv4 packets arriving via IPv6 sockets */
+	
 	if (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))
 		family = PF_INET;
 
-	/* If any sort of compatibility mode is enabled then handoff processing
-	 * to the selinux_sock_rcv_skb_compat() function to deal with the
-	 * special handling.  We do this in an attempt to keep this function
-	 * as fast and as clean as possible. */
 	if (!selinux_policycap_netpeer)
 		return selinux_sock_rcv_skb_compat(sk, skb, family);
 
@@ -4357,7 +4107,7 @@
 	u32 newsid;
 	u32 peersid;
 
-	/* handle mapped IPv4 packets arriving via IPv6 sockets */
+	
 	if (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))
 		family = PF_INET;
 
@@ -4385,13 +4135,7 @@
 
 	newsksec->sid = req->secid;
 	newsksec->peer_sid = req->peer_secid;
-	/* NOTE: Ideally, we should also get the isec->sid for the
-	   new socket in sync, but we don't have the isec available yet.
-	   So we will wait until sock_graft to do it, by which
-	   time it will have been created and available. */
 
-	/* We don't need to take any sort of lock here as we are the only
-	 * thread with access to newsksec */
 	selinux_netlbl_inet_csk_clone(newsk, req->rsk_ops->family);
 }
 
@@ -4400,7 +4144,7 @@
 	u16 family = sk->sk_family;
 	struct sk_security_struct *sksec = sk->sk_security;
 
-	/* handle mapped IPv4 packets arriving via IPv6 sockets */
+	
 	if (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))
 		family = PF_INET;
 
@@ -4438,12 +4182,6 @@
 {
 	u32 sid = current_sid();
 
-	/* we aren't taking into account the "sockcreate" SID since the socket
-	 * that is being created here is not a socket in the traditional sense,
-	 * instead it is a private sock, accessible only to the kernel, and
-	 * representing a wide range of network traffic spanning multiple
-	 * connections unlike traditional sockets - check the TUN driver to
-	 * get a better understanding of why this socket is special */
 
 	return avc_has_perm(sid, sid, SECCLASS_TUN_SOCKET, TUN_SOCKET__CREATE,
 			    NULL);
@@ -4453,15 +4191,7 @@
 {
 	struct sk_security_struct *sksec = sk->sk_security;
 
-	/* we don't currently perform any NetLabel based labeling here and it
-	 * isn't clear that we would want to do so anyway; while we could apply
-	 * labeling without the support of the TUN user the resulting labeled
-	 * traffic from the other end of the connection would almost certainly
-	 * cause confusion to the TUN user that had no idea network labeling
-	 * protocols were being used */
 
-	/* see the comments in selinux_tun_dev_create() about why we don't use
-	 * the sockcreate SID here */
 
 	sksec->sid = current_sid();
 	sksec->sclass = SECCLASS_TUN_SOCKET;
@@ -4511,7 +4241,7 @@
 				err = 0;
 		}
 
-		/* Ignore */
+		
 		if (err == -ENOENT)
 			err = 0;
 		goto out;
@@ -4572,10 +4302,6 @@
 			return NF_DROP;
 
 	if (netlbl_active)
-		/* we do this in the FORWARD path and not the POST_ROUTING
-		 * path because we want to make sure we apply the necessary
-		 * labeling before IPsec is applied so we can leverage AH
-		 * protection */
 		if (selinux_netlbl_skbuff_setsid(skb, family, peer_sid) != 0)
 			return NF_DROP;
 
@@ -4600,7 +4326,7 @@
 {
 	return selinux_ip_forward(skb, in->ifindex, PF_INET6);
 }
-#endif	/* IPV6 */
+#endif	
 
 static unsigned int selinux_ip_output(struct sk_buff *skb,
 				      u16 family)
@@ -4610,9 +4336,6 @@
 	if (!netlbl_enabled())
 		return NF_ACCEPT;
 
-	/* we do this in the LOCAL_OUT path and not the POST_ROUTING path
-	 * because we want to make sure we apply the necessary labeling
-	 * before IPsec is applied so we can leverage AH protection */
 	if (skb->sk) {
 		struct sk_security_struct *sksec = skb->sk->sk_security;
 		sid = sksec->sid;
@@ -4681,19 +4404,9 @@
 	u8 secmark_active;
 	u8 peerlbl_active;
 
-	/* If any sort of compatibility mode is enabled then handoff processing
-	 * to the selinux_ip_postroute_compat() function to deal with the
-	 * special handling.  We do this in an attempt to keep this function
-	 * as fast and as clean as possible. */
 	if (!selinux_policycap_netpeer)
 		return selinux_ip_postroute_compat(skb, ifindex, family);
 #ifdef CONFIG_XFRM
-	/* If skb->dst->xfrm is non-NULL then the packet is undergoing an IPsec
-	 * packet transformation so allow the packet to pass without any checks
-	 * since we'll have another chance to perform access control checks
-	 * when the packet is on it's final way out.
-	 * NOTE: there appear to be some IPv6 multicast cases where skb->dst
-	 *       is NULL, in this case go ahead and apply access control. */
 	if (skb_dst(skb) != NULL && skb_dst(skb)->xfrm != NULL)
 		return NF_ACCEPT;
 #endif
@@ -4702,10 +4415,6 @@
 	if (!secmark_active && !peerlbl_active)
 		return NF_ACCEPT;
 
-	/* if the packet is being forwarded then get the peer label from the
-	 * packet itself; otherwise check to see if it is from a local
-	 * application or the kernel, if from an application get the peer label
-	 * from the sending socket, otherwise use the kernel's sid */
 	sk = skb->sk;
 	if (sk == NULL) {
 		if (skb->skb_iif) {
@@ -4773,9 +4482,9 @@
 {
 	return selinux_ip_postroute(skb, out->ifindex, PF_INET6);
 }
-#endif	/* IPV6 */
+#endif	
 
-#endif	/* CONFIG_NETFILTER */
+#endif	
 
 static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)
 {
@@ -4863,7 +4572,6 @@
 	msg_msg_free_security(msg);
 }
 
-/* message queue security operations */
 static int selinux_msg_queue_alloc_security(struct msg_queue *msq)
 {
 	struct ipc_security_struct *isec;
@@ -4921,7 +4629,7 @@
 	switch (cmd) {
 	case IPC_INFO:
 	case MSG_INFO:
-		/* No specific object, just general system-wide information. */
+		
 		return task_has_system(current, SYSTEM__IPC_INFO);
 	case IPC_STAT:
 	case MSG_STAT:
@@ -4953,14 +4661,7 @@
 	isec = msq->q_perm.security;
 	msec = msg->security;
 
-	/*
-	 * First time through, need to assign label to the message
-	 */
 	if (msec->sid == SECINITSID_UNLABELED) {
-		/*
-		 * Compute new sid based on current process and
-		 * message queue this message will be stored in
-		 */
 		rc = security_transition_sid(sid, isec->sid, SECCLASS_MSG,
 					     NULL, &msec->sid);
 		if (rc)
@@ -4971,15 +4672,15 @@
 	ad.selinux_audit_data = &sad;
 	ad.u.ipc_id = msq->q_perm.key;
 
-	/* Can this process write to the queue? */
+	
 	rc = avc_has_perm(sid, isec->sid, SECCLASS_MSGQ,
 			  MSGQ__WRITE, &ad);
 	if (!rc)
-		/* Can this process send the message */
+		
 		rc = avc_has_perm(sid, msec->sid, SECCLASS_MSG,
 				  MSG__SEND, &ad);
 	if (!rc)
-		/* Can the message be put in the queue? */
+		
 		rc = avc_has_perm(msec->sid, isec->sid, SECCLASS_MSGQ,
 				  MSGQ__ENQUEUE, &ad);
 
@@ -5012,7 +4713,6 @@
 	return rc;
 }
 
-/* Shared Memory security operations */
 static int selinux_shm_alloc_security(struct shmid_kernel *shp)
 {
 	struct ipc_security_struct *isec;
@@ -5062,7 +4762,6 @@
 			    SHM__ASSOCIATE, &ad);
 }
 
-/* Note, at this point, shp is locked down */
 static int selinux_shm_shmctl(struct shmid_kernel *shp, int cmd)
 {
 	int perms;
@@ -5071,7 +4770,7 @@
 	switch (cmd) {
 	case IPC_INFO:
 	case SHM_INFO:
-		/* No specific object, just general system-wide information. */
+		
 		return task_has_system(current, SYSTEM__IPC_INFO);
 	case IPC_STAT:
 	case SHM_STAT:
@@ -5108,7 +4807,6 @@
 	return ipc_has_perm(&shp->shm_perm, perms);
 }
 
-/* Semaphore security operations */
 static int selinux_sem_alloc_security(struct sem_array *sma)
 {
 	struct ipc_security_struct *isec;
@@ -5158,7 +4856,6 @@
 			    SEM__ASSOCIATE, &ad);
 }
 
-/* Note, at this point, sma is locked down */
 static int selinux_sem_semctl(struct sem_array *sma, int cmd)
 {
 	int err;
@@ -5167,7 +4864,7 @@
 	switch (cmd) {
 	case IPC_INFO:
 	case SEM_INFO:
-		/* No specific object, just general system-wide information. */
+		
 		return task_has_system(current, SYSTEM__IPC_INFO);
 	case GETPID:
 	case GETNCNT:
@@ -5298,16 +4995,9 @@
 	char *str = value;
 
 	if (current != p) {
-		/* SELinux only allows a process to change its own
-		   security attributes. */
 		return -EACCES;
 	}
 
-	/*
-	 * Basic control over ability to set these attributes at all.
-	 * current == p, but we'll pass them separately in case the
-	 * above restriction is ever removed.
-	 */
 	if (!strcmp(name, "exec"))
 		error = current_has_perm(p, PROCESS__SETEXEC);
 	else if (!strcmp(name, "fscreate"))
@@ -5323,7 +5013,7 @@
 	if (error)
 		return error;
 
-	/* Obtain a SID for the context, if one was specified. */
+	
 	if (size && str[1] && str[1] != '\n') {
 		if (str[size-1] == '\n') {
 			str[size-1] = 0;
@@ -5344,12 +5034,6 @@
 	if (!new)
 		return -ENOMEM;
 
-	/* Permission checking based on the specified context is
-	   performed during the actual operation (execve,
-	   open/mkdir/...), when we know the full context of the
-	   operation.  See selinux_bprm_set_creds for the execve
-	   checks and may_create for the file creation checks. The
-	   operation will then fail if the context is not permitted. */
 	tsec = new->security;
 	if (!strcmp(name, "exec")) {
 		tsec->exec_sid = sid;
@@ -5367,7 +5051,7 @@
 		if (sid == 0)
 			goto abort_change;
 
-		/* Only allow single threaded processes to change context */
+		
 		error = -EPERM;
 		if (!current_is_single_threaded()) {
 			error = security_bounded_transition(tsec->sid, sid);
@@ -5375,14 +5059,12 @@
 				goto abort_change;
 		}
 
-		/* Check permissions for the transition. */
+		
 		error = avc_has_perm(tsec->sid, sid, SECCLASS_PROCESS,
 				     PROCESS__DYNTRANSITION, NULL);
 		if (error)
 			goto abort_change;
 
-		/* Check for ptracing, and update the task SID if ok.
-		   Otherwise, leave SID unchanged and fail. */
 		ptsid = 0;
 		task_lock(p);
 		tracer = ptrace_parent(p);
@@ -5426,17 +5108,11 @@
 	kfree(secdata);
 }
 
-/*
- *	called with inode->i_mutex locked
- */
 static int selinux_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
 {
 	return selinux_inode_setsecurity(inode, XATTR_SELINUX_SUFFIX, ctx, ctxlen, 0);
 }
 
-/*
- *	called with inode->i_mutex locked
- */
 static int selinux_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
 {
 	return __vfs_setxattr_noperm(dentry, XATTR_NAME_SELINUX, ctx, ctxlen, 0);
@@ -5490,9 +5166,6 @@
 	struct key_security_struct *ksec;
 	u32 sid;
 
-	/* if no specific permissions are requested, we skip the
-	   permission check. No serious, additional covert channels
-	   appear to be created. */
 	if (perm == 0)
 		return 0;
 
@@ -5523,6 +5196,11 @@
 static struct security_operations selinux_ops = {
 	.name =				"selinux",
 
+	.binder_set_context_mgr =	selinux_binder_set_context_mgr,
+	.binder_transaction =		selinux_binder_transaction,
+	.binder_transfer_binder =	selinux_binder_transfer_binder,
+	.binder_transfer_file =		selinux_binder_transfer_file,
+
 	.ptrace_access_check =		selinux_ptrace_access_check,
 	.ptrace_traceme =		selinux_ptrace_traceme,
 	.capget =			selinux_capget,
@@ -5731,7 +5409,7 @@
 
 	printk(KERN_INFO "SELinux:  Initializing.\n");
 
-	/* Set the security state for the initial task. */
+	
 	cred_init_security();
 
 	default_noexec = !(VM_DATA_DEFAULT_FLAGS & VM_EXEC);
@@ -5761,13 +5439,11 @@
 {
 	printk(KERN_DEBUG "SELinux:  Completing initialization.\n");
 
-	/* Set up any superblocks initialized prior to the policy load. */
+	
 	printk(KERN_DEBUG "SELinux:  Setting up existing superblocks.\n");
 	iterate_supers(delayed_superblock_init, NULL);
 }
 
-/* SELinux requires early initialization in order to label
-   all processes and objects when they are created. */
 security_initcall(selinux_init);
 
 #if defined(CONFIG_NETFILTER)
@@ -5815,7 +5491,7 @@
 	}
 };
 
-#endif	/* IPV6 */
+#endif	
 
 static int __init selinux_nf_ip_init(void)
 {
@@ -5834,7 +5510,7 @@
 	err = nf_register_hooks(selinux_ipv6_ops, ARRAY_SIZE(selinux_ipv6_ops));
 	if (err)
 		panic("SELinux: nf_register_hooks for IPv6: error %d\n", err);
-#endif	/* IPV6 */
+#endif	
 
 out:
 	return err;
@@ -5850,17 +5526,17 @@
 	nf_unregister_hooks(selinux_ipv4_ops, ARRAY_SIZE(selinux_ipv4_ops));
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 	nf_unregister_hooks(selinux_ipv6_ops, ARRAY_SIZE(selinux_ipv6_ops));
-#endif	/* IPV6 */
+#endif	
 }
 #endif
 
-#else /* CONFIG_NETFILTER */
+#else 
 
 #ifdef CONFIG_SECURITY_SELINUX_DISABLE
 #define selinux_nf_ip_exit()
 #endif
 
-#endif /* CONFIG_NETFILTER */
+#endif 
 
 #ifdef CONFIG_SECURITY_SELINUX_DISABLE
 static int selinux_disabled;
@@ -5868,12 +5544,12 @@
 int selinux_disable(void)
 {
 	if (ss_initialized) {
-		/* Not permitted after initial policy load. */
+		
 		return -EINVAL;
 	}
 
 	if (selinux_disabled) {
-		/* Only do this once. */
+		
 		return -EINVAL;
 	}
 
@@ -5884,13 +5560,13 @@
 
 	reset_security_ops();
 
-	/* Try to destroy the avc node cache */
+	
 	avc_disable();
 
-	/* Unregister netfilter hooks. */
+	
 	selinux_nf_ip_exit();
 
-	/* Unregister selinuxfs. */
+	
 	exit_sel_fs();
 
 	return 0;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/audit.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/audit.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/audit.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/audit.h	2013-08-01 23:38:04.000000000 -0600
@@ -18,48 +18,14 @@
 #ifndef _SELINUX_AUDIT_H
 #define _SELINUX_AUDIT_H
 
-/**
- *	selinux_audit_rule_init - alloc/init an selinux audit rule structure.
- *	@field: the field this rule refers to
- *	@op: the operater the rule uses
- *	@rulestr: the text "target" of the rule
- *	@rule: pointer to the new rule structure returned via this
- *
- *	Returns 0 if successful, -errno if not.  On success, the rule structure
- *	will be allocated internally.  The caller must free this structure with
- *	selinux_audit_rule_free() after use.
- */
 int selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **rule);
 
-/**
- *	selinux_audit_rule_free - free an selinux audit rule structure.
- *	@rule: pointer to the audit rule to be freed
- *
- *	This will free all memory associated with the given rule.
- *	If @rule is NULL, no operation is performed.
- */
 void selinux_audit_rule_free(void *rule);
 
-/**
- *	selinux_audit_rule_match - determine if a context ID matches a rule.
- *	@sid: the context ID to check
- *	@field: the field this rule refers to
- *	@op: the operater the rule uses
- *	@rule: pointer to the audit rule to check against
- *	@actx: the audit context (can be NULL) associated with the check
- *
- *	Returns 1 if the context id matches the rule, 0 if it does not, and
- *	-errno on failure.
- */
 int selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *rule,
 			     struct audit_context *actx);
 
-/**
- *	selinux_audit_rule_known - check to see if rule contains selinux fields.
- *	@rule: rule to be checked
- *	Returns 1 if there are selinux fields specified in the rule, 0 otherwise.
- */
 int selinux_audit_rule_known(struct audit_krule *krule);
 
-#endif /* _SELINUX_AUDIT_H */
+#endif 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/avc.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/avc.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/avc.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/avc.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Access vector cache interface for object managers.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SELINUX_AVC_H_
 #define _SELINUX_AVC_H_
 
@@ -25,9 +20,6 @@
 #define selinux_enforcing 1
 #endif
 
-/*
- * An entry in the AVC.
- */
 struct avc_entry;
 
 struct task_struct;
@@ -35,9 +27,6 @@
 struct sock;
 struct sk_buff;
 
-/*
- * AVC statistics
- */
 struct avc_cache_stats {
 	unsigned int lookups;
 	unsigned int misses;
@@ -46,9 +35,6 @@
 	unsigned int frees;
 };
 
-/*
- * We only need this data after we have decided to send an audit message.
- */
 struct selinux_late_audit_data {
 	u32 ssid;
 	u32 tsid;
@@ -59,21 +45,11 @@
 	int result;
 };
 
-/*
- * We collect this at the beginning or during an selinux security operation
- */
 struct selinux_audit_data {
-	/*
-	 * auditdeny is a bit tricky and unintuitive.  See the
-	 * comments in avc.c for it's meaning and usage.
-	 */
 	u32 auditdeny;
 	struct selinux_late_audit_data *slad;
 };
 
-/*
- * AVC operations
- */
 
 void __init avc_init(void);
 
@@ -83,7 +59,7 @@
 	       int result,
 	      struct common_audit_data *a, unsigned flags);
 
-#define AVC_STRICT 1 /* Ignore permissive mode. */
+#define AVC_STRICT 1 
 int avc_has_perm_noaudit(u32 ssid, u32 tsid,
 			 u16 tclass, u32 requested,
 			 unsigned flags,
@@ -118,16 +94,14 @@
 		     u32 events, u32 ssid, u32 tsid,
 		     u16 tclass, u32 perms);
 
-/* Exported to selinuxfs */
 int avc_get_hash_stats(char *page);
 extern unsigned int avc_cache_threshold;
 
-/* Attempt to free avc node cache */
 void avc_disable(void);
 
 #ifdef CONFIG_SECURITY_SELINUX_AVC_STATS
 DECLARE_PER_CPU(struct avc_cache_stats, avc_cache_stats);
 #endif
 
-#endif /* _SELINUX_AVC_H_ */
+#endif 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/avc_ss.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/avc_ss.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/avc_ss.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/avc_ss.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Access vector cache interface for the security server.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SELINUX_AVC_SS_H_
 #define _SELINUX_AVC_SS_H_
 
@@ -10,7 +5,6 @@
 
 int avc_ss_reset(u32 seqno);
 
-/* Class/perm mapping support */
 struct security_class_mapping {
 	const char *name;
 	const char *perms[sizeof(u32) * 8 + 1];
@@ -18,11 +12,7 @@
 
 extern struct security_class_mapping secclass_map[];
 
-/*
- * The security server must be initialized before
- * any labeling or access decisions can be provided.
- */
 extern int ss_initialized;
 
-#endif /* _SELINUX_AVC_SS_H_ */
+#endif 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/classmap.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/classmap.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/classmap.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/classmap.h	2013-08-01 23:38:04.000000000 -0600
@@ -12,10 +12,6 @@
 #define COMMON_IPC_PERMS "create", "destroy", "getattr", "setattr", "read", \
 	    "write", "associate", "unix_read", "unix_write"
 
-/*
- * Note: The name for any socket class should be suffixed by "socket",
- *	 and doesn't contain more than one substr of "socket".
- */
 struct security_class_mapping secclass_map[] = {
 	{ "security",
 	  { "compute_av", "compute_create", "compute_member",
@@ -149,5 +145,6 @@
 	{ "kernel_service", { "use_as_override", "create_files_as", NULL } },
 	{ "tun_socket",
 	  { COMMON_SOCK_PERMS, NULL } },
+	{ "binder", { "impersonate", "call", "set_context_mgr", "transfer", NULL } },
 	{ NULL }
   };
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/initial_sid_to_string.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/initial_sid_to_string.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/initial_sid_to_string.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/initial_sid_to_string.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,4 +1,3 @@
-/* This file is automatically generated.  Do not edit. */
 static const char *initial_sid_to_string[] =
 {
     "null",
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netif.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/netif.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netif.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/netif.h	2013-08-01 23:38:04.000000000 -0600
@@ -19,5 +19,5 @@
 
 int sel_netif_sid(int ifindex, u32 *sid);
 
-#endif	/* _SELINUX_NETIF_H_ */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netlabel.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/netlabel.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netlabel.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/netlabel.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,3 @@
-/*
- * SELinux interface to the NetLabel subsystem
- *
- * Author: Paul Moore <paul@paul-moore.com>
- *
- */
 
 /*
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2006
@@ -144,6 +138,6 @@
 {
 	return 0;
 }
-#endif /* CONFIG_NETLABEL */
+#endif 
 
 #endif
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netnode.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/netnode.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netnode.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/netnode.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,14 +1,3 @@
-/*
- * Network node table
- *
- * SELinux must keep a mapping of network nodes to labels/SIDs.  This
- * mapping is maintained as part of the normal policy but a fast cache is
- * needed to reduce the lookup overhead since most of these queries happen on
- * a per-packet basis.
- *
- * Author: Paul Moore <paul@paul-moore.com>
- *
- */
 
 /*
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2007
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netport.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/netport.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/netport.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/netport.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,13 +1,3 @@
-/*
- * Network port table
- *
- * SELinux must keep a mapping of network ports to labels/SIDs.  This
- * mapping is maintained as part of the normal policy but a fast cache is
- * needed to reduce the lookup overhead.
- *
- * Author: Paul Moore <paul@paul-moore.com>
- *
- */
 
 /*
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2008
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/objsec.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/objsec.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/objsec.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/objsec.h	2013-08-01 23:38:04.000000000 -0600
@@ -28,92 +28,92 @@
 #include "avc.h"
 
 struct task_security_struct {
-	u32 osid;		/* SID prior to last execve */
-	u32 sid;		/* current SID */
-	u32 exec_sid;		/* exec SID */
-	u32 create_sid;		/* fscreate SID */
-	u32 keycreate_sid;	/* keycreate SID */
-	u32 sockcreate_sid;	/* fscreate SID */
+	u32 osid;		
+	u32 sid;		
+	u32 exec_sid;		
+	u32 create_sid;		
+	u32 keycreate_sid;	
+	u32 sockcreate_sid;	
 };
 
 struct inode_security_struct {
-	struct inode *inode;	/* back pointer to inode object */
-	struct list_head list;	/* list of inode_security_struct */
-	u32 task_sid;		/* SID of creating task */
-	u32 sid;		/* SID of this object */
-	u16 sclass;		/* security class of this object */
-	unsigned char initialized;	/* initialization flag */
+	struct inode *inode;	
+	struct list_head list;	
+	u32 task_sid;		
+	u32 sid;		
+	u16 sclass;		
+	unsigned char initialized;	
 	struct mutex lock;
 };
 
 struct file_security_struct {
-	u32 sid;		/* SID of open file description */
-	u32 fown_sid;		/* SID of file owner (for SIGIO) */
-	u32 isid;		/* SID of inode at the time of file open */
-	u32 pseqno;		/* Policy seqno at the time of file open */
+	u32 sid;		
+	u32 fown_sid;		
+	u32 isid;		
+	u32 pseqno;		
 };
 
 struct superblock_security_struct {
-	struct super_block *sb;		/* back pointer to sb object */
-	u32 sid;			/* SID of file system superblock */
-	u32 def_sid;			/* default SID for labeling */
-	u32 mntpoint_sid;		/* SECURITY_FS_USE_MNTPOINT context for files */
-	unsigned int behavior;		/* labeling behavior */
-	unsigned char flags;		/* which mount options were specified */
+	struct super_block *sb;		
+	u32 sid;			
+	u32 def_sid;			
+	u32 mntpoint_sid;		
+	unsigned int behavior;		
+	unsigned char flags;		
 	struct mutex lock;
 	struct list_head isec_head;
 	spinlock_t isec_lock;
 };
 
 struct msg_security_struct {
-	u32 sid;	/* SID of message */
+	u32 sid;	
 };
 
 struct ipc_security_struct {
-	u16 sclass;	/* security class of this object */
-	u32 sid;	/* SID of IPC resource */
+	u16 sclass;	
+	u32 sid;	
 };
 
 struct netif_security_struct {
-	int ifindex;			/* device index */
-	u32 sid;			/* SID for this interface */
+	int ifindex;			
+	u32 sid;			
 };
 
 struct netnode_security_struct {
 	union {
-		__be32 ipv4;		/* IPv4 node address */
-		struct in6_addr ipv6;	/* IPv6 node address */
+		__be32 ipv4;		
+		struct in6_addr ipv6;	
 	} addr;
-	u32 sid;			/* SID for this node */
-	u16 family;			/* address family */
+	u32 sid;			
+	u16 family;			
 };
 
 struct netport_security_struct {
-	u32 sid;			/* SID for this node */
-	u16 port;			/* port number */
-	u8 protocol;			/* transport protocol */
+	u32 sid;			
+	u16 port;			
+	u8 protocol;			
 };
 
 struct sk_security_struct {
 #ifdef CONFIG_NETLABEL
-	enum {				/* NetLabel state */
+	enum {				
 		NLBL_UNSET = 0,
 		NLBL_REQUIRE,
 		NLBL_LABELED,
 		NLBL_REQSKB,
 		NLBL_CONNLABELED,
 	} nlbl_state;
-	struct netlbl_lsm_secattr *nlbl_secattr; /* NetLabel sec attributes */
+	struct netlbl_lsm_secattr *nlbl_secattr; 
 #endif
-	u32 sid;			/* SID of this object */
-	u32 peer_sid;			/* SID of peer */
-	u16 sclass;			/* sock security class */
+	u32 sid;			
+	u32 peer_sid;			
+	u16 sclass;			
 };
 
 struct key_security_struct {
-	u32 sid;	/* SID of key */
+	u32 sid;	
 };
 
 extern unsigned int selinux_checkreqprot;
 
-#endif /* _SELINUX_OBJSEC_H_ */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/security.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/security.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/security.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/security.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,3 @@
-/*
- * Security server interface.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- *
- */
 
 #ifndef _SELINUX_SECURITY_H_
 #define _SELINUX_SECURITY_H_
@@ -13,11 +7,10 @@
 #include <linux/types.h>
 #include "flask.h"
 
-#define SECSID_NULL			0x00000000 /* unspecified SID */
-#define SECSID_WILD			0xffffffff /* wildcard SID */
-#define SECCLASS_NULL			0x0000 /* no class */
+#define SECSID_NULL			0x00000000 
+#define SECSID_WILD			0xffffffff 
+#define SECCLASS_NULL			0x0000 
 
-/* Identify specific policy version changes */
 #define POLICYDB_VERSION_BASE		15
 #define POLICYDB_VERSION_BOOL		16
 #define POLICYDB_VERSION_IPV6		17
@@ -32,7 +25,6 @@
 #define POLICYDB_VERSION_FILENAME_TRANS	25
 #define POLICYDB_VERSION_ROLETRANS	26
 
-/* Range of policy versions we understand*/
 #define POLICYDB_VERSION_MIN   POLICYDB_VERSION_BASE
 #ifdef CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX
 #define POLICYDB_VERSION_MAX	CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX_VALUE
@@ -40,14 +32,11 @@
 #define POLICYDB_VERSION_MAX	POLICYDB_VERSION_ROLETRANS
 #endif
 
-/* Mask for just the mount related flags */
 #define SE_MNTMASK	0x0f
-/* Super block security struct flags for mount options */
 #define CONTEXT_MNT	0x01
 #define FSCONTEXT_MNT	0x02
 #define ROOTCONTEXT_MNT	0x04
 #define DEFCONTEXT_MNT	0x08
-/* Non-mount related flags */
 #define SE_SBINITIALIZED	0x10
 #define SE_SBPROC		0x20
 #define SE_SBLABELSUPP	0x40
@@ -62,7 +51,6 @@
 
 extern int selinux_enabled;
 
-/* Policy capabilities */
 enum {
 	POLICYDB_CAPABILITY_NETPEER,
 	POLICYDB_CAPABILITY_OPENPERM,
@@ -73,14 +61,9 @@
 extern int selinux_policycap_netpeer;
 extern int selinux_policycap_openperm;
 
-/*
- * type_datum properties
- * available at the kernel policy version >= POLICYDB_VERSION_BOUNDARY
- */
 #define TYPEDATUM_PROPERTY_PRIMARY	0x0001
 #define TYPEDATUM_PROPERTY_ATTRIBUTE	0x0002
 
-/* limitation of boundary depth  */
 #define POLICYDB_BOUNDS_MAXDEPTH	4
 
 int security_mls_enabled(void);
@@ -100,7 +83,6 @@
 	u32 flags;
 };
 
-/* definitions of av_decision.flags */
 #define AVD_FLAGS_PERMISSIVE	0x0001
 
 void security_compute_av(u32 ssid, u32 tsid,
@@ -161,12 +143,12 @@
 int security_get_reject_unknown(void);
 int security_get_allow_unknown(void);
 
-#define SECURITY_FS_USE_XATTR		1 /* use xattr */
-#define SECURITY_FS_USE_TRANS		2 /* use transition SIDs, e.g. devpts/tmpfs */
-#define SECURITY_FS_USE_TASK		3 /* use task SIDs, e.g. pipefs/sockfs */
-#define SECURITY_FS_USE_GENFS		4 /* use the genfs support */
-#define SECURITY_FS_USE_NONE		5 /* no labeling support */
-#define SECURITY_FS_USE_MNTPOINT	6 /* use mountpoint labeling */
+#define SECURITY_FS_USE_XATTR		1 
+#define SECURITY_FS_USE_TRANS		2 
+#define SECURITY_FS_USE_TASK		3 
+#define SECURITY_FS_USE_GENFS		4 
+#define SECURITY_FS_USE_NONE		5 
+#define SECURITY_FS_USE_MNTPOINT	6 
 
 int security_fs_use(const char *fstype, unsigned int *behavior,
 	u32 *sid);
@@ -193,25 +175,19 @@
 {
 	return -ENOENT;
 }
-#endif /* CONFIG_NETLABEL */
+#endif 
 
 const char *security_get_initial_sid_context(u32 sid);
 
-/*
- * status notifier using mmap interface
- */
 extern struct page *selinux_kernel_status_page(void);
 
 #define SELINUX_KERNEL_STATUS_VERSION	1
 struct selinux_kernel_status {
-	u32	version;	/* version number of thie structure */
-	u32	sequence;	/* sequence number of seqlock logic */
-	u32	enforcing;	/* current setting of enforcing mode */
-	u32	policyload;	/* times of policy reloaded */
-	u32	deny_unknown;	/* current setting of deny_unknown */
-	/*
-	 * The version > 0 supports above members.
-	 */
+	u32	version;	
+	u32	sequence;	
+	u32	enforcing;	
+	u32	policyload;	
+	u32	deny_unknown;	
 } __attribute__((packed));
 
 extern void selinux_status_update_setenforce(int enforcing);
@@ -225,5 +201,5 @@
 extern void selnl_notify_policyload(u32 seqno);
 extern int selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm);
 
-#endif /* _SELINUX_SECURITY_H_ */
+#endif 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/xfrm.h monarudo-jb-3.4.10-e22f38b/security/selinux/include/xfrm.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/include/xfrm.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/include/xfrm.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,3 @@
-/*
- * SELinux support for the XFRM LSM hooks
- *
- * Author : Trent Jaeger, <jaegert@us.ibm.com>
- * Updated : Venkat Yekkirala, <vyekkirala@TrustedCS.com>
- */
 #ifndef _SELINUX_XFRM_H_
 #define _SELINUX_XFRM_H_
 
@@ -23,9 +17,6 @@
 int selinux_xfrm_state_pol_flow_match(struct xfrm_state *x,
 			struct xfrm_policy *xp, const struct flowi *fl);
 
-/*
- * Extract the security blob from the sock (it's actually on the socket)
- */
 static inline struct inode_security_struct *get_sock_isec(struct sock *sk)
 {
 	if (!sk->sk_socket)
@@ -87,4 +78,4 @@
 	BUG_ON(err);
 }
 
-#endif /* _SELINUX_XFRM_H_ */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netif.c monarudo-jb-3.4.10-e22f38b/security/selinux/netif.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netif.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/netif.c	2013-08-01 23:38:04.000000000 -0600
@@ -43,52 +43,23 @@
 static DEFINE_SPINLOCK(sel_netif_lock);
 static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];
 
-/**
- * sel_netif_hashfn - Hashing function for the interface table
- * @ifindex: the network interface
- *
- * Description:
- * This is the hashing function for the network interface table, it returns the
- * bucket number for the given interface.
- *
- */
 static inline u32 sel_netif_hashfn(int ifindex)
 {
 	return (ifindex & (SEL_NETIF_HASH_SIZE - 1));
 }
 
-/**
- * sel_netif_find - Search for an interface record
- * @ifindex: the network interface
- *
- * Description:
- * Search the network interface table and return the record matching @ifindex.
- * If an entry can not be found in the table return NULL.
- *
- */
 static inline struct sel_netif *sel_netif_find(int ifindex)
 {
 	int idx = sel_netif_hashfn(ifindex);
 	struct sel_netif *netif;
 
 	list_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)
-		/* all of the devices should normally fit in the hash, so we
-		 * optimize for that case */
 		if (likely(netif->nsec.ifindex == ifindex))
 			return netif;
 
 	return NULL;
 }
 
-/**
- * sel_netif_insert - Insert a new interface into the table
- * @netif: the new interface record
- *
- * Description:
- * Add a new interface record to the network interface hash table.  Returns
- * zero on success, negative values on failure.
- *
- */
 static int sel_netif_insert(struct sel_netif *netif)
 {
 	int idx;
@@ -103,14 +74,6 @@
 	return 0;
 }
 
-/**
- * sel_netif_destroy - Remove an interface record from the table
- * @netif: the existing interface record
- *
- * Description:
- * Remove an existing interface record from the network interface table.
- *
- */
 static void sel_netif_destroy(struct sel_netif *netif)
 {
 	list_del_rcu(&netif->list);
@@ -118,18 +81,6 @@
 	kfree_rcu(netif, rcu_head);
 }
 
-/**
- * sel_netif_sid_slow - Lookup the SID of a network interface using the policy
- * @ifindex: the network interface
- * @sid: interface SID
- *
- * Description:
- * This function determines the SID of a network interface by quering the
- * security policy.  The result is added to the network interface table to
- * speedup future queries.  Returns zero on success, negative values on
- * failure.
- *
- */
 static int sel_netif_sid_slow(int ifindex, u32 *sid)
 {
 	int ret;
@@ -137,8 +88,6 @@
 	struct sel_netif *new = NULL;
 	struct net_device *dev;
 
-	/* NOTE: we always use init's network namespace since we don't
-	 * currently support containers */
 
 	dev = dev_get_by_index(&init_net, ifindex);
 	if (unlikely(dev == NULL)) {
@@ -182,19 +131,6 @@
 	return ret;
 }
 
-/**
- * sel_netif_sid - Lookup the SID of a network interface
- * @ifindex: the network interface
- * @sid: interface SID
- *
- * Description:
- * This function determines the SID of a network interface using the fastest
- * method possible.  First the interface table is queried, but if an entry
- * can't be found then the policy is queried and the result is added to the
- * table to speedup future queries.  Returns zero on success, negative values
- * on failure.
- *
- */
 int sel_netif_sid(int ifindex, u32 *sid)
 {
 	struct sel_netif *netif;
@@ -211,15 +147,6 @@
 	return sel_netif_sid_slow(ifindex, sid);
 }
 
-/**
- * sel_netif_kill - Remove an entry from the network interface table
- * @ifindex: the network interface
- *
- * Description:
- * This function removes the entry matching @ifindex from the network interface
- * table if it exists.
- *
- */
 static void sel_netif_kill(int ifindex)
 {
 	struct sel_netif *netif;
@@ -233,13 +160,6 @@
 	rcu_read_unlock();
 }
 
-/**
- * sel_netif_flush - Flush the entire network interface table
- *
- * Description:
- * Remove all entries from the network interface table.
- *
- */
 static void sel_netif_flush(void)
 {
 	int idx;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netnode.c monarudo-jb-3.4.10-e22f38b/security/selinux/netnode.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netnode.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/netnode.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,18 +1,3 @@
-/*
- * Network node table
- *
- * SELinux must keep a mapping of network nodes to labels/SIDs.  This
- * mapping is maintained as part of the normal policy but a fast cache is
- * needed to reduce the lookup overhead since most of these queries happen on
- * a per-packet basis.
- *
- * Author: Paul Moore <paul@paul-moore.com>
- *
- * This code is heavily based on the "netif" concept originally developed by
- * James Morris <jmorris@redhat.com>
- *   (see security/selinux/netif.c for more information)
- *
- */
 
 /*
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2007
@@ -58,59 +43,21 @@
 	struct rcu_head rcu;
 };
 
-/* NOTE: we are using a combined hash table for both IPv4 and IPv6, the reason
- * for this is that I suspect most users will not make heavy use of both
- * address families at the same time so one table will usually end up wasted,
- * if this becomes a problem we can always add a hash table for each address
- * family later */
 
 static LIST_HEAD(sel_netnode_list);
 static DEFINE_SPINLOCK(sel_netnode_lock);
 static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];
 
-/**
- * sel_netnode_hashfn_ipv4 - IPv4 hashing function for the node table
- * @addr: IPv4 address
- *
- * Description:
- * This is the IPv4 hashing function for the node interface table, it returns
- * the bucket number for the given IP address.
- *
- */
 static unsigned int sel_netnode_hashfn_ipv4(__be32 addr)
 {
-	/* at some point we should determine if the mismatch in byte order
-	 * affects the hash function dramatically */
 	return (addr & (SEL_NETNODE_HASH_SIZE - 1));
 }
 
-/**
- * sel_netnode_hashfn_ipv6 - IPv6 hashing function for the node table
- * @addr: IPv6 address
- *
- * Description:
- * This is the IPv6 hashing function for the node interface table, it returns
- * the bucket number for the given IP address.
- *
- */
 static unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)
 {
-	/* just hash the least significant 32 bits to keep things fast (they
-	 * are the most likely to be different anyway), we can revisit this
-	 * later if needed */
 	return (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));
 }
 
-/**
- * sel_netnode_find - Search for a node record
- * @addr: IP address
- * @family: address family
- *
- * Description:
- * Search the network node table and return the record matching @addr.  If an
- * entry can not be found in the table return NULL.
- *
- */
 static struct sel_netnode *sel_netnode_find(const void *addr, u16 family)
 {
 	unsigned int idx;
@@ -145,14 +92,6 @@
 	return NULL;
 }
 
-/**
- * sel_netnode_insert - Insert a new node into the table
- * @node: the new node record
- *
- * Description:
- * Add a new node record to the network address hash table.
- *
- */
 static void sel_netnode_insert(struct sel_netnode *node)
 {
 	unsigned int idx;
@@ -168,13 +107,12 @@
 		BUG();
 	}
 
-	/* we need to impose a limit on the growth of the hash table so check
-	 * this bucket to make sure it is within the specified bounds */
 	list_add_rcu(&node->list, &sel_netnode_hash[idx].list);
 	if (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {
 		struct sel_netnode *tail;
 		tail = list_entry(
-			rcu_dereference(sel_netnode_hash[idx].list.prev),
+			rcu_dereference_protected(sel_netnode_hash[idx].list.prev,
+						  lockdep_is_held(&sel_netnode_lock)),
 			struct sel_netnode, list);
 		list_del_rcu(&tail->list);
 		kfree_rcu(tail, rcu);
@@ -182,19 +120,6 @@
 		sel_netnode_hash[idx].size++;
 }
 
-/**
- * sel_netnode_sid_slow - Lookup the SID of a network address using the policy
- * @addr: the IP address
- * @family: the address family
- * @sid: node SID
- *
- * Description:
- * This function determines the SID of a network address by quering the
- * security policy.  The result is added to the network address table to
- * speedup future queries.  Returns zero on success, negative values on
- * failure.
- *
- */
 static int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)
 {
 	int ret = -ENOMEM;
@@ -243,20 +168,6 @@
 	return ret;
 }
 
-/**
- * sel_netnode_sid - Lookup the SID of a network address
- * @addr: the IP address
- * @family: the address family
- * @sid: node SID
- *
- * Description:
- * This function determines the SID of a network address using the fastest
- * method possible.  First the address table is queried, but if an entry
- * can't be found then the policy is queried and the result is added to the
- * table to speedup future queries.  Returns zero on success, negative values
- * on failure.
- *
- */
 int sel_netnode_sid(void *addr, u16 family, u32 *sid)
 {
 	struct sel_netnode *node;
@@ -273,13 +184,6 @@
 	return sel_netnode_sid_slow(addr, family, sid);
 }
 
-/**
- * sel_netnode_flush - Flush the entire network address table
- *
- * Description:
- * Remove all entries from the network address table.
- *
- */
 static void sel_netnode_flush(void)
 {
 	unsigned int idx;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netport.c monarudo-jb-3.4.10-e22f38b/security/selinux/netport.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/netport.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/netport.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,17 +1,3 @@
-/*
- * Network port table
- *
- * SELinux must keep a mapping of network ports to labels/SIDs.  This
- * mapping is maintained as part of the normal policy but a fast cache is
- * needed to reduce the lookup overhead.
- *
- * Author: Paul Moore <paul@paul-moore.com>
- *
- * This code is heavily based on the "netif" concept originally developed by
- * James Morris <jmorris@redhat.com>
- *   (see security/selinux/netif.c for more information)
- *
- */
 
 /*
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2008
@@ -57,40 +43,16 @@
 	struct rcu_head rcu;
 };
 
-/* NOTE: we are using a combined hash table for both IPv4 and IPv6, the reason
- * for this is that I suspect most users will not make heavy use of both
- * address families at the same time so one table will usually end up wasted,
- * if this becomes a problem we can always add a hash table for each address
- * family later */
 
 static LIST_HEAD(sel_netport_list);
 static DEFINE_SPINLOCK(sel_netport_lock);
 static struct sel_netport_bkt sel_netport_hash[SEL_NETPORT_HASH_SIZE];
 
-/**
- * sel_netport_hashfn - Hashing function for the port table
- * @pnum: port number
- *
- * Description:
- * This is the hashing function for the port table, it returns the bucket
- * number for the given port.
- *
- */
 static unsigned int sel_netport_hashfn(u16 pnum)
 {
 	return (pnum & (SEL_NETPORT_HASH_SIZE - 1));
 }
 
-/**
- * sel_netport_find - Search for a port record
- * @protocol: protocol
- * @port: pnum
- *
- * Description:
- * Search the network port table and return the matching record.  If an entry
- * can not be found in the table return NULL.
- *
- */
 static struct sel_netport *sel_netport_find(u8 protocol, u16 pnum)
 {
 	unsigned int idx;
@@ -104,20 +66,10 @@
 	return NULL;
 }
 
-/**
- * sel_netport_insert - Insert a new port into the table
- * @port: the new port record
- *
- * Description:
- * Add a new port record to the network address hash table.
- *
- */
 static void sel_netport_insert(struct sel_netport *port)
 {
 	unsigned int idx;
 
-	/* we need to impose a limit on the growth of the hash table so check
-	 * this bucket to make sure it is within the specified bounds */
 	idx = sel_netport_hashfn(port->psec.port);
 	list_add_rcu(&port->list, &sel_netport_hash[idx].list);
 	if (sel_netport_hash[idx].size == SEL_NETPORT_HASH_BKT_LIMIT) {
@@ -133,18 +85,6 @@
 		sel_netport_hash[idx].size++;
 }
 
-/**
- * sel_netport_sid_slow - Lookup the SID of a network address using the policy
- * @protocol: protocol
- * @pnum: port
- * @sid: port SID
- *
- * Description:
- * This function determines the SID of a network port by quering the security
- * policy.  The result is added to the network port table to speedup future
- * queries.  Returns zero on success, negative values on failure.
- *
- */
 static int sel_netport_sid_slow(u8 protocol, u16 pnum, u32 *sid)
 {
 	int ret = -ENOMEM;
@@ -181,19 +121,6 @@
 	return ret;
 }
 
-/**
- * sel_netport_sid - Lookup the SID of a network port
- * @protocol: protocol
- * @pnum: port
- * @sid: port SID
- *
- * Description:
- * This function determines the SID of a network port using the fastest method
- * possible.  First the port table is queried, but if an entry can't be found
- * then the policy is queried and the result is added to the table to speedup
- * future queries.  Returns zero on success, negative values on failure.
- *
- */
 int sel_netport_sid(u8 protocol, u16 pnum, u32 *sid)
 {
 	struct sel_netport *port;
@@ -210,13 +137,6 @@
 	return sel_netport_sid_slow(protocol, pnum, sid);
 }
 
-/**
- * sel_netport_flush - Flush the entire network port table
- *
- * Description:
- * Remove all entries from the network address table.
- *
- */
 static void sel_netport_flush(void)
 {
 	unsigned int idx;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/nlmsgtab.c monarudo-jb-3.4.10-e22f38b/security/selinux/nlmsgtab.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/nlmsgtab.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/nlmsgtab.c	2013-08-01 23:38:04.000000000 -0600
@@ -173,7 +173,7 @@
 		}
 		break;
 
-	/* No messaging from userspace, or class unknown/unhandled */
+	
 	default:
 		err = -ENOENT;
 		break;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/selinuxfs.c monarudo-jb-3.4.10-e22f38b/security/selinux/selinuxfs.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/selinuxfs.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/selinuxfs.c	2013-08-01 23:38:04.000000000 -0600
@@ -31,8 +31,6 @@
 #include <linux/kobject.h>
 #include <linux/ctype.h>
 
-/* selinuxfs pseudo filesystem for exporting the security policy API.
-   Based on the proc code and the fs/nfsd/nfsctl.c code. */
 
 #include "flask.h"
 #include "avc.h"
@@ -41,7 +39,6 @@
 #include "objsec.h"
 #include "conditional.h"
 
-/* Policy capability filenames */
 static char *policycap_names[] = {
 	"network_peer_controls",
 	"open_perms"
@@ -60,22 +57,18 @@
 
 static DEFINE_MUTEX(sel_mutex);
 
-/* global data for booleans */
 static struct dentry *bool_dir;
 static int bool_num;
 static char **bool_pending_names;
 static int *bool_pending_values;
 
-/* global data for classes */
 static struct dentry *class_dir;
 static unsigned long last_class_ino;
 
 static char policy_opened;
 
-/* global data for policy capabilities */
 static struct dentry *policycap_dir;
 
-/* Check whether a task is allowed to use a security operation. */
 static int task_has_security(struct task_struct *tsk,
 			     u32 perms)
 {
@@ -96,25 +89,25 @@
 
 enum sel_inos {
 	SEL_ROOT_INO = 2,
-	SEL_LOAD,	/* load policy */
-	SEL_ENFORCE,	/* get or set enforcing status */
-	SEL_CONTEXT,	/* validate context */
-	SEL_ACCESS,	/* compute access decision */
-	SEL_CREATE,	/* compute create labeling decision */
-	SEL_RELABEL,	/* compute relabeling decision */
-	SEL_USER,	/* compute reachable user contexts */
-	SEL_POLICYVERS,	/* return policy version for this kernel */
-	SEL_COMMIT_BOOLS, /* commit new boolean values */
-	SEL_MLS,	/* return if MLS policy is enabled */
-	SEL_DISABLE,	/* disable SELinux until next reboot */
-	SEL_MEMBER,	/* compute polyinstantiation membership decision */
-	SEL_CHECKREQPROT, /* check requested protection, not kernel-applied one */
-	SEL_COMPAT_NET,	/* whether to use old compat network packet controls */
-	SEL_REJECT_UNKNOWN, /* export unknown reject handling to userspace */
-	SEL_DENY_UNKNOWN, /* export unknown deny handling to userspace */
-	SEL_STATUS,	/* export current status using mmap() */
-	SEL_POLICY,	/* allow userspace to read the in kernel policy */
-	SEL_INO_NEXT,	/* The next inode number to use */
+	SEL_LOAD,	
+	SEL_ENFORCE,	
+	SEL_CONTEXT,	
+	SEL_ACCESS,	
+	SEL_CREATE,	
+	SEL_RELABEL,	
+	SEL_USER,	
+	SEL_POLICYVERS,	
+	SEL_COMMIT_BOOLS, 
+	SEL_MLS,	
+	SEL_DISABLE,	
+	SEL_MEMBER,	
+	SEL_CHECKREQPROT, 
+	SEL_COMPAT_NET,	
+	SEL_REJECT_UNKNOWN, 
+	SEL_DENY_UNKNOWN, 
+	SEL_STATUS,	
+	SEL_POLICY,	
+	SEL_INO_NEXT,	
 };
 
 static unsigned long sel_last_ino = SEL_INO_NEXT - 1;
@@ -149,7 +142,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -247,13 +240,13 @@
 
 	BUG_ON(!status);
 
-	/* only allows one page from the head */
+	
 	if (vma->vm_pgoff > 0 || size != PAGE_SIZE)
 		return -EIO;
-	/* disallow writable mapping */
+	
 	if (vma->vm_flags & VM_WRITE)
 		return -EPERM;
-	/* disallow mprotect() turns it into writable */
+	
 	vma->vm_flags &= ~VM_MAYWRITE;
 
 	return remap_pfn_range(vma, vma->vm_start,
@@ -281,7 +274,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -338,12 +331,10 @@
 	.llseek		= generic_file_llseek,
 };
 
-/* declaration for sel_write_load */
 static int sel_make_bools(void);
 static int sel_make_classes(void);
 static int sel_make_policycap(void);
 
-/* declaration for sel_make_class_dirs */
 static struct dentry *sel_make_dir(struct dentry *dir, const char *name,
 			unsigned long *ino);
 
@@ -478,7 +469,7 @@
 static int sel_mmap_policy(struct file *filp, struct vm_area_struct *vma)
 {
 	if (vma->vm_flags & VM_SHARED) {
-		/* do not allow mprotect to make mapping writable */
+		
 		vma->vm_flags &= ~VM_MAYWRITE;
 
 		if (vma->vm_flags & VM_WRITE)
@@ -511,7 +502,7 @@
 	if (length)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -620,7 +611,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -650,9 +641,6 @@
 	.llseek		= generic_file_llseek,
 };
 
-/*
- * Remaining nodes use transaction based IO methods like nfsd/nfsctl.c
- */
 static ssize_t sel_write_access(struct file *file, char *buf, size_t size);
 static ssize_t sel_write_create(struct file *file, char *buf, size_t size);
 static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);
@@ -696,11 +684,6 @@
 	.llseek		= generic_file_llseek,
 };
 
-/*
- * payload - write methods
- * If the method has a response, the response should be put in buf,
- * and the length returned.  Otherwise return 0 or and -error.
- */
 
 static ssize_t sel_write_access(struct file *file, char *buf, size_t size)
 {
@@ -784,13 +767,6 @@
 	if (nargs < 3 || nargs > 4)
 		goto out;
 	if (nargs == 4) {
-		/*
-		 * If and when the name of new object to be queried contains
-		 * either whitespace or multibyte characters, they shall be
-		 * encoded based on the percentage-encoding rule.
-		 * If not encoded, the sscanf logic picks up only left-half
-		 * of the supplied name; splitted by a whitespace unexpectedly.
-		 */
 		char   *r, *w;
 		int     c1, c2;
 
@@ -1094,7 +1070,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -1148,7 +1124,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -1227,7 +1203,7 @@
 	int *values = NULL;
 	u32 sid;
 
-	/* remove any existing files */
+	
 	for (i = 0; i < bool_num; i++)
 		kfree(bool_pending_names[i]);
 	kfree(bool_pending_names);
@@ -1329,7 +1305,7 @@
 	if (count >= PAGE_SIZE)
 		goto out;
 
-	/* No partial writes. */
+	
 	ret = -EINVAL;
 	if (*ppos != 0)
 		goto out;
@@ -1648,7 +1624,7 @@
 			goto out;
 
 		inode->i_fop = &sel_perm_ops;
-		/* i+1 since perm values are 1-indexed */
+		
 		inode->i_ino = sel_perm_to_ino(classvalue, i + 1);
 		d_add(dentry, inode);
 	}
@@ -1717,14 +1693,14 @@
 	int rc, nclasses, i;
 	char **classes;
 
-	/* delete any existing entries */
+	
 	sel_remove_classes();
 
 	rc = security_get_classes(&classes, &nclasses);
 	if (rc)
 		return rc;
 
-	/* +2 since classes are 1-indexed */
+	
 	last_class_ino = sel_class_to_ino(nclasses + 2);
 
 	for (i = 0; i < nclasses; i++) {
@@ -1737,7 +1713,7 @@
 			goto out;
 		}
 
-		/* i+1 since class values are 1-indexed */
+		
 		rc = sel_make_class_dir_entries(classes[i], i + 1,
 				class_name_dir);
 		if (rc)
@@ -1799,10 +1775,10 @@
 	inode->i_op = &simple_dir_inode_operations;
 	inode->i_fop = &simple_dir_operations;
 	inode->i_ino = ++(*ino);
-	/* directory inodes start off with i_nlink == 2 (for "." entry) */
+	
 	inc_nlink(inode);
 	d_add(dentry, inode);
-	/* bump link count on parent directory, too */
+	
 	inc_nlink(dir->d_inode);
 
 	return dentry;
@@ -1833,7 +1809,7 @@
 		[SEL_DENY_UNKNOWN] = {"deny_unknown", &sel_handle_unknown_ops, S_IRUGO},
 		[SEL_STATUS] = {"status", &sel_handle_status_ops, S_IRUGO},
 		[SEL_POLICY] = {"policy", &sel_policy_ops, S_IRUSR},
-		/* last one */ {""}
+		 {""}
 	};
 	ret = simple_fill_super(sb, SELINUX_MAGIC, selinux_files);
 	if (ret)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/avtab.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/avtab.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/avtab.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/avtab.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the access vector table type.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 
 /* Updated: Frank Mayer <mayerf@tresys.com> and Karl MacMillan <kmacmillan@tresys.com>
  *
@@ -90,10 +85,6 @@
 	return 0;
 }
 
-/* Unlike avtab_insert(), this function allow multiple insertions of the same
- * key/specified mask into the table, as needed by the conditional avtab.
- * It also returns a pointer to the node inserted.
- */
 struct avtab_node *
 avtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)
 {
@@ -156,9 +147,6 @@
 	return NULL;
 }
 
-/* This search function returns a node pointer, and can be used in
- * conjunction with avtab_search_next_node()
- */
 struct avtab_node*
 avtab_search_node(struct avtab *h, struct avtab_key *key)
 {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/avtab.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/avtab.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/avtab.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/avtab.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,12 +1,3 @@
-/*
- * An access vector table (avtab) is a hash table
- * of access vectors and transition types indexed
- * by a type pair and a class.  An access vector
- * table is used to represent the type enforcement
- * tables.
- *
- *  Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 
 /* Updated: Frank Mayer <mayerf@tresys.com> and Karl MacMillan <kmacmillan@tresys.com>
  *
@@ -24,9 +15,9 @@
 #define _SS_AVTAB_H_
 
 struct avtab_key {
-	u16 source_type;	/* source type */
-	u16 target_type;	/* target type */
-	u16 target_class;	/* target object class */
+	u16 source_type;	
+	u16 target_type;	
+	u16 target_class;	
 #define AVTAB_ALLOWED		0x0001
 #define AVTAB_AUDITALLOW	0x0002
 #define AVTAB_AUDITDENY		0x0004
@@ -35,13 +26,13 @@
 #define AVTAB_MEMBER		0x0020
 #define AVTAB_CHANGE		0x0040
 #define AVTAB_TYPE		(AVTAB_TRANSITION | AVTAB_MEMBER | AVTAB_CHANGE)
-#define AVTAB_ENABLED_OLD   0x80000000 /* reserved for used in cond_avtab */
-#define AVTAB_ENABLED		0x8000 /* reserved for used in cond_avtab */
-	u16 specified;	/* what field is specified */
+#define AVTAB_ENABLED_OLD   0x80000000 
+#define AVTAB_ENABLED		0x8000 
+	u16 specified;	
 };
 
 struct avtab_datum {
-	u32 data; /* access vector or type value */
+	u32 data; 
 };
 
 struct avtab_node {
@@ -52,9 +43,9 @@
 
 struct avtab {
 	struct avtab_node **htable;
-	u32 nel;	/* number of elements */
-	u32 nslot;      /* number of hash slots */
-	u16 mask;       /* mask to compute hash func */
+	u32 nel;	
+	u32 nslot;      
+	u16 mask;       
 
 };
 
@@ -87,5 +78,5 @@
 #define MAX_AVTAB_HASH_BITS 11
 #define MAX_AVTAB_HASH_BUCKETS (1 << MAX_AVTAB_HASH_BITS)
 
-#endif	/* _SS_AVTAB_H_ */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/conditional.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/conditional.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/conditional.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/conditional.c	2013-08-01 23:38:04.000000000 -0600
@@ -16,12 +16,6 @@
 #include "security.h"
 #include "conditional.h"
 
-/*
- * cond_evaluate_expr evaluates a conditional expr
- * in reverse polish notation. It returns true (1), false (0),
- * or undefined (-1). Undefined occurs when the expression
- * exceeds the stack depth of COND_EXPR_MAXDEPTH.
- */
 static int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)
 {
 
@@ -79,13 +73,6 @@
 	return s[0];
 }
 
-/*
- * evaluate_cond_node evaluates the conditional stored in
- * a struct cond_node and if the result is different than the
- * current state of the node it sets the rules in the true/false
- * list appropriately. If the result of the expression is undefined
- * all of the rules are disabled for safety.
- */
 int evaluate_cond_node(struct policydb *p, struct cond_node *node)
 {
 	int new_state;
@@ -96,7 +83,7 @@
 		node->cur_state = new_state;
 		if (new_state == -1)
 			printk(KERN_ERR "SELinux: expression result was undefined - disabling all rules.\n");
-		/* turn the rules on or off */
+		
 		for (cur = node->true_list; cur; cur = cur->next) {
 			if (new_state <= 0)
 				cur->node->key.specified &= ~AVTAB_ENABLED;
@@ -105,7 +92,7 @@
 		}
 
 		for (cur = node->false_list; cur; cur = cur->next) {
-			/* -1 or 1 */
+			
 			if (new_state)
 				cur->node->key.specified &= ~AVTAB_ENABLED;
 			else
@@ -134,7 +121,7 @@
 	struct cond_av_list *cur, *next;
 	for (cur = list; cur; cur = next) {
 		next = cur->next;
-		/* the avtab_ptr_t node is destroy by the avtab */
+		
 		kfree(cur);
 	}
 }
@@ -276,24 +263,11 @@
 	u8 found;
 	int rc = -EINVAL;
 
-	/*
-	 * For type rules we have to make certain there aren't any
-	 * conflicting rules by searching the te_avtab and the
-	 * cond_te_avtab.
-	 */
 	if (k->specified & AVTAB_TYPE) {
 		if (avtab_search(&p->te_avtab, k)) {
 			printk(KERN_ERR "SELinux: type rule already exists outside of a conditional.\n");
 			goto err;
 		}
-		/*
-		 * If we are reading the false list other will be a pointer to
-		 * the true list. We can have duplicate entries if there is only
-		 * 1 other entry and it is in our true list.
-		 *
-		 * If we are reading the true list (other == NULL) there shouldn't
-		 * be any other entries.
-		 */
 		if (other) {
 			node_ptr = avtab_search_node(&p->te_cond_avtab, k);
 			if (node_ptr) {
@@ -413,7 +387,7 @@
 	if (rc)
 		return rc;
 
-	/* expr */
+	
 	len = le32_to_cpu(buf[0]);
 
 	for (i = 0; i < len; i++) {
@@ -517,15 +491,6 @@
 	return 0;
 }
 
-/*
- * cond_write_cond_av_list doesn't write out the av_list nodes.
- * Instead it writes out the key/value pairs from the avtab. This
- * is necessary because there is no way to uniquely identifying rules
- * in the avtab so it is not possible to associate individual rules
- * in the avtab with a conditional without saving them as part of
- * the conditional. This means that the avtab with the conditional
- * rules will not be saved but will be rebuilt on policy load.
- */
 static int cond_write_av_list(struct policydb *p,
 			      struct cond_av_list *list, struct policy_file *fp)
 {
@@ -617,9 +582,6 @@
 
 	return 0;
 }
-/* Determine whether additional permissions are granted by the conditional
- * av table, and if so, add them to the result
- */
 void cond_compute_av(struct avtab *ctab, struct avtab_key *key, struct av_decision *avd)
 {
 	struct avtab_node *node;
@@ -634,11 +596,6 @@
 			avd->allowed |= node->datum.data;
 		if ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==
 		    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))
-			/* Since a '0' in an auditdeny mask represents a
-			 * permission we do NOT want to audit (dontaudit), we use
-			 * the '&' operand to ensure that all '0's in the mask
-			 * are retained (much unlike the allow and auditallow cases).
-			 */
 			avd->auditdeny &= node->datum.data;
 		if ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==
 		    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/conditional.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/conditional.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/conditional.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/conditional.h	2013-08-01 23:38:04.000000000 -0600
@@ -17,41 +17,25 @@
 
 #define COND_EXPR_MAXDEPTH 10
 
-/*
- * A conditional expression is a list of operators and operands
- * in reverse polish notation.
- */
 struct cond_expr {
-#define COND_BOOL	1 /* plain bool */
-#define COND_NOT	2 /* !bool */
-#define COND_OR		3 /* bool || bool */
-#define COND_AND	4 /* bool && bool */
-#define COND_XOR	5 /* bool ^ bool */
-#define COND_EQ		6 /* bool == bool */
-#define COND_NEQ	7 /* bool != bool */
+#define COND_BOOL	1 
+#define COND_NOT	2 
+#define COND_OR		3 
+#define COND_AND	4 
+#define COND_XOR	5 
+#define COND_EQ		6 
+#define COND_NEQ	7 
 #define COND_LAST	COND_NEQ
 	__u32 expr_type;
 	__u32 bool;
 	struct cond_expr *next;
 };
 
-/*
- * Each cond_node contains a list of rules to be enabled/disabled
- * depending on the current value of the conditional expression. This
- * struct is for that list.
- */
 struct cond_av_list {
 	struct avtab_node *node;
 	struct cond_av_list *next;
 };
 
-/*
- * A cond node represents a conditional block in a policy. It
- * contains a conditional expression, the current state of the expression,
- * two lists of rules to enable/disable depending on the value of the
- * expression (the true list corresponds to if and the false list corresponds
- * to else)..
- */
 struct cond_node {
 	int cur_state;
 	struct cond_expr *expr;
@@ -77,4 +61,4 @@
 
 int evaluate_cond_node(struct policydb *p, struct cond_node *node);
 
-#endif /* _CONDITIONAL_H_ */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/constraint.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/constraint.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/constraint.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/constraint.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,17 +1,3 @@
-/*
- * A constraint is a condition that must be satisfied in
- * order for one or more permissions to be granted.
- * Constraints are used to impose additional restrictions
- * beyond the type-based rules in `te' or the role-based
- * transition rules in `rbac'.  Constraints are typically
- * used to prevent a process from transitioning to a new user
- * identity or role unless it is in a privileged type.
- * Constraints are likewise typically used to prevent a
- * process from labeling an object with a different user
- * identity.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_CONSTRAINT_H_
 #define _SS_CONSTRAINT_H_
 
@@ -20,42 +6,42 @@
 #define CEXPR_MAXDEPTH 5
 
 struct constraint_expr {
-#define CEXPR_NOT		1 /* not expr */
-#define CEXPR_AND		2 /* expr and expr */
-#define CEXPR_OR		3 /* expr or expr */
-#define CEXPR_ATTR		4 /* attr op attr */
-#define CEXPR_NAMES		5 /* attr op names */
-	u32 expr_type;		/* expression type */
-
-#define CEXPR_USER 1		/* user */
-#define CEXPR_ROLE 2		/* role */
-#define CEXPR_TYPE 4		/* type */
-#define CEXPR_TARGET 8		/* target if set, source otherwise */
-#define CEXPR_XTARGET 16	/* special 3rd target for validatetrans rule */
-#define CEXPR_L1L2 32		/* low level 1 vs. low level 2 */
-#define CEXPR_L1H2 64		/* low level 1 vs. high level 2 */
-#define CEXPR_H1L2 128		/* high level 1 vs. low level 2 */
-#define CEXPR_H1H2 256		/* high level 1 vs. high level 2 */
-#define CEXPR_L1H1 512		/* low level 1 vs. high level 1 */
-#define CEXPR_L2H2 1024		/* low level 2 vs. high level 2 */
-	u32 attr;		/* attribute */
-
-#define CEXPR_EQ     1		/* == or eq */
-#define CEXPR_NEQ    2		/* != */
-#define CEXPR_DOM    3		/* dom */
-#define CEXPR_DOMBY  4		/* domby  */
-#define CEXPR_INCOMP 5		/* incomp */
-	u32 op;			/* operator */
+#define CEXPR_NOT		1 
+#define CEXPR_AND		2 
+#define CEXPR_OR		3 
+#define CEXPR_ATTR		4 
+#define CEXPR_NAMES		5 
+	u32 expr_type;		
+
+#define CEXPR_USER 1		
+#define CEXPR_ROLE 2		
+#define CEXPR_TYPE 4		
+#define CEXPR_TARGET 8		
+#define CEXPR_XTARGET 16	
+#define CEXPR_L1L2 32		
+#define CEXPR_L1H2 64		
+#define CEXPR_H1L2 128		
+#define CEXPR_H1H2 256		
+#define CEXPR_L1H1 512		
+#define CEXPR_L2H2 1024		
+	u32 attr;		
+
+#define CEXPR_EQ     1		
+#define CEXPR_NEQ    2		
+#define CEXPR_DOM    3		
+#define CEXPR_DOMBY  4		
+#define CEXPR_INCOMP 5		
+	u32 op;			
 
-	struct ebitmap names;	/* names */
+	struct ebitmap names;	
 
-	struct constraint_expr *next;   /* next expression */
+	struct constraint_expr *next;   
 };
 
 struct constraint_node {
-	u32 permissions;	/* constrained permissions */
-	struct constraint_expr *expr;	/* constraint on permissions */
-	struct constraint_node *next;	/* next constraint */
+	u32 permissions;	
+	struct constraint_expr *expr;	
+	struct constraint_node *next;	
 };
 
-#endif	/* _SS_CONSTRAINT_H_ */
+#endif	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/context.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/context.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/context.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/context.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,17 +1,3 @@
-/*
- * A security context is a set of security attributes
- * associated with each subject and object controlled
- * by the security policy.  Security contexts are
-  * externally represented as variable-length strings
- * that can be interpreted by a user or application
- * with an understanding of the security policy.
- * Internally, the security server uses a simple
- * structure.  This structure is private to the
- * security server and can be changed without affecting
- * clients of the security server.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_CONTEXT_H_
 #define _SS_CONTEXT_H_
 
@@ -19,17 +5,13 @@
 #include "mls_types.h"
 #include "security.h"
 
-/*
- * A security context consists of an authenticated user
- * identity, a role, a type and a MLS range.
- */
 struct context {
 	u32 user;
 	u32 role;
 	u32 type;
-	u32 len;        /* length of string in bytes */
+	u32 len;        
 	struct mls_range range;
-	char *str;	/* string representation if context cannot be mapped. */
+	char *str;	
 };
 
 static inline void mls_context_init(struct context *c)
@@ -54,9 +36,6 @@
 	return rc;
 }
 
-/*
- * Sets both levels in the MLS range of 'dst' to the low level of 'src'.
- */
 static inline int mls_context_cpy_low(struct context *dst, struct context *src)
 {
 	int rc;
@@ -139,5 +118,5 @@
 		mls_context_cmp(c1, c2));
 }
 
-#endif	/* _SS_CONTEXT_H_ */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/ebitmap.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/ebitmap.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/ebitmap.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/ebitmap.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,19 +1,10 @@
 /*
- * Implementation of the extensible bitmap type.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
-/*
  * Updated: Hewlett-Packard <paul@paul-moore.com>
  *
  *      Added support to import/export the NetLabel category bitmap
  *
  * (c) Copyright Hewlett-Packard Development Company, L.P., 2006
  */
-/*
- * Updated: KaiGai Kohei <kaigai@ak.jp.nec.com>
- *      Applied standard bit operations to improve bitmap scanning.
- */
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -75,16 +66,6 @@
 }
 
 #ifdef CONFIG_NETLABEL
-/**
- * ebitmap_netlbl_export - Export an ebitmap into a NetLabel category bitmap
- * @ebmap: the ebitmap to export
- * @catmap: the NetLabel category bitmap
- *
- * Description:
- * Export a SELinux extensibile bitmap into a NetLabel category bitmap.
- * Returns zero on success, negative values on error.
- *
- */
 int ebitmap_netlbl_export(struct ebitmap *ebmap,
 			  struct netlbl_lsm_secattr_catmap **catmap)
 {
@@ -93,12 +74,6 @@
 	u32 cmap_idx, cmap_sft;
 	int i;
 
-	/* NetLabel's NETLBL_CATMAP_MAPTYPE is defined as an array of u64,
-	 * however, it is not always compatible with an array of unsigned long
-	 * in ebitmap_node.
-	 * In addition, you should pay attention the following implementation
-	 * assumes unsigned long has a width equal with or less than 64-bit.
-	 */
 
 	if (e_iter == NULL) {
 		*catmap = NULL;
@@ -142,16 +117,6 @@
 	return -ENOMEM;
 }
 
-/**
- * ebitmap_netlbl_import - Import a NetLabel category bitmap into an ebitmap
- * @ebmap: the ebitmap to import
- * @catmap: the NetLabel category bitmap
- *
- * Description:
- * Import a NetLabel category bitmap into a SELinux extensibile bitmap.
- * Returns zero on success, negative values on error.
- *
- */
 int ebitmap_netlbl_import(struct ebitmap *ebmap,
 			  struct netlbl_lsm_secattr_catmap *catmap)
 {
@@ -160,12 +125,6 @@
 	struct netlbl_lsm_secattr_catmap *c_iter = catmap;
 	u32 c_idx, c_pos, e_idx, e_sft;
 
-	/* NetLabel's NETLBL_CATMAP_MAPTYPE is defined as an array of u64,
-	 * however, it is not always compatible with an array of unsigned long
-	 * in ebitmap_node.
-	 * In addition, you should pay attention the following implementation
-	 * assumes unsigned long has a width equal with or less than 64-bit.
-	 */
 
 	do {
 		for (c_idx = 0; c_idx < NETLBL_CATMAP_MAPCNT; c_idx++) {
@@ -211,7 +170,7 @@
 	ebitmap_destroy(ebmap);
 	return -ENOMEM;
 }
-#endif /* CONFIG_NETLABEL */
+#endif 
 
 int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2)
 {
@@ -279,12 +238,8 @@
 				if (s < EBITMAP_SIZE)
 					return 0;
 
-				/* drop this node from the bitmap */
+				
 				if (!n->next) {
-					/*
-					 * this was the highest map
-					 * within the bitmap
-					 */
 					if (prev)
 						e->highbit = prev->startbit
 							     + EBITMAP_SIZE;
@@ -314,7 +269,7 @@
 	ebitmap_node_set_bit(new, bit);
 
 	if (!n)
-		/* this node will be the highest map within the bitmap */
+		
 		e->highbit = new->startbit + EBITMAP_SIZE;
 
 	if (prev) {
@@ -372,7 +327,7 @@
 		goto bad;
 	}
 
-	/* round up e->highbit */
+	
 	e->highbit += EBITMAP_SIZE - 1;
 	e->highbit -= (e->highbit % EBITMAP_SIZE);
 
@@ -411,7 +366,7 @@
 				rc = -ENOMEM;
 				goto bad;
 			}
-			/* round down */
+			
 			tmp->startbit = startbit - (startbit % EBITMAP_SIZE);
 			if (n)
 				n->next = tmp;
@@ -482,14 +437,14 @@
 		if (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {
 			__le64 buf64[1];
 
-			/* this is the very first bit */
+			
 			if (!map) {
 				last_startbit = rounddown(bit, BITS_PER_U64);
 				map = (u64)1 << (bit - last_startbit);
 				continue;
 			}
 
-			/* write the last node */
+			
 			buf[0] = cpu_to_le32(last_startbit);
 			rc = put_entry(buf, sizeof(u32), 1, fp);
 			if (rc)
@@ -500,17 +455,17 @@
 			if (rc)
 				return rc;
 
-			/* set up for the next node */
+			
 			map = 0;
 			last_startbit = rounddown(bit, BITS_PER_U64);
 		}
 		map |= (u64)1 << (bit - last_startbit);
 	}
-	/* write the last node */
+	
 	if (map) {
 		__le64 buf64[1];
 
-		/* write the last node */
+		
 		buf[0] = cpu_to_le32(last_startbit);
 		rc = put_entry(buf, sizeof(u32), 1, fp);
 		if (rc)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/ebitmap.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/ebitmap.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/ebitmap.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/ebitmap.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,16 +1,3 @@
-/*
- * An extensible bitmap is a bitmap that supports an
- * arbitrary number of bits.  Extensible bitmaps are
- * used to represent sets of values, such as types,
- * roles, categories, and classes.
- *
- * Each extensible bitmap is implemented as a linked
- * list of bitmap nodes, where each bitmap node has
- * an explicitly specified starting bit position within
- * the total bitmap.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_EBITMAP_H_
 #define _SS_EBITMAP_H_
 
@@ -31,8 +18,8 @@
 };
 
 struct ebitmap {
-	struct ebitmap_node *node;	/* first node in the bitmap */
-	u32 highbit;	/* highest position in the total bitmap */
+	struct ebitmap_node *node;	
+	u32 highbit;	
 };
 
 #define ebitmap_length(e) ((e)->highbit)
@@ -142,4 +129,4 @@
 }
 #endif
 
-#endif	/* _SS_EBITMAP_H_ */
+#endif	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/hashtab.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/hashtab.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/hashtab.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/hashtab.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the hash table type.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/errno.h>
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/hashtab.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/hashtab.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/hashtab.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/hashtab.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,12 +1,3 @@
-/*
- * A hash table (hashtab) maintains associations between
- * key values and datum values.  The type of the key values
- * and the type of the datum values is arbitrary.  The
- * functions for hash computation and key comparison are
- * provided by the creator of the table.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_HASHTAB_H_
 #define _SS_HASHTAB_H_
 
@@ -19,13 +10,13 @@
 };
 
 struct hashtab {
-	struct hashtab_node **htable;	/* hash table */
-	u32 size;			/* number of slots in hash table */
-	u32 nel;			/* number of elements in hash table */
+	struct hashtab_node **htable;	
+	u32 size;			
+	u32 nel;			
 	u32 (*hash_value)(struct hashtab *h, const void *key);
-					/* hash function */
+					
 	int (*keycmp)(struct hashtab *h, const void *key1, const void *key2);
-					/* key comparison function */
+					
 };
 
 struct hashtab_info {
@@ -33,55 +24,20 @@
 	u32 max_chain_len;
 };
 
-/*
- * Creates a new hash table with the specified characteristics.
- *
- * Returns NULL if insufficent space is available or
- * the new hash table otherwise.
- */
 struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),
 			       int (*keycmp)(struct hashtab *h, const void *key1, const void *key2),
 			       u32 size);
 
-/*
- * Inserts the specified (key, datum) pair into the specified hash table.
- *
- * Returns -ENOMEM on memory allocation error,
- * -EEXIST if there is already an entry with the same key,
- * -EINVAL for general errors or
-  0 otherwise.
- */
 int hashtab_insert(struct hashtab *h, void *k, void *d);
 
-/*
- * Searches for the entry with the specified key in the hash table.
- *
- * Returns NULL if no entry has the specified key or
- * the datum of the entry otherwise.
- */
 void *hashtab_search(struct hashtab *h, const void *k);
 
-/*
- * Destroys the specified hash table.
- */
 void hashtab_destroy(struct hashtab *h);
 
-/*
- * Applies the specified apply function to (key,datum,args)
- * for each entry in the specified hash table.
- *
- * The order in which the function is applied to the entries
- * is dependent upon the internal structure of the hash table.
- *
- * If apply returns a non-zero status, then hashtab_map will cease
- * iterating through the hash table and will propagate the error
- * return to its caller.
- */
 int hashtab_map(struct hashtab *h,
 		int (*apply)(void *k, void *d, void *args),
 		void *args);
 
-/* Fill info with some hash table statistics */
 void hashtab_stat(struct hashtab *h, struct hashtab_info *info);
 
-#endif	/* _SS_HASHTAB_H */
+#endif	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,4 @@
 /*
- * Implementation of the multi-level security (MLS) policy.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
-/*
  * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>
  *
  *	Support for enhanced MLS infrastructure.
@@ -28,10 +23,6 @@
 #include "policydb.h"
 #include "services.h"
 
-/*
- * Return the length in bytes for the MLS fields of the
- * security context string representation of `context'.
- */
 int mls_compute_context_len(struct context *context)
 {
 	int i, l, len, head, prev;
@@ -42,18 +33,18 @@
 	if (!policydb.mls_enabled)
 		return 0;
 
-	len = 1; /* for the beginning ":" */
+	len = 1; 
 	for (l = 0; l < 2; l++) {
 		int index_sens = context->range.level[l].sens;
 		len += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));
 
-		/* categories */
+		
 		head = -2;
 		prev = -2;
 		e = &context->range.level[l].cat;
 		ebitmap_for_each_positive_bit(e, node, i) {
 			if (i - prev > 1) {
-				/* one or more negative bits are skipped */
+				
 				if (head != prev) {
 					nm = sym_name(&policydb, SYM_CATS, prev);
 					len += strlen(nm) + 1;
@@ -80,11 +71,6 @@
 	return len;
 }
 
-/*
- * Write the security context string representation of
- * the MLS fields of `context' into the string `*scontext'.
- * Update `*scontext' to point to the end of the MLS fields.
- */
 void mls_sid_to_context(struct context *context,
 			char **scontext)
 {
@@ -106,13 +92,13 @@
 					   context->range.level[l].sens - 1));
 		scontextp += strlen(scontextp);
 
-		/* categories */
+		
 		head = -2;
 		prev = -2;
 		e = &context->range.level[l].cat;
 		ebitmap_for_each_positive_bit(e, node, i) {
 			if (i - prev > 1) {
-				/* one or more negative bits are skipped */
+				
 				if (prev != head) {
 					if (prev - head > 1)
 						*scontextp++ = '.';
@@ -174,10 +160,6 @@
 		if (i > p->p_cats.nprim)
 			return 0;
 		if (!ebitmap_get_bit(&levdatum->level->cat, i)) {
-			/*
-			 * Category may not be associated with
-			 * sensitivity.
-			 */
 			return 0;
 		}
 	}
@@ -192,10 +174,6 @@
 		mls_level_dom(&r->level[1], &r->level[0]));
 }
 
-/*
- * Return 1 if the MLS fields in the security context
- * structure `c' are valid.  Return 0 otherwise.
- */
 int mls_context_isvalid(struct policydb *p, struct context *c)
 {
 	struct user_datum *usrdatum;
@@ -209,36 +187,15 @@
 	if (c->role == OBJECT_R_VAL)
 		return 1;
 
-	/*
-	 * User must be authorized for the MLS range.
-	 */
 	if (!c->user || c->user > p->p_users.nprim)
 		return 0;
 	usrdatum = p->user_val_to_struct[c->user - 1];
 	if (!mls_range_contains(usrdatum->range, c->range))
-		return 0; /* user may not be associated with range */
+		return 0; 
 
 	return 1;
 }
 
-/*
- * Set the MLS fields in the security context structure
- * `context' based on the string representation in
- * the string `*scontext'.  Update `*scontext' to
- * point to the end of the string representation of
- * the MLS fields.
- *
- * This function modifies the string in place, inserting
- * NULL characters to terminate the MLS fields.
- *
- * If a def_sid is provided and no MLS field is present,
- * copy the MLS field of the associated default context.
- * Used for upgraded to MLS systems where objects may lack
- * MLS fields.
- *
- * Policy read-lock must be held for sidtab lookup.
- *
- */
 int mls_context_to_sid(struct policydb *pol,
 		       char oldc,
 		       char **scontext,
@@ -259,10 +216,6 @@
 		return 0;
 	}
 
-	/*
-	 * No MLS component to the security context, try and map to
-	 * default if provided.
-	 */
 	if (!oldc) {
 		struct context *defcon;
 
@@ -277,7 +230,7 @@
 		goto out;
 	}
 
-	/* Extract low sensitivity. */
+	
 	scontextp = p = *scontext;
 	while (*p && *p != ':' && *p != '-')
 		p++;
@@ -296,7 +249,7 @@
 		context->range.level[l].sens = levdatum->level->sens;
 
 		if (delim == ':') {
-			/* Extract category set. */
+			
 			while (1) {
 				scontextp = p;
 				while (*p && *p != ',' && *p != '-')
@@ -305,10 +258,10 @@
 				if (delim != '\0')
 					*p++ = '\0';
 
-				/* Separate into range if exists */
+				
 				rngptr = strchr(scontextp, '.');
 				if (rngptr != NULL) {
-					/* Remove '.' */
+					
 					*rngptr++ = '\0';
 				}
 
@@ -324,7 +277,7 @@
 				if (rc)
 					goto out;
 
-				/* If range, set all categories in range */
+				
 				if (rngptr) {
 					int i;
 
@@ -351,7 +304,7 @@
 			}
 		}
 		if (delim == '-') {
-			/* Extract high sensitivity. */
+			
 			scontextp = p;
 			while (*p && *p != ':')
 				p++;
@@ -376,12 +329,6 @@
 	return rc;
 }
 
-/*
- * Set the MLS fields in the security context structure
- * `context' based on the string representation in
- * the string `str'.  This function will allocate temporary memory with the
- * given constraints of gfp_mask.
- */
 int mls_from_string(char *str, struct context *context, gfp_t gfp_mask)
 {
 	char *tmpstr, *freestr;
@@ -390,8 +337,6 @@
 	if (!policydb.mls_enabled)
 		return -EINVAL;
 
-	/* we need freestr because mls_context_to_sid will change
-	   the value of tmpstr */
 	tmpstr = freestr = kstrdup(str, gfp_mask);
 	if (!tmpstr) {
 		rc = -ENOMEM;
@@ -404,15 +349,12 @@
 	return rc;
 }
 
-/*
- * Copies the MLS range `range' into `context'.
- */
 int mls_range_set(struct context *context,
 				struct mls_range *range)
 {
 	int l, rc = 0;
 
-	/* Copy the MLS range into the  context */
+	
 	for (l = 0; l < 2; l++) {
 		context->range.level[l].sens = range->level[l].sens;
 		rc = ebitmap_cpy(&context->range.level[l].cat,
@@ -436,7 +378,7 @@
 		struct mls_level *usercon_sen = &(usercon->range.level[0]);
 		struct mls_level *usercon_clr = &(usercon->range.level[1]);
 
-		/* Honor the user's default level if we can */
+		
 		if (mls_level_between(user_def, fromcon_sen, fromcon_clr))
 			*usercon_sen = *user_def;
 		else if (mls_level_between(fromcon_sen, user_def, user_clr))
@@ -446,11 +388,6 @@
 		else
 			return -EINVAL;
 
-		/* Lower the clearance of available contexts
-		   if the clearance of "fromcon" is lower than
-		   that of the user's default clearance (but
-		   only if the "fromcon" clearance dominates
-		   the user's computed sensitivity level) */
 		if (mls_level_dom(user_clr, fromcon_clr))
 			*usercon_clr = *fromcon_clr;
 		else if (mls_level_dom(fromcon_clr, user_clr))
@@ -462,11 +399,6 @@
 	return 0;
 }
 
-/*
- * Convert the MLS fields in the security context
- * structure `c' from the values specified in the
- * policy `oldp' to the values specified in the policy `newp'.
- */
 int mls_convert_context(struct policydb *oldp,
 			struct policydb *newp,
 			struct context *c)
@@ -523,41 +455,31 @@
 
 	switch (specified) {
 	case AVTAB_TRANSITION:
-		/* Look for a range transition rule. */
+		
 		rtr.source_type = scontext->type;
 		rtr.target_type = tcontext->type;
 		rtr.target_class = tclass;
 		r = hashtab_search(policydb.range_tr, &rtr);
 		if (r)
 			return mls_range_set(newcontext, r);
-		/* Fallthrough */
+		
 	case AVTAB_CHANGE:
 		if ((tclass == policydb.process_class) || (sock == true))
-			/* Use the process MLS attributes. */
+			
 			return mls_context_cpy(newcontext, scontext);
 		else
-			/* Use the process effective MLS attributes. */
+			
 			return mls_context_cpy_low(newcontext, scontext);
 	case AVTAB_MEMBER:
-		/* Use the process effective MLS attributes. */
+		
 		return mls_context_cpy_low(newcontext, scontext);
 
-	/* fall through */
+	
 	}
 	return -EINVAL;
 }
 
 #ifdef CONFIG_NETLABEL
-/**
- * mls_export_netlbl_lvl - Export the MLS sensitivity levels to NetLabel
- * @context: the security context
- * @secattr: the NetLabel security attributes
- *
- * Description:
- * Given the security context copy the low MLS sensitivity level into the
- * NetLabel MLS sensitivity level field.
- *
- */
 void mls_export_netlbl_lvl(struct context *context,
 			   struct netlbl_lsm_secattr *secattr)
 {
@@ -568,16 +490,6 @@
 	secattr->flags |= NETLBL_SECATTR_MLS_LVL;
 }
 
-/**
- * mls_import_netlbl_lvl - Import the NetLabel MLS sensitivity levels
- * @context: the security context
- * @secattr: the NetLabel security attributes
- *
- * Description:
- * Given the security context and the NetLabel security attributes, copy the
- * NetLabel MLS sensitivity level into the context.
- *
- */
 void mls_import_netlbl_lvl(struct context *context,
 			   struct netlbl_lsm_secattr *secattr)
 {
@@ -588,16 +500,6 @@
 	context->range.level[1].sens = context->range.level[0].sens;
 }
 
-/**
- * mls_export_netlbl_cat - Export the MLS categories to NetLabel
- * @context: the security context
- * @secattr: the NetLabel security attributes
- *
- * Description:
- * Given the security context copy the low MLS categories into the NetLabel
- * MLS category field.  Returns zero on success, negative values on failure.
- *
- */
 int mls_export_netlbl_cat(struct context *context,
 			  struct netlbl_lsm_secattr *secattr)
 {
@@ -614,18 +516,6 @@
 	return rc;
 }
 
-/**
- * mls_import_netlbl_cat - Import the MLS categories from NetLabel
- * @context: the security context
- * @secattr: the NetLabel security attributes
- *
- * Description:
- * Copy the NetLabel security attributes into the SELinux context; since the
- * NetLabel security attribute only contains a single MLS category use it for
- * both the low and high categories of the context.  Returns zero on success,
- * negative values on failure.
- *
- */
 int mls_import_netlbl_cat(struct context *context,
 			  struct netlbl_lsm_secattr *secattr)
 {
@@ -651,4 +541,4 @@
 	ebitmap_destroy(&context->range.level[1].cat);
 	return rc;
 }
-#endif /* CONFIG_NETLABEL */
+#endif 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,4 @@
 /*
- * Multi-level security (MLS) policy operations.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
-/*
  * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>
  *
  *	Support for enhanced MLS infrastructure.
@@ -87,5 +82,5 @@
 }
 #endif
 
-#endif	/* _SS_MLS_H */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls_types.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls_types.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/mls_types.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/mls_types.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,4 @@
 /*
- * Type definitions for the multi-level security (MLS) policy.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
-/*
  * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>
  *
  *	Support for enhanced MLS infrastructure.
@@ -18,12 +13,12 @@
 #include "ebitmap.h"
 
 struct mls_level {
-	u32 sens;		/* sensitivity */
-	struct ebitmap cat;	/* category set */
+	u32 sens;		
+	struct ebitmap cat;	
 };
 
 struct mls_range {
-	struct mls_level level[2]; /* low == level[0], high == level[1] */
+	struct mls_level level[2]; 
 };
 
 static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)
@@ -48,4 +43,4 @@
 (mls_level_dom(&(r2).level[0], &(r1).level[0]) && \
  mls_level_dom(&(r1).level[1], &(r2).level[1]))
 
-#endif	/* _SS_MLS_TYPES_H_ */
+#endif	
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/policydb.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/policydb.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/policydb.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/policydb.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the policy database.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 
 /*
  * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>
@@ -71,7 +66,6 @@
 	int ocon_num;
 };
 
-/* These need to be updated if SYM_NUM or OCON_NUM changes */
 static struct policydb_compat_info policydb_compat[] = {
 	{
 		.version	= POLICYDB_VERSION_BASE,
@@ -149,9 +143,6 @@
 	return info;
 }
 
-/*
- * Initialize the role table.
- */
 static int roles_init(struct policydb *p)
 {
 	char *key = NULL;
@@ -246,9 +237,6 @@
 	return v;
 }
 
-/*
- * Initialize a policy database structure.
- */
 static int policydb_init(struct policydb *p)
 {
 	int i, rc;
@@ -294,15 +282,6 @@
 	return rc;
 }
 
-/*
- * The following *_index functions are used to
- * define the val_to_name and val_to_struct arrays
- * in a policy database structure.  The val_to_name
- * arrays are used when converting security context
- * structures into string representations.  The
- * val_to_struct arrays are used when the attributes
- * of a class, role, or user are needed.
- */
 
 static int common_index(void *key, void *datum, void *datap)
 {
@@ -490,12 +469,6 @@
 }
 #endif
 
-/*
- * Define the other val_to_name and val_to_struct arrays
- * in a policy database structure.
- *
- * Caller must clean up on failure.
- */
 static int policydb_index(struct policydb *p)
 {
 	int i, rc;
@@ -536,7 +509,7 @@
 	if (!p->user_val_to_struct)
 		goto out;
 
-	/* Yes, I want the sizeof the pointer, not the structure */
+	
 	rc = -ENOMEM;
 	p->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),
 						       p->p_types.nprim,
@@ -576,11 +549,6 @@
 	return rc;
 }
 
-/*
- * The following *_destroy functions are used to
- * free any memory allocated for each kind of
- * symbol data in the policy database.
- */
 
 static int perm_destroy(void *key, void *datum, void *p)
 {
@@ -752,9 +720,6 @@
 	kfree(c);
 }
 
-/*
- * Free any memory allocated by a policy database structure.
- */
 void policydb_destroy(struct policydb *p)
 {
 	struct ocontext *c, *ctmp;
@@ -850,10 +815,6 @@
 	return;
 }
 
-/*
- * Load the initial SIDs specified in a policy database
- * structure into a SID table.
- */
 int policydb_load_isids(struct policydb *p, struct sidtab *s)
 {
 	struct ocontext *head, *c;
@@ -907,10 +868,6 @@
 	return 1;
 }
 
-/*
- * Return 1 if the fields in the security context
- * structure `c' are valid.  Return 0 otherwise.
- */
 int policydb_context_isvalid(struct policydb *p, struct context *c)
 {
 	struct role_datum *role;
@@ -926,23 +883,17 @@
 		return 0;
 
 	if (c->role != OBJECT_R_VAL) {
-		/*
-		 * Role must be authorized for the type.
-		 */
 		role = p->role_val_to_struct[c->role - 1];
 		if (!ebitmap_get_bit(&role->types, c->type - 1))
-			/* role may not be associated with type */
+			
 			return 0;
 
-		/*
-		 * User must be authorized for the role.
-		 */
 		usrdatum = p->user_val_to_struct[c->user - 1];
 		if (!usrdatum)
 			return 0;
 
 		if (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))
-			/* user may not be associated with role */
+			
 			return 0;
 	}
 
@@ -952,10 +903,6 @@
 	return 1;
 }
 
-/*
- * Read a MLS range structure from a policydb binary
- * representation file.
- */
 static int mls_read_range_helper(struct mls_range *r, void *fp)
 {
 	__le32 buf[2];
@@ -1011,10 +958,6 @@
 	return rc;
 }
 
-/*
- * Read and validate a security context structure
- * from a policydb binary representation file.
- */
 static int context_read_and_validate(struct context *c,
 				     struct policydb *p,
 				     void *fp)
@@ -1049,11 +992,6 @@
 	return rc;
 }
 
-/*
- * The following *_read functions are used to
- * read the symbol data from a policy database
- * binary representation file.
- */
 
 static int perm_read(struct policydb *p, struct hashtab *h, void *fp)
 {
@@ -1296,7 +1234,7 @@
 		goto bad;
 
 	if (p->policyvers >= POLICYDB_VERSION_VALIDATETRANS) {
-		/* grab the validatetrans rules */
+		
 		rc = next_entry(buf, fp, sizeof(u32));
 		if (rc)
 			goto bad;
@@ -1433,10 +1371,6 @@
 }
 
 
-/*
- * Read a MLS level structure from a policydb binary
- * representation file.
- */
 static int mls_read_level(struct mls_level *lp, void *fp)
 {
 	__le32 buf[1];
@@ -1881,7 +1815,7 @@
 		if (!otype)
 			goto out;
 
-		/* length of the path component string */
+		
 		rc = next_entry(buf, fp, sizeof(u32));
 		if (rc)
 			goto out;
@@ -1894,7 +1828,7 @@
 
 		ft->name = name;
 
-		/* path component string */
+		
 		rc = next_entry(name, fp, len);
 		if (rc)
 			goto out;
@@ -2128,8 +2062,8 @@
 				rc = next_entry(nodebuf, fp, sizeof(u32) * 2);
 				if (rc)
 					goto out;
-				c->u.node.addr = nodebuf[0]; /* network order */
-				c->u.node.mask = nodebuf[1]; /* network order */
+				c->u.node.addr = nodebuf[0]; 
+				c->u.node.mask = nodebuf[1]; 
 				rc = context_read_and_validate(&c->context[0], p, fp);
 				if (rc)
 					goto out;
@@ -2181,10 +2115,6 @@
 	return rc;
 }
 
-/*
- * Read the configuration data from a policy database binary
- * representation file into a policy database structure.
- */
 int policydb_read(struct policydb *p, void *fp)
 {
 	struct role_allow *ra, *lra;
@@ -2200,7 +2130,7 @@
 	if (rc)
 		return rc;
 
-	/* Read the magic number and string length. */
+	
 	rc = next_entry(buf, fp, sizeof(u32) * 2);
 	if (rc)
 		goto bad;
@@ -2245,11 +2175,11 @@
 		kfree(policydb_str);
 		goto bad;
 	}
-	/* Done with policydb_str. */
+	
 	kfree(policydb_str);
 	policydb_str = NULL;
 
-	/* Read the version and table sizes. */
+	
 	rc = next_entry(buf, fp, sizeof(u32)*4);
 	if (rc)
 		goto bad;
@@ -2436,7 +2366,7 @@
 	if (!p->type_attr_map_array)
 		goto bad;
 
-	/* preallocate so we don't have to worry about the put ever failing */
+	
 	rc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,
 				 GFP_KERNEL | __GFP_ZERO);
 	if (rc)
@@ -2452,7 +2382,7 @@
 			if (rc)
 				goto bad;
 		}
-		/* add the type itself as the degenerate case */
+		
 		rc = ebitmap_set_bit(e, i, 1);
 		if (rc)
 			goto bad;
@@ -2470,10 +2400,6 @@
 	goto out;
 }
 
-/*
- * Write a MLS level structure to a policydb binary
- * representation file.
- */
 static int mls_write_level(struct mls_level *l, void *fp)
 {
 	__le32 buf[1];
@@ -2491,10 +2417,6 @@
 	return 0;
 }
 
-/*
- * Write a MLS range structure to a policydb binary
- * representation file.
- */
 static int mls_write_range_helper(struct mls_range *r, void *fp)
 {
 	__le32 buf[3];
@@ -2640,10 +2562,6 @@
 	return 0;
 }
 
-/*
- * Write a security context structure
- * to a policydb binary representation file.
- */
 static int context_write(struct policydb *p, struct context *c,
 			 void *fp)
 {
@@ -2665,11 +2583,6 @@
 	return 0;
 }
 
-/*
- * The following *_write functions are used to
- * write the symbol data to a policy database
- * binary representation file.
- */
 
 static int perm_write(void *vkey, void *datum, void *fp)
 {
@@ -2818,7 +2731,7 @@
 	if (rc)
 		return rc;
 
-	/* write out the validatetrans rule */
+	
 	ncons = 0;
 	for (c = cladatum->validatetrans; c; c = c->next)
 		ncons++;
@@ -3025,8 +2938,8 @@
 					return rc;
 				break;
 			case OCON_NODE:
-				nodebuf[0] = c->u.node.addr; /* network order */
-				nodebuf[1] = c->u.node.mask; /* network order */
+				nodebuf[0] = c->u.node.addr; 
+				nodebuf[1] = c->u.node.mask; 
 				rc = put_entry(nodebuf, sizeof(u32), 2, fp);
 				if (rc)
 					return rc;
@@ -3050,9 +2963,9 @@
 				break;
 			case OCON_NODE6:
 				for (j = 0; j < 4; j++)
-					nodebuf[j] = c->u.node6.addr[j]; /* network order */
+					nodebuf[j] = c->u.node6.addr[j]; 
 				for (j = 0; j < 4; j++)
-					nodebuf[j + 4] = c->u.node6.mask[j]; /* network order */
+					nodebuf[j + 4] = c->u.node6.mask[j]; 
 				rc = put_entry(nodebuf, sizeof(u32), 8, fp);
 				if (rc)
 					return rc;
@@ -3164,7 +3077,7 @@
 	pd.p = p;
 	pd.fp = fp;
 
-	/* count the number of entries in the hashtab */
+	
 	nel = 0;
 	rc = hashtab_map(p->range_tr, hashtab_cnt, &nel);
 	if (rc)
@@ -3175,7 +3088,7 @@
 	if (rc)
 		return rc;
 
-	/* actually write all of the entries */
+	
 	rc = hashtab_map(p->range_tr, range_write_helper, &pd);
 	if (rc)
 		return rc;
@@ -3240,11 +3153,6 @@
 	return 0;
 }
 
-/*
- * Write the configuration data in a policy database
- * structure to a policy database binary representation
- * file.
- */
 int policydb_write(struct policydb *p, void *fp)
 {
 	unsigned int i, num_syms;
@@ -3254,12 +3162,6 @@
 	size_t len;
 	struct policydb_compat_info *info;
 
-	/*
-	 * refuse to write policy older than compressed avtab
-	 * to simplify the writer.  There are other tests dropped
-	 * since we assume this throughout the writer code.  Be
-	 * careful if you ever try to remove this restriction
-	 */
 	if (p->policyvers < POLICYDB_VERSION_AVTAB) {
 		printk(KERN_ERR "SELinux: refusing to write policy version %d."
 		       "  Because it is less than version %d\n", p->policyvers,
@@ -3276,7 +3178,7 @@
 	if (p->allow_unknown)
 		config |= ALLOW_UNKNOWN;
 
-	/* Write the magic number and string identifiers. */
+	
 	buf[0] = cpu_to_le32(POLICYDB_MAGIC);
 	len = strlen(POLICYDB_STRING);
 	buf[1] = cpu_to_le32(len);
@@ -3287,7 +3189,7 @@
 	if (rc)
 		return rc;
 
-	/* Write the version, config, and table sizes. */
+	
 	info = policydb_lookup_compat(p->policyvers);
 	if (!info) {
 		printk(KERN_ERR "SELinux: compatibility lookup failed for policy "
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/policydb.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/policydb.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/policydb.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/policydb.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,9 +1,3 @@
-/*
- * A policy database (policydb) specifies the
- * configuration data for the security policy.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 
 /*
  * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>
@@ -34,95 +28,81 @@
 #include "context.h"
 #include "constraint.h"
 
-/*
- * A datum type is defined for each kind of symbol
- * in the configuration data:  individual permissions,
- * common prefixes for access vectors, classes,
- * users, roles, types, sensitivities, categories, etc.
- */
 
-/* Permission attributes */
 struct perm_datum {
-	u32 value;		/* permission bit + 1 */
+	u32 value;		
 };
 
-/* Attributes of a common prefix for access vectors */
 struct common_datum {
-	u32 value;			/* internal common value */
-	struct symtab permissions;	/* common permissions */
+	u32 value;			
+	struct symtab permissions;	
 };
 
-/* Class attributes */
 struct class_datum {
-	u32 value;			/* class value */
-	char *comkey;			/* common name */
-	struct common_datum *comdatum;	/* common datum */
-	struct symtab permissions;	/* class-specific permission symbol table */
-	struct constraint_node *constraints;	/* constraints on class permissions */
-	struct constraint_node *validatetrans;	/* special transition rules */
+	u32 value;			
+	char *comkey;			
+	struct common_datum *comdatum;	
+	struct symtab permissions;	
+	struct constraint_node *constraints;	
+	struct constraint_node *validatetrans;	
 };
 
-/* Role attributes */
 struct role_datum {
-	u32 value;			/* internal role value */
-	u32 bounds;			/* boundary of role */
-	struct ebitmap dominates;	/* set of roles dominated by this role */
-	struct ebitmap types;		/* set of authorized types for role */
+	u32 value;			
+	u32 bounds;			
+	struct ebitmap dominates;	
+	struct ebitmap types;		
 };
 
 struct role_trans {
-	u32 role;		/* current role */
-	u32 type;		/* program executable type, or new object type */
-	u32 tclass;		/* process class, or new object class */
-	u32 new_role;		/* new role */
+	u32 role;		
+	u32 type;		
+	u32 tclass;		
+	u32 new_role;		
 	struct role_trans *next;
 };
 
 struct filename_trans {
-	u32 stype;		/* current process */
-	u32 ttype;		/* parent dir context */
-	u16 tclass;		/* class of new object */
-	const char *name;	/* last path component */
+	u32 stype;		
+	u32 ttype;		
+	u16 tclass;		
+	const char *name;	
 };
 
 struct filename_trans_datum {
-	u32 otype;		/* expected of new object */
+	u32 otype;		
 };
 
 struct role_allow {
-	u32 role;		/* current role */
-	u32 new_role;		/* new role */
+	u32 role;		
+	u32 new_role;		
 	struct role_allow *next;
 };
 
-/* Type attributes */
 struct type_datum {
-	u32 value;		/* internal type value */
-	u32 bounds;		/* boundary of type */
-	unsigned char primary;	/* primary name? */
-	unsigned char attribute;/* attribute ?*/
+	u32 value;		
+	u32 bounds;		
+	unsigned char primary;	
+	unsigned char attribute;
 };
 
-/* User attributes */
 struct user_datum {
-	u32 value;			/* internal user value */
-	u32 bounds;			/* bounds of user */
-	struct ebitmap roles;		/* set of authorized roles for user */
-	struct mls_range range;		/* MLS range (min - max) for user */
-	struct mls_level dfltlevel;	/* default login MLS level for user */
+	u32 value;			
+	u32 bounds;			
+	struct ebitmap roles;		
+	struct mls_range range;		
+	struct mls_level dfltlevel;	
 };
 
 
-/* Sensitivity attributes */
 struct level_datum {
-	struct mls_level *level;	/* sensitivity and associated categories */
-	unsigned char isalias;	/* is this sensitivity an alias for another? */
+	struct mls_level *level;	
+	unsigned char isalias;	
 };
 
-/* Category attributes */
 struct cat_datum {
-	u32 value;		/* internal category bit + 1 */
-	unsigned char isalias;  /* is this category an alias for another? */
+	u32 value;		
+	unsigned char isalias;  
 };
 
 struct range_trans {
@@ -131,44 +111,36 @@
 	u32 target_class;
 };
 
-/* Boolean data type */
 struct cond_bool_datum {
-	__u32 value;		/* internal type value */
+	__u32 value;		
 	int state;
 };
 
 struct cond_node;
 
-/*
- * The configuration data includes security contexts for
- * initial SIDs, unlabeled file systems, TCP and UDP port numbers,
- * network interfaces, and nodes.  This structure stores the
- * relevant data for one such entry.  Entries of the same kind
- * (e.g. all initial SIDs) are linked together into a list.
- */
 struct ocontext {
 	union {
-		char *name;	/* name of initial SID, fs, netif, fstype, path */
+		char *name;	
 		struct {
 			u8 protocol;
 			u16 low_port;
 			u16 high_port;
-		} port;		/* TCP or UDP port information */
+		} port;		
 		struct {
 			u32 addr;
 			u32 mask;
-		} node;		/* node information */
+		} node;		
 		struct {
 			u32 addr[4];
 			u32 mask[4];
-		} node6;        /* IPv6 node information */
+		} node6;        
 	} u;
 	union {
-		u32 sclass;  /* security class for genfs */
-		u32 behavior;  /* labeling behavior for fs_use */
+		u32 sclass;  
+		u32 behavior;  
 	} v;
-	struct context context[2];	/* security context(s) */
-	u32 sid[2];	/* SID(s) */
+	struct context context[2];	
+	u32 sid[2];	
 	struct ocontext *next;
 };
 
@@ -178,7 +150,6 @@
 	struct genfs *next;
 };
 
-/* symbol table array indices */
 #define SYM_COMMONS 0
 #define SYM_CLASSES 1
 #define SYM_ROLES   2
@@ -189,21 +160,19 @@
 #define SYM_CATS    7
 #define SYM_NUM     8
 
-/* object context array indices */
-#define OCON_ISID  0	/* initial SIDs */
-#define OCON_FS    1	/* unlabeled file systems */
-#define OCON_PORT  2	/* TCP and UDP port numbers */
-#define OCON_NETIF 3	/* network interfaces */
-#define OCON_NODE  4	/* nodes */
-#define OCON_FSUSE 5	/* fs_use */
-#define OCON_NODE6 6	/* IPv6 nodes */
+#define OCON_ISID  0	
+#define OCON_FS    1	
+#define OCON_PORT  2	
+#define OCON_NETIF 3	
+#define OCON_NODE  4	
+#define OCON_FSUSE 5	
+#define OCON_NODE6 6	
 #define OCON_NUM   7
 
-/* The policy database */
 struct policydb {
 	int mls_enabled;
 
-	/* symbol tables */
+	
 	struct symtab symtab[SYM_NUM];
 #define p_commons symtab[SYM_COMMONS]
 #define p_classes symtab[SYM_CLASSES]
@@ -214,57 +183,52 @@
 #define p_levels symtab[SYM_LEVELS]
 #define p_cats symtab[SYM_CATS]
 
-	/* symbol names indexed by (value - 1) */
+	
 	struct flex_array *sym_val_to_name[SYM_NUM];
 
-	/* class, role, and user attributes indexed by (value - 1) */
+	
 	struct class_datum **class_val_to_struct;
 	struct role_datum **role_val_to_struct;
 	struct user_datum **user_val_to_struct;
 	struct flex_array *type_val_to_struct_array;
 
-	/* type enforcement access vectors and transitions */
+	
 	struct avtab te_avtab;
 
-	/* role transitions */
+	
 	struct role_trans *role_tr;
 
-	/* file transitions with the last path component */
-	/* quickly exclude lookups when parent ttype has no rules */
+	
+	
 	struct ebitmap filename_trans_ttypes;
-	/* actual set of filename_trans rules */
+	
 	struct hashtab *filename_trans;
 
-	/* bools indexed by (value - 1) */
+	
 	struct cond_bool_datum **bool_val_to_struct;
-	/* type enforcement conditional access vectors and transitions */
+	
 	struct avtab te_cond_avtab;
-	/* linked list indexing te_cond_avtab by conditional */
+	
 	struct cond_node *cond_list;
 
-	/* role allows */
+	
 	struct role_allow *role_allow;
 
-	/* security contexts of initial SIDs, unlabeled file systems,
-	   TCP or UDP port numbers, network interfaces and nodes */
 	struct ocontext *ocontexts[OCON_NUM];
 
-	/* security contexts for files in filesystems that cannot support
-	   a persistent label mapping or use another
-	   fixed labeling behavior. */
 	struct genfs *genfs;
 
-	/* range transitions table (range_trans_key -> mls_range) */
+	
 	struct hashtab *range_tr;
 
-	/* type -> attribute reverse mapping */
+	
 	struct flex_array *type_attr_map_array;
 
 	struct ebitmap policycaps;
 
 	struct ebitmap permissive_map;
 
-	/* length of this policy when it was loaded */
+	
 	size_t len;
 
 	unsigned int policyvers;
@@ -289,7 +253,6 @@
 
 #define POLICYDB_CONFIG_MLS    1
 
-/* the config flags related to unknown classes/perms are bits 2 and 3 */
 #define REJECT_UNKNOWN	0x00000002
 #define ALLOW_UNKNOWN	0x00000004
 
@@ -341,5 +304,5 @@
 extern u16 string_to_security_class(struct policydb *p, const char *name);
 extern u32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name);
 
-#endif	/* _SS_POLICYDB_H_ */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/services.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/services.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/services.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/services.c	2013-08-01 23:38:04.000000000 -0600
@@ -79,15 +79,8 @@
 struct policydb policydb;
 int ss_initialized;
 
-/*
- * The largest sequence number that has been used when
- * providing an access decision to the access vector cache.
- * The sequence number only changes when a policy change
- * occurs.
- */
 static u32 latest_granting;
 
-/* Forward declaration. */
 static int context_struct_to_string(struct context *context, char **scontext,
 				    u32 *scontext_len);
 
@@ -97,7 +90,7 @@
 				      struct av_decision *avd);
 
 struct selinux_mapping {
-	u16 value; /* policy value */
+	u16 value; 
 	unsigned num_perms;
 	u32 perms[sizeof(u32) * 8];
 };
@@ -116,25 +109,25 @@
 	unsigned k;
 	bool print_unknown_handle = false;
 
-	/* Find number of classes in the input mapping */
+	
 	if (!map)
 		return -EINVAL;
 	i = 0;
 	while (map[i].name)
 		i++;
 
-	/* Allocate space for the class records, plus one for class zero */
+	
 	out_map = kcalloc(++i, size, GFP_ATOMIC);
 	if (!out_map)
 		return -ENOMEM;
 
-	/* Store the raw class and permission values */
+	
 	j = 0;
 	while (map[j].name) {
 		struct security_class_mapping *p_in = map + (j++);
 		struct selinux_mapping *p_out = out_map + j;
 
-		/* An empty class string skips ahead */
+		
 		if (!strcmp(p_in->name, "")) {
 			p_out->num_perms = 0;
 			continue;
@@ -154,7 +147,7 @@
 
 		k = 0;
 		while (p_in->perms && p_in->perms[k]) {
-			/* An empty permission string skips ahead */
+			
 			if (!*p_in->perms[k]) {
 				k++;
 				continue;
@@ -187,9 +180,6 @@
 	return -EINVAL;
 }
 
-/*
- * Get real, policy values from mapped values
- */
 
 static u16 unmap_class(u16 tclass)
 {
@@ -199,9 +189,6 @@
 	return tclass;
 }
 
-/*
- * Get kernel value for class from its policy value
- */
 static u16 map_class(u16 pol_value)
 {
 	u16 i;
@@ -240,11 +227,6 @@
 			if (!allow_unknown && !current_mapping[tclass].perms[i])
 				result |= 1<<i;
 		}
-		/*
-		 * In case the kernel has a bug and requests a permission
-		 * between num_perms and the maximum permission number, we
-		 * should audit that denial
-		 */
 		for (; i < (sizeof(u32)*8); i++)
 			result |= 1<<i;
 		avd->auditdeny = result;
@@ -256,17 +238,6 @@
 	return policydb.mls_enabled;
 }
 
-/*
- * Return the boolean value of a constraint expression
- * when it is applied to the specified source and target
- * security contexts.
- *
- * xcontext is a special beast...  It is used by the validatetrans rules
- * only.  For these rules, scontext is the context before the transition,
- * tcontext is the context after the transition, and xcontext is the context
- * of the process performing the transition.  All other callers of
- * constraint_expr_eval should pass in NULL for xcontext.
- */
 static int constraint_expr_eval(struct context *scontext,
 				struct context *tcontext,
 				struct context *xcontext,
@@ -441,10 +412,6 @@
 	return s[0];
 }
 
-/*
- * security_dump_masked_av - dumps masked permissions during
- * security_compute_av due to RBAC, MLS/Constraint and Type bounds.
- */
 static int dump_masked_av_helper(void *k, void *d, void *args)
 {
 	struct perm_datum *pdatum = d;
@@ -481,7 +448,7 @@
 	tclass_dat = policydb.class_val_to_struct[tclass - 1];
 	common_dat = tclass_dat->comdatum;
 
-	/* init permission_names */
+	
 	if (common_dat &&
 	    hashtab_map(common_dat->permissions.table,
 			dump_masked_av_helper, permission_names) < 0)
@@ -491,7 +458,7 @@
 			dump_masked_av_helper, permission_names) < 0)
 		goto out;
 
-	/* get scontext/tcontext in text form */
+	
 	if (context_struct_to_string(scontext,
 				     &scontext_name, &length) < 0)
 		goto out;
@@ -500,7 +467,7 @@
 				     &tcontext_name, &length) < 0)
 		goto out;
 
-	/* audit a message */
+	
 	ab = audit_log_start(current->audit_context,
 			     GFP_ATOMIC, AUDIT_SELINUX_ERR);
 	if (!ab)
@@ -524,17 +491,13 @@
 	}
 	audit_log_end(ab);
 out:
-	/* release scontext/tcontext */
+	
 	kfree(tcontext_name);
 	kfree(scontext_name);
 
 	return;
 }
 
-/*
- * security_boundary_permission - drops violated permissions
- * on boundary constraint.
- */
 static void type_attribute_bounds_av(struct context *scontext,
 				     struct context *tcontext,
 				     u16 tclass,
@@ -566,7 +529,7 @@
 					  tclass,
 					  &lo_avd);
 		if ((lo_avd.allowed & avd->allowed) == avd->allowed)
-			return;		/* no masked permission */
+			return;		
 		masked = ~lo_avd.allowed & avd->allowed;
 	}
 
@@ -581,40 +544,32 @@
 					  tclass,
 					  &lo_avd);
 		if ((lo_avd.allowed & avd->allowed) == avd->allowed)
-			return;		/* no masked permission */
+			return;		
 		masked = ~lo_avd.allowed & avd->allowed;
 	}
 
 	if (source->bounds && target->bounds) {
 		memset(&lo_avd, 0, sizeof(lo_avd));
-		/*
-		 * lo_scontext and lo_tcontext are already
-		 * set up.
-		 */
 
 		context_struct_compute_av(&lo_scontext,
 					  &lo_tcontext,
 					  tclass,
 					  &lo_avd);
 		if ((lo_avd.allowed & avd->allowed) == avd->allowed)
-			return;		/* no masked permission */
+			return;		
 		masked = ~lo_avd.allowed & avd->allowed;
 	}
 
 	if (masked) {
-		/* mask violated permissions */
+		
 		avd->allowed &= ~masked;
 
-		/* audit masked permissions */
+		
 		security_dump_masked_av(scontext, tcontext,
 					tclass, masked, "bounds");
 	}
 }
 
-/*
- * Compute access vectors based on a context structure pair for
- * the permissions in a particular class.
- */
 static void context_struct_compute_av(struct context *scontext,
 				      struct context *tcontext,
 				      u16 tclass,
@@ -641,10 +596,6 @@
 
 	tclass_datum = policydb.class_val_to_struct[tclass - 1];
 
-	/*
-	 * If a specific type enforcement rule was defined for
-	 * this permission check, then use it.
-	 */
 	avkey.target_class = tclass;
 	avkey.specified = AVTAB_AV;
 	sattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);
@@ -666,16 +617,12 @@
 					avd->auditdeny &= node->datum.data;
 			}
 
-			/* Check conditional av table for additional permissions */
+			
 			cond_compute_av(&policydb.te_cond_avtab, &avkey, avd);
 
 		}
 	}
 
-	/*
-	 * Remove any permissions prohibited by a constraint (this includes
-	 * the MLS policy).
-	 */
 	constraint = tclass_datum->constraints;
 	while (constraint) {
 		if ((constraint->permissions & (avd->allowed)) &&
@@ -686,11 +633,6 @@
 		constraint = constraint->next;
 	}
 
-	/*
-	 * If checking process transition permission and the
-	 * role is changing, then check the (current_role, new_role)
-	 * pair.
-	 */
 	if (tclass == policydb.process_class &&
 	    (avd->allowed & policydb.process_trans_perms) &&
 	    scontext->role != tcontext->role) {
@@ -703,11 +645,6 @@
 			avd->allowed &= ~policydb.process_trans_perms;
 	}
 
-	/*
-	 * If the given source and target types have boundary
-	 * constraint, lazy checks have to mask any violated
-	 * permission and notice it to userspace via audit.
-	 */
 	type_attribute_bounds_av(scontext, tcontext,
 				 tclass, avd);
 }
@@ -806,15 +743,6 @@
 	return rc;
 }
 
-/*
- * security_bounded_transition - check whether the given
- * transition is directed to bounded, or not.
- * It returns 0, if @newsid is bounded by @oldsid.
- * Otherwise, it returns error code.
- *
- * @oldsid : current security identifier
- * @newsid : destinated security identifier
- */
 int security_bounded_transition(u32 old_sid, u32 new_sid)
 {
 	struct context *old_context, *new_context;
@@ -841,7 +769,7 @@
 	}
 
 	rc = 0;
-	/* type/domain unchanged */
+	
 	if (old_context->type == new_context->type)
 		goto out;
 
@@ -851,12 +779,12 @@
 					  index - 1);
 		BUG_ON(!type);
 
-		/* not bounded anymore */
+		
 		rc = -EPERM;
 		if (!type->bounds)
 			break;
 
-		/* @newsid is bounded by @oldsid */
+		
 		rc = 0;
 		if (type->bounds == old_context->type)
 			break;
@@ -899,16 +827,6 @@
 }
 
 
-/**
- * security_compute_av - Compute access vector decisions.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @avd: access vector decisions
- *
- * Compute a set of access vector decisions based on the
- * SID pair (@ssid, @tsid) for the permissions in @tclass.
- */
 void security_compute_av(u32 ssid,
 			 u32 tsid,
 			 u16 orig_tclass,
@@ -929,7 +847,7 @@
 		goto out;
 	}
 
-	/* permissive domain? */
+	
 	if (ebitmap_get_bit(&policydb.permissive_map, scontext->type))
 		avd->flags |= AVD_FLAGS_PERMISSIVE;
 
@@ -975,7 +893,7 @@
 		goto out;
 	}
 
-	/* permissive domain? */
+	
 	if (ebitmap_get_bit(&policydb.permissive_map, scontext->type))
 		avd->flags |= AVD_FLAGS_PERMISSIVE;
 
@@ -1001,13 +919,6 @@
 	goto out;
 }
 
-/*
- * Write the security context string representation of
- * the context structure `context' into a dynamically
- * allocated string of the correct size.  Set `*scontext'
- * to point to this string and set `*scontext_len' to
- * the length of the string.
- */
 static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)
 {
 	char *scontextp;
@@ -1024,7 +935,7 @@
 		return 0;
 	}
 
-	/* Compute the size of the context. */
+	
 	*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;
 	*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;
 	*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;
@@ -1033,15 +944,12 @@
 	if (!scontext)
 		return 0;
 
-	/* Allocate space for the context; caller must free this space. */
+	
 	scontextp = kmalloc(*scontext_len, GFP_ATOMIC);
 	if (!scontextp)
 		return -ENOMEM;
 	*scontext = scontextp;
 
-	/*
-	 * Copy the user name, role name and type name into the context.
-	 */
 	sprintf(scontextp, "%s:%s:%s",
 		sym_name(&policydb, SYM_USERS, context->user - 1),
 		sym_name(&policydb, SYM_ROLES, context->role - 1),
@@ -1116,16 +1024,6 @@
 
 }
 
-/**
- * security_sid_to_context - Obtain a context for a given SID.
- * @sid: security identifier, SID
- * @scontext: security context
- * @scontext_len: length in bytes
- *
- * Write the string representation of the context associated with @sid
- * into a dynamically allocated string of the correct size.  Set @scontext
- * to point to this string and set @scontext_len to the length of the string.
- */
 int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)
 {
 	return security_sid_to_context_core(sid, scontext, scontext_len, 0);
@@ -1136,9 +1034,6 @@
 	return security_sid_to_context_core(sid, scontext, scontext_len, 1);
 }
 
-/*
- * Caveat:  Mutates scontext.
- */
 static int string_to_context_struct(struct policydb *pol,
 				    struct sidtab *sidtabp,
 				    char *scontext,
@@ -1154,12 +1049,12 @@
 
 	context_init(ctx);
 
-	/* Parse the security context. */
+	
 
 	rc = -EINVAL;
 	scontextp = (char *) scontext;
 
-	/* Extract the user. */
+	
 	p = scontextp;
 	while (*p && *p != ':')
 		p++;
@@ -1175,7 +1070,7 @@
 
 	ctx->user = usrdatum->value;
 
-	/* Extract role. */
+	
 	scontextp = p;
 	while (*p && *p != ':')
 		p++;
@@ -1190,7 +1085,7 @@
 		goto out;
 	ctx->role = role->value;
 
-	/* Extract type. */
+	
 	scontextp = p;
 	while (*p && *p != ':')
 		p++;
@@ -1211,7 +1106,7 @@
 	if ((p - scontext) < scontext_len)
 		goto out;
 
-	/* Check the validity of the new context. */
+	
 	if (!policydb_context_isvalid(pol, ctx))
 		goto out;
 	rc = 0;
@@ -1243,7 +1138,7 @@
 	}
 	*sid = SECSID_NULL;
 
-	/* Copy the string so that we can modify the copy as we parse it. */
+	
 	scontext2 = kmalloc(scontext_len + 1, gfp_flags);
 	if (!scontext2)
 		return -ENOMEM;
@@ -1251,7 +1146,7 @@
 	scontext2[scontext_len] = 0;
 
 	if (force) {
-		/* Save another copy for storing in uninterpreted form */
+		
 		rc = -ENOMEM;
 		str = kstrdup(scontext2, gfp_flags);
 		if (!str)
@@ -1277,41 +1172,12 @@
 	return rc;
 }
 
-/**
- * security_context_to_sid - Obtain a SID for a given security context.
- * @scontext: security context
- * @scontext_len: length in bytes
- * @sid: security identifier, SID
- *
- * Obtains a SID associated with the security context that
- * has the string representation specified by @scontext.
- * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient
- * memory is available, or 0 on success.
- */
 int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid)
 {
 	return security_context_to_sid_core(scontext, scontext_len,
 					    sid, SECSID_NULL, GFP_KERNEL, 0);
 }
 
-/**
- * security_context_to_sid_default - Obtain a SID for a given security context,
- * falling back to specified default if needed.
- *
- * @scontext: security context
- * @scontext_len: length in bytes
- * @sid: security identifier, SID
- * @def_sid: default SID to assign on error
- *
- * Obtains a SID associated with the security context that
- * has the string representation specified by @scontext.
- * The default SID is passed to the MLS layer to be used to allow
- * kernel labeling of the MLS field if the MLS field is not present
- * (for upgrading to MLS without full relabel).
- * Implicitly forces adding of the context even if it cannot be mapped yet.
- * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient
- * memory is available, or 0 on success.
- */
 int security_context_to_sid_default(const char *scontext, u32 scontext_len,
 				    u32 *sid, u32 def_sid, gfp_t gfp_flags)
 {
@@ -1363,11 +1229,6 @@
 	struct filename_trans ft;
 	struct filename_trans_datum *otype;
 
-	/*
-	 * Most filename trans rules are going to live in specific directories
-	 * like /dev or /var/run.  This bitmap will quickly skip rule searches
-	 * if the ttype does not contain any rules.
-	 */
 	if (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))
 		return;
 
@@ -1400,7 +1261,7 @@
 
 	if (!ss_initialized) {
 		switch (orig_tclass) {
-		case SECCLASS_PROCESS: /* kernel value */
+		case SECCLASS_PROCESS: 
 			*out_sid = ssid;
 			break;
 		default:
@@ -1437,39 +1298,39 @@
 		goto out_unlock;
 	}
 
-	/* Set the user identity. */
+	
 	switch (specified) {
 	case AVTAB_TRANSITION:
 	case AVTAB_CHANGE:
-		/* Use the process user identity. */
+		
 		newcontext.user = scontext->user;
 		break;
 	case AVTAB_MEMBER:
-		/* Use the related object owner. */
+		
 		newcontext.user = tcontext->user;
 		break;
 	}
 
-	/* Set the role and type to default values. */
+	
 	if ((tclass == policydb.process_class) || (sock == true)) {
-		/* Use the current role and type of process. */
+		
 		newcontext.role = scontext->role;
 		newcontext.type = scontext->type;
 	} else {
-		/* Use the well-defined object role. */
+		
 		newcontext.role = OBJECT_R_VAL;
-		/* Use the type of the related object. */
+		
 		newcontext.type = tcontext->type;
 	}
 
-	/* Look for a type transition/member/change rule. */
+	
 	avkey.source_type = scontext->type;
 	avkey.target_type = tcontext->type;
 	avkey.target_class = tclass;
 	avkey.specified = specified;
 	avdatum = avtab_search(&policydb.te_avtab, &avkey);
 
-	/* If no permanent rule, also check for enabled conditional rules */
+	
 	if (!avdatum) {
 		node = avtab_search_node(&policydb.te_cond_avtab, &avkey);
 		for (; node; node = avtab_search_node_next(node, specified)) {
@@ -1481,37 +1342,35 @@
 	}
 
 	if (avdatum) {
-		/* Use the type from the type transition/member/change rule. */
+		
 		newcontext.type = avdatum->data;
 	}
 
-	/* if we have a objname this is a file trans check so check those rules */
+	
 	if (objname)
 		filename_compute_type(&policydb, &newcontext, scontext->type,
 				      tcontext->type, tclass, objname);
 
-	/* Check for class-specific changes. */
+	
 	if (specified & AVTAB_TRANSITION) {
-		/* Look for a role transition rule. */
+		
 		for (roletr = policydb.role_tr; roletr; roletr = roletr->next) {
 			if ((roletr->role == scontext->role) &&
 			    (roletr->type == tcontext->type) &&
 			    (roletr->tclass == tclass)) {
-				/* Use the role transition rule. */
+				
 				newcontext.role = roletr->new_role;
 				break;
 			}
 		}
 	}
 
-	/* Set the MLS attributes.
-	   This is done last because it may allocate memory. */
 	rc = mls_compute_sid(scontext, tcontext, tclass, specified,
 			     &newcontext, sock);
 	if (rc)
 		goto out_unlock;
 
-	/* Check the validity of the context. */
+	
 	if (!policydb_context_isvalid(&policydb, &newcontext)) {
 		rc = compute_sid_handle_invalid_context(scontext,
 							tcontext,
@@ -1520,7 +1379,7 @@
 		if (rc)
 			goto out_unlock;
 	}
-	/* Obtain the sid for the context. */
+	
 	rc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);
 out_unlock:
 	read_unlock(&policy_rwlock);
@@ -1529,19 +1388,6 @@
 	return rc;
 }
 
-/**
- * security_transition_sid - Compute the SID for a new subject/object.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @out_sid: security identifier for new subject/object
- *
- * Compute a SID to use for labeling a new subject or object in the
- * class @tclass based on a SID pair (@ssid, @tsid).
- * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
- * if insufficient memory is available, or %0 if the new SID was
- * computed successfully.
- */
 int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,
 			    const struct qstr *qstr, u32 *out_sid)
 {
@@ -1556,19 +1402,6 @@
 				    objname, out_sid, false);
 }
 
-/**
- * security_member_sid - Compute the SID for member selection.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @out_sid: security identifier for selected member
- *
- * Compute a SID to use when selecting a member of a polyinstantiated
- * object of class @tclass based on a SID pair (@ssid, @tsid).
- * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
- * if insufficient memory is available, or %0 if the SID was
- * computed successfully.
- */
 int security_member_sid(u32 ssid,
 			u32 tsid,
 			u16 tclass,
@@ -1578,19 +1411,6 @@
 				    out_sid, false);
 }
 
-/**
- * security_change_sid - Compute the SID for object relabeling.
- * @ssid: source security identifier
- * @tsid: target security identifier
- * @tclass: target security class
- * @out_sid: security identifier for selected member
- *
- * Compute a SID to use for relabeling an object of class @tclass
- * based on a SID pair (@ssid, @tsid).
- * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
- * if insufficient memory is available, or %0 if the SID was
- * computed successfully.
- */
 int security_change_sid(u32 ssid,
 			u32 tsid,
 			u16 tclass,
@@ -1600,7 +1420,6 @@
 				    out_sid, false);
 }
 
-/* Clone the SID into the new SID table. */
 static int clone_sid(u32 sid,
 		     struct context *context,
 		     void *arg)
@@ -1633,13 +1452,6 @@
 	struct policydb *newp;
 };
 
-/*
- * Convert the values in the security context
- * structure `c' from the values specified
- * in the policy `p->oldp' to the values specified
- * in the policy `p->newp'.  Verify that the
- * context is valid under the new policy.
- */
 static int convert_context(u32 key,
 			   struct context *c,
 			   void *p)
@@ -1674,16 +1486,16 @@
 		if (!rc) {
 			printk(KERN_INFO "SELinux:  Context %s became valid (mapped).\n",
 			       c->str);
-			/* Replace string with mapped representation. */
+			
 			kfree(c->str);
 			memcpy(c, &ctx, sizeof(*c));
 			goto out;
 		} else if (rc == -EINVAL) {
-			/* Retain string representation for later mapping. */
+			
 			rc = 0;
 			goto out;
 		} else {
-			/* Other error condition, e.g. ENOMEM. */
+			
 			printk(KERN_ERR "SELinux:   Unable to map context %s, rc = %d.\n",
 			       c->str, -rc);
 			goto out;
@@ -1694,7 +1506,7 @@
 	if (rc)
 		goto out;
 
-	/* Convert the user. */
+	
 	rc = -EINVAL;
 	usrdatum = hashtab_search(args->newp->p_users.table,
 				  sym_name(args->oldp, SYM_USERS, c->user - 1));
@@ -1702,7 +1514,7 @@
 		goto bad;
 	c->user = usrdatum->value;
 
-	/* Convert the role. */
+	
 	rc = -EINVAL;
 	role = hashtab_search(args->newp->p_roles.table,
 			      sym_name(args->oldp, SYM_ROLES, c->role - 1));
@@ -1710,7 +1522,7 @@
 		goto bad;
 	c->role = role->value;
 
-	/* Convert the type. */
+	
 	rc = -EINVAL;
 	typdatum = hashtab_search(args->newp->p_types.table,
 				  sym_name(args->oldp, SYM_TYPES, c->type - 1));
@@ -1718,26 +1530,14 @@
 		goto bad;
 	c->type = typdatum->value;
 
-	/* Convert the MLS fields if dealing with MLS policies */
+	
 	if (args->oldp->mls_enabled && args->newp->mls_enabled) {
 		rc = mls_convert_context(args->oldp, args->newp, c);
 		if (rc)
 			goto bad;
 	} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {
-		/*
-		 * Switching between MLS and non-MLS policy:
-		 * free any storage used by the MLS fields in the
-		 * context for all existing entries in the sidtab.
-		 */
 		mls_context_destroy(c);
 	} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {
-		/*
-		 * Switching between non-MLS and MLS policy:
-		 * ensure that the MLS fields of the context for all
-		 * existing entries in the sidtab are filled in with a
-		 * suitable default value, likely taken from one of the
-		 * initial SIDs.
-		 */
 		oc = args->newp->ocontexts[OCON_ISID];
 		while (oc && oc->sid[0] != SECINITSID_UNLABELED)
 			oc = oc->next;
@@ -1753,7 +1553,7 @@
 			goto bad;
 	}
 
-	/* Check the validity of the new context. */
+	
 	if (!policydb_context_isvalid(args->newp, c)) {
 		rc = convert_context_handle_invalid_context(&oldc);
 		if (rc)
@@ -1766,7 +1566,7 @@
 out:
 	return rc;
 bad:
-	/* Map old representation to string and save it. */
+	
 	rc = context_struct_to_string(&oldc, &s, &len);
 	if (rc)
 		return rc;
@@ -1790,16 +1590,6 @@
 
 static int security_preserve_bools(struct policydb *p);
 
-/**
- * security_load_policy - Load a security policy configuration.
- * @data: binary policy data
- * @len: length of data in bytes
- *
- * Load a new set of security policy configuration data,
- * validate it and convert the SID table as necessary.
- * This function will flush the access vector cache after
- * loading the new policy.
- */
 int security_load_policy(void *data, size_t len)
 {
 	struct policydb oldpolicydb, newpolicydb;
@@ -1857,7 +1647,7 @@
 		return rc;
 
 	newpolicydb.len = len;
-	/* If switching between different policy types, log MLS status */
+	
 	if (policydb.mls_enabled && !newpolicydb.mls_enabled)
 		printk(KERN_INFO "SELinux: Disabling MLS support...\n");
 	else if (!policydb.mls_enabled && newpolicydb.mls_enabled)
@@ -1880,17 +1670,13 @@
 		goto err;
 	}
 
-	/* Clone the SID table. */
+	
 	sidtab_shutdown(&sidtab);
 
 	rc = sidtab_map(&sidtab, clone_sid, &newsidtab);
 	if (rc)
 		goto err;
 
-	/*
-	 * Convert the internal representations of contexts
-	 * in the new SID table.
-	 */
 	args.oldp = &policydb;
 	args.newp = &newpolicydb;
 	rc = sidtab_map(&newsidtab, convert_context, &args);
@@ -1901,11 +1687,11 @@
 		goto err;
 	}
 
-	/* Save the old policydb and SID table to free later. */
+	
 	memcpy(&oldpolicydb, &policydb, sizeof policydb);
 	sidtab_set(&oldsidtab, &sidtab);
 
-	/* Install the new policydb and SID table. */
+	
 	write_lock_irq(&policy_rwlock);
 	memcpy(&policydb, &newpolicydb, sizeof policydb);
 	sidtab_set(&sidtab, &newsidtab);
@@ -1916,7 +1702,7 @@
 	seqno = ++latest_granting;
 	write_unlock_irq(&policy_rwlock);
 
-	/* Free the old policydb and SID table. */
+	
 	policydb_destroy(&oldpolicydb);
 	sidtab_destroy(&oldsidtab);
 	kfree(oldmap);
@@ -1948,12 +1734,6 @@
 	return len;
 }
 
-/**
- * security_port_sid - Obtain the SID for a port.
- * @protocol: protocol number
- * @port: port number
- * @out_sid: security identifier
- */
 int security_port_sid(u8 protocol, u16 port, u32 *out_sid)
 {
 	struct ocontext *c;
@@ -1988,11 +1768,6 @@
 	return rc;
 }
 
-/**
- * security_netif_sid - Obtain the SID for a network interface.
- * @name: interface name
- * @if_sid: interface SID
- */
 int security_netif_sid(char *name, u32 *if_sid)
 {
 	int rc = 0;
@@ -2042,13 +1817,6 @@
 	return !fail;
 }
 
-/**
- * security_node_sid - Obtain the SID for a node (host).
- * @domain: communication domain aka address family
- * @addrp: address
- * @addrlen: address length in bytes
- * @out_sid: security identifier
- */
 int security_node_sid(u16 domain,
 		      void *addrp,
 		      u32 addrlen,
@@ -2118,19 +1886,6 @@
 
 #define SIDS_NEL 25
 
-/**
- * security_get_user_sids - Obtain reachable SIDs for a user.
- * @fromsid: starting SID
- * @username: username
- * @sids: array of reachable SIDs for user
- * @nel: number of elements in @sids
- *
- * Generate the set of SIDs for legal security contexts
- * for a given user that can be reached by @fromsid.
- * Set *@sids to point to a dynamically allocated
- * array containing the set of SIDs.  Set *@nel to the
- * number of elements in the array.
- */
 
 int security_get_user_sids(u32 fromsid,
 			   char *username,
@@ -2216,7 +1971,7 @@
 	for (i = 0, j = 0; i < mynel; i++) {
 		struct av_decision dummy_avd;
 		rc = avc_has_perm_noaudit(fromsid, mysids[i],
-					  SECCLASS_PROCESS, /* kernel value */
+					  SECCLASS_PROCESS, 
 					  PROCESS__TRANSITION, AVC_STRICT,
 					  &dummy_avd);
 		if (!rc)
@@ -2231,17 +1986,6 @@
 	return rc;
 }
 
-/**
- * security_genfs_sid - Obtain a SID for a file in a filesystem
- * @fstype: filesystem type
- * @path: path from root of mount
- * @sclass: file security class
- * @sid: SID for path
- *
- * Obtain a SID to use for a file in a filesystem that
- * cannot support xattr or use a fixed labeling behavior like
- * transition SIDs or task SIDs.
- */
 int security_genfs_sid(const char *fstype,
 		       char *path,
 		       u16 orig_sclass,
@@ -2295,12 +2039,6 @@
 	return rc;
 }
 
-/**
- * security_fs_use - Determine how to handle labeling for a filesystem.
- * @fstype: filesystem type
- * @behavior: labeling behavior
- * @sid: SID for filesystem (superblock)
- */
 int security_fs_use(
 	const char *fstype,
 	unsigned int *behavior,
@@ -2491,10 +2229,6 @@
 	return rc;
 }
 
-/*
- * security_sid_mls_copy() - computes a new sid based on the given
- * sid and the mls portion of mls_sid.
- */
 int security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)
 {
 	struct context *context1;
@@ -2537,7 +2271,7 @@
 	if (rc)
 		goto out_unlock;
 
-	/* Check the validity of the new context. */
+	
 	if (!policydb_context_isvalid(&policydb, &newcon)) {
 		rc = convert_context_handle_invalid_context(&newcon);
 		if (rc) {
@@ -2558,26 +2292,6 @@
 	return rc;
 }
 
-/**
- * security_net_peersid_resolve - Compare and resolve two network peer SIDs
- * @nlbl_sid: NetLabel SID
- * @nlbl_type: NetLabel labeling protocol type
- * @xfrm_sid: XFRM SID
- *
- * Description:
- * Compare the @nlbl_sid and @xfrm_sid values and if the two SIDs can be
- * resolved into a single SID it is returned via @peer_sid and the function
- * returns zero.  Otherwise @peer_sid is set to SECSID_NULL and the function
- * returns a negative value.  A table summarizing the behavior is below:
- *
- *                                 | function return |      @sid
- *   ------------------------------+-----------------+-----------------
- *   no peer labels                |        0        |    SECSID_NULL
- *   single peer label             |        0        |    <peer_label>
- *   multiple, consistent labels   |        0        |    <peer_label>
- *   multiple, inconsistent labels |    -<errno>     |    SECSID_NULL
- *
- */
 int security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,
 				 u32 xfrm_sid,
 				 u32 *peer_sid)
@@ -2588,24 +2302,15 @@
 
 	*peer_sid = SECSID_NULL;
 
-	/* handle the common (which also happens to be the set of easy) cases
-	 * right away, these two if statements catch everything involving a
-	 * single or absent peer SID/label */
 	if (xfrm_sid == SECSID_NULL) {
 		*peer_sid = nlbl_sid;
 		return 0;
 	}
-	/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a "fallback" label
-	 * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label
-	 * is present */
 	if (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {
 		*peer_sid = xfrm_sid;
 		return 0;
 	}
 
-	/* we don't need to check ss_initialized here since the only way both
-	 * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the
-	 * security server was initialized and ss_initialized was true */
 	if (!policydb.mls_enabled)
 		return 0;
 
@@ -2629,11 +2334,6 @@
 	if (rc)
 		goto out;
 
-	/* at present NetLabel SIDs/labels really only carry MLS
-	 * information so if the MLS portion of the NetLabel SID
-	 * matches the MLS portion of the labeled XFRM SID/label
-	 * then pass along the XFRM SID as it is the most
-	 * expressive */
 	*peer_sid = xfrm_sid;
 out:
 	read_unlock(&policy_rwlock);
@@ -2747,16 +2447,6 @@
 	return policydb.allow_unknown;
 }
 
-/**
- * security_policycap_supported - Check for a specific policy capability
- * @req_cap: capability
- *
- * Description:
- * This function queries the currently loaded policy to see if it supports the
- * capability specified by @req_cap.  Returns true (1) if the capability is
- * supported, false (0) if it isn't supported.
- *
- */
 int security_policycap_supported(unsigned int req_cap)
 {
 	int rc;
@@ -2804,7 +2494,7 @@
 	case AUDIT_OBJ_USER:
 	case AUDIT_OBJ_ROLE:
 	case AUDIT_OBJ_TYPE:
-		/* only 'equals' and 'not equals' fit user, role, and type */
+		
 		if (op != Audit_equal && op != Audit_not_equal)
 			return -EINVAL;
 		break;
@@ -2812,12 +2502,12 @@
 	case AUDIT_SUBJ_CLR:
 	case AUDIT_OBJ_LEV_LOW:
 	case AUDIT_OBJ_LEV_HIGH:
-		/* we do not allow a range, indicated by the presence of '-' */
+		
 		if (strchr(rulestr, '-'))
 			return -EINVAL;
 		break;
 	default:
-		/* only the above fields are valid */
+		
 		return -EINVAL;
 	}
 
@@ -2879,7 +2569,6 @@
 	return rc;
 }
 
-/* Check to see if the rule contains any selinux fields */
 int selinux_audit_rule_known(struct audit_krule *rule)
 {
 	int i;
@@ -2936,8 +2625,6 @@
 		goto out;
 	}
 
-	/* a field/op pair that is not caught here will simply fall through
-	   without a match */
 	switch (field) {
 	case AUDIT_SUBJ_USER:
 	case AUDIT_OBJ_USER:
@@ -3042,17 +2729,6 @@
 __initcall(aurule_init);
 
 #ifdef CONFIG_NETLABEL
-/**
- * security_netlbl_cache_add - Add an entry to the NetLabel cache
- * @secattr: the NetLabel packet security attributes
- * @sid: the SELinux SID
- *
- * Description:
- * Attempt to cache the context in @ctx, which was derived from the packet in
- * @skb, in the NetLabel subsystem cache.  This function assumes @secattr has
- * already been initialized.
- *
- */
 static void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,
 				      u32 sid)
 {
@@ -3073,21 +2749,6 @@
 	secattr->flags |= NETLBL_SECATTR_CACHE;
 }
 
-/**
- * security_netlbl_secattr_to_sid - Convert a NetLabel secattr to a SELinux SID
- * @secattr: the NetLabel packet security attributes
- * @sid: the SELinux SID
- *
- * Description:
- * Convert the given NetLabel security attributes in @secattr into a
- * SELinux SID.  If the @secattr field does not contain a full SELinux
- * SID/context then use SECINITSID_NETMSG as the foundation.  If possible the
- * 'cache' field of @secattr is set and the CACHE flag is set; this is to
- * allow the @secattr to be used by NetLabel to cache the secattr to SID
- * conversion for future lookups.  Returns zero on success, negative values on
- * failure.
- *
- */
 int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,
 				   u32 *sid)
 {
@@ -3149,16 +2810,6 @@
 	return rc;
 }
 
-/**
- * security_netlbl_sid_to_secattr - Convert a SELinux SID to a NetLabel secattr
- * @sid: the SELinux SID
- * @secattr: the NetLabel packet security attributes
- *
- * Description:
- * Convert the given SELinux SID in @sid into a NetLabel security attribute.
- * Returns zero on success, negative values on failure.
- *
- */
 int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)
 {
 	int rc;
@@ -3188,14 +2839,8 @@
 	read_unlock(&policy_rwlock);
 	return rc;
 }
-#endif /* CONFIG_NETLABEL */
+#endif 
 
-/**
- * security_read_policy - read the policy.
- * @data: binary policy data
- * @len: length of data in bytes
- *
- */
 int security_read_policy(void **data, size_t *len)
 {
 	int rc;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/services.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/services.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/services.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/services.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the security services.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_SERVICES_H_
 #define _SS_SERVICES_H_
 
@@ -11,5 +6,5 @@
 
 extern struct policydb policydb;
 
-#endif	/* _SS_SERVICES_H_ */
+#endif	
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/sidtab.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/sidtab.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/sidtab.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/sidtab.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the SID table type.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
@@ -99,7 +94,7 @@
 		return &cur->context;
 
 	if (cur == NULL || sid != cur->sid || cur->context.len) {
-		/* Remap invalid SIDs to the unlabeled SID. */
+		
 		sid = SECINITSID_UNLABELED;
 		hvalue = SIDTAB_HASH(sid);
 		cur = s->htable[hvalue];
@@ -209,11 +204,11 @@
 		sid = sidtab_search_context(s, context);
 	if (!sid) {
 		spin_lock_irqsave(&s->lock, flags);
-		/* Rescan now that we hold the lock. */
+		
 		sid = sidtab_search_context(s, context);
 		if (sid)
 			goto unlock_out;
-		/* No SID exists for the context.  Allocate a new one. */
+		
 		if (s->next_sid == UINT_MAX || s->shutdown) {
 			ret = -ENOMEM;
 			goto unlock_out;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/sidtab.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/sidtab.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/sidtab.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/sidtab.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,17 +1,11 @@
-/*
- * A security identifier table (sidtab) is a hash table
- * of security context structures indexed by SID value.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_SIDTAB_H_
 #define _SS_SIDTAB_H_
 
 #include "context.h"
 
 struct sidtab_node {
-	u32 sid;		/* security identifier */
-	struct context context;	/* security context structure */
+	u32 sid;		
+	struct context context;	
 	struct sidtab_node *next;
 };
 
@@ -23,8 +17,8 @@
 
 struct sidtab {
 	struct sidtab_node **htable;
-	unsigned int nel;	/* number of elements */
-	unsigned int next_sid;	/* next SID to allocate */
+	unsigned int nel;	
+	unsigned int next_sid;	
 	unsigned char shutdown;
 #define SIDTAB_CACHE_LEN	3
 	struct sidtab_node *cache[SIDTAB_CACHE_LEN];
@@ -51,6 +45,6 @@
 void sidtab_set(struct sidtab *dst, struct sidtab *src);
 void sidtab_shutdown(struct sidtab *s);
 
-#endif	/* _SS_SIDTAB_H_ */
+#endif	
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/status.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/status.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/status.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/status.c	2013-08-01 23:38:04.000000000 -0600
@@ -16,34 +16,9 @@
 #include "avc.h"
 #include "services.h"
 
-/*
- * The selinux_status_page shall be exposed to userspace applications
- * using mmap interface on /selinux/status.
- * It enables to notify applications a few events that will cause reset
- * of userspace access vector without context switching.
- *
- * The selinux_kernel_status structure on the head of status page is
- * protected from concurrent accesses using seqlock logic, so userspace
- * application should reference the status page according to the seqlock
- * logic.
- *
- * Typically, application checks status->sequence at the head of access
- * control routine. If it is odd-number, kernel is updating the status,
- * so please wait for a moment. If it is changed from the last sequence
- * number, it means something happen, so application will reset userspace
- * avc, if needed.
- * In most cases, application shall confirm the kernel status is not
- * changed without any system call invocations.
- */
 static struct page *selinux_status_page;
 static DEFINE_MUTEX(selinux_status_lock);
 
-/*
- * selinux_kernel_status_page
- *
- * It returns a reference to selinux_status_page. If the status page is
- * not allocated yet, it also tries to allocate it at the first time.
- */
 struct page *selinux_kernel_status_page(void)
 {
 	struct selinux_kernel_status   *status;
@@ -59,12 +34,6 @@
 			status->version = SELINUX_KERNEL_STATUS_VERSION;
 			status->sequence = 0;
 			status->enforcing = selinux_enforcing;
-			/*
-			 * NOTE: the next policyload event shall set
-			 * a positive value on the status->policyload,
-			 * although it may not be 1, but never zero.
-			 * So, application can know it was updated.
-			 */
 			status->policyload = 0;
 			status->deny_unknown = !security_get_allow_unknown();
 		}
@@ -75,11 +44,6 @@
 	return result;
 }
 
-/*
- * selinux_status_update_setenforce
- *
- * It updates status of the current enforcing/permissive mode.
- */
 void selinux_status_update_setenforce(int enforcing)
 {
 	struct selinux_kernel_status   *status;
@@ -99,12 +63,6 @@
 	mutex_unlock(&selinux_status_lock);
 }
 
-/*
- * selinux_status_update_policyload
- *
- * It updates status of the times of policy reloaded, and current
- * setting of deny_unknown.
- */
 void selinux_status_update_policyload(int seqno)
 {
 	struct selinux_kernel_status   *status;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/symtab.c monarudo-jb-3.4.10-e22f38b/security/selinux/ss/symtab.c
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/symtab.c	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/symtab.c	2013-08-01 23:38:04.000000000 -0600
@@ -1,8 +1,3 @@
-/*
- * Implementation of the symbol table type.
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/errno.h>
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/symtab.h monarudo-jb-3.4.10-e22f38b/security/selinux/ss/symtab.h
--- monarudo-jb-crc-3.4.10-7edee3c/security/selinux/ss/symtab.h	2012-08-26 16:02:10.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/security/selinux/ss/symtab.h	2013-08-01 23:38:04.000000000 -0600
@@ -1,23 +1,15 @@
-/*
- * A symbol table (symtab) maintains associations between symbol
- * strings and datum values.  The type of the datum values
- * is arbitrary.  The symbol table type is implemented
- * using the hash table type (hashtab).
- *
- * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
- */
 #ifndef _SS_SYMTAB_H_
 #define _SS_SYMTAB_H_
 
 #include "hashtab.h"
 
 struct symtab {
-	struct hashtab *table;	/* hash table (keyed on a string) */
-	u32 nprim;		/* number of primary names in table */
+	struct hashtab *table;	
+	u32 nprim;		
 };
 
 int symtab_init(struct symtab *s, unsigned int size);
 
-#endif	/* _SS_SYMTAB_H_ */
+#endif	
 
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/codecs/wcd9304.c monarudo-jb-3.4.10-e22f38b/sound/soc/codecs/wcd9304.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/codecs/wcd9304.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/codecs/wcd9304.c	2013-08-01 23:38:03.000000000 -0600
@@ -1157,6 +1157,7 @@
 	switch (w->shift) {
 	case 0:
 		lineout_gain_reg = SITAR_A_RX_LINE_1_GAIN;
+		usleep_range(100000, 100000);
 		break;
 	case 1:
 		lineout_gain_reg = SITAR_A_RX_LINE_2_GAIN;
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/apq8064_monarudo.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/apq8064_monarudo.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/apq8064_monarudo.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/apq8064_monarudo.c	2013-08-01 23:38:03.000000000 -0600
@@ -2530,7 +2530,39 @@
 		.codec_name = "snd-soc-dummy",
 	},
 	
-
+	
+	{   
+	    .name = "VoLTE",
+	    .stream_name = "VoLTE",
+	    .cpu_dai_name   = "VoLTE",
+	    .platform_name  = "msm-pcm-voice",
+	    .dynamic = 1,
+	    .trigger = {SND_SOC_DPCM_TRIGGER_POST,
+	            SND_SOC_DPCM_TRIGGER_POST},
+	    .no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+	    .ignore_suspend = 1,
+	    
+	    .ignore_pmdown_time = 1,
+	    .codec_dai_name = "snd-soc-dummy-dai",
+	    .codec_name = "snd-soc-dummy",
+	    .be_id = MSM_FRONTEND_DAI_VOLTE,
+	},
+	{    
+	    .name = "MSM8960 LowLatency",
+	    .stream_name = "MultiMedia5",
+	    .cpu_dai_name   = "MultiMedia5",
+	    .platform_name  = "msm-lowlatency-pcm-dsp",
+	    .dynamic = 1,
+	    .codec_dai_name = "snd-soc-dummy-dai",
+	    .codec_name = "snd-soc-dummy",
+	    .trigger = {SND_SOC_DPCM_TRIGGER_POST,
+	            SND_SOC_DPCM_TRIGGER_POST},
+	    .ignore_suspend = 1,
+	    
+	    .ignore_pmdown_time = 1,
+	    .be_id = MSM_FRONTEND_DAI_MULTIMEDIA5,
+	},
+	
 };
 
 struct snd_soc_card snd_soc_card_msm = {
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/Makefile monarudo-jb-3.4.10-e22f38b/sound/soc/msm/Makefile
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/Makefile	2013-06-24 02:50:48.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/Makefile	2013-08-01 23:38:05.000000000 -0600
@@ -56,7 +56,10 @@
 
 obj-$(CONFIG_SND_SOC_MSM_QDSP6_INTF) += qdsp6/
 
-snd-soc-qdsp6-objs := msm-dai-q6.o msm-pcm-q6.o msm-multi-ch-pcm-q6.o msm-pcm-routing.o msm-dai-fe.o msm-compr-q6.o msm-dai-stub.o
+#snd-soc-qdsp6-objs := msm-dai-q6.o msm-pcm-q6.o msm-multi-ch-pcm-q6.o msm-pcm-routing.o msm-dai-fe.o msm-compr-q6.o msm-dai-stub.o
+#HTC_AUD_LOWL_START
+snd-soc-qdsp6-objs := msm-dai-q6.o msm-pcm-q6.o msm-multi-ch-pcm-q6.o msm-pcm-routing.o msm-dai-fe.o msm-compr-q6.o msm-dai-stub.o msm-lowlatency-pcm-q6.o
+#HTC_AUD_LOWL_END
 obj-$(CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO) += msm-dai-q6-hdmi.o
 obj-$(CONFIG_SND_SOC_VOICE) += msm-pcm-voice.o msm-pcm-voip.o
 snd-soc-qdsp6-objs += msm-pcm-lpa.o msm-pcm-afe.o
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-compr-q6.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-compr-q6.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-compr-q6.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-compr-q6.c	2013-08-01 23:38:03.000000000 -0600
@@ -605,6 +605,9 @@
 	}
 	prtd = &compr->prtd;
 	prtd->substream = substream;
+	
+	prtd->audio_client->perf_mode = false;
+	
 	prtd->audio_client = q6asm_audio_client_alloc(
 				(app_cb)compr_event_handler, compr);
 	if (!prtd->audio_client) {
@@ -885,7 +888,9 @@
 			}
 			msm_pcm_routing_reg_phy_stream(
 				soc_prtd->dai_link->be_id,
-				prtd->session_id, substream->stream);
+				prtd->audio_client->perf_mode,
+				prtd->session_id,
+				substream->stream);
 
 			break;
 		}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-dai-fe.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-dai-fe.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-dai-fe.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-dai-fe.c	2013-08-01 23:38:03.000000000 -0600
@@ -213,6 +213,19 @@
 			.rate_min =	8000,
 			.rate_max = 48000,
 		},
+		
+		.capture = {
+		    .stream_name = "MultiMedia5 Capture",
+		    .aif_name = "MM_UL5",
+		    .rates = (SNDRV_PCM_RATE_8000_48000|
+		            SNDRV_PCM_RATE_KNOT),
+		    .formats = SNDRV_PCM_FMTBIT_S16_LE,
+		    .channels_min = 1,
+		    .channels_max = 8,
+		    .rate_min =     8000,
+		    .rate_max = 48000,
+		},
+		
 		.ops = &msm_fe_Multimedia_dai_ops,
 		.name = "MultiMedia5",
 	},
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-lowlatency-pcm-q6.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-lowlatency-pcm-q6.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-lowlatency-pcm-q6.c	1969-12-31 17:00:00.000000000 -0700
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-lowlatency-pcm-q6.c	2013-08-01 23:38:03.000000000 -0600
@@ -0,0 +1,775 @@
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/android_pmem.h>
+#include <asm/dma.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/pcm_params.h>
+
+#include "msm-pcm-q6.h"
+#include "msm-pcm-routing.h"
+
+static struct audio_locks the_locks;
+
+struct snd_msm {
+   struct snd_card *card;
+   struct snd_pcm *pcm;
+};
+
+struct snd_msm_volume {
+   struct msm_audio *prtd;
+   unsigned volume;
+};
+
+#define PLAYBACK_NUM_PERIODS       4
+#define PLAYBACK_MAX_PERIOD_SIZE   1024
+#define PLAYBACK_MIN_PERIOD_SIZE   512
+#define CAPTURE_NUM_PERIODS        4
+#define CAPTURE_MIN_PERIOD_SIZE        128
+#define CAPTURE_MAX_PERIOD_SIZE        1024
+
+static struct snd_pcm_hardware msm_pcm_hardware_capture = {
+   .info =                 (SNDRV_PCM_INFO_MMAP |
+               SNDRV_PCM_INFO_BLOCK_TRANSFER |
+               SNDRV_PCM_INFO_MMAP_VALID |
+               SNDRV_PCM_INFO_INTERLEAVED |
+               SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+   .formats =              SNDRV_PCM_FMTBIT_S16_LE,
+   .rates =                SNDRV_PCM_RATE_8000_48000,
+   .rate_min =             8000,
+   .rate_max =             48000,
+   .channels_min =         1,
+   .channels_max =         8,
+   .buffer_bytes_max =     CAPTURE_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,
+   .period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,
+   .period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,
+   .periods_min =          CAPTURE_NUM_PERIODS,
+   .periods_max =          CAPTURE_NUM_PERIODS,
+   .fifo_size =            0,
+};
+
+static struct snd_pcm_hardware msm_pcm_hardware_playback = {
+   .info =                 (SNDRV_PCM_INFO_MMAP |
+               SNDRV_PCM_INFO_BLOCK_TRANSFER |
+               SNDRV_PCM_INFO_MMAP_VALID |
+               SNDRV_PCM_INFO_INTERLEAVED |
+               SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+   .formats =              SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+   .rates =                SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT,
+   .rate_min =             8000,
+   .rate_max =             48000,
+   .channels_min =         1,
+   .channels_max =         6,
+   .buffer_bytes_max =     PLAYBACK_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE,
+   .period_bytes_min =     PLAYBACK_MIN_PERIOD_SIZE,
+   .period_bytes_max =     PLAYBACK_MAX_PERIOD_SIZE,
+   .periods_min =          PLAYBACK_NUM_PERIODS,
+   .periods_max =          PLAYBACK_NUM_PERIODS,
+   .fifo_size =            0,
+};
+
+static unsigned int supported_sample_rates[] = {
+   8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
+};
+
+static uint32_t in_frame_info[CAPTURE_NUM_PERIODS][2];
+
+static struct snd_pcm_hw_constraint_list constraints_sample_rates = {
+   .count = ARRAY_SIZE(supported_sample_rates),
+   .list = supported_sample_rates,
+   .mask = 0,
+};
+
+static void event_handler(uint32_t opcode,
+       uint32_t token, uint32_t *payload, void *priv)
+{
+   struct msm_audio *prtd = priv;
+   struct snd_pcm_substream *substream = prtd->substream;
+   uint32_t *ptrmem = (uint32_t *)payload;
+   int i = 0;
+   uint32_t idx = 0;
+   uint32_t size = 0;
+
+   pr_debug("%s\n", __func__);
+   switch (opcode) {
+   case ASM_DATA_EVENT_WRITE_DONE: {
+       pr_debug("ASM_DATA_EVENT_WRITE_DONE\n");
+       pr_debug("Buffer Consumed = 0x%08x\n", *ptrmem);
+       prtd->pcm_irq_pos += prtd->pcm_count;
+       if (atomic_read(&prtd->start))
+           snd_pcm_period_elapsed(substream);
+       atomic_inc(&prtd->out_count);
+       wake_up(&the_locks.write_wait);
+       if (!atomic_read(&prtd->start))
+           break;
+       if (!prtd->mmap_flag)
+           break;
+       if (q6asm_is_cpu_buf_avail_nolock(IN,
+               prtd->audio_client,
+               &size, &idx)) {
+           pr_debug("%s:writing %d bytes of buffer to dsp 2\n",
+                   __func__, prtd->pcm_count);
+           q6asm_write_nolock(prtd->audio_client,
+               prtd->pcm_count, 0, 0, NO_TIMESTAMP);
+       }
+       break;
+   }
+   case ASM_DATA_CMDRSP_EOS:
+       pr_debug("ASM_DATA_CMDRSP_EOS\n");
+       prtd->cmd_ack = 1;
+       wake_up(&the_locks.eos_wait);
+       break;
+   case ASM_DATA_EVENT_READ_DONE: {
+       pr_debug("ASM_DATA_EVENT_READ_DONE\n");
+       pr_debug("token = 0x%08x\n", token);
+       for (i = 0; i < 8; i++, ++ptrmem)
+           pr_debug("cmd[%d]=0x%08x\n", i, *ptrmem);
+       in_frame_info[token][0] = payload[2];
+       in_frame_info[token][1] = payload[3];
+       prtd->pcm_irq_pos += in_frame_info[token][0];
+       pr_debug("pcm_irq_pos=%d\n", prtd->pcm_irq_pos);
+       if (atomic_read(&prtd->start))
+           snd_pcm_period_elapsed(substream);
+       if (atomic_read(&prtd->in_count) <= prtd->periods)
+           atomic_inc(&prtd->in_count);
+       wake_up(&the_locks.read_wait);
+       if (prtd->mmap_flag
+           && q6asm_is_cpu_buf_avail_nolock(OUT,
+               prtd->audio_client,
+               &size, &idx))
+           q6asm_read_nolock(prtd->audio_client);
+       break;
+   }
+   case APR_BASIC_RSP_RESULT: {
+       switch (payload[0]) {
+       case ASM_SESSION_CMD_RUN:
+           if (substream->stream
+               != SNDRV_PCM_STREAM_PLAYBACK) {
+               atomic_set(&prtd->start, 1);
+               break;
+           }
+           if (prtd->mmap_flag) {
+               pr_debug("%s:writing %d bytes buffer to dsp\n",
+                   __func__, prtd->pcm_count);
+               q6asm_write_nolock(prtd->audio_client,
+                   prtd->pcm_count,
+                   0, 0, NO_TIMESTAMP);
+           } else {
+               while (atomic_read(&prtd->out_needed)) {
+                   pr_debug("%s:writing %d bytesto dsp\n",
+                       __func__, prtd->pcm_count);
+                   q6asm_write_nolock(prtd->audio_client,
+                       prtd->pcm_count,
+                       0, 0, NO_TIMESTAMP);
+                   atomic_dec(&prtd->out_needed);
+                   wake_up(&the_locks.write_wait);
+               };
+           }
+           atomic_set(&prtd->start, 1);
+           break;
+       default:
+           break;
+       }
+   }
+   break;
+   default:
+       pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
+       break;
+   }
+}
+
+static int msm_pcm_playback_prepare(struct snd_pcm_substream *substream)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+   int ret;
+   short bit_width = 16;
+
+   pr_debug("%s\n", __func__);
+   prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
+   prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
+   prtd->pcm_irq_pos = 0;
+   
+   prtd->samp_rate = runtime->rate;
+   prtd->channel_mode = runtime->channels;
+   if (prtd->enabled)
+       return 0;
+
+	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
+		bit_width = 24;
+   ret = q6asm_media_format_block_multi_ch_pcm(prtd->audio_client,
+           runtime->rate, runtime->channels, bit_width);
+   if (ret < 0)
+       pr_info("%s: CMD Format block failed\n", __func__);
+
+   atomic_set(&prtd->out_count, runtime->periods);
+
+   prtd->enabled = 1;
+   prtd->cmd_ack = 0;
+
+   return 0;
+}
+
+static int msm_pcm_capture_prepare(struct snd_pcm_substream *substream)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+   int ret = 0;
+   int i = 0;
+   pr_debug("%s\n", __func__);
+   prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
+   prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
+   prtd->pcm_irq_pos = 0;
+
+   
+   prtd->samp_rate = runtime->rate;
+   prtd->channel_mode = runtime->channels;
+
+   if (prtd->enabled)
+       return 0;
+
+   pr_debug("Samp_rate = %d\n", prtd->samp_rate);
+   pr_debug("Channel = %d\n", prtd->channel_mode);
+   ret = q6asm_enc_cfg_blk_pcm(prtd->audio_client, prtd->samp_rate,
+                   prtd->channel_mode);
+   if (ret < 0)
+       pr_debug("%s: cmd cfg pcm was block failed", __func__);
+
+   for (i = 0; i < runtime->periods; i++)
+       q6asm_read(prtd->audio_client);
+   prtd->periods = runtime->periods;
+
+   prtd->enabled = 1;
+
+   return ret;
+}
+
+static int msm_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+   int ret = 0;
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+
+   switch (cmd) {
+   case SNDRV_PCM_TRIGGER_START:
+   case SNDRV_PCM_TRIGGER_RESUME:
+   case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+       pr_debug("%s: Trigger start\n", __func__);
+       q6asm_run_nowait(prtd->audio_client, 0, 0, 0);
+       break;
+   case SNDRV_PCM_TRIGGER_STOP:
+       pr_debug("SNDRV_PCM_TRIGGER_STOP\n");
+       atomic_set(&prtd->start, 0);
+       if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+           break;
+       prtd->cmd_ack = 0;
+       q6asm_cmd_nowait(prtd->audio_client, CMD_EOS);
+       break;
+   case SNDRV_PCM_TRIGGER_SUSPEND:
+   case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+       pr_debug("SNDRV_PCM_TRIGGER_PAUSE\n");
+       q6asm_cmd_nowait(prtd->audio_client, CMD_PAUSE);
+       atomic_set(&prtd->start, 0);
+       break;
+   default:
+       ret = -EINVAL;
+       break;
+   }
+
+   return ret;
+}
+
+static int msm_pcm_open(struct snd_pcm_substream *substream)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+   struct msm_audio *prtd;
+   int ret = 0;
+   pr_debug("%s lowlatency\n", __func__);
+   prtd = kzalloc(sizeof(struct msm_audio), GFP_KERNEL);
+   if (prtd == NULL) {
+       pr_err("Failed to allocate memory for msm_audio\n");
+       return -ENOMEM;
+   }
+   prtd->substream = substream;
+   prtd->audio_client = q6asm_audio_client_alloc(
+               (app_cb)event_handler, prtd);
+   if (!prtd->audio_client) {
+       pr_err("%s: Could not allocate memory\n", __func__);
+       kfree(prtd);
+       return -ENOMEM;
+   }
+   prtd->audio_client->perf_mode = true;
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+       runtime->hw = msm_pcm_hardware_playback;
+       ret = q6asm_open_write(prtd->audio_client,
+               FORMAT_MULTI_CHANNEL_LINEAR_PCM);
+       if (ret < 0) {
+           pr_err("%s: pcm out open failed\n", __func__);
+           q6asm_audio_client_free(prtd->audio_client);
+           kfree(prtd);
+           return -ENOMEM;
+       }
+   }
+   
+   if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+       runtime->hw = msm_pcm_hardware_capture;
+       ret = q6asm_open_read_v2_1(prtd->audio_client,
+                   FORMAT_LINEAR_PCM);
+       if (ret < 0) {
+           pr_err("%s: pcm in open failed\n", __func__);
+           q6asm_audio_client_free(prtd->audio_client);
+           kfree(prtd);
+           return -ENOMEM;
+       }
+   }
+
+   pr_debug("%s: session ID %d\n", __func__, prtd->audio_client->session);
+
+   prtd->session_id = prtd->audio_client->session;
+   msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
+           prtd->audio_client->perf_mode,
+           prtd->session_id, substream->stream);
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+       prtd->cmd_ack = 1;
+
+   ret = snd_pcm_hw_constraint_list(runtime, 0,
+               SNDRV_PCM_HW_PARAM_RATE,
+               &constraints_sample_rates);
+   if (ret < 0)
+       pr_err("snd_pcm_hw_constraint_list failed\n");
+   
+   ret = snd_pcm_hw_constraint_integer(runtime,
+                       SNDRV_PCM_HW_PARAM_PERIODS);
+   if (ret < 0)
+       pr_err("snd_pcm_hw_constraint_integer failed\n");
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+       ret = snd_pcm_hw_constraint_minmax(runtime,
+           SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+           PLAYBACK_NUM_PERIODS * PLAYBACK_MIN_PERIOD_SIZE,
+           PLAYBACK_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE);
+       if (ret < 0) {
+           pr_err("constraint for buffer bytes min max ret = %d\n",
+                                   ret);
+       }
+   }
+
+   if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+       ret = snd_pcm_hw_constraint_minmax(runtime,
+           SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+           CAPTURE_NUM_PERIODS * CAPTURE_MIN_PERIOD_SIZE,
+           CAPTURE_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE);
+       if (ret < 0) {
+           pr_err("constraint for buffer bytes min max ret = %d\n",
+                                   ret);
+       }
+   }
+
+   prtd->dsp_cnt = 0;
+   runtime->private_data = prtd;
+   pr_debug("substream->pcm->device = %d\n", substream->pcm->device);
+   pr_debug("soc_prtd->dai_link->be_id = %d\n", soc_prtd->dai_link->be_id);
+   return 0;
+}
+
+static int msm_pcm_playback_copy(struct snd_pcm_substream *substream, int a,
+   snd_pcm_uframes_t hwoff, void __user *buf, snd_pcm_uframes_t frames)
+{
+   int ret = 0;
+   int fbytes = 0;
+   int xfer = 0;
+   char *bufptr = NULL;
+   void *data = NULL;
+   uint32_t idx = 0;
+   uint32_t size = 0;
+
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+
+   fbytes = frames_to_bytes(runtime, frames);
+   pr_debug("%s: prtd->out_count = %d\n",
+               __func__, atomic_read(&prtd->out_count));
+   ret = wait_event_timeout(the_locks.write_wait,
+           (atomic_read(&prtd->out_count)), 5 * HZ);
+   if (ret < 0) {
+       pr_err("%s: wait_event_timeout failed\n", __func__);
+       goto fail;
+   }
+
+   if (!atomic_read(&prtd->out_count)) {
+       pr_err("%s: pcm stopped out_count 0\n", __func__);
+       return 0;
+   }
+
+   data = q6asm_is_cpu_buf_avail(IN, prtd->audio_client, &size, &idx);
+   bufptr = data;
+   if (bufptr) {
+       pr_debug("%s:fbytes =%d: xfer=%d size=%d\n",
+                   __func__, fbytes, xfer, size);
+       xfer = fbytes;
+       if (copy_from_user(bufptr, buf, xfer)) {
+           ret = -EFAULT;
+           goto fail;
+       }
+       buf += xfer;
+       fbytes -= xfer;
+       pr_debug("%s:fbytes = %d: xfer=%d\n", __func__, fbytes, xfer);
+       if (atomic_read(&prtd->start)) {
+           pr_debug("%s:writing %d bytes of buffer to dsp\n",
+                   __func__, xfer);
+           ret = q6asm_write(prtd->audio_client, xfer,
+                       0, 0, NO_TIMESTAMP);
+           if (ret < 0) {
+               ret = -EFAULT;
+               goto fail;
+           }
+       } else
+           atomic_inc(&prtd->out_needed);
+       atomic_dec(&prtd->out_count);
+   }
+fail:
+   return  ret;
+}
+
+static int msm_pcm_playback_close(struct snd_pcm_substream *substream)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+   struct msm_audio *prtd = runtime->private_data;
+   int dir = 0;
+   int ret = 0;
+
+   pr_debug("%s\n", __func__);
+
+   dir = IN;
+   ret = wait_event_timeout(the_locks.eos_wait,
+               prtd->cmd_ack, 5 * HZ);
+   if (ret < 0)
+       pr_err("%s: CMD_EOS failed\n", __func__);
+   q6asm_cmd(prtd->audio_client, CMD_CLOSE);
+   q6asm_audio_client_buf_free_contiguous(dir,
+               prtd->audio_client);
+
+   msm_pcm_routing_dereg_phy_stream(soc_prtd->dai_link->be_id,
+           SNDRV_PCM_STREAM_PLAYBACK);
+   q6asm_audio_client_free(prtd->audio_client);
+   kfree(prtd);
+   return 0;
+}
+
+static int msm_pcm_capture_copy(struct snd_pcm_substream *substream,
+        int channel, snd_pcm_uframes_t hwoff, void __user *buf,
+                        snd_pcm_uframes_t frames)
+{
+   int ret = 0;
+   int fbytes = 0;
+   int xfer;
+   char *bufptr;
+   void *data = NULL;
+   static uint32_t idx;
+   static uint32_t size;
+   uint32_t offset = 0;
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = substream->runtime->private_data;
+
+
+   pr_debug("%s\n", __func__);
+   fbytes = frames_to_bytes(runtime, frames);
+
+   pr_debug("appl_ptr %d\n", (int)runtime->control->appl_ptr);
+   pr_debug("hw_ptr %d\n", (int)runtime->status->hw_ptr);
+   pr_debug("avail_min %d\n", (int)runtime->control->avail_min);
+
+   ret = wait_event_timeout(the_locks.read_wait,
+           (atomic_read(&prtd->in_count)), 5 * HZ);
+   if (ret < 0) {
+       pr_debug("%s: wait_event_timeout failed\n", __func__);
+       goto fail;
+   }
+   if (!atomic_read(&prtd->in_count)) {
+       pr_debug("%s: pcm stopped in_count 0\n", __func__);
+       return 0;
+   }
+   pr_debug("Checking if valid buffer is available...%08x\n",
+                       (unsigned int) data);
+   data = q6asm_is_cpu_buf_avail(OUT, prtd->audio_client, &size, &idx);
+   bufptr = data;
+   pr_debug("Size = %d\n", size);
+   pr_debug("fbytes = %d\n", fbytes);
+   pr_debug("idx = %d\n", idx);
+   if (bufptr) {
+       xfer = fbytes;
+       if (xfer > size)
+           xfer = size;
+       offset = in_frame_info[idx][1];
+       pr_debug("Offset value = %d\n", offset);
+       if (copy_to_user(buf, bufptr+offset, xfer)) {
+           pr_err("Failed to copy buf to user\n");
+           ret = -EFAULT;
+           goto fail;
+       }
+       fbytes -= xfer;
+       size -= xfer;
+       in_frame_info[idx][1] += xfer;
+       pr_debug("%s:fbytes = %d: size=%d: xfer=%d\n",
+                   __func__, fbytes, size, xfer);
+       pr_debug(" Sending next buffer to dsp\n");
+       memset(&in_frame_info[idx], 0,
+           sizeof(uint32_t) * 2);
+       atomic_dec(&prtd->in_count);
+       ret = q6asm_read(prtd->audio_client);
+       if (ret < 0) {
+           pr_err("q6asm read failed\n");
+           ret = -EFAULT;
+           goto fail;
+       }
+   } else
+       pr_err("No valid buffer\n");
+
+   pr_debug("Returning from capture_copy... %d\n", ret);
+fail:
+   return ret;
+}
+
+static int msm_pcm_capture_close(struct snd_pcm_substream *substream)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+   struct msm_audio *prtd = runtime->private_data;
+   int dir = OUT;
+
+   pr_debug("%s\n", __func__);
+   q6asm_cmd(prtd->audio_client, CMD_CLOSE);
+   q6asm_audio_client_buf_free_contiguous(dir,
+               prtd->audio_client);
+   msm_pcm_routing_dereg_phy_stream(soc_prtd->dai_link->be_id,
+           SNDRV_PCM_STREAM_CAPTURE);
+   q6asm_audio_client_free(prtd->audio_client);
+   kfree(prtd);
+
+   return 0;
+}
+
+static int msm_pcm_copy(struct snd_pcm_substream *substream, int a,
+    snd_pcm_uframes_t hwoff, void __user *buf, snd_pcm_uframes_t frames)
+{
+   int ret = 0;
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+       ret = msm_pcm_playback_copy(substream, a, hwoff, buf, frames);
+   else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+       ret = msm_pcm_capture_copy(substream, a, hwoff, buf, frames);
+   return ret;
+}
+
+static int msm_pcm_close(struct snd_pcm_substream *substream)
+{
+   int ret = 0;
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+       ret = msm_pcm_playback_close(substream);
+   else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+       ret = msm_pcm_capture_close(substream);
+   return ret;
+}
+static int msm_pcm_prepare(struct snd_pcm_substream *substream)
+{
+   int ret = 0;
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+       ret = msm_pcm_playback_prepare(substream);
+   else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+       ret = msm_pcm_capture_prepare(substream);
+   return ret;
+}
+
+static snd_pcm_uframes_t msm_pcm_pointer(struct snd_pcm_substream *substream)
+{
+
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+
+   if (prtd->pcm_irq_pos >= prtd->pcm_size)
+       prtd->pcm_irq_pos = 0;
+
+   pr_debug("pcm_irq_pos = %d\n", prtd->pcm_irq_pos);
+   return bytes_to_frames(runtime, (prtd->pcm_irq_pos));
+}
+
+static int msm_pcm_mmap(struct snd_pcm_substream *substream,
+               struct vm_area_struct *vma)
+{
+   int result = 0;
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+
+   pr_debug("%s\n", __func__);
+   prtd->mmap_flag = 1;
+
+   if (runtime->dma_addr && runtime->dma_bytes) {
+       vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+       result = remap_pfn_range(vma, vma->vm_start,
+               runtime->dma_addr >> PAGE_SHIFT,
+               runtime->dma_bytes,
+               vma->vm_page_prot);
+   } else {
+       pr_err("Physical address or size of buf is NULL");
+       return -EINVAL;
+   }
+
+   return result;
+}
+
+static int msm_pcm_hw_params(struct snd_pcm_substream *substream,
+               struct snd_pcm_hw_params *params)
+{
+   struct snd_pcm_runtime *runtime = substream->runtime;
+   struct msm_audio *prtd = runtime->private_data;
+   struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
+   struct audio_buffer *buf;
+   int dir, ret;
+   short bit_width = 16;
+
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+       dir = IN;
+   else
+       dir = OUT;
+
+	if (params_format(params) == SNDRV_PCM_FORMAT_S24_LE)
+		bit_width = 24;
+
+    
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && params_format(params) == SNDRV_PCM_FORMAT_S24_LE) {
+		bit_width = 24;
+		ret = q6asm_open_write_v2(prtd->audio_client,
+				FORMAT_MULTI_CHANNEL_LINEAR_PCM, bit_width);
+		if (ret < 0) {
+			pr_err("%s: q6asm_open_write_v2 failed\n", __func__);
+			q6asm_audio_client_free(prtd->audio_client);
+			kfree(prtd);
+			return -ENOMEM;
+		}
+
+		pr_debug("%s: session ID %d\n", __func__,
+			prtd->audio_client->session);
+		prtd->session_id = prtd->audio_client->session;
+		prtd->cmd_ack = 1;
+	}
+
+   ret = q6asm_audio_client_buf_alloc_contiguous(dir,
+       prtd->audio_client,
+       (params_buffer_bytes(params) / params_periods(params)),
+       params_periods(params));
+
+   if (ret < 0) {
+       pr_err("Audio Start: Buffer Allocation failed rc = %d\n", ret);
+       return -ENOMEM;
+   }
+   buf = prtd->audio_client->port[dir].buf;
+
+   pr_debug("%s:buf = %p\n", __func__, buf);
+   dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
+   dma_buf->dev.dev = substream->pcm->card->dev;
+   dma_buf->private_data = NULL;
+   dma_buf->area = buf[0].data;
+   dma_buf->addr =  buf[0].phys;
+   dma_buf->bytes = params_buffer_bytes(params);
+   if (!dma_buf->area)
+       return -ENOMEM;
+
+   snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+   return 0;
+}
+
+static struct snd_pcm_ops msm_pcm_ops = {
+   .open           = msm_pcm_open,
+   .copy       = msm_pcm_copy,
+   .hw_params  = msm_pcm_hw_params,
+   .close          = msm_pcm_close,
+   .ioctl          = snd_pcm_lib_ioctl,
+   .prepare        = msm_pcm_prepare,
+   .trigger        = msm_pcm_trigger,
+   .pointer        = msm_pcm_pointer,
+   .mmap       = msm_pcm_mmap,
+};
+
+static int msm_asoc_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+   struct snd_card *card = rtd->card->snd_card;
+   int ret = 0;
+
+   if (!card->dev->coherent_dma_mask)
+       card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+   return ret;
+}
+
+static struct snd_soc_platform_driver msm_soc_platform = {
+   .ops        = &msm_pcm_ops,
+   .pcm_new    = msm_asoc_pcm_new,
+};
+
+static __devinit int msm_pcm_probe(struct platform_device *pdev)
+{
+   pr_info("%s: dev name %s\n", __func__, dev_name(&pdev->dev));
+   return snd_soc_register_platform(&pdev->dev,
+                  &msm_soc_platform);
+}
+
+static int msm_pcm_remove(struct platform_device *pdev)
+{
+   snd_soc_unregister_platform(&pdev->dev);
+   return 0;
+}
+
+static struct platform_driver msm_pcm_driver = {
+   .driver = {
+       .name = "msm-lowlatency-pcm-dsp",
+       .owner = THIS_MODULE,
+   },
+   .probe = msm_pcm_probe,
+   .remove = __devexit_p(msm_pcm_remove),
+};
+
+static int __init msm_soc_platform_init(void)
+{
+   init_waitqueue_head(&the_locks.enable_wait);
+   init_waitqueue_head(&the_locks.eos_wait);
+   init_waitqueue_head(&the_locks.write_wait);
+   init_waitqueue_head(&the_locks.read_wait);
+
+   return platform_driver_register(&msm_pcm_driver);
+}
+module_init(msm_soc_platform_init);
+
+static void __exit msm_soc_platform_exit(void)
+{
+   platform_driver_unregister(&msm_pcm_driver);
+}
+module_exit(msm_soc_platform_exit);
+
+MODULE_DESCRIPTION("Multi channel PCM module platform driver");
+MODULE_LICENSE("GPL v2");
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-multi-ch-pcm-q6.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-multi-ch-pcm-q6.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-multi-ch-pcm-q6.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-multi-ch-pcm-q6.c	2013-08-01 23:38:03.000000000 -0600
@@ -336,6 +336,7 @@
 		return -ENOMEM;
 	}
 	prtd->substream = substream;
+	prtd->audio_client->perf_mode = false;
 	prtd->audio_client = q6asm_audio_client_alloc(
 				(app_cb)event_handler, prtd);
 	if (!prtd->audio_client) {
@@ -370,6 +371,7 @@
 
 	prtd->session_id = prtd->audio_client->session;
 	msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
+	        prtd->audio_client->perf_mode,
 			prtd->session_id, substream->stream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-lpa.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-lpa.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-lpa.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-lpa.c	2013-08-01 23:38:03.000000000 -0600
@@ -294,6 +294,7 @@
 	}
 	runtime->hw = msm_pcm_hardware;
 	prtd->substream = substream;
+	prtd->audio_client->perf_mode = false;
 	prtd->audio_client = q6asm_audio_client_alloc(
 				(app_cb)event_handler, prtd);
 	if (!prtd->audio_client) {
@@ -323,6 +324,9 @@
 	pr_debug("%s: session ID %d\n", __func__, prtd->audio_client->session);
 	prtd->session_id = prtd->audio_client->session;
 	msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
+		
+		prtd->audio_client->perf_mode,
+		
 		prtd->session_id, substream->stream);
 
 	ret = snd_pcm_hw_constraint_list(runtime, 0,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-q6.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-q6.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-q6.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-q6.c	2013-08-01 23:38:03.000000000 -0600
@@ -46,7 +46,7 @@
 };
 
 #define PLAYBACK_NUM_PERIODS	8
-#define PLAYBACK_PERIOD_SIZE	2048
+#define PLAYBACK_PERIOD_SIZE	8192
 #define CAPTURE_NUM_PERIODS	16
 #define CAPTURE_PERIOD_SIZE	320
 
@@ -370,6 +370,9 @@
 		kfree(prtd);
 		return -ENOMEM;
 	}
+	
+	prtd->audio_client->perf_mode = false;
+	
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->hw = msm_pcm_hardware_playback;
 	}
@@ -685,6 +688,7 @@
 			prtd->audio_client->session);
 		prtd->session_id = prtd->audio_client->session;
 		msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
+		prtd->audio_client->perf_mode,
 			prtd->session_id, substream->stream);
 		prtd->cmd_ack = 1;
 	}
@@ -710,6 +714,9 @@
 		event.event_func = msm_pcm_route_event_handler;
 		event.priv_data = (void*) prtd;
 		msm_pcm_routing_reg_phy_stream_v2(soc_prtd->dai_link->be_id,
+				
+						prtd->audio_client->perf_mode,
+				
 						  prtd->session_id,
 						  substream->stream, event);
 	}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-routing.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-routing.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-routing.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-routing.c	2013-08-01 23:38:03.000000000 -0600
@@ -46,7 +46,9 @@
 	unsigned int  sample_rate;
 	unsigned int  channel;
 	unsigned int  format;
+	
 	bool perf_mode;
+	
 };
 
 struct msm_pcm_routing_fdai_data {
@@ -321,7 +323,8 @@
 	mutex_unlock(&routing_lock);
 }
 
-void msm_pcm_routing_reg_phy_stream(int fedai_id, int dspst_id, int stream_type)
+void msm_pcm_routing_reg_phy_stream(int fedai_id, bool perf_mode, int dspst_id,
+							int stream_type)
 {
 	int i, session_type, path_type, port_type;
 	struct route_payload payload;
@@ -329,6 +332,9 @@
 	u16 bit_width = 16;
 	int topology = DEFAULT_COPP_TOPOLOGY;
 
+#ifdef CONFIG_MSM8960_ONLY
+	bool skip_adm_matrix_map = false;
+#endif
 	if (fedai_id > MSM_FRONTEND_DAI_MM_MAX_ID) {
 		
 		pr_err("%s: bad MM ID %d\n", __func__, fedai_id);
@@ -362,6 +368,10 @@
 	if (eq_data[fedai_id].enable)
 		msm_send_eq_values(fedai_id);
 	for (i = 0; i < MSM_BACKEND_DAI_MAX; i++) {
+		
+		if (test_bit(fedai_id, &msm_bedais[i].fe_sessions))
+			msm_bedais[i].perf_mode = perf_mode;
+		
 		if (!is_be_dai_extproc(i) &&
 		   (afe_get_port_type(msm_bedais[i].port_id) == port_type) &&
 		   (msm_bedais[i].active) &&
@@ -376,13 +386,26 @@
 				bit_width = 24;
 
 			if ((stream_type == SNDRV_PCM_STREAM_PLAYBACK) &&
+				
+				((channels == 1) || (channels == 2)) &&
+				msm_bedais[i].perf_mode) {
+				pr_debug("%s configure COPP to lowlatency mode",
+								__func__);
+				
+				adm_multi_ch_copp_open(msm_bedais[i].port_id,
+				path_type,
+				msm_bedais[i].sample_rate,
+				msm_bedais[i].channel,
+				topology, msm_bedais[i].perf_mode);
+			}else if((stream_type == SNDRV_PCM_STREAM_PLAYBACK) &&
+				
 				(channels > 0))
 				adm_multi_ch_copp_open_v2(msm_bedais[i].port_id,
 				path_type,
 				msm_bedais[i].sample_rate,
 				msm_bedais[i].channel,
 				topology,
-				bit_width);
+				bit_width, msm_bedais[i].perf_mode);
 			else
 				adm_open(msm_bedais[i].port_id,
 				path_type,
@@ -396,17 +419,28 @@
 			srs_send_params(srs_port_id, 1, 0);
 		}
 	}
-	if (payload.num_copps)
-		adm_matrix_map(dspst_id, path_type,
-			payload.num_copps, payload.copp_ids, 0);
-
+#ifdef CONFIG_MSM8960_ONLY
+	if ( msm_bedais[2].active && ((fedai_id == 3)||(fedai_id == 6)) && (stream_type == SNDRV_PCM_STREAM_PLAYBACK) ){
+		skip_adm_matrix_map = true;
+	}
+	if ( skip_adm_matrix_map ){
+		pr_info("%s: skip redundant adm_matrix_map for session_id %d fedai_id %d \n", __func__,dspst_id,fedai_id );
+	}else{
+#endif
+		if (payload.num_copps)
+			adm_matrix_map(dspst_id, path_type,
+				payload.num_copps, payload.copp_ids, 0);
+#ifdef CONFIG_MSM8960_ONLY
+	}
+#endif
 	mutex_unlock(&routing_lock);
 }
 void msm_pcm_routing_reg_phy_stream_v2(int fedai_id,
+						bool perf_mode,
 				       int dspst_id, int stream_type,
 				       struct msm_pcm_routing_evt event_info)
 {
-	msm_pcm_routing_reg_phy_stream(fedai_id, dspst_id, stream_type);
+	msm_pcm_routing_reg_phy_stream(fedai_id, perf_mode, dspst_id, stream_type);
 
 	if (stream_type == SNDRV_PCM_STREAM_PLAYBACK)
 		fe_dai_map[fedai_id][SESSION_TYPE_RX].event_info = event_info;
@@ -525,14 +559,27 @@
 
 			if (msm_bedais[reg].format == SNDRV_PCM_FORMAT_S24_LE)
 				bit_width = 24;
-			if ((session_type == SESSION_TYPE_RX)
-					&& (channels > 0))
+			if ((session_type == SESSION_TYPE_RX) &&
+			
+						((channels == 1) || (channels == 2))
+						&& msm_bedais[reg].perf_mode) {
+				adm_multi_ch_copp_open_v2(msm_bedais[reg].port_id,
+				path_type,
+				msm_bedais[reg].sample_rate,
+				channels,
+				topology, bit_width,
+				msm_bedais[reg].perf_mode);
+				pr_debug("%s:configure COPP to lowlatency mode",
+											 __func__);
+			}else if((session_type == SESSION_TYPE_RX) &&
+			
+					 (channels > 0))
 				adm_multi_ch_copp_open_v2(
 				msm_bedais[reg].port_id, path_type,
 				msm_bedais[reg].sample_rate,
 				channels,
 				topology,
-				bit_width);
+				bit_width, msm_bedais[reg].perf_mode);
 			else
 				adm_open(msm_bedais[reg].port_id,
 				path_type,
@@ -1459,6 +1506,11 @@
 	SOC_SINGLE_EXT("MultiMedia4", MSM_BACKEND_DAI_INT_BT_SCO_RX,
 	MSM_FRONTEND_DAI_MULTIMEDIA4, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
+	
+	SOC_SINGLE_EXT("MultiMedia5", MSM_BACKEND_DAI_INT_BT_SCO_RX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	
 };
 
 static const struct snd_kcontrol_new int_fm_rx_mixer_controls[] = {
@@ -1474,6 +1526,11 @@
 	SOC_SINGLE_EXT("MultiMedia4", MSM_BACKEND_DAI_INT_FM_RX,
 	MSM_FRONTEND_DAI_MULTIMEDIA4, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
+	
+	SOC_SINGLE_EXT("MultiMedia5", MSM_BACKEND_DAI_INT_FM_RX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	
 };
 
 static const struct snd_kcontrol_new afe_pcm_rx_mixer_controls[] = {
@@ -1489,6 +1546,11 @@
 	SOC_SINGLE_EXT("MultiMedia4", MSM_BACKEND_DAI_AFE_PCM_RX,
 	MSM_FRONTEND_DAI_MULTIMEDIA4, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
+	
+	SOC_SINGLE_EXT("MultiMedia5", MSM_BACKEND_DAI_AUXPCM_RX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	
 	SOC_SINGLE_EXT("MultiMedia7", MSM_BACKEND_DAI_AFE_PCM_RX,
 	MSM_FRONTEND_DAI_MULTIMEDIA7, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
@@ -1510,6 +1572,11 @@
 	SOC_SINGLE_EXT("MultiMedia4", MSM_BACKEND_DAI_AUXPCM_RX,
 	MSM_FRONTEND_DAI_MULTIMEDIA4, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
+	
+	SOC_SINGLE_EXT("MultiMedia5", MSM_BACKEND_DAI_AUXPCM_RX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	
 };
 
 static const struct snd_kcontrol_new sec_auxpcm_rx_mixer_controls[] = {
@@ -1566,6 +1633,23 @@
 	msm_routing_put_audio_mixer),
 };
 
+static const struct snd_kcontrol_new mmul5_mixer_controls[] = {
+	SOC_SINGLE_EXT("SLIM_0_TX", MSM_BACKEND_DAI_SLIMBUS_0_TX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	SOC_SINGLE_EXT("INTERNAL_FM_TX", MSM_BACKEND_DAI_INT_FM_TX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	SOC_SINGLE_EXT("MI2S_TX", MSM_BACKEND_DAI_MI2S_TX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	SOC_SINGLE_EXT("AFE_PCM_TX", MSM_BACKEND_DAI_AFE_PCM_TX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+	SOC_SINGLE_EXT("INTERNAL_BT_SCO_TX", MSM_BACKEND_DAI_INT_BT_SCO_TX,
+	MSM_FRONTEND_DAI_MULTIMEDIA5, 1, 0, msm_routing_get_audio_mixer,
+	msm_routing_put_audio_mixer),
+};
 
 static const struct snd_kcontrol_new mmul4_mixer_controls[] = {
 	SOC_SINGLE_EXT("MI2S_TX", MSM_BACKEND_DAI_MI2S_TX,
@@ -2295,6 +2379,9 @@
 	SND_SOC_DAPM_AIF_OUT("MM_UL1", "MultiMedia1 Capture", 0, 0, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("MM_UL2", "MultiMedia2 Capture", 0, 0, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("MM_UL4", "MultiMedia4 Capture", 0, 0, 0, 0),
+	
+	SND_SOC_DAPM_AIF_OUT("MM_UL5", "MultiMedia5 Capture", 0, 0, 0, 0),
+	
 	SND_SOC_DAPM_AIF_IN("CS-VOICE_DL1", "CS-VOICE Playback", 0, 0, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("CS-VOICE_UL1", "CS-VOICE Capture", 0, 0, 0, 0),
 	SND_SOC_DAPM_AIF_IN("VoLTE_DL", "VoLTE Playback", 0, 0, 0, 0),
@@ -2406,6 +2493,10 @@
 	mmul2_mixer_controls, ARRAY_SIZE(mmul2_mixer_controls)),
 	SND_SOC_DAPM_MIXER("MultiMedia4 Mixer", SND_SOC_NOPM, 0, 0,
 	mmul4_mixer_controls, ARRAY_SIZE(mmul4_mixer_controls)),
+	
+	SND_SOC_DAPM_MIXER("MultiMedia5 Mixer", SND_SOC_NOPM, 0, 0,
+	mmul5_mixer_controls, ARRAY_SIZE(mmul5_mixer_controls)),
+	
 	SND_SOC_DAPM_MIXER("AUX_PCM_RX Audio Mixer", SND_SOC_NOPM, 0, 0,
 	auxpcm_rx_mixer_controls, ARRAY_SIZE(auxpcm_rx_mixer_controls)),
 	SND_SOC_DAPM_MIXER("SEC_AUX_PCM_RX Audio Mixer", SND_SOC_NOPM, 0, 0,
@@ -2570,10 +2661,16 @@
 	{"MultiMedia1 Mixer", "VOC_REC_UL", "INCALL_RECORD_TX"},
 	{"MultiMedia1 Mixer", "VOC_REC_DL", "INCALL_RECORD_RX"},
 	{"MultiMedia1 Mixer", "SLIM_4_TX", "SLIMBUS_4_TX"},
+	
+	{"MultiMedia5 Mixer", "SLIM_0_TX", "SLIMBUS_0_TX"},
+	
 	{"MI2S_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
 	{"MI2S_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
 	{"MI2S_RX Audio Mixer", "MultiMedia3", "MM_DL3"},
 	{"MI2S_RX Audio Mixer", "MultiMedia4", "MM_DL4"},
+	
+	{"MI2S_RX Audio Mixer", "MultiMedia5", "MM_DL5"},
+	
 	{"MI2S_RX Audio Mixer", "MultiMedia7", "MM_DL7"},
 	{"MI2S_RX Audio Mixer", "MultiMedia8", "MM_DL8"},
 	{"MI2S_RX Audio Mixer", "MultiMedia Stub", "MM_STUB_DL"},
@@ -2593,12 +2690,18 @@
 	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
 	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia3", "MM_DL3"},
 	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia4", "MM_DL4"},
+	
+	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia5", "MM_DL5"},
+	
 	{"INT_BT_SCO_RX", NULL, "INTERNAL_BT_SCO_RX Audio Mixer"},
 
 	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
 	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
 	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia3", "MM_DL3"},
 	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia4", "MM_DL4"},
+	
+	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia5", "MM_DL5"},
+	
 	{"INT_FM_RX", NULL, "INTERNAL_FM_RX Audio Mixer"},
 
 	{"AFE_PCM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
@@ -2610,18 +2713,32 @@
 	{"PCM_RX", NULL, "AFE_PCM_RX Audio Mixer"},
 
 	{"MultiMedia1 Mixer", "INTERNAL_BT_SCO_TX", "INT_BT_SCO_TX"},
+	
+	{"MultiMedia5 Mixer", "INTERNAL_BT_SCO_TX", "INT_BT_SCO_TX"},
+	
 	{"MultiMedia1 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
-
+	
+	{"MultiMedia5 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
+	
 	{"MultiMedia1 Mixer", "AFE_PCM_TX", "PCM_TX"},
+	
+	{"MultiMedia5 Mixer", "AFE_PCM_TX", "PCM_TX"},
+	
 	{"MM_UL1", NULL, "MultiMedia1 Mixer"},
 	{"MultiMedia2 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
 	{"MM_UL2", NULL, "MultiMedia2 Mixer"},
 	{"MM_UL4", NULL, "MultiMedia4 Mixer"},
+	
+	{"MM_UL5", NULL, "MultiMedia5 Mixer"},
+	
 
 	{"AUX_PCM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
 	{"AUX_PCM_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
 	{"AUX_PCM_RX Audio Mixer", "MultiMedia3", "MM_DL3"},
 	{"AUX_PCM_RX Audio Mixer", "MultiMedia4", "MM_DL4"},
+	
+	{"AUX_PCM_RX Audio Mixer", "MultiMedia5", "MM_DL5"},
+	
 	{"AUX_PCM_RX", NULL, "AUX_PCM_RX Audio Mixer"},
 
 	{"SEC_AUX_PCM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
@@ -2728,11 +2845,7 @@
 	{"SEC_I2S_RX", NULL, "SEC_I2S_DL_HL"},
 	{"PRI_I2S_RX", NULL, "PRI_I2S_DL_HL"},
 	{"PRI_I2S_UL_HL", NULL, "PRI_I2S_TX"},
-#if defined(CONFIG_MACH_monarudo_DXG)  || \
-    defined(CONFIG_MACH_DUMMY) || \
-    defined(CONFIG_MACH_DUMMY) || \
-    defined(CONFIG_MACH_DUMMY) || \
-    defined(CONFIG_MACH_T6_DXG)
+#if defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY) || defined(CONFIG_ARCH_DUMMY)
 	
 	
 	
@@ -2912,6 +3025,9 @@
 	bedai->active = 0;
 	bedai->sample_rate = 0;
 	bedai->channel = 0;
+	
+	bedai->perf_mode = false;
+	
 	mutex_unlock(&routing_lock);
 
 	return 0;
@@ -3002,7 +3118,10 @@
 			   bedai->sample_rate,
 			   channels,
 			   DEFAULT_COPP_TOPOLOGY,
-			   bit_width);
+			   bit_width,
+			   
+			   bedai->perf_mode);
+			   
 #ifdef CONFIG_MSM8960_ONLY
 			} else if ((capture)
 			   && (channels > 2))
@@ -3014,7 +3133,10 @@
 			   path_type,
 			   bedai->sample_rate,
 			   channels,
-			   topology);
+			   topology,
+			   
+			   bedai->perf_mode);
+			   
 			else
 				adm_open(bedai->port_id,
 				path_type,
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-routing.h monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-routing.h
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/msm-pcm-routing.h	2013-06-24 02:50:43.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/msm-pcm-routing.h	2013-08-01 23:37:55.000000000 -0600
@@ -113,8 +113,9 @@
 	int (*get_q6_effect) (void);
 };
 
-void msm_pcm_routing_reg_phy_stream(int fedai_id, int dspst_id,
-	int stream_type);
+void msm_pcm_routing_reg_phy_stream(int fedai_id, bool perf_mode,
+				int dspst_id, int stream_type);
+
 void msm_pcm_routing_reg_psthr_stream(int fedai_id, int dspst_id,
 		int stream_type, int enable);
 
@@ -124,6 +125,7 @@
 };
 
 void msm_pcm_routing_reg_phy_stream_v2(int fedai_id,
+						bool perf_mode,
 				       int dspst_id, int stream_type,
 				       struct msm_pcm_routing_evt event_info);
 
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/qdsp6/q6adm.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/qdsp6/q6adm.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/qdsp6/q6adm.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/qdsp6/q6adm.c	2013-08-01 23:38:03.000000000 -0600
@@ -302,6 +302,9 @@
 		switch (data->opcode) {
 		case ADM_CMDRSP_COPP_OPEN:
 		case ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN:
+		
+		case ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN_V3:
+		
 		case ADM_CMDRSP_MULTI_CHANNEL_COPP_OPEN_V2: {
 			struct adm_copp_open_respond *open = data->payload;
 			if (open->copp_id == INVALID_COPP_ID) {
@@ -785,7 +788,7 @@
 
 
 int adm_multi_ch_copp_open(int port_id, int path, int rate, int channel_mode,
-				int topology)
+int topology, int perfmode)
 {
 	struct adm_multi_ch_copp_open_command open;
 	int ret = 0;
@@ -823,8 +826,17 @@
 
 		open.hdr.pkt_size =
 			sizeof(struct adm_multi_ch_copp_open_command);
-		open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN;
-		open.reserved = 0;
+		
+		if (perfmode) {
+			pr_debug("%s Performance mode", __func__);
+			open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN_V3;
+			open.flags = ADM_MULTI_CH_COPP_OPEN_PERF_MODE_BIT;
+			open.reserved = PCM_BITS_PER_SAMPLE;
+		} else {
+			open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN;
+			open.reserved = 0;
+		}
+		
 		memset(open.dev_channel_mapping, 0, 8);
 
 		if (channel_mode == 1)	{
@@ -934,7 +946,7 @@
 
 
 int adm_multi_ch_copp_open_v2(int port_id, int path, int rate, int channel_mode,
-				int topology, uint16_t bit_width)
+				int topology, uint16_t bit_width, int perfmode)
 {
 	struct adm_multi_ch_copp_open_command_v2 open;
 	int ret = 0;
@@ -973,7 +985,15 @@
 		open.hdr.pkt_size =
 			sizeof(struct adm_multi_ch_copp_open_command_v2);
 
-		open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN_V2;
+		
+		if (perfmode) {
+			pr_debug("%s Performance mode", __func__);
+			open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN_V3;
+			open.flags = ADM_MULTI_CH_COPP_OPEN_PERF_MODE_BIT;
+		} else {
+			open.hdr.opcode = ADM_CMD_MULTI_CHANNEL_COPP_OPEN_V2;
+		}
+		
 		pr_debug("%s Performance mode", __func__);
 
 		memset(open.dev_channel_mapping, 0, 8);
@@ -1156,7 +1176,6 @@
 	if (!ret) {
 		pr_err("%s: ADM cmd Route failed for port %d\n",
 					__func__, port_id[0]);
-		HTC_Q6_BUG();
 		ret = -EINVAL;
 		goto fail_cmd;
 	}
@@ -1397,7 +1416,6 @@
 		if (!ret) {
 			pr_err("%s: ADM cmd Route failed for port %d\n",
 						__func__, port_id);
-			HTC_Q6_BUG();
 			ret = -EINVAL;
 			goto fail_cmd;
 		}
diff -Naur monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/qdsp6/q6asm.c monarudo-jb-3.4.10-e22f38b/sound/soc/msm/qdsp6/q6asm.c
--- monarudo-jb-crc-3.4.10-7edee3c/sound/soc/msm/qdsp6/q6asm.c	2013-06-24 02:50:47.000000000 -0600
+++ monarudo-jb-3.4.10-e22f38b/sound/soc/msm/qdsp6/q6asm.c	2013-08-01 23:38:03.000000000 -0600
@@ -216,10 +216,17 @@
 {
 	pr_debug("%s: sessionid[%d]\n", __func__, ac->session);
 	rtac_remove_popp_from_adm_devices(ac->session);
+	if (ac->session < 1 || ac->session > SESSION_MAX) {
+		pr_err("%s: sessionid[%d] out of range!\n", __func__, ac->session);
+		return;
+	}
 	mutex_lock(&session_lock);
 	session[ac->session] = 0;
 	mutex_unlock(&session_lock);
 	ac->session = 0;
+	
+	ac->perf_mode = false;
+	
 	return;
 }
 
@@ -429,6 +436,9 @@
 	ac->cb = cb;
 	ac->priv = priv;
 	ac->io_mode = SYNC_IO_MODE;
+	
+	ac->perf_mode = false;
+	
 	ac->apr = apr_register("ADSP", "ASM", \
 				(apr_fn)q6asm_callback,\
 				((ac->session) << 8 | 0x0001),\
@@ -880,6 +890,9 @@
 
 	if (data->opcode == APR_BASIC_RSP_RESULT) {
 		token = data->token;
+		
+		pr_debug("%s payload[0]:%x", __func__, payload[0]);
+		
 		switch (payload[0]) {
 		case ASM_STREAM_CMD_SET_PP_PARAMS:
 			if (rtac_make_asm_callback(ac->session, payload,
@@ -899,8 +912,10 @@
 			return -EINVAL;
 		}
 		case ASM_STREAM_CMD_OPEN_READ:
+		case ASM_STREAM_CMD_OPEN_READ_V2_1:
 		case ASM_STREAM_CMD_OPEN_WRITE:
 		case ASM_STREAM_CMD_OPEN_WRITE_V2:
+		case ASM_STREAM_CMD_OPEN_WRITE_V2_1:
 		case ASM_STREAM_CMD_OPEN_READWRITE:
 		case ASM_DATA_CMD_MEDIA_FORMAT_UPDATE:
 		case ASM_STREAM_CMD_SET_ENCDEC_PARAM:
@@ -908,8 +923,13 @@
 		case ASM_STREAM_CMD_OPEN_READ_COMPRESSED:
 			if (atomic_read(&ac->cmd_state) && wakeup_flag) {
 				atomic_set(&ac->cmd_state, 0);
-				if (payload[1] == ADSP_EUNSUPPORTED)
+				if (payload[1] == ADSP_EUNSUPPORTED) {
+					
+					pr_debug("paload[1]:%d unsupported",
+											payload[1]);
+					
 					atomic_set(&ac->cmd_response, 1);
+				}
 				else
 					atomic_set(&ac->cmd_response, 0);
 				wake_up(&ac->cmd_wait);
@@ -1282,6 +1302,81 @@
 	return -EINVAL;
 }
 
+int q6asm_open_read_v2_1(struct audio_client *ac,
+		uint32_t format)
+{
+	int rc = 0x00;
+	struct asm_stream_cmd_open_read_v2_1 open;
+#ifdef CONFIG_DEBUG_FS
+	in_cont_index = 0;
+#endif
+	if ((ac == NULL) || (ac->apr == NULL)) {
+		pr_err("%s: APR handle NULL\n", __func__);
+		return -EINVAL;
+	}
+	pr_debug("%s:session[%d]", __func__, ac->session);
+
+	q6asm_add_hdr(ac, &open.hdr, sizeof(open), TRUE);
+	open.hdr.opcode = ASM_STREAM_CMD_OPEN_READ_V2_1;
+	open.src_endpoint = ASM_END_POINT_DEVICE_MATRIX;
+	open.pre_proc_top = get_asm_topology();
+	if (open.pre_proc_top == 0)
+		open.pre_proc_top = DEFAULT_POPP_TOPOLOGY;
+
+	switch (format) {
+	case FORMAT_LINEAR_PCM:
+		open.uMode = STREAM_PRIORITY_HIGH;
+		open.format = LINEAR_PCM;
+		break;
+	case FORMAT_MULTI_CHANNEL_LINEAR_PCM:
+		open.uMode = STREAM_PRIORITY_HIGH;
+		open.format = MULTI_CHANNEL_PCM;
+		break;
+	case FORMAT_MPEG4_AAC:
+		open.uMode = BUFFER_META_ENABLE | STREAM_PRIORITY_HIGH;
+		open.format = MPEG4_AAC;
+		break;
+	case FORMAT_V13K:
+		open.uMode = BUFFER_META_ENABLE | STREAM_PRIORITY_HIGH;
+		open.format = V13K_FS;
+		break;
+	case FORMAT_EVRC:
+		open.uMode = BUFFER_META_ENABLE | STREAM_PRIORITY_HIGH;
+		open.format = EVRC_FS;
+		break;
+	case FORMAT_AMRNB:
+		open.uMode = BUFFER_META_ENABLE | STREAM_PRIORITY_HIGH;
+		open.format = AMRNB_FS;
+		break;
+	case FORMAT_AMRWB:
+		open.uMode = BUFFER_META_ENABLE | STREAM_PRIORITY_HIGH;
+		open.format = AMRWB_FS;
+		break;
+	default:
+		pr_err("Invalid format[%d]\n", format);
+		goto fail_cmd;
+	}
+	open.uMode = ASM_OPEN_READ_PERF_MODE_BIT;
+	open.bits_per_sample = PCM_BITS_PER_SAMPLE;
+	open.reserved = 0;
+	rc = apr_send_pkt(ac->apr, (uint32_t *) &open);
+	if (rc < 0) {
+		pr_err("open failed op[0x%x]rc[%d]\n", \
+						open.hdr.opcode, rc);
+		goto fail_cmd;
+	}
+	rc = wait_event_timeout(ac->cmd_wait,
+			(atomic_read(&ac->cmd_state) == 0), 5*HZ);
+	if (!rc) {
+		pr_err("%s: timeout. waited for OPEN_WRITE rc[%d]\n", __func__,
+			rc);
+		goto fail_cmd;
+	}
+	return 0;
+fail_cmd:
+	return -EINVAL;
+}
+
 int q6asm_open_read_compressed(struct audio_client *ac, uint32_t format)
 {
 	int rc = 0x00;
@@ -1413,6 +1508,22 @@
 	
 	open.sink_endpoint = ASM_END_POINT_DEVICE_MATRIX;
 	open.stream_handle = 0x00;
+	
+	if (ac->perf_mode) {
+		pr_debug("%s In Performance/lowlatency mode", __func__);
+		open.hdr.opcode = ASM_STREAM_CMD_OPEN_WRITE_V2_1;
+		open.uMode = ASM_OPEN_WRITE_PERF_MODE_BIT;
+		
+		open.sink_endpoint = ASM_END_POINT_DEVICE_MATRIX;
+		open.stream_handle = PCM_BITS_PER_SAMPLE;
+	} else {
+		open.hdr.opcode = ASM_STREAM_CMD_OPEN_WRITE;
+		open.uMode = STREAM_PRIORITY_HIGH;
+		
+		open.sink_endpoint = ASM_END_POINT_DEVICE_MATRIX;
+		open.stream_handle = 0x00;
+	}
+	
 
 	open.post_proc_top = get_asm_topology();
 	if (open.post_proc_top == 0)
@@ -2405,7 +2516,7 @@
 }
 
 int q6asm_media_format_block_multi_ch_pcm(struct audio_client *ac,
-				uint32_t rate, uint32_t channels)
+				uint32_t rate, uint32_t channels, uint16_t bit_width)
 {
 	struct asm_stream_media_format_update fmt;
 	u8 *channel_mapping;
@@ -2421,7 +2532,7 @@
 	fmt.format = MULTI_CHANNEL_PCM;
 	fmt.cfg_size = sizeof(struct asm_multi_channel_pcm_fmt_blk);
 	fmt.write_cfg.multi_ch_pcm_cfg.num_channels = channels;
-	fmt.write_cfg.multi_ch_pcm_cfg.bits_per_sample = 16;
+	fmt.write_cfg.multi_ch_pcm_cfg.bits_per_sample = bit_width;
 	fmt.write_cfg.multi_ch_pcm_cfg.sample_rate = rate;
 	fmt.write_cfg.multi_ch_pcm_cfg.is_signed = 1;
 	fmt.write_cfg.multi_ch_pcm_cfg.is_interleaved = 1;
